<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>各种IT网站收藏</title>
    <url>/%E6%8A%80%E6%9C%AF/%E5%90%84%E7%A7%8DIT%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F.html</url>
    <content><![CDATA[<h2 id="git-command"><a href="#git-command" class="headerlink" title="git command"></a>git command</h2><ul>
<li><a href="https://www.yiibai.com/git" target="_blank" rel="noopener">git command</a></li>
</ul>
<h2 id="前端九部-前端入门手册"><a href="#前端九部-前端入门手册" class="headerlink" title="前端九部-前端入门手册"></a>前端九部-前端入门手册</h2><ul>
<li><a href="https://www.yuque.com/fe9/basic/zw24qu" target="_blank" rel="noopener">前端九部-前端入门手册</a></li>
</ul>
<h3 id="Vuejs开源项目"><a href="#Vuejs开源项目" class="headerlink" title="Vuejs开源项目"></a>Vuejs开源项目</h3><ul>
<li><a href="https://github.com/opendigg/awesome-github-vue" target="_blank" rel="noopener">vuejs开源项目汇总</a></li>
</ul>
<h3 id="react开源项目汇总"><a href="#react开源项目汇总" class="headerlink" title="react开源项目汇总"></a>react开源项目汇总</h3><ul>
<li><a href="https://github.com/zuiidea/antd-admin" target="_blank" rel="noopener">一套优秀的中后台前端解决方案</a></li>
<li><a href="https://github.com/trazyn/ieaseMusic" target="_blank" rel="noopener">网易云音乐第三方</a></li>
<li><a href="https://github.com/bailicangdu/react-pxq" target="_blank" rel="noopener">一个 react + redux 的完整项目 和 个人总结</a></li>
<li><a href="https://github.com/yezihaohao/react-admin" target="_blank" rel="noopener">react 后台管理系统解决方案</a></li>
<li><a href="https://github.com/crazycodeboy/GitHubPopular" target="_blank" rel="noopener">这是一个用来查看GitHub最受欢迎与最热项目的App,它基于React Native支持Android和iOS双平台</a></li>
<li><a href="https://github.com/stoneWeb/elm-react-native" target="_blank" rel="noopener">RN写的饿了么，还原度相当高，实现了各类动效</a></li>
<li><a href="https://github.com/race604/ZhiHuDaily-React-Native" target="_blank" rel="noopener">仿知乎日报</a></li>
<li><a href="https://github.com/biaochenxuying/blog-react" target="_blank" rel="noopener">react + Ant Design + 支持 markdown 的博客前台展示</a></li>
<li><a href="https://github.com/gershonv/react-blog" target="_blank" rel="noopener">使用 react hooks + koa2 + sequelize + mysql 搭建的前后台的博客</a></li>
<li><a href="https://github.com/fxy5869571/blog-react" target="_blank" rel="noopener">基于typescript koa2 react的个人博客</a></li>
</ul>
<h3 id="前端面试题"><a href="#前端面试题" class="headerlink" title="前端面试题"></a>前端面试题</h3><ul>
<li><a href="https://github.com/haizlin/fe-interview" target="_blank" rel="noopener">前端每日3+1</a></li>
<li><a href="https://muyiy.cn/question/" target="_blank" rel="noopener">壹题汇总-木易杨</a></li>
</ul>
<h3 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h3><ul>
<li><a href="https://github.com/bailicangdu/node-elm" target="_blank" rel="noopener">基于 node.js + Mongodb 构建的后台系统</a></li>
<li><a href="https://github.com/cnodejs/nodeclub" target="_blank" rel="noopener">Nodeclub 是使用 Node.js 和 MongoDB 开发的社区系统</a></li>
<li><a href="https://github.com/tumobi/nideshop-mini-program" target="_blank" rel="noopener">基于Node.js+MySQL开发的开源微信小程序商城（微信小程序）</a></li>
<li><a href="https://github.com/tumobi/nideshop" target="_blank" rel="noopener">NideShop 开源微信小程序商城服务端 API（Node.js + ThinkJS）</a></li>
<li><a href="https://github.com/Nealyang/React-Express-Blog-Demo" target="_blank" rel="noopener">React+Express+Mongo -&gt;前后端博客网站</a></li>
<li><a href="https://github.com/biaochenxuying/blog-node" target="_blank" rel="noopener">基于 node + express + mongodb 的博客网站后台</a></li>
</ul>
<h3 id="免费视频"><a href="#免费视频" class="headerlink" title="免费视频"></a>免费视频</h3><ul>
<li><a href="https://jspang.com/posts/2017/01/11/all-video-list.html" target="_blank" rel="noopener">技术胖免费视频</a></li>
</ul>
<h3 id="react-native"><a href="#react-native" class="headerlink" title="react native"></a>react native</h3><ul>
<li><a href="https://www.jianshu.com/p/c7a8f115dca0" target="_blank" rel="noopener">React Native 第三方组件之–UI类</a></li>
</ul>
<h3 id="日本输入邮编自动填充地址"><a href="#日本输入邮编自动填充地址" class="headerlink" title="日本输入邮编自动填充地址"></a>日本输入邮编自动填充地址</h3><ul>
<li><a href="https://zipaddr.github.io/" target="_blank" rel="noopener">https://zipaddr.github.io/</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网站收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-262-3深入解析第四章：作用域链</title>
    <url>/%E6%8A%80%E6%9C%AF/ECMA-262-3%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html</url>
    <content><![CDATA[<p>从来没有深入了解ECMA，网上找了一下，发现早在2010年就有大佬 <a href="http://dmitrysoshnikov.com/about/" target="_blank" rel="noopener">Dmitry Soshnikov</a> 总结了ECMA中的核心内容，我这里只是翻译记录，加深自己的印象。文章原文来自<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="noopener">ECMA-262-3 in detail. Chapter 4. Scope chain.</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13" target="_blank" rel="noopener">第二章</a>我们已经了解了<em>变量对象</em>，<a href="https://juejin.im/post/5ebcdda76fb9a0433567b062" target="_blank" rel="noopener">执行上下文</a>中的数据（变量，函数声明，函数形参）作为这个变量对象的属性被存起来了。</p>
<p>同时，我们也知道，变量对象是在每一次<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13#heading-6" target="_blank" rel="noopener">进入上下文</a>的时候被创建并且赋予初始值的，并且在<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13#heading-7" target="_blank" rel="noopener">代码执行阶段</a>更新。</p>
<p>本章致力于讨论与执行上下文紧密相关的更多细节；这一次，我们会提到一个<em>作用域链</em>的概念。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果要简短描述并且展现出重点，那么，作用域链主要与内部函数息息相关。</p>
<p>我们知道，ECMAScript允许在函数内部创建函数，并且，我们甚至可以从父级函数中返回这些函数。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(x + y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>因此，每一个上下文都有他自己的变量对象：对于全局上下文就是全局对象自己，对于函数就是活动对象。</p>
<p>作用域链正好就是内部上下文所有变量对象的列表。这个链条用域变量查找。在上面的例子中，‘bar’上下文的作用域链中包含了AO（bar），AO（foo）和VO（global）；</p>
<p>让我们详细讨论这个主题。</p>
<p>我们从定义开始，然后进一步深入讨论示例。</p>
<blockquote>
<p>作用域链与执行上下文息息相关，一连串的变量对象是为了在标识符解析的时候查找变量。</p>
</blockquote>
<p>函数上下文的作用域链是在函数调用的时候创建，并且由<em>变量对象</em>和内置的<em>[[Scope]]</em>属性构成。下面我们详细讨论一下函数的 [[Scrope]] 属性。</p>
<p>在上下文中的示意图：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line">	VO: &#123;...&#125;, <span class="comment">// or AO</span></span><br><span class="line">	<span class="keyword">this</span>: thisValue,</span><br><span class="line">	Scope: [</span><br><span class="line">		<span class="comment">// 为了标识符查找的变量对象作用域链列表</span></span><br><span class="line">	]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Scope 定义的范围是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Scope = AO + [[Scope]]</span><br></pre></td></tr></table></figure>
<p>在我我们的例子中，可以使用ECMAScript的普通函数来表示 <em>Scope</em>，和 <em>[[SCope]]</em></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Scope = [VO1, VO2, ..., VOn]; <span class="comment">// scope chain</span></span><br></pre></td></tr></table></figure>
<p>可以将替代结构视图表示为分层对象链，并在链的每个链接上都引用父作用域（父变量对象）。对于此视图，</p>
<p>对应某些实现的 <strong>parent</strong> 概念，这个我们在第二章变量对象中有<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13#heading-9" target="_blank" rel="noopener">讨论</a>过。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> VO1 = &#123;<span class="attr">__parent__</span>: <span class="literal">null</span>, ... other data&#125;; --&gt;</span><br><span class="line"><span class="keyword">var</span> VO2 = &#123;<span class="attr">__parent__</span>: VO1, ... other data&#125;; --&gt;</span><br><span class="line"><span class="comment">// etc.</span></span><br></pre></td></tr></table></figure>
<p>但是使用一个数字来表示一个作用域链更方便，所以我们将使用这种方法。除此之外，规范中声明的“一个作用域链就是一个对象列表”本身就是抽象的。不管可以在实现级别上使用带有<strong>parent</strong>功能的层次链的方法。数组抽象表示法是列表概念的理想选择。</p>
<p>我们接下来要讨论的AO + [[Scope]]的组合和标识符解析过程都与函数生命周期有关</p>
<h2 id="函数声明周期"><a href="#函数声明周期" class="headerlink" title="函数声明周期"></a>函数声明周期</h2><p>函数的声明周期分为创建和执行两个阶段。接下来详细看看。</p>
<h3 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h3><p>我们知道，在进入上下文阶段的时候，函数声明会放入变量/活动对象（VO/AO）。来看看这个例子，在全局上下文（即变量对象就是全局对象自身，还记得吗？）中声明一个变量和一个函数：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">	alert(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>在函数激活时候，我们看到正确的（意料中的）结果 — 30。但是，其中有非常重要的一点。</p>
<p>在这之前，我们值讨论了当前上下文的变量对象。但是这里我们可以看到， ‘y’ 变量是定义在函数 ‘foo’ 的内部（即是在 ’foo‘ 上下文的 AO 中），而变量 ‘x’ 没有定义在 ‘foo’ 上下文中，因此它没有被添加到 ‘foo’ 的AO中。乍一看，函数 ‘foo’ 中根本不存在变量 ‘x’，但是正如我们看到的那样，仅仅只是“乍一看”。 ‘foo’上下文的活动对象中只有一个属性 — 属性 ‘y’ 。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">fooContext.AO = &#123;</span><br><span class="line">	y: <span class="literal">undefined</span> <span class="comment">// 进入上下文的时候是 undefined ， 执行的时候才是 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那’foo’函数又是如何访问’x’变量的呢？我们设想函数可以访问更高层上下文的变量对象，那这一切就说得通了。事实上，的确如此，并且实际上，这种机制是通过函数内部的[[Scope]]属性实现的。</p>
<blockquote>
<p>[[Scope]]是所有父变量对象的层级链，这些父变量对象位于当前函数上下文之上。这个层次连在（函数）创建时候被保存到函数。</p>
</blockquote>
<p>注意重要的一点 — [[Scope]]在函数创建是被保存 — 永久的保存 — 直到函数销毁。函数可以不被调用，但是 [[Scope]] 属性却写入并保存到函数对象中了。</p>
<p>另一个值得思考的，与作用域（作用域链）相比， [[Scope]] 是函数的属性，而不是上下文。上面的那个例子中， ‘foo’ 函数的 [[Scope]] 可以这样表示：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">foo.[[Scope]] = [</span><br><span class="line">	globalContext.VO <span class="comment">// === global</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>更远的说，真如我们知道的，函数调用的时候，进入函数上下文并且活动对象（AO）被创建，同时， <code>this</code> 值和 <code>Scope</code> （作用域链）被决定。我们来详解看看这种情况。</p>
<h3 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h3><p>在定义中以及说过了，在进入上下文和确定AO/VO后，上下文（供变量查找的作用域链）的 <em>Scope</em> 属性被定义为这样：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Scope = AO|VO = [[Scope]]</span><br></pre></td></tr></table></figure>
<p>这里的重点是，<em>Scope</em>数组的第一个元素是活动对象，我们他把添加到作用域链中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure>
<p>这一点对于标识符解析的过程非常重要。</p>
<blockquote>
<p>标识符解析是确定变量（或者是函数声明）属于哪一个变量对象的过程。</p>
</blockquote>
<p>这个算法的返回此总是一个引用类型的值，基本组成都是相应的变量对象（如果变量没有找到则为 <code>null</code> ），并且属性名称是由查找（解析）标识符的名称组成。在<a href="https://juejin.im/post/5ec49063e51d457848684711" target="_blank" rel="noopener">第三章</a>中我们详细讨论了引用类型。</p>
<p>标识符解析过程包括寻找与变量名一致的属性，例如，在作用域链中对变量对象进行了连续检查，从上下文的最底层到作用域链的最顶层。</p>
<p>因此，在查找上变量的优先级上，上下文中的局部变量比父级上下文中的变量更高，即使是在不同上下文中两个变量名字相同的情况下，第一个找到的也是更深层次上下文中的变量（即更接近局部上下文的那一个）。</p>
<p>我们来使上述例子复杂一点，并在更里层添加一些其他内容：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="number">30</span>;</span><br><span class="line">    alert(x +  y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">foo(); <span class="comment">// 60</span></span><br></pre></td></tr></table></figure>
<p>这些上下文中，包含了如下内容：<em>变量对象/活动对象，函数的[[Scope]]属性和作用域链。</em></p>
<p>全局上下文的变量对象是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">globalContext.VO === Global = &#123;</span><br><span class="line">	x: <span class="number">10</span>,</span><br><span class="line">	foo: <span class="xml"><span class="tag">&lt;<span class="name">函数引用</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>foo</code>创建的时候， <code>foo</code> 的 <code>[[Scope]]</code> 属性是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">foo.[[Scope]] = [</span><br><span class="line">	globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>foo</code> 调用的时候， <code>foo</code> 上下文中的活动对象是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">fooContext.AO = &#123;</span><br><span class="line">	y: <span class="number">20</span>,</span><br><span class="line">	bar: <span class="xml"><span class="tag">&lt;<span class="name">函数引用</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>foo</code> 上下文的作用域链是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">fooContext.Scope = fooContext.AO + foo.[[Scope]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即</span></span><br><span class="line">fooContext.Scope = [</span><br><span class="line">	fooContext.AO,</span><br><span class="line">	globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>内部 <code>bar</code> 函数创建时，它的 <code>[[Scope]]</code> 是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">bar.[[Scope]] = [</span><br><span class="line">	fooContext.AO,</span><br><span class="line">	globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p><code>bar</code> 函数调用时候， <code>bar</code> 上下文的活动对象是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">barContext.AO = &#123;</span><br><span class="line">	z: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bar</code> 上下文的作用域链是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">barContext.Scope = barContext.AO + bar.[[Scope]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即：</span></span><br><span class="line">barContext.Scope = [</span><br><span class="line">	barContext.AO,</span><br><span class="line">	fooContext.AO,</span><br><span class="line">	globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p><code>x</code> ， <code>y</code> ， <code>z</code> 的标识符解析：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x</span></span><br><span class="line">--&gt; barContext.AO <span class="comment">// 没有，进入上一层</span></span><br><span class="line">--&gt; fooContext.AO <span class="comment">// 没有，进入上一层</span></span><br><span class="line">--&gt; globalContext.VO <span class="comment">// 找到了 x = 10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y</span></span><br><span class="line">--&gt; barContext.AO <span class="comment">// 没有，进入上一层</span></span><br><span class="line">--&gt; fooContext.AO <span class="comment">// 找到了 y = 20</span></span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// z</span></span><br><span class="line">--&gt; barContext.AO <span class="comment">// 找到了 z = 30</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域的特性"><a href="#作用域的特性" class="headerlink" title="作用域的特性"></a>作用域的特性</h2><p>我们来看看与作用域链与函数 <code>[[Scope]]</code> 属性更多相关的特性。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>ECMAScript中闭包与函数的 <code>[[Scope]]</code> 属性直接相关。之前说过， <code>[[Scope]]</code> 在函数创建是保存并在函数对象销毁的时候消失。实际上，闭包恰恰就是函数代码与 <code>[[Scope]]</code> 属性的组合。因此，</p>
<p><code>[[Scope]]</code> 包含了函数创建时的词法环境（即父级变量对象）。在进一步的函数激活中，将在此词汇链（创建时静态保存的）中搜索更高上下文中的变量。</p>
<p>例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">	foo(); <span class="comment">// 10 ，而不是20</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>变量 <code>x</code> 在 <code>foo</code> 函数的 <code>[[Scope]]</code> 属性中找到了，对于变量而言，实在函数创建那一刻的词汇（封闭）链中查找，而不是在函数调用（这时候 <code>x</code> 被赋值为20）时候的动态链。</p>
<p>另一个闭包的典型案例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert([x, y])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo(); <span class="comment">// 返回匿名函数</span></span><br><span class="line">bar();<span class="comment">// [10, 20];</span></span><br></pre></td></tr></table></figure>
<p>我们再次看到，对于标识符解析，使用了在函数创建时定义的词法作用域链 — 变量 <code>x</code> 被赋值为 <code>10</code> ，而不是 <code>30</code> 。而且，这个例子还清楚的展示了，即使是在一个函数已经创建完成上下文后，函数的 <code>[[Scope]]</code> （这个例子中， <code>foo</code> 函数番号的匿名函数）依然存在。</p>
<p>有关闭包理论以及其在ECMAScript中的实现的更多详情，请查阅<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="noopener">第六章：闭包</a>。</p>
<h3 id="通过Function构造函数创建的函数的-Scope"><a href="#通过Function构造函数创建的函数的-Scope" class="headerlink" title="通过Function构造函数创建的函数的[[Scope]]"></a>通过Function构造函数创建的函数的[[Scope]]</h3><p>在上面的例子中，我们了解到函数在创建的时候获得 <code>[[Scope]]</code> 属性，并且通过此属性可以访问所有父级作用域的变量。然而对于一点有一个例外，这关系到通过Function构造函数创建的函数。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">barFD</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 函数声明</span></span><br><span class="line">		alert(x);</span><br><span class="line">		alert(y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> barFE = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 函数表达式</span></span><br><span class="line">		alert(x);</span><br><span class="line">		alert(y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> barFn = <span class="built_in">Function</span>(<span class="string">'alert(x); alert(y);'</span>);</span><br><span class="line"></span><br><span class="line">	barFD(); <span class="comment">// 10, 20</span></span><br><span class="line">	barFE(); <span class="comment">// 10, 20</span></span><br><span class="line">	barFn(); <span class="comment">// 20, y is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>可以看到，对于通过 <code>Function</code> 构造函数创建的函数 <code>barFn</code> ，变量 <code>y</code> 是不可访问的。但是这并不意味着函数 <code>barFn</code> 没有内部的 <code>[[Scope]]</code> 属性（即使他没有权限访问变量 <code>x</code> ）。原因是因为用过 <code>Function</code> 构造函数创建的函数的 <code>[[Scope]]</code> 的属性总是<strong>只包含全局对象。</strong>因此，通过这种函数无法创建除了全局以外的（还包含其他）上层上下文的闭包。</p>
<h3 id="二维作用域链查找"><a href="#二维作用域链查找" class="headerlink" title="二维作用域链查找"></a>二维作用域链查找</h3><p>在作用域链中查找的很重要的一点就是变量对象的原型（如果有）也要被考虑进去 — 由于ECMAScript的原型性质：如果没有直接在对象中找到属性，则其查找将会在原型链中进行。就像是链的某种2D查找：（1）在原型链连接上，（2）在每一个原型链连接上 — 深入到链链接的原型。如果在 <code>Object.prototype</code> 中定义属性，我们可以观察到这种效果：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>活动对象没有原型链，我们可以在下面的例子中看出来：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>bar</code> 函数上下文的活动对象有原型，那么 <code>x</code> 属性应该在 <code>Object.prototype</code> 中解析，而不是直接在AO中解析。但是在上面的第一个例子中，在解析标识符中遍历作用域链，我们到达了全局对象（在某些视线中而不是全部），它继承自 <code>Object.prototype</code> ，因此解析为10。</p>
<p>类似的情况在某些版本的带有明明函数表达式的SpiderMokey中也有，其中存储函数表达式可选名称的对象是继承自 <code>Object.protoype</code> 的，在某些版本的Balckberry中，活动对象也是继承自 <code>Object.prototype</code>。更多这个特性的详情将在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="noopener">第五章：函数</a>中讨论。</p>
<h3 id="全局上下文与eval上下文的作用域链"><a href="#全局上下文与eval上下文的作用域链" class="headerlink" title="全局上下文与eval上下文的作用域链"></a>全局上下文与eval上下文的作用域链</h3><p>这或许不太有趣，但是这很重要。全局上下文的作用域链中只包含了全局对象。“eval”类型代码的上下文与调用上下文有相同的作用域链。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">globalContext.Scope = [</span><br><span class="line">  Global</span><br><span class="line">];</span><br><span class="line">  </span><br><span class="line">evalContext.Scope === callingContext.Scope;</span><br></pre></td></tr></table></figure>
<h3 id="代码执行时对作用域链的影响"><a href="#代码执行时对作用域链的影响" class="headerlink" title="代码执行时对作用域链的影响"></a>代码执行时对作用域链的影响</h3><p>在ECMAScript中有两种语句在代码执行时可以修改作用域链。他们是 <code>with</code> 语句和 <code>catch</code> 语句。他们都把出现在这些语句中的查询标识符所需要的对象添加到了作用域链的最前端。如果其中一种情况发生了，那么作用域链就会被修改为如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Scope = withObject|catchObject + AO/VO + [[Scope]]</span><br></pre></td></tr></table></figure>
<p>下面例子中 <code>with</code> 语句添加一个对象作为他的参数（因此这个对象的属性无需前缀即可访问）：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(foo) &#123;</span><br><span class="line">	alert(x); <span class="comment">// 10</span></span><br><span class="line">	alert(y); <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的作用域：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Scope = foo + AO/VO + [[Scope]]</span><br></pre></td></tr></table></figure>
<p>让我们再次展示，标识符是在with语句添加到作用域链前面的对象中解析的：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>, y = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> (&#123;<span class="attr">x</span>: <span class="number">20</span>&#125;) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">30</span>, y = <span class="number">30</span>;</span><br><span class="line">  </span><br><span class="line">  alert(x); <span class="comment">// 30</span></span><br><span class="line">  alert(y); <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">alert(x); <span class="comment">// 10</span></span><br><span class="line">alert(y); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>发生了什么？在进入上下文阶段，”x”和”y”被添加到变量对象。因此，代码执行阶段，有如下修改：</p>
<ul>
<li>x = 10, y = 10；</li>
<li>对象 <code>{x: 20}</code> 添加到作用域链的顶端；</li>
<li><code>with</code> 代码块中遇到 <code>var</code> 语句，什么也没有创建，因为所有的变量已经在进入上下文的阶段被解析和添加；</li>
<li>只有 “x” 的值修改了，确切的说 “x” 是第二步在作用域顶端添加对象的时候被修改的。“x“先是20，然后变成了30；</li>
<li>”y“也修改了，因为上面的变量对象造成的，因此，先是10，变成了30；</li>
<li>因此， <code>with</code> 语句完成后，他的特殊对象从作用域链中移除（并且被修改的 ”x“ — 30也随着对象移除被移除），作用域链恢复到 <code>with</code> 语句增强以前的状态；</li>
<li>最后两个alert：当前变量对象中的“ x”值保持不变，并且“ y”的值现在等于30，并且在 <code>with</code> 语句中被更改。</li>
</ul>
<p>另外，为了能够访问parameter-exception的catch子句会创建一个具有唯一属性（异常参数名称）的中间范围对象，并将此对象置于范围链的前面。从示意图上看，它看起来是这样的：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  alert(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的作用域：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> catchObject = &#123;</span><br><span class="line">  ex: <span class="xml"><span class="tag">&lt;<span class="name">exception</span> <span class="attr">object</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml">  </span></span><br><span class="line"><span class="xml">Scope = catchObject + AO|VO + [[Scope]]</span></span><br></pre></td></tr></table></figure>
<p>catch语句执行完成后，作用域链也会恢复到之前的状态。</p>
<hr>
<p>所以啊，开发中经常听到老前辈说尽量不要使用 <code>with</code> 和 <code>try...catch</code> 。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMA</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-262-3深入解析第三章：This</title>
    <url>/%E6%8A%80%E6%9C%AF/ECMA-262-3%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AThis.html</url>
    <content><![CDATA[<p>从来没有深入了解ECMA，网上找了一下，发现早在2010年就有大佬 <a href="http://dmitrysoshnikov.com/about/" target="_blank" rel="noopener">Dmitry Soshnikov</a> 总结了ECMA中的核心内容，我这里只是翻译记录，加深自己的印象。文章原文来自 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="noopener">ECMA-262-3 in detail. Chapter 3. This.</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在这篇文章里，我们将讨论更多与执行上下文相关的细节。讨论的主题就是 <code>This</code> 关键字。</p>
<p>实践证明，这个主题很难，并且在不同的执行上下文中经常导致确定 <code>this</code> 的值很难。</p>
<p>许多程序员认为，在程序语言中， <code>this</code> 关键字与面向对象编程很接近（紧密相关），它完全指向于由构造函数新创建的对象。在ECMAScript中，这个概念也得到了实现，但是，正如我们即将看到的，这里的概念不仅限于所创建对象的定义。</p>
<p>让我们更详细的了解一下，在ECMAScript中， <code>this</code> 的值到底是什么。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p><code>this</code> 是执行上下文的一个属性。这是一个在代码初始时就存在的一个特殊对象。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line">	VO: &#123;...&#125;,</span><br><span class="line">	<span class="keyword">this</span>: thisValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 VO 就是<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13" target="_blank" rel="noopener">上一章</a>中我们讨论过的变量对象。</p>
<p><code>this</code> 与<a href="https://juejin.im/post/5ebcdda76fb9a0433567b062" target="_blank" rel="noopener">上下文中可执行代码类型</a>直接相关。这个值在进入上下文的时候就已经确定了，并且在代码运行的时候不会改变。</p>
<p>让我们更详细的考虑一下这些情况。</p>
<h2 id="全局代码中的This的值"><a href="#全局代码中的This的值" class="headerlink" title="全局代码中的This的值"></a>全局代码中的This的值</h2><p>在这里，一切都很简单。在全局代码中， <code>this</code> 的值总是指向 <em>global object（全局对象自身）</em>。因此，可以间接使用它：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示的在全局对象上定义属性</span></span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">10</span>; <span class="comment">// global.a = 10;</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过分配不合规的标识符进行隐式定义</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过变量声明的形式隐式定义，因为全局上下文中的变量对象就是全局对象自己</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.c); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<h2 id="函数代码中的This值"><a href="#函数代码中的This值" class="headerlink" title="函数代码中的This值"></a>函数代码中的This值</h2><p>当 <code>this</code> 的值在函数代码中的时候，事情变得更加有趣了。这种情况很难（理解this），并且可能会造成很多问题。</p>
<p>在这种类型的代码中， <code>this</code> 的第一（或者说，主要）特征就是 <code>this</code> 没有静态的与函数绑定。</p>
<p>上面已经提到了， <code>this</code> 的值是在进行上下文的时候就已经确定了的，但是在函数代码的这种情况下， <code>this</code> 的值可能在每一次（进入执行上下文）都不同。</p>
<p>但是，在代码运行的时候， <code>this</code> 的值是不可变的。例如：不能传递一个新的值给他，因为他<em>不是一个变量</em>。相比之下，使用 <code>Python</code> 编程语言及其显示定义的 <code>self</code> 对象，都是可以在运行的时候进行多次更改。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">	x: <span class="number">20</span>,</span><br><span class="line">	test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === bar); <span class="comment">// true</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span> = foo; <span class="comment">// 报错了 Invalid left-hand side in assignment</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// 如果没有报错的话，将会是10而不是20</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当进入上下文的时候，this的值被确定为 ‘bar’ 对象</span></span><br><span class="line"><span class="comment">// 为什么会这样，将会在下面讨论</span></span><br><span class="line">bar.test(); <span class="comment">// true, 20</span></span><br><span class="line">foo.test = bat.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，这里的 this 值没有指向 'foo' -- 即使我们调用了相同的函数 </span></span><br><span class="line">foo.test(); <span class="comment">// false, 10</span></span><br></pre></td></tr></table></figure>
<p>那么，什么会影响函数代码中 <code>this</code> 的值呢？有几种因素。</p>
<p>首先，在通常的函数调用中， <code>this</code> 是由激活上下文的调用者提供（就是我们说的谁调用就指向谁），即调用户数的父级上下文。 <code>this</code> 的值取决于调用函数的方式。（换句话说，在语法构成上，函数是以怎样的形式被调用的）</p>
<p>为了能够在任何上下文中毫无疑问的确定 <code>this</code> 的值，理解并记住这个重点是非常有必要的。调用表达式的确切形式，或者说调用函数的方法影响了调用上下文中的 <code>this</code> 值而不是其他（情况）。</p>
<p>（我们在一些文章甚至是关于Javascript的书籍中看到，他们指出： <code>this</code> 值取决于函数如何定义：如果是一个全局函数， <code>this</code> 指向全局对象，如果是一个对象的方法， <code>this</code> 总是指向这个对象。 — 这绝对是不正确的）。继续，我们可以看到，即使是普通的全局函数也可以被不同形式的的调用形式激活，这些不同的形式影响了不同的 <code>this</code> 值。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// global</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo === foo.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是相同的函数使用另一种形式， this 值就不一样了</span></span><br><span class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype</span></span><br></pre></td></tr></table></figure>
<p>作为一个对象的方法来调用的时候也可能出现类似的情况， <code>this</code> 的值不会是这个对象。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">	bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === foo);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar(); <span class="comment">// foo, true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exampleFunc = foo.bar;</span><br><span class="line"><span class="built_in">console</span>.log(exampleFunc === foo.bar); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再一次，相同函数的不同调用方式，不同的this值</span></span><br><span class="line">exampleFunc(); <span class="comment">// global, false</span></span><br></pre></td></tr></table></figure>
<p>所以，不同调用形式是怎样影响 <code>this</code> 值的呢？为了充分了解 <code>this</code> 的值，有必要详细分析一种内部类型 — 引用类型（Reference Type）。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>使用伪代码（假设存在这样的代码）的形式可以将 <code>Reference</code> 的值表示为一个含有两个属性的对象：</p>
<ul>
<li>base（拥有这个属性的对象）</li>
<li>base中的propertyName</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> valueOfReferenceType = &#123;</span><br><span class="line">	base: <span class="xml"><span class="tag">&lt;<span class="name">base</span> <span class="attr">object</span>&gt;</span>,</span></span><br><span class="line">	propertyName: &lt;property name&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：从ES5开始，在使用严格模式（use strict）的代码中，一个引用也包含了一个名为 <code>strict</code> 的属性。</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooReference = &#123;</span><br><span class="line">	base: global,</span><br><span class="line">	propertyName: foo,</span><br><span class="line">	strict: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引用类型的值只有两种情况：</p>
<ol>
<li>当我们处理一个标识符（原文：when we deal with an identifier）</li>
<li>或者一个属性访问器（原文：or with a property accessor）</li>
</ol>
<p>标识符的处理过程会在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="noopener">Chapter 4. Scope chain</a>中详细介绍。这里呢，我们只需要注意，从这个算法返回值总是一个引用类型的值（这对 <code>this</code> 的值很重要）。</p>
<p><strong>标识符是变量名，函数名，函数参数名和全局对象中不合规（没有定义）的属性名</strong>。例如，下面标识符中的值：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>在操作的过度结果中，引用类型对应的值如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">	base: global,</span><br><span class="line">	propertyName: <span class="string">'foo'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> barReference = &#123;</span><br><span class="line">	base: global,</span><br><span class="line">	propertyName: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了从引用类型的值中获取一个对象真正的值，在伪代码中可以使用 <code>GetValue</code> 方法，就像下面这样：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Type(value) != Reference) &#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> base = GetBase(value);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (base === <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> base.[[<span class="keyword">get</span>]](GetPropertyName(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部 <code>[[Get]]</code> 方法返回对象属性的真实值，包括对原型链继承属性的分析：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">GetValue(fooReference); <span class="comment">// 10</span></span><br><span class="line">GetValue(barReference); <span class="comment">// function object 'bar'</span></span><br></pre></td></tr></table></figure>
<p>属性访问器因该知道，他的两种变体：点（.）符号（当属性名是正确的标识符且实现知道的时候），和括号（[]）符号。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">foo.bar();</span><br><span class="line">foo[<span class="string">'bar'</span>]();</span><br></pre></td></tr></table></figure>
<p>在计算中间的返回值中，引用类型对应的值如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooBarReference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  propertyName: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">GetValue(fooBarReference); <span class="comment">// function object "bar"</span></span><br></pre></td></tr></table></figure>
<p>那么，引用类型的值又和函数上下文中的 <code>this</code> 的值又是怎样关联起来的呢？<strong>重点来了</strong>，这个关联时机是整篇文章个核心。在一个函数上下文中， 确定<code>this</code> 值的通用规则如下：</p>
<ul>
<li>函数上下文中的 <code>this</code> 值由调用者提供，由函数调用的方式决定（语法上怎么写函数就怎么调用）</li>
<li>如果调用括号()的左侧是一个引用类型的值， <code>this</code> 将被设置成这个引用类型值的 base 对象。</li>
<li>所有的其他情况中（与引用类型不同的任何其它属性）, <code>this</code> 的值往往都是 <code>null</code> 。但是 <code>this</code> 值为 <code>null</code> 将没有任何意义，所以，他将隐式的被转换成全局对象。</li>
</ul>
<p>看一个例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;;</span><br><span class="line">foo(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p>我们看到在括号调用的左边是一个引用类型值（因为 foo 是一个标识符）：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooFeference = &#123;</span><br><span class="line">	base: global,</span><br><span class="line">	propertyName: <span class="string">'foo'</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>因此， <code>this</code> 的值被设置成了引用类型值的base对象，即，全局对象。</p>
<p>相似的情况也出现在属性访问中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">	bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<p>同样，我们拥有一个引用类型的值，其base是foo对象，在bar函数激活的时候将base赋值给this。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooBarReference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  propertyName: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然而，同样的函数，使用另一种方式执行，得到不一样的值：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = foo.bar;</span><br><span class="line">test(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>test</code> 是标识符，生成了其他引用类型值，该值的base（全局对象）被设置为this的值。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: <span class="string">'test'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：在ES5的严格模式中， <code>this</code>值没有强制指向全局对象，而是<code>undefined</code></p>
<p>现在，我们可以很明确的说，为什么用不同的形式激活相同的函数会有不一样的 <code>this</code> 值呢？答案是引用类型的不同中间值。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// global object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">	base: global,</span><br><span class="line">	propertyName: <span class="string">'foo'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo === foo.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype, 因为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooPrototypeConstructorReference = &#123;</span><br><span class="line">	base: foo.prototype,</span><br><span class="line">	propertyName: <span class="string">'constructor'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一个动态确定 <code>this</code> 值的（经典）例子，就是调用表达式的方式：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = &#123;<span class="attr">bar</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> y = &#123;<span class="attr">bar</span>: <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">x.test = foo;</span><br><span class="line">y.test = foo;</span><br><span class="line"></span><br><span class="line">x.test(); <span class="comment">// 10</span></span><br><span class="line">y.test(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<h2 id="函数调用与非引用类型"><a href="#函数调用与非引用类型" class="headerlink" title="函数调用与非引用类型"></a>函数调用与非引用类型</h2><p>因此，真如我们上面提到的，如果在调用括号的左侧有一个不是引用类型的值，而是其他类型的值，那么 <code>this</code> 的值将自动设置为 <code>null</code> ，最终的结果就是， <code>this</code> 指向了全局对象。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// null ==&gt; global</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这个例子中，（括号左侧）是一个函数对象而不是一个引用类型的对象（他不是标识符也不是属性访问器），相应的， <code>this</code> 的值最终设置成了全局对象。</p>
<p>更复杂的例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">	bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); <span class="comment">// Reference, OK ==&gt; foo</span></span><br><span class="line">(foo.bar)(); <span class="comment">// Reference, OK ==&gt; foo</span></span><br><span class="line"></span><br><span class="line">(foo.bar = foo.bar)(); <span class="comment">// global ?</span></span><br><span class="line">(<span class="literal">false</span> || foo.bar)(); <span class="comment">// global ?</span></span><br><span class="line">(foo.bar, foo.bar)(); <span class="comment">// global ?</span></span><br></pre></td></tr></table></figure>
<p>那么，为什么有一个属性访问器了，中间值也是一个引用类型的值，在某些调用中，我们得到的 <code>this</code> 值不是base对象而是global。</p>
<p>问题出现在最后的三个调用中，在调用某些操作后，括号左侧的值将<strong>不再是</strong>引用类型。</p>
<p>在第二个例子中，分组运算（grouping operator，结合上面的例子，这里指的就是这个<code>()</code>）没有生效，仔细想想上面提到的，从一个引用类型获取真正值的方法，如：<code>GetValue</code> 。因此，分组运算的返回值依旧是一个引用类型的值，这就是为什么 <code>this</code> 值仍然是base对象，即这里的 <code>foo</code> 。</p>
<p>在第三个例子中，不像分组运算，复制运算调用了 <code>GetValue</code> 方法。结果就是这个运算返回的是一个函数对象（而不是一个引用类型），这就意味着， <code>this</code> 值成了 <code>null</code> ，最终指向了global。</p>
<p>第四个与第五个也是一样的，逗号运算与逻辑运算（OR）调用了 <code>GetValue</code> 方法，失去了引用类型的值，取而代之的是一个函数类型的值，最终 <code>this</code> 指向了global。</p>
<p><strong>关于这个问题，其实有点模糊，原文中作者为一个名叫Aprit的提问者做出了这样的回答</strong>：</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d6e05455-3a77-418b-80b9-f1cddce2cc93/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d6e05455-3a77-418b-80b9-f1cddce2cc93/Untitled.png"></p>
<h2 id="引用类型与this为null"><a href="#引用类型与this为null" class="headerlink" title="引用类型与this为null"></a>引用类型与this为null</h2><p>有一种情况，当括号左侧的表达式（即调用方式）决定了引用类型的值， <code>this</code> 的值无论是以何种方式设置成 <code>null</code> 的，最终都将被设置成 global。当引用类型的base对象是一个活动对象的时候就造成这种情况。</p>
<p>我们可以从父级调用内部函数的例子中看到这种情况。在<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13" target="_blank" rel="noopener">第二章</a>我我们了解到，局部变量，内部函数和形式参数存储在给定函数的活动对象中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// global</span></span><br><span class="line">	&#125;</span><br><span class="line">	bar(); <span class="comment">// 等同于 AO.bar()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>活动对象总是作为 <code>this</code> 的值返回 — null（伪代码 <code>AO.bar()</code> 等同于 <code>null.bar()</code>）。再次回到上面的描述中， <code>this</code> 的值再次被设置为 null。</p>
<p>有一个例外，在 <code>with</code> 语句中调用一个函数且 <code>with</code> 对象包含函数名称属性（结合下面的例子，值得应该是属性对应的值是一个函数）。 <code>with</code> 语言把他的对象添加到<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="noopener">作用域链</a>的最前端，即在活动对象之前。因此，引用类型有值（通过标识符或者属性访问器），base对象不是活动对象而是 <code>with</code> 语句对象。顺便提一下，这种情况不仅与内部函数有个，也与全局函数有关，因为 <code>with</code> 对象比作用域链的顶层对象（全局对象或者活动对象）还有靠前。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> (&#123;</span><br><span class="line"> </span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">  x: <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">&#125;) &#123;</span><br><span class="line"> </span><br><span class="line">  foo(); <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// because</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span>  fooReference = &#123;</span><br><span class="line">  base: __withObject,</span><br><span class="line">  propertyName: <span class="string">'foo'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>catch</code> 语句中的实际参数的函数调用也存在相同的情况：在这种情况下， <code>catch</code> 对象也是被添加到了作用域链的最前端，在活动对象或者全局对象之前。但是，这种表现在 ECMA-262-3 中被认为是一个bug，并且在 ECMA-262-5 中被修复。修复后，在给定的活动中， <code>this</code> 值指向的是全局对象而不是 <code>catch</code> 对象。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  e(); <span class="comment">// __catchObject - in ES3, global - fixed in ES5</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// on idea</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> eReference = &#123;</span><br><span class="line">  base: __catchObject,</span><br><span class="line">  propertyName: <span class="string">'e'</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// but, as this is a bug</span></span><br><span class="line"><span class="comment">// then this value is forced to global</span></span><br><span class="line"><span class="comment">// null =&gt; global</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> eReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: <span class="string">'e'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样的情况还出现在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#feature-of-named-function-expression-nfe" target="_blank" rel="noopener">命名函数</a>（关于函数的更多细节查看 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="noopener">Chapter 5. Functions</a>）的递归调用中。在函数第一次调用的时候，base对象是父级的活动对象（或者是全局对象），在递归调用中，base对象应该是存储着函数表达式可选名称的特殊对象。但是，在这个例子中， <code>this</code> 总是被设置为 global。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">  !bar &amp;&amp; foo(<span class="number">1</span>); <span class="comment">// "should" be special object, but always (correct) global</span></span><br><span class="line"> </span><br><span class="line">&#125;)(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<h2 id="构造函数中的-this-值"><a href="#构造函数中的-this-值" class="headerlink" title="构造函数中的 this 值"></a>构造函数中的 this 值</h2><p>还有一个在函数上下文中和 <code>this</code> 值息息相关的例子 — 函数作为构造器调用。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// newly created object, below - "a" object</span></span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，new操作符调用 <code>A</code> 函数内部的 [[Constructor]] 方法，在创建对象以后，接着调用内部的 [[Call]] 方法，所有相同函数 <code>A</code> ，都将 <code>this</code> 值设置为新创建的对象。</p>
<h2 id="手动设置一个函数调用的this"><a href="#手动设置一个函数调用的this" class="headerlink" title="手动设置一个函数调用的this"></a>手动设置一个函数调用的this</h2><p>在 <code>Function.prototype</code> 中定义了两个方法（因此所有的函数都可以访问），函数调用的时候可以手动的修改 <code>this</code> 值。他们是 <code>call</code> 和 <code>apply</code> 方法。</p>
<p>这两个函数都可以在函数执行上下文中将 <code>this</code> 值设置为接收的第一个参数。两个方法的区别不大：对于 <code>apply</code> 来说，第二个参数必须是一个数组（或者是一个类数组的对象，比如： <code>arguments</code> ）。相反的， <code>call</code> 方法可以接收人么参数。两个方法都必须有第一个参数 — this。</p>
<p>例如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">a(<span class="number">20</span>); <span class="comment">// this === global, this.b == 10, c == 20</span></span><br><span class="line"> </span><br><span class="line">a.call(&#123;<span class="attr">b</span>: <span class="number">20</span>&#125;, <span class="number">30</span>); <span class="comment">// this === &#123;b: 20&#125;, this.b == 20, c == 30</span></span><br><span class="line">a.apply(&#123;<span class="attr">b</span>: <span class="number">30</span>&#125;, [<span class="number">40</span>]) <span class="comment">// this === &#123;b: 30&#125;, this.b == 30, c == 40</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMA</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-262-3深入解析第二章：变量对象</title>
    <url>/%E6%8A%80%E6%9C%AF/ECMA-262-3%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html</url>
    <content><![CDATA[<p>从来没有深入了解ECMA，网上找了一下，发现早在2010年就有大佬 <a href="http://dmitrysoshnikov.com/about/" target="_blank" rel="noopener">Dmitry Soshnikov</a> 总结了ECMA中的核心内容，我这里只是翻译记录，加深自己的印象。文章原文来自 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="noopener">ECMA-262-3 in detail. Chapter 2. Variable object.</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在我们创建应用程序的时候，总是避免不了会进行函数和变量的声明。但是，解释器（interpreter）是怎么找到我们的数据（函数和变量）的呢？又是在哪里找到的呢？我们引用我们需要的对象的时候又发生了什么呢？</p>
<p>大部分程序员都知道变量与<a href="https://juejin.im/post/5ebcdda76fb9a0433567b062" target="_blank" rel="noopener">执行上下文</a>紧密相关。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// variable of global context</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// local variable of the function context</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">alert(a); <span class="comment">// 10</span></span><br><span class="line">alert(b); <span class="comment">// b is not defined</span></span><br></pre></td></tr></table></figure>
<p>同样，许多程序员也都知道，在当前的版本规范中，只有函数（function）代码的执行上下文才可以创建独立的作用域。与C++等语言相反，在ECMAScript中，for循环 <code>没有</code> 创建一个独立的作用域。这就是为什么，下面的代码， <code>i</code> 始终是5</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	obj[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123; obj[k]() &#125;</span><br></pre></td></tr></table></figure>
<p>我们来详细了解一下声明数据的时候都发生了什么。</p>
<h2 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h2><p>如果变量与执行上下文相关，那么，他就知道它的数据存放在哪里以及如何获取。这种机制称为 <code>变量对象(variable object)</code></p>
<p>一个变量对象（缩写形式 - VO）是包含执行上下文的特殊对象，并且保存着：</p>
<ul>
<li>variables( <code>var</code>, 变量声明 )</li>
<li>function declarations(函数声明，缩写形式为FD)</li>
<li>函数形参</li>
</ul>
<p>以上内容均在上下文中声明。</p>
<p><strong>Notice：在ES5中，变量对象的概念已经被词汇环境模型所取代。</strong></p>
<p>举例来说，可以将变量对象表示为普通的ESMAScript对象：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">VO = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>正如我们所说，变量对象是执行上下文的一个属性，则：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line">	VO: &#123;</span><br><span class="line">		<span class="comment">// context data(var, FD, function arguments)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有全局上下文中的变量对象可以通过VO的属性名称间接访问、使用（其中全局变量自身就是变量对象）。对于其他的上下文，直接访问VO是不可能的，因为它（VO）纯粹是实现机制（内部的事情）。</p>
<p>当我们声明变量或者函数的时候，除了使用变量名和值创建VO的新属性外，没有其他的事情了。</p>
<p>例如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line">test(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>对应的变量对象是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局的变量对象</span></span><br><span class="line">VO(globalContext) = &#123;</span><br><span class="line">	a: <span class="number">10</span>,</span><br><span class="line">	test: <span class="xml"><span class="tag">&lt;<span class="name">test</span>&gt;</span> fn</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 函数 test 中的变量对象</span></span><br><span class="line"><span class="xml">VO(test functionContext) = &#123;</span></span><br><span class="line"><span class="xml">	x: 30,</span></span><br><span class="line"><span class="xml">	b: 20</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是在具体的实现层级（和规范中），变量对象只是抽象的事物（实际上是不存在的）。从根本上来说，在不同的具体执行上下文中，VO的名称和初始结构都是不同的。</p>
<h2 id="不同执行上下文中的变量对象"><a href="#不同执行上下文中的变量对象" class="headerlink" title="不同执行上下文中的变量对象"></a>不同执行上下文中的变量对象</h2><p>变量对象的某些操作（例如：变量实例化）和表现对于所有的执行上下文类型都成很普通的。从这个角度出发，将变量对象当作为一个抽象的基础物质更容易理解。函数上下文还可以定义域变量对象相关的其他详细信息。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">AbstractVO (变量实例化过程的一般行为)</span><br><span class="line"> </span><br><span class="line">  ║</span><br><span class="line">  ╠══&gt; GlobalContextVO</span><br><span class="line">  ║        (<span class="attr">VO</span> === <span class="attr">this</span> === global)</span><br><span class="line">  ║</span><br><span class="line">  ╚══&gt; FunctionContextVO</span><br><span class="line">           (<span class="attr">VO</span> === AO, &lt;arguments&gt; object <span class="literal">and</span> &lt;formal parameters&gt; are added)</span><br></pre></td></tr></table></figure>
<p>我们来详细分析一下：</p>
<h2 id="全局上下文中的VO"><a href="#全局上下文中的VO" class="headerlink" title="全局上下文中的VO"></a>全局上下文中的VO</h2><p>首先，要给出Global对象的定义：</p>
<blockquote>
<p>全局对象是在进入任何执行上下文之前就被创建好的。这个对象只存在一份，他的属性可以在进程的任何地方访问，进程结束，全局对象的声明周期结束。</p>
</blockquote>
<p>在创建时候，全局对象通过 <code>Math</code>， <code>String</code>， <code>Date</code> ， <code>parseInt</code> 等属性进行初始化，还可以附加其他对象作为属性，其中也包括引用全局对象自身的对象。例如：在BOM（浏览器对象模型）中，全局对象的 <code>window</code> 属性就是指向全局的（当然，并不是所有的实现都是这样的）。</p>
<p>请看下面的这个例子： <code>windos</code> 是global的属性，但同时值是global。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">global = &#123;</span><br><span class="line">	<span class="built_in">Math</span>: <span class="xml"><span class="tag">&lt;<span class="name">...</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">	String: <span class="tag">&lt;<span class="name">...</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">	...,</span></span><br><span class="line"><span class="xml">	window: global</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>当引用全局对象属性的时候，通常是省略前缀的，因为全局对象不可以直接通过名称访问。但是，可以通过<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/#this-value-in-the-global-code" target="_blank" rel="noopener">全局上下文中的 <code>this</code></a> 访问，也可以通过递归自己调用自己（例如BOM中的window）来访问。所以，代码可简写为：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">10</span>); <span class="comment">// 等同于 global.String(10);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有前缀</span></span><br><span class="line"><span class="built_in">window</span>.a = <span class="number">10</span>; <span class="comment">// === global.window.a = 10 === global.a = 10;</span></span><br><span class="line"><span class="keyword">this</span>.b = <span class="number">20</span>; <span class="comment">// global.b = 20;</span></span><br></pre></td></tr></table></figure>
<p>回到全局上下文中的变量对象，这里的变量对象就是全局变量本身。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">VO(globalContext) === global;</span><br></pre></td></tr></table></figure>
<p>准确理解 <em>全局上下文中的变量对象就是全局变量自身</em> 是非常有必要的，基于这个事实，在全局上下文中声明一个变量的时候，我们才可以通过全局对象的属性访问到这个变量（例如：实现未知变量名时）：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">alert(a); <span class="comment">// 直接获取到，因为在VO中找到了：'text'</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">window</span>[<span class="string">'a'</span>]); <span class="comment">// 间接获取到，通过 global === VO: 'text'</span></span><br><span class="line">alert(a === <span class="keyword">this</span>.a); <span class="comment">// true this === window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> akey = <span class="string">'a'</span>;</span><br><span class="line">alert(<span class="built_in">window</span>[akey]); <span class="comment">// 间接获取到，通过动态属性名 akey === 'a'</span></span><br></pre></td></tr></table></figure>
<h2 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h2><p>关于函数的执行上下文，VO是不能直接获取的。此时由活动对象（activation object）扮演VO的角色。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">VO(functionContext) === AO;</span><br></pre></td></tr></table></figure>
<p>活动对象在进入函数上下文的时候被创建，并且有一个属性名为 <code>argumants</code> ，属性值为 <code>Argumants Object</code> 的初始值：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">	<span class="built_in">arguments</span>: <span class="xml"><span class="tag">&lt;<span class="name">ArgO</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>Arguments Object</code> 是活动对象的属性，他包含以下属性：</p>
<ul>
<li>callee：指向当前函数的引用</li>
<li>length：实际传递的参数的数量</li>
<li>properties-indexes（属性索引，字符串类型的整数）：属性的值就是函数的参数值（按照参数列表从左往右排列）。属性索引的数量==arguments.length。属性索引对应的值和实际传进来的参数是 <strong>共享的</strong>。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义的函数的参数数量 (x, y, z)</span></span><br><span class="line">  alert(foo.length); <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 实际传递参数的数量 (only x, y)</span></span><br><span class="line">  alert(<span class="built_in">arguments</span>.length); <span class="comment">// 2</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 函数自身的引用</span></span><br><span class="line">  alert(<span class="built_in">arguments</span>.callee === foo); <span class="comment">// true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 参数共享</span></span><br><span class="line"> </span><br><span class="line">  alert(x === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line">  alert(x); <span class="comment">// 10</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">  alert(x); <span class="comment">// 20</span></span><br><span class="line">  <span class="number">11549</span></span><br><span class="line">  x = <span class="number">30</span>;</span><br><span class="line">  alert(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 30</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 但是，对于未传递参数的z，属性索引的值是不共享的</span></span><br><span class="line">  </span><br><span class="line">  z = <span class="number">40</span>;</span><br><span class="line">  alert(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">50</span>;</span><br><span class="line">  alert(z); <span class="comment">// 40</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>关于最后一个例子，在 chrome 的老版本中存在一个bug — 即，没有传递参数z，z 与 arguments[2] 的仍然是共享的。</p>
<h2 id="处理上下文代码的阶段"><a href="#处理上下文代码的阶段" class="headerlink" title="处理上下文代码的阶段"></a>处理上下文代码的阶段</h2><p>现在，我们终于进入到本文的关键部分，处理上下文代码的过程被分为两个基本阶段：</p>
<ol>
<li>进入执行上下文</li>
<li>代码运行</li>
</ol>
<p>变量对象的修改与这两个阶段有着密切的关联。</p>
<p>注意：这两个阶段的处理是一般行为，与上下文类型无关。（对于全局和函数上下文都是公平的）。</p>
<h2 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h2><p>当进入执行上下文（但是是在代码运行 <code>之前</code>），VO被下面这些属性填充（在前文已经描述过）（从上往下优先级依次降低）</p>
<ul>
<li>函数的每一个形参（如果我们是在函数执行上下文） — 变量对象的一个属性，这个属性由形参的名称与值组成；如果没有传递实际参数，那么这个属性就由形参形式的名称和 <code>undefined</code> 的值组成。</li>
<li>每一个函数声明（FunctionDeclaration， FD） — 变量对象的一个属性，这个属性的名称是函数名，值是这个函数对象，如果这个变量对象已经拥有了相同名称的属性，那么完全替换这个属性。</li>
<li>每一个变量声明（var， VariableDecalartion） — 变量对象的一个属性，这个属性的名称是变量名，值是 <code>undefined</code> 。如果这个变量名和已经声明的形参或者是函数名称相同，那么这个变量<strong>不会影响</strong>已经存在的属性。</li>
</ul>
<p>来看一个例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>当进入到 test 函数的上下文的时候，test函数接收了一个实参 10，AO对象如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">AO(test) = &#123;</span><br><span class="line">	a: <span class="number">10</span>,</span><br><span class="line">	b: <span class="literal">undefined</span>,</span><br><span class="line">	c: <span class="literal">undefined</span>,</span><br><span class="line">	d: <span class="xml"><span class="tag">&lt;<span class="name">FD</span> <span class="attr">d</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">	e: undefined</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，AO中并没有包含函数 x，这是因为 x 并不是一个函数声明而是一个函数表达式（FunctionExpression， 缩写形式：FE），不影响VO（即这里的AO）。</p>
<p>但是，函数 _e 也是一个函数表达式，就像接下来要看到的，它是被分配给了变量 e，它可以通过变量 e 来访问。关于函数声明( <code>FunctionDeclaration</code> ）和函数表达式( <code>FunctionExpression</code> )的不同将会在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="noopener">Chapter 5. Functions</a>中讲到。</p>
<h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>这个时候，AO/VO已经被各种属性填满了（但是，不是所有的属性都已经由具体的值了，他们中的大部分的初始值都还是 <code>undefined</code> ）。</p>
<p>所有代码以及环境不变的情况下，上面的代码中，AO/VO在代码解释器间被修改为如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">AO[<span class="string">'c'</span>] = <span class="number">10</span>;</span><br><span class="line">AO[<span class="string">'e'</span>] = <span class="xml"><span class="tag">&lt;<span class="name">FE</span> <span class="attr">_e</span>&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>再次注意，因为FE _e 是被保存在变量 e 中，所以，它仍然存在于内存（理解成AO/VO）中。但是FE x 不在了。如果我们在定义之前或者时候调用 x 函数，我们会得到一个错误： <code>x is not defined</code> 。没有保存到一个变量的函数表达式（FE）只能立即执行或者是递归调用。</p>
<p>另一个经典例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">alert(x); <span class="comment">// function</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">alert(x); <span class="comment">// 10</span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">alert(x); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>为什么第一次 <code>alert x</code> 的是一个函数，而且，还是在声明之前？为什么不是 <code>10</code> 或者 <code>20</code> ？因为，根据规则 — 当进去执行上下文的时候，VO是由函数声明填充的。同时，在相同的阶段，进入执行上下文的时候，有一个 x 的变量声明，但是我们上面已经提到了，如果这个变量名和已经声明的形参或者是函数名称相同，那么这个变量<strong>不会影响</strong>已经存在的属性。因此，当进入执行上下文的时候。VO进行如下填充：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">VO = &#123;&#125;;</span><br><span class="line">VO[<span class="string">'x'</span>] = <span class="xml"><span class="tag">&lt;<span class="name">FD</span> <span class="attr">X</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">// 找到x的变量声明，但是x已经存在了，所以变量声明无效</span></span><br><span class="line"><span class="xml">VO['x'] = <span class="tag">&lt;<span class="name">值没有被影响，仍然是</span> <span class="attr">function</span> <span class="attr">x</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>当到了函数执行阶段，VO进行如下填充：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">VO[<span class="string">'x'</span>] = <span class="number">10</span>;</span><br><span class="line">VO[<span class="string">'x'</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>这就是我们在第二次 alert 和第三次 alert 看到的内容。</p>
<p>下面的例子中，我们看到，当进入执行上下文阶段的时候变量都被存放在了 VO 中（虽然 <code>else</code> 语句块没有执行，但是， <code>b</code> 依然存在于 VO中）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(a); <span class="comment">// 1</span></span><br><span class="line">alert(b); <span class="comment">// undefined 不是 b is not defined.</span></span><br></pre></td></tr></table></figure>
<h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p>通常很多关于JavaScript的文章或者数据中都指出：“不管是使用var关键字（在全局上下文）还是不使用var关键字（在任何地方），都可以声明一个变量”。 <strong>根本就不是这样的</strong>。<strong>请记住：</strong></p>
<p><strong><em>变量声明只能通过 var 关键字进行声明。</em></strong></p>
<p>就像这样：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这仅仅只是在全局对象上创建了一个新的属性（而不是一个变量）。“不是变量”不是表示不能被修改，而是指ESMAScript规范中的“不是变量”。（由于 VO(globalContext) === global的原因，也会成为全局对象上的属性，还记得吗？）</p>
<p>让我们用代码来展示两者的不同</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">alert(a); <span class="comment">// undefined</span></span><br><span class="line">alert(b); <span class="comment">// b is not defined</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>所有这些都取决于VO及其修改的阶段（进入上下文阶段和代码执行阶段）：</p>
<p>进入上下文：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">	a: <span class="literal">undefined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这里没有 <code>b</code> ，因为这不是一个变量。 <code>b</code> 只会出现在在代码执行阶段（但是上面的例子中不会出现，因为出错了）。</p>
<p>来改一下这段代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">alert(a); <span class="comment">// undefined 我们知道为什么</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line">alert(b); <span class="comment">// 10 创建 代码执行阶段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">alert(a); <span class="comment">// 20 代码执行阶段修改</span></span><br></pre></td></tr></table></figure>
<p>关于变量还有一个很重要的观点。与简单属性相反，变量具有 <code>DontDelete</code> 属性(ES5中为 <code>[[Configurable]]</code>)，意味着我们不能通过 <code>delete</code> 删除变量。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="keyword">delete</span> a); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">alert(<span class="built_in">window</span>.b); <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="keyword">delete</span> b); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="built_in">window</span>.b); <span class="comment">// still 20</span></span><br></pre></td></tr></table></figure>
<p>然而，有一个例外。在 <code>eval</code> 上下文中，声明的变量没有 <code>{DontDelete}</code> 属性：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'var a = 10;'</span>);</span><br><span class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="keyword">delete</span> a); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>使用一些调试工具(例如：Firebug)的控制台测试该实例时，请注意，Firebug同样是使用eval来执行控制台里你的代码。因此，变量属性同样没有 <code>{DontDelete}</code>特性，可以被删除。</p>
<h2 id="特殊实现：parent属性-不重要了"><a href="#特殊实现：parent属性-不重要了" class="headerlink" title="特殊实现：parent属性(不重要了)"></a>特殊实现：<strong>parent</strong>属性(不重要了)</h2><p>前面已经提到过，按照标准规范，活动对象是不能直接访问的。然而，一些具体的实现并没有按照这个标准，例如 <a href="https://zh.wikipedia.org/wiki/SpiderMonkey" target="_blank" rel="noopener"><code>SpiderMonkey</code></a> 和Rhino。在这些视实现中，函数具有特殊的属性 <code>__parent__</code> ，通过这个属性可以访问到已经创建的活动对象（或者是全局变量对象）。</p>
<p>例如（SpiderMonkey, Rhino）:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">alert(foo.__parent__); <span class="comment">// global</span></span><br><span class="line"><span class="keyword">var</span> VO = foo.__parent__;</span><br><span class="line">alert(VO.a); <span class="comment">// 10</span></span><br><span class="line">alert(VO === global);</span><br></pre></td></tr></table></figure>
<p>在上面的例子中我们可以看到，函数foo是在全局上下文中创建的，所以属性<strong>parent</strong> 指向全局上下文的变量对象，即全局对象。(译者注：还记得这个吧：VO(globalContext) === global)</p>
<p>然而，在SpiderMonkey中用同样的方式访问激活对象是不可能的：在不同版本的SpiderMonkey中，内部函数的<strong>parent</strong> 有时指向null ，有时指向全局对象。</p>
<p>在Rhino中，用同样的方式访问激活对象是完全可以的。</p>
<p>例如 (Rhino)：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// the activation object of the "foo" context</span></span><br><span class="line">  <span class="keyword">var</span> AO = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).__parent__;</span><br><span class="line"> </span><br><span class="line">  print(AO.y); <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// __parent__ of the current activation</span></span><br><span class="line">  <span class="comment">// object is already the global object,</span></span><br><span class="line">  <span class="comment">// i.e. the special chain of variable objects is formed,</span></span><br><span class="line">  <span class="comment">// so-called, a scope chain</span></span><br><span class="line">  print(AO.__parent__ === global); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">  print(AO.__parent__.x); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMA</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMA-262-3深入解析第一章：执行上下文</title>
    <url>/%E6%8A%80%E6%9C%AF/ECMA-262-3%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html</url>
    <content><![CDATA[<h1 id="ECMA-262-3-详解：1、执行上下文"><a href="#ECMA-262-3-详解：1、执行上下文" class="headerlink" title="ECMA-262-3 详解：1、执行上下文"></a>ECMA-262-3 详解：1、执行上下文</h1><p>转行来的前端，从来没有深入了解ECMA，网上找了一下，发现早在2010年就有大佬 <a href="http://dmitrysoshnikov.com/about/" target="_blank" rel="noopener">Dmitry Soshnikov</a> 总结了ECMA中的核心内容，我这里只是翻译记录，加深自己的印象。文章原文来自 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="noopener">ECMA-262-3 in detail. Chapter 1. Execution Contexts</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这篇文章中将会涉及到ECMAScript的执行上下文和与之相关的可执行代码类型。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>每一次当控件进入ECMA的可执行代码区域，那么控件就进入到了执行上下文。</p>
<blockquote>
<p>执行上下文（缩写为-EC）是ECMA-262规范用于可执行代码的典型和区分的抽象概念。</p>
</blockquote>
<p>从技术实施的角度来看，这个标准并没有定义EC的准确结构和类型。这是ECMAScript引擎实施标准的问题。</p>
<p>从逻辑上来说，一组活动的执行上下文形成一个堆栈。栈底始终都是一个全局上下文，栈顶则是当前（活动）执行上下文。在进入和退出各种EC的时候修改（推入/推出）堆栈。</p>
<h2 id="可执行代码的种类"><a href="#可执行代码的种类" class="headerlink" title="可执行代码的种类"></a>可执行代码的种类</h2><p>对于可执行上下文的抽象概念，可执行代码的类型的概念是与之相关的。说道代码类型，在某些时候，是可以表示执行上下文的。</p>
<p>例如，我们将执行上下栈定义为一个数组</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">ECStack = [];</span><br></pre></td></tr></table></figure>
<p>每一次进入一个函数的时候（即使这个函数是一个递归函数或者是一个构造函数），以及内置的 <code>eval</code> 函数工作时，堆栈都会被推入。</p>
<h2 id="全局代码"><a href="#全局代码" class="headerlink" title="全局代码"></a>全局代码</h2><p>这类代码在程序初始化的时候执行：例如加载外部的js文件或者通过本地的内联js代码（包含在 <code>&lt;script&gt;&lt;/script&gt;</code> 中的代码）。全局代码不包含任何函数体中的代码。</p>
<p>初始的时候（程序开始运行的时候）， <code>ECStack</code> 看起来是这样：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">	globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h2 id="函数代码（功能代码）"><a href="#函数代码（功能代码）" class="headerlink" title="函数代码（功能代码）"></a>函数代码（功能代码）</h2><p>当进入函数代码时候（各种函数，构造函数，递归，IIFE，eval等）， <code>ECStack</code> 推入一个新的元素。需要注意的是，具体函数的代码不包括内部函数的代码。</p>
<p>举个例子，我们运行一个一次递归的函数</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">flag</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">	foo(<span class="literal">true</span>);</span><br><span class="line">&#125;)(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>然后，对 ECStack 进行如下修改：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次运行 foo 函数，即 foo 的立即执行</span></span><br><span class="line">ECStack = [</span><br><span class="line">	&lt;foo&gt; functionContext,</span><br><span class="line">	globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行 foo 函数的递归</span></span><br><span class="line">ECStack = [</span><br><span class="line">	&lt;foo&gt; functionContext - recursively,</span><br><span class="line">	&lt;foo&gt; functionContext,</span><br><span class="line">	globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>函数的每个返回（可以理解为这段函数执行完成）都会退出当前的执行上下文，并且 <code>ECStack</code> 进行相对应的退出，这是堆栈的客观规律。上面这段代码（包含一次递归）执行完成后， <code>ECStack</code> 将再次只包含 <code>globalContext</code> ，知道程序结束。</p>
<p>抛出但未捕获的异常也可能会导致一个或者多个执行上下文退出。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">'退出 bar 和 foo 的执行上下文'</span>;</span><br><span class="line">	&#125;)();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>虽然上面的代码是推出了栈，但是，程序出错，可能就不执行了。</p>
<h2 id="Eval代码"><a href="#Eval代码" class="headerlink" title="Eval代码"></a><code>Eval</code>代码</h2><p><code>eval</code> 代码让事情变得更加有趣了。在使用 <code>eval</code> 的情况下，关于 <em>调用上下文</em> 的概念产生了。即，在一个上下文中调用了 <code>eval</code> 函数。</p>
<p>由 <code>eval</code> 进行的操作，比如定义一个函数或者函数声明的时候会直接影响了调用上下文。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 影响了全局上下文</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'var x = 10'</span>);</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 影响了 foo 函数的局部上下文，b 是函数的局部变量</span></span><br><span class="line">	<span class="built_in">eval</span>(<span class="string">'var y = 20'</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">alert(x); <span class="comment">// 10</span></span><br><span class="line">alert(y); <span class="comment">// y is not defined</span></span><br></pre></td></tr></table></figure>
<p><strong>Note：在 <code>ES5</code> 的严格模式中， <code>eval</code> 不会影响调用上下文，取而代之的是，会对沙箱代码进行评估。</strong></p>
<p>上面的例子会对 <code>ECStack</code> 进行如下修改：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">ESStack = [</span><br><span class="line">	globalContext,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval('var x = 10');</span></span><br><span class="line">ECStack.push(&#123;</span><br><span class="line">	context: evalContext,</span><br><span class="line">	callingContext: globalContext</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval('var x = 10'); 执行完成</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo function 执行</span></span><br><span class="line">ECStack.push(</span><br><span class="line">	&lt;foo&gt; functionContext</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval('var y = 20');</span></span><br><span class="line">ECStack.push(&#123;</span><br><span class="line">	context: evalContext,</span><br><span class="line">	callingContext: <span class="xml"><span class="tag">&lt;<span class="name">foo</span>&gt;</span> functionContext</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// eval('var y = 20'); 执行完成</span></span><br><span class="line"><span class="xml">ECStack.pop();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// foo function 执行完成</span></span><br><span class="line"><span class="xml">ECStack.pop();</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ECMA</tag>
      </tags>
  </entry>
  <entry>
    <title>react+antd+webpack4 构建项目框架</title>
    <url>/%E6%8A%80%E6%9C%AF/react-antd-webpack4%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6.html</url>
    <content><![CDATA[<p>入职新公司，要求自己搭建一个react的开发模板，而不是使用现有的 <code>create-react-app</code> 。所以自己搭建了一个</p>
<p>涉及到的功能：</p>
<ol>
<li>react, react-dom, react-router</li>
<li>ESlint + Aribnb</li>
<li>prettier</li>
<li>具体使用还是不使用状态管理库（redux or mobx），视情况而定，不复杂使用 React.crateContext() </li>
<li>使用less不使用scss</li>
<li>热更新，不是热重载</li>
</ol>
<p>其他的功能自己适适当配置</p>
<p>项目地址：<a href="https://github.com/tal007/react-antd-webpack" target="_blank" rel="noopener">https://github.com/tal007/react-antd-webpack</a></p>
<h2 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h2><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p>处理js，jsx，ts，tsx语法</p>
<h3 id="style-loader，css-loader，less-loader，postcss-loader"><a href="#style-loader，css-loader，less-loader，postcss-loader" class="headerlink" title="style-loader，css-loader，less-loader，postcss-loader"></a>style-loader，css-loader，less-loader，postcss-loader</h3><p>处理css</p>
<p>style-loader：添加到js中，这样修改才会热更新，在开发环境中需要加上，生产环境如果使用<code>mini-css-extract-plugin</code>抽离css，那么不要加上style-loader</p>
<p>注意loader使用顺序</p>
<p>使用less-loader需要同时安装less库</p>
<p>postcss-loader处理css中的一些问题，压缩等，同时可以使用postcss插件，例如<code>postcss-flexbugs-fixes</code>, <code>postcss-cssnext</code>, <code>cssnano</code> 等。</p>
<h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>处理文件（字体，图片，影视频等）并重新命名</p>
<h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>处理图片，设置路径以及base64图片压缩</p>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>设置html模板以及输出路径等</p>
<h3 id="webpack-ProvidePlugin"><a href="#webpack-ProvidePlugin" class="headerlink" title="webpack.ProvidePlugin"></a>webpack.ProvidePlugin</h3><p>设置webpack全局变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  <span class="comment">// 这样就不用每个文件都引用react了，但是需要在eslintrc中配置eslint语法检测</span></span><br><span class="line">  React: <span class="string">'react'</span>,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>css代码抽离，详见<code>config/webpack.prod.js</code></p>
<h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>清除之前打包的代码</p>
<h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p><code>webpack.HotModuleReplacementPlugin</code> 与 <code>webpack.NamedModulesPlugin()</code>。前者使用热更新，后者在控制台展示热更新名字。</p>
<p>热更新需要同时使用 <code>react-hot-loader</code>。</p>
<blockquote>
<p>npm i –save-dev react-hot-loader</p>
</blockquote>
<p>使用详见： <code>src/App.jsx</code>。还需要在 <code>.babelrc</code> 中配置 plugins</p>
<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>ESlint + Prettier</p>
<blockquote>
<p>npm i –save-dev eslint</p>
</blockquote>
<h3 id="配合VSCode使用"><a href="#配合VSCode使用" class="headerlink" title="配合VSCode使用"></a>配合VSCode使用</h3><p>VSCode 安装插件</p>
<ul>
<li><p><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank" rel="noopener">Prettier - Code formatter</a></p>
</li>
<li><p><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener">ESLint</a></p>
</li>
</ul>
<p>.eslintrc.js中添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"plugins"</span>: [<span class="string">"prettier"</span>],</span><br><span class="line"><span class="string">"rules"</span>: &#123;</span><br><span class="line">  <span class="string">"prettier/prettier"</span>: <span class="string">"error"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加 .ptettierrc.js 配置如下，可自行修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// configs see https://prettier.io/docs/en/options.html</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  trailingComma: <span class="string">'es5'</span>,</span><br><span class="line">  singleQuote: <span class="literal">true</span>,</span><br><span class="line">  tabWidth: <span class="number">2</span>,</span><br><span class="line">  semi: <span class="literal">true</span>,</span><br><span class="line">  bracketSpacing: <span class="literal">true</span>,</span><br><span class="line">  arrowParens: <span class="string">'always'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在settings.json 中添加如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// jsx自动修复有问题，取消js的format</span><br><span class="line">"editor.formatOnSave": false,</span><br><span class="line">// Enable/disable default JavaScript formatter (For Prettier)</span><br><span class="line">"javascript.format.enable": false,</span><br><span class="line">"prettier.singleQuote": true,</span><br><span class="line">// 点击保存时，根据 eslint 规则自定修复，同时集成 prettier 到 eslint 中</span><br><span class="line">"prettier.eslintIntegration": true,</span><br><span class="line">// 保存自动修复</span><br><span class="line">"editor.codeActionsOnSave": &#123;</span><br><span class="line">  "source.fixAll.eslint": true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="使用-BrowserRouter-刷新-404"><a href="#使用-BrowserRouter-刷新-404" class="headerlink" title="使用 BrowserRouter 刷新 404"></a>使用 BrowserRouter 刷新 404</h3><p>在 devServer 中 添加 <code>historyApiFallback: true</code></p>
<h3 id="使用-webpack-alias-的时候路径提示"><a href="#使用-webpack-alias-的时候路径提示" class="headerlink" title="使用 webpack alias 的时候路径提示"></a>使用 webpack alias 的时候路径提示</h3><p>根目录添加 <code>jsconfig.json</code> 文件，与 alias 中的对应</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">      <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"baseUrl"</span>: <span class="string">"./"</span>,</span><br><span class="line">      <span class="attr">"paths"</span>: &#123;</span><br><span class="line">        <span class="attr">"@/*"</span>: [<span class="string">"./src"</span>],</span><br><span class="line">        <span class="attr">"@comp/*"</span>: [<span class="string">"./src/components"</span>],</span><br><span class="line">        <span class="attr">"@img/*"</span>: [<span class="string">"./src/img"</span>],</span><br><span class="line">        <span class="attr">"@styl/*"</span>: [<span class="string">"./src/style"</span>],</span><br><span class="line">        <span class="attr">"@pages/*"</span>: [<span class="string">"./src/pages"</span>],</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>, <span class="string">"dist"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用git-commit-规范"><a href="#使用git-commit-规范" class="headerlink" title="使用git commit 规范"></a>使用git commit 规范</h2><p>git-commit规范可以查看<a href="https://juejin.im/post/5afc5242f265da0b7f44bee4" target="_blank" rel="noopener">优雅的提交你的 Git Commit Message</a></p>
<p>项目地址：<a href="https://github.com/tal007/react-antd-webpack" target="_blank" rel="noopener">https://github.com/tal007/react-antd-webpack</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>使用nextjs进行react项目的服务端渲染</title>
    <url>/%E6%8A%80%E6%9C%AF/%E4%BD%BF%E7%94%A8nextjs%E8%BF%9B%E8%A1%8Creact%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93.html</url>
    <content><![CDATA[<p>react作为前端三大框架之一，用的人自然是很多的。我也是一直使用react进行项目的开发，不管是移动端还是PC端，不管是大项目还是小项目，大部分都是使用的是react进行开发的。当然，其他的框架（vue等）也是使用的。当然，客户端渲染的弊端也是很明显的，<code>首页加载缓慢</code>，<code>网站SEO问题</code>等等。</p>
<blockquote>
<p>如果功能不是太复杂又要SEO，可以尝试预渲染的模式<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/react%E9%A1%B9%E7%9B%AE%E9%A2%84%E6%B8%B2%E6%9F%93%E5%BC%80%E5%8F%91.html">react项目预渲染开发</a></p>
</blockquote>
<p>React服务端渲染可以解决这个问题。以前在没有<a href="https://nextjs.org/" target="_blank" rel="noopener">nextjs</a>的时候，我们通常都是使用react提供的<code>renderToString</code>方法在结合express等来实现的服务端渲染。当然也可以实现。但是正所谓专业的人做专业的事。自己搭建一个服务端渲染先不说麻烦，自己要踩得坑也是很多的。所以，如果是要上正式环境，在自己构建不熟悉的情况下，使用服务端渲染框架也是很不错的。</p>
<p>目前用的比较多的就是<a href="https://nextjs.org/" target="_blank" rel="noopener">nextjs</a>。</p>
<p>关于nextjs的使用在<a href="https://nextjs.org/" target="_blank" rel="noopener">官网</a>上面说的很明确。可以自己去看看。这里我记录一下实际使用的时候遇到的一些问题。</p>
<h2 id="1-项目部署。"><a href="#1-项目部署。" class="headerlink" title="1.项目部署。"></a>1.项目部署。</h2><p>构建自己的项目后，并成功添加页面，在本地跑起来都是没有问题的。这时候就需要部署到服务端了。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hello-next"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"next"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"next build"</span>,</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"next start"</span>,</span><br><span class="line">    <span class="attr">"export"</span>: <span class="string">"npm run build &amp;&amp; next export"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"axios"</span>: <span class="string">"^0.19.2"</span>,</span><br><span class="line">    <span class="attr">"next"</span>: <span class="string">"^9.2.2"</span>,</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"^16.13.0"</span>,</span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^16.13.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>yarn build</code>以后会生成一个<code>.next</code>目录的文件夹，里面就是我们需要部署的内容。然后使用<code>yarn start</code>就可以跑起来了。可以在本地试试。</p>
<blockquote>
<p>执行 <code>yarn start</code> 之前必须先执行 <code>yarn build</code>。因为 start 需要的就是 <code>.next</code> 文件夹里面的东西。</p>
</blockquote>
<p>所以，我们在服务器上面只需要上传 <code>.next</code> 和 <code>package.json</code> 就可以了。</p>
<p>这样操作以后，就可以在服务器3000端口访问了。但是，如果一关闭命令窗口，那么久GG了，无法访问。</p>
<h2 id="使用pm2托管node项目"><a href="#使用pm2托管node项目" class="headerlink" title="使用pm2托管node项目"></a>使用pm2托管node项目</h2><p>在服务器上面安装pm2 然后使用 <code>pm2 start --name=&#39;nextjs&#39; npm -- start</code> 运行项目。这样就可以解决上面的问题。</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20200324103128.png" alt="pm2启动成功"></p>
<p>启动成功，这样就可以在对应的端口查看了 <a href="http://118.24.6.33:3000/" target="_blank" rel="noopener">http://118.24.6.33:3000/</a></p>
<p>关于pm2的一系列操作可以查看<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/PM2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html">PM2常用命令</a></p>
<h2 id="路由页面与路由需要对应"><a href="#路由页面与路由需要对应" class="headerlink" title="路由页面与路由需要对应"></a>路由页面与路由需要对应</h2><p>开始学习的时候，我创建组件也是按照传统的创建组件（首字母大写）的方式创建的，而路由跳转又是小写的，本地一切正常，但是在部署后，就出问题了。找不到对应的小写的js的文件。这就是问题所在。</p>
<p>两种解决：</p>
<ol>
<li>使用小写，或者说路由与文件名字一样</li>
<li>使用自定义路由而不是用默认的路由</li>
</ol>
<h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><p>一直使用域名 + 端口访问是很愚蠢的。所以我们需要绑定域名。在你的域名里面添加一个二级域名解析，我这里是<code>nextjs.lyt007.cn</code>。</p>
<p>然后需要配置服务器上的nginx。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义了一个名字</span><br><span class="line">upstream nodenext &#123;</span><br><span class="line">    server 127.0.0.1:3000; #next项目 监听端口</span><br><span class="line">    keepalive 64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name nextjs.lyt007.cn;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;  </span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Nginx-Proxy true;</span><br><span class="line">        proxy_cache_bypass $http_upgrade;</span><br><span class="line">        # 这里使用这个名字反向代理</span><br><span class="line">        proxy_pass http://nodenext; #反向代理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>服务端渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-从使用new到手写new</title>
    <url>/%E6%8A%80%E6%9C%AF/JavaScript-%E4%BB%8E%E4%BD%BF%E7%94%A8new%E5%88%B0%E6%89%8B%E5%86%99new.html</url>
    <content><![CDATA[<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><blockquote>
<p>new运算符创建一个用户定义的对象类型的实例或者具有构造函数的内置对象类型之一</p>
</blockquote>
<p>在手写 <code>new</code> 之前，我们来看看 new 实现了那些功能。</p>
<p>Demo：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 狗的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, age</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.habit = <span class="string">"Ball"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.weight = <span class="number">50</span>;</span><br><span class="line">Dog.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I am"</span> + <span class="keyword">this</span>.name + <span class="string">", i am run..."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一条白色的狗</span></span><br><span class="line"><span class="keyword">var</span> whiteDog = <span class="keyword">new</span> Dog(<span class="string">'xiao bai'</span>, <span class="string">'2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(whiteDog.name); <span class="comment">// xiao bai</span></span><br><span class="line"><span class="built_in">console</span>.log(whiteDog.age); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(whiteDog.weight); <span class="comment">// 50</span></span><br><span class="line">whiteDog.run(); <span class="comment">// I am xiao bai, i am run...</span></span><br></pre></td></tr></table></figure>
<p>从上面的Demo中可以看出来，实例 whiteDog 可以：</p>
<ol>
<li>访问到 Dog 构造函数中的属性；</li>
<li>访问到 Dog.prototype 中的属性；</li>
</ol>
<p>所以。我们可以简单的实现一个 new。</p>
<p><strong>因为new是关键字，我们无法覆盖，所以我们用new2来表示我们的new</strong></p>
<p>使用的时候呢如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">...</span>)</span>&#123;...&#125;;</span><br><span class="line"><span class="comment">// 使用new</span></span><br><span class="line"><span class="keyword">var</span> whiteDog = <span class="keyword">new</span> Dog(...);</span><br><span class="line"><span class="comment">// 使用new2</span></span><br><span class="line"><span class="keyword">var</span> whiteDog = new2(Dog,...);</span><br></pre></td></tr></table></figure>
<h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>分析：</p>
<p>因为 new 的结果会返回一个对象，所以在模拟实现它的时候，我们也要建立一个新的对象，假设这个对象叫 obj。因为 obj 会具有构造函数（这里指Dog）里面的属性。我们使用 Dog.allpy(obj, arguments) 来给 obj 添加新的属性。</p>
<p>补充两点：</p>
<ol>
<li><code>__proto__</code> 和 <code>constructor</code> 属性是对象所独有的；</li>
<li><code>prototype</code> 属性是函数所独有的。</li>
</ol>
<p>第一版代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  obj.__proto__ = Constructor.prototype;</span><br><span class="line">  Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实上面的代码已经可以生效了。不信你可以复制下面的代码运行一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 狗的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, age</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.habit = <span class="string">"Ball"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.weight = <span class="number">50</span>;</span><br><span class="line">Dog.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I am"</span> + <span class="keyword">this</span>.name + <span class="string">", i am run..."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一条白色的狗的实例</span></span><br><span class="line"><span class="keyword">var</span> whiteDog = <span class="keyword">new</span> Dog(<span class="string">'xiao bai'</span>, <span class="string">'2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(whiteDog.name); // xiao bai</span></span><br><span class="line"><span class="comment">// console.log(whiteDog.age); // 2</span></span><br><span class="line"><span class="comment">// console.log(whiteDog.weight); // 50</span></span><br><span class="line"><span class="comment">// whiteDog.run(); // I am xiao bai, i am run...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 这里通过定制传参规则，获取第一个参数，即我们需要继承的对象。</span></span><br><span class="line">  <span class="comment">// 同时因为使用的数组的 shift 方法，最后的 arguments 是少了第一项的</span></span><br><span class="line">  <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  obj.__proto__ = Constructor.prototype;</span><br><span class="line">  Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blackDog = new2(Dog, <span class="string">"xiao hei"</span>, <span class="string">'1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(blackDog.name); <span class="comment">// xiao hei</span></span><br></pre></td></tr></table></figure>
<p>但是有一个问题。</p>
<p>什么问题呢？那就是如果我的构造函数不是默认的返回值而是自己添加了一个返回值呢？</p>
<p>Demo2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.weight = <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    habit: <span class="string">'Games'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'Kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.weight) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.age) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。</p>
<p>而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个 <code>基本类型</code> 的值呢？</p>
<p>Demo3:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.weight = <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Kevin"</span> <span class="comment">// 你可以试试其他基本类型，包括ES6中的 Symbol();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'Kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.habit) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.weight) <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.age) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<p>结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。</p>
<p>所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。</p>
<p>所以我们有了第二版的 new2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二版的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;,</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> res= Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">'object'</span> ? res: obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>PM2常用命令</title>
    <url>/%E6%8A%80%E6%9C%AF/PM2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<p>pm2常用命令记录</p>
<p><code>pm2 start app.js</code> # 启动app.js应用程序</p>
<p><code>pm2 start app.js -i 4</code>        # cluster mode 模式启动4个app.js的应用实例 4个应用程序会自动进行负载均衡</p>
<p><code>pm2 start app.js --name=&quot;api&quot;</code> # 启动应用程序并命名为 “api”</p>
<p><code>pm2 start app.js --watch</code>      # 当文件变化时自动重启应用</p>
<p><code>pm2 start script.sh</code>          # 启动 bash 脚本</p>
<p><code>pm2 list</code>                      # 列表 PM2 启动的所有的应用程序</p>
<p><code>pm2 monit</code>                    # 显示每个应用程序的CPU和内存占用情况</p>
<p><code>pm2 show [app-name]</code>          # 显示应用程序的所有信息</p>
<p><code>pm2 logs</code>                      # 显示所有应用程序的日志</p>
<p><code>pm2 logs [app-name]</code>          # 显示指定应用程序的日志</p>
<p><code>pm2 flush</code>                       # 清空所有日志文件</p>
<p><code>pm2 stop all</code>                  # 停止所有的应用程序</p>
<p><code>pm2 stop 0</code>                    # 停止 id为 0的指定应用程序</p>
<p><code>pm2 restart all</code>              # 重启所有应用</p>
<p><code>pm2 reload all</code>               # 重启 cluster mode下的所有应用</p>
<p><code>pm2 gracefulReload all</code>        # Graceful reload all apps in cluster mode</p>
<p><code>pm2 delete all</code>                # 关闭并删除所有应用</p>
<p><code>pm2 delete 0</code>                  # 删除指定应用 id 0</p>
<p><code>pm2 scale api 10</code>              # 把名字叫api的应用扩展到10个实例</p>
<p><code>pm2 reset [app-name]</code>          # 重置重启数量</p>
<p><code>pm2 startup</code>                  # 创建开机自启动命令</p>
<p><code>pm2 save</code>                      # 保存当前应用列表</p>
<p><code>pm2 resurrect</code>                # 重新加载保存的应用列表</p>
<p><code>pm2 update</code>                    # Save processes, kill PM2 and restore processes</p>
<p><code>pm2 generate</code>                  # Generate a sample json configuration file</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><code>pm2 start npm -- start</code>        # pm2 启动 npm 命令。scripts中名字为 start</p>
<p>pm2文档地址：<a href="https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端UI框架</title>
    <url>/%E6%8A%80%E6%9C%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AFUI%E6%A1%86%E6%9E%B6.html</url>
    <content><![CDATA[<p>UI框架作为前端一门必须要了解并且熟练掌握的一门技术，关于目前不同的js框架对应的不同的框架还是有必要说说。</p>
<p>关于PC端的UI框架是在是太多了。</p>
<ul>
<li><p>react：目前常用的得数蚂蚁金服出的<a href="https://ant.design/" target="_blank" rel="noopener">Ant Design</a>了。而最新刚刚发布了4.0版本。移除了对IE9/10的支持，同时也支持 React Hook。当然还有其他的</p>
</li>
<li><p>vue：目前常用的算得上是饿了么出的ElementUI了。当然还有其他的</p>
</li>
</ul>
<p>移动端的UI框架也挺多。不过这是针对于VUE来说的。</p>
<ul>
<li><a href="https://youzan.github.io/vant/#/zh-CN/" target="_blank" rel="noopener">Vant UI</a>。有赞公司出的一套电商类的UI框架，如果是做移动端电商的，想必这款UI框架用的是得心应手了吧</li>
<li><a href="https://muse-ui.org/#/zh-CN" target="_blank" rel="noopener">Muse UI</a>。社区人员维护的一套UI框架。</li>
<li><a href="https://didi.github.io/mand-mobile/#/zh-CN/home" target="_blank" rel="noopener">Mand Mobile</a>。也是社区活跃挺高的一款UI。同时还包含了<a href="https://didi.github.io/mand-mobile-rn/?path=/story/mand-mobile-rn--%E5%BF%AB%E9%80%9F%E6%8E%A5%E5%85%A5" target="_blank" rel="noopener">React Native的UI</a>。</li>
</ul>
<p>VUE的可以说有很多，但也有很多都不再维护了。比如滴滴公司的Cube UI，京东的Nut UI等等。</p>
<p>再来看看React，相对来说就很少了。我一直都是在使用react开发网站，不管是PC还是H5的。PC的当然是首选了 Ant Design，但是H5端的ant是真的没有PC的好用。所以最开始在开发移动端的时候都是自己写的样式，交互体验也比较差。后面觉得是在是不行了。就到处找，找了一款国外的UI框架 <a href="https://framework7.io/" target="_blank" rel="noopener">Framework7</a>。</p>
<p>Framework7其实最开始是专注于 WebApp 开发的，而且在IOS的上面的体验几乎与原生媲美，安卓上性能就差很多了。不多最近我在使用这个框架的时候，其中的大部分功能还是挺不错的，在使用React开发的时候可以选择这款UI框架。不过如果是做H5，那最好就不要使用UI框架自带的路由了，真的太差了。</p>
<p>如果你有其他的react的UI框架推荐，欢迎留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>不打算在使用BootCND</title>
    <url>/%E6%8A%80%E6%9C%AF/%E4%B8%8D%E6%89%93%E7%AE%97%E5%9C%A8%E4%BD%BF%E7%94%A8BootCND.html</url>
    <content><![CDATA[<p>今天（2020年02月24日）上班来到公司，一如既往的开机准备开开心心的敲代码了。结果，日了狗了。网站报错了。</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/E8EF11D3-D0D4-4E6F-8EEF-2D76D59784B2.png" alt></p>
<p>结果。就是因为使用了 <a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">BootCND</a> 导致的网站无法访问。</p>
<p>出问题了。可能会亏损几个亿吧。当然，几个亿是不可能的。</p>
<p>所以。这件事情以后，打算不再使用CDN了。<strong>还是老老实实的放本地吧。</strong></p>
<p>或者 <a href="cdnjs.com">https://cdnjs.com/</a> 可能也是一个不错的选择。</p>
<p>记在这里，就当给自己一个教训。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CDN</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hook</title>
    <url>/%E6%8A%80%E6%9C%AF/React-Hook.html</url>
    <content><![CDATA[<p>React Hook 在 <code>react 16.8及以后的版本</code>中才会有</p>
<h2 id="React-Hook-解决的问题"><a href="#React-Hook-解决的问题" class="headerlink" title="React Hook 解决的问题"></a>React Hook 解决的问题</h2><h3 id="1-组件之间复用状态逻辑"><a href="#1-组件之间复用状态逻辑" class="headerlink" title="1. 组件之间复用状态逻辑"></a>1. 组件之间复用状态逻辑</h3><h3 id="2-减少组件的复杂程度"><a href="#2-减少组件的复杂程度" class="headerlink" title="2. 减少组件的复杂程度"></a>2. 减少组件的复杂程度</h3><p>在传统的 class 中，会使用 componentDidMount 和 componentDidUpdate 获取数据。同时 componentDidMount 中也会处理一些其他的事务，例如事件监听，定时器等等。而后还需要在 componentWillUnmount 中取消。万一忘记其中某一个部分或者处理的时间过多，很可能导致一些可怕的bug。</p>
<h3 id="3-关于-class-类与函数组件-this-的问题"><a href="#3-关于-class-类与函数组件-this-的问题" class="headerlink" title="3. 关于 class 类与函数组件 this 的问题"></a>3. 关于 class 类与函数组件 this 的问题</h3><p>对于一部分人来说，理解 class 中的 this 会比理解函数组件中的 this 更加困难，而且增加了学习成本。<strong>但是，react 中并不会移除 class 这种方法</strong></p>
<p><a href="https://www.youtube.com/watch?time_continue=356&amp;v=dpw9EHDh2bM&amp;feature=emb_logo" target="_blank" rel="noopener">YouTube上面的视频</a></p>
<h2 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h2><p>传统的 React 组件的 state 都是这样的，创建一个 state 与更新（this.setState）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;_</span> =&gt;</span> this.setState(&#123;count: this.state.count++&#125;)&#125;&gt;&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 React Hook 后<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;_</span> =&gt;</span> setCount(count++)&#125;&gt;&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到。使用 Hook 后的代码简洁了很多。但是，使用 <code>useState</code> 不会把新的 state 和旧的 state 进行合并。</p>
<p>上面，我们只是用了一个 count。但是通常一个组件都不会只有一个 state 的，这时候可以多次使用 <code>useState</code>。</p>
<p>同时，定义 state 的时候定义在一个数组里面，可以猜到， useState 返回的不是一个不同的数字或者字符串，而是一个对象（数组）。这里这样定义，使用了 ES6 中的<a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">解构赋值</a></p>
<h2 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h2><p><code>useState</code> 其实不难理解，唯一需要注意的就是 <code>this.setState</code> 是修改后的 state 与之前的 state 对比合并，而采用 <code>useState</code> 则是直接替换。</p>
<p>作为使用过一段时间的 React Hook 的程序员，个人认为 <code>Effect Hook</code> 才需要更多的理解。</p>
<p>React官方文档中这样定义的</p>
<blockquote>
<p>你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。<br><code>useEffect</code> 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API。</p>
</blockquote>
<p>所以，我们使用 Hook 后，数据获取、订阅或者手动修改过 DOM等都需要在 <code>useEffect</code> 中进行了。</p>
<blockquote>
<p>不要以为 <code>useEffect</code> 和 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 一样只能使用一次，他与 <code>useState</code> 一样，可以多次使用。</p>
</blockquote>
<p>默认情况下，React 会在每次渲染后调用副作用函数(<code>useEffect</code>) —— 包括第一次渲染的时候。所以，在 <code>useEffect</code> 函数中可以直接使用 props 和 state</p>
<p><code>useEffect</code> 接收两个参数。第一个参数是一个函数，第一个参数相当于 <code>componentDidMount</code> 和 <code>componentDidUpdate</code>，第一个参数可以有一个返回值（一般就是一个函数，我们将之称为<em>清除函数</em>），相当于与 <code>componentWillUnmount</code>。这样一说，你可能就理解了。再来举个例子，更形象的说明一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> doSomething(), <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.timer) clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的是传统的方式，添加以及移除定时器的操作。因为需要在 <code>componentWillUnmount</code> 中进行判断，有时候（大部分时候）可能都会遗忘。</p>
<p>再来看看使用 <code>useEffect</code> 的代码<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> doSomething(), <span class="number">1000</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// return 一个函数，将会在组件将要卸载的时候调用 相当于 componentWillUnmount</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(timer)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，使用 <code>useEffect</code> 不单单是代码更简洁，同时使我们的代码逻辑看起来更直观。设置定时器与清除定时器是放在一个API里面的，代码的耦合更高。更能体现这是一个整体，也避免了遗忘。</p>
<p><strong>为什么要在 effect 中返回一个函数？</strong> 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p>
<p><strong>React 何时清除 effect？</strong> React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</p>
<p>如果不涉及到异步，订阅等操作，可以不用返回清除函数</p>
<p>上面只是 <code>useEffect</code> 的一个简单的事例，它的功能不止于此。因为之前还说过，处理数据请求也是在里面处理的。那么怎么使用呢</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do ajax request</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只是上面那样写，会有一个严重的问题。之前说过， <code>useEffect</code> 是会在<strong>DOM初次加载完成以及DOM更新完成的时候调用</strong>，所以上面的请求会在每一次DOM更新的时候再次执行，而如果请求返回的结果会使DOM更新，那么，这就是一个无限循环的过程了。</p>
<p>那么怎么处理这个副作用呢？这时候就需要 <code>useEffect</code> 的第二个参数了。一般是一个数组</p>
<p>如果两次需要更新的数据没有变化，只需要在第二个参数（数组）中添加对应的变量，例如<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure></p>
<p>但是如果是上面的处理 <code>ajax request</code> 的 effect 。只需要传递一个空数组即可。这样，这个 effect 只会执行一次。</p>
<p><em>React 会对数组中的数据进行更新前后数据的对比，如果没有变化，那么则不更新</em></p>
<p>这个方法对于有清除函数的 effect 同样适用。</p>
<blockquote>
<p>React官网中说到：未来版本，可能会在构建时自动添加第二个参数。期待他的到来，这将大大减少可能出现的bug。</p>
</blockquote>
<h2 id="其他-Hook"><a href="#其他-Hook" class="headerlink" title="其他 Hook"></a>其他 Hook</h2><p>除了 <code>useState</code> 和 <code>useEffect</code> 两个常用的 Hook， 还有一些其他的 Hook， 这些可能用的不多。</p>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure>
<p>这个 Hook 用于连接 React 上下文。使用过 <code>React.createContext</code> 的老铁应该知道，这是创建一个 React 上下文</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Context = React.createContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上层组件</span></span><br><span class="line">&lt;Context.Provider&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 消费这个 Context 的组件</span></span><br><span class="line">&lt;Context.Consumer&gt;&lt;/Context.Consumer&gt;</span><br></pre></td></tr></table></figure>
<p>使用 <code>useContext</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Context = React.createContext;</span><br><span class="line"></span><br><span class="line">useContext(Context)</span><br></pre></td></tr></table></figure></p>
<p>例子<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">"#000000"</span>,</span><br><span class="line">    background: <span class="string">"#eeeeee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">"#ffffff"</span>,</span><br><span class="line">    background: <span class="string">"#222222"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br><span class="line">      &lt;Toolbar /&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemedButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ThemedButton() &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 通过 useContext 使用 React.createContext(themes.light) 创建的 Context</span></span><br><span class="line"><span class="regexp">  const theme = useContext(ThemeContext);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      I am styled by theme context!</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>
<p><code>useState</code> 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>既然作用类似于 Redux， 那么可以用这个取代 Redux 么？答案是可以的，不过需要结合 <code>useContext</code> 来使用。掘金上面有码友给出了一个例子<a href="https://juejin.im/post/5ceb37c851882520724c7504" target="_blank" rel="noopener">用 useContext + useReducer 替代 redux</a>。</p>
<p>你可以在新项目中或者涉及状态管理不多的项目中尝试使用，现有的大型项目不建议重构，使用 Redux 依然是不错的方案。</p>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>返回一个 <code>memoized</code> 回调函数。</p>
<p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code> ，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code> ）的子组件时，它将非常有用。</p>
<p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>
<p>返回一个 memoized 值。</p>
<p><code>useCallback</code> 与 <code>useMemo</code> 都可以用于 React 性能优化的手段。</p>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure>
<p><code>useRef</code> 返回一个可变的 <code>ref</code> 对象，其 <code>.current</code> 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</p>
<p>所以，这个方法就相当于 class 中的 <code>ref</code> 属性，用于获取具体的DOM元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3><p>上面未说明的 Hook 可以查看 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext" target="_blank" rel="noopener">React 官网</a></p>
<h2 id="Hook-规则"><a href="#Hook-规则" class="headerlink" title="Hook 规则"></a>Hook 规则</h2><p>Hook <strong>永远是在最顶层调用</strong>，不能在条件判断语句或者其他语句中。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(name === <span class="string">'tal'</span>)&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误</span></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'tal'</span>) &#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你害怕你写错了，但是没有检查出来，可以使用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">eslint-plugin-react-hooks</a> 这个插件来检测。</p>
<h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h2><p>Hook 我们也是可以自定义的。那么为什么需要自定义。答案是 <strong>逻辑共享</strong>。</p>
<p>假如有一个 state 需要在多个组件中使用，我们不应该在多个组件中都单独的去创建这个 state， 而是应该<strong>逻辑共享</strong>。把这个 state 以及操作这个 state 的方法定义在我们自己的 Hook 中。那这个 Hook 就是我们自定义的 Hook，其实，他也是一个函数，接收参数，返回你需要的值。唯一需要注意的是：<strong>自定义 Hook 必须以 <code>use</code> 开头</strong>，不管怎么变，使用需要遵循 React Hook 以 <code>use</code> 开头的规则。</p>
<p>下面是一个获取window视窗的hook</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useCallback, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取窗口大小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWinSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [size, setSize] = useState(&#123;</span><br><span class="line">    width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">    height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onResize = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setSize(&#123;</span><br><span class="line">      width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">      height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, onResize);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, onResize);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useWinSize;</span><br></pre></td></tr></table></figure>
<p><a href="https://zh-hans.reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">官网介绍</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react 读书笔记</title>
    <url>/%E6%8A%80%E6%9C%AF/react-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h2 id="在-React-组件中，代码重用的主要方式是组合而不是继承。"><a href="#在-React-组件中，代码重用的主要方式是组合而不是继承。" class="headerlink" title="在 React 组件中，代码重用的主要方式是组合而不是继承。"></a>在 React 组件中，代码重用的主要方式是组合而不是继承。</h2><blockquote>
<p>We strongly recommend against creating your own base component classes. In React components, code reuse is primarily achieved through composition rather than inheritance.</p>
</blockquote>
<p>这句话来自于react的<a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">官方网站</a></p>
<p>为什么要提及这句话呢。因为现在我的项目中也有自己的创建的组件类，然后其余的组件来继承它。</p>
<p>其实最开始我也是一步一步的使用<code>class App extends React.Component</code>来写我自己的组件，这样确实有点复杂，但是还算过得去。或许是因为初学react或者是对react的了解不深入，所以，一直就这样。去年了解了一下同事的安卓开发，他们都会建一个基础的类来继承于这个类，这个基础的类实现了一些公用的方法，所以继承于这个基础类的组件也会有这些方法，而且不用每一次都引入。这样理念确实很不错。自己用了一段时间，某些地方也确实方便，尤其是在组件数据请求的时候，需要渲染不同的组件（loading，completed，empty，request_error and so on），而且目前还没有发现有什么不一样的地方，因为这些继承于基础类的组件也是可以使用React的生命周期。直到今天，我才知道，原来这是<strong>违背了react的开发理念</strong>。那要怎么实现呢。正如上面所说</p>
<blockquote>
<p>code reuse is primarily achieved through composition rather than inheritance.</p>
</blockquote>
<p>通过组件的组合来实现，通过<code>props</code>参数来实现，具体查看<a href="https://reactjs.org/docs/composition-vs-inheritance.html" target="_blank" rel="noopener">Composition vs Inheritance</a>。</p>
<p>虽说这样开发可能会复杂一点（或许是自己的技术能力有限），不过这样也算是符合react的理念。</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>react组件的生命周期作为react开发人员面试的必考知识，还是很有必要实时掌握，并且实时更新。</p>
<p>React生命周期有一份<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">图谱</a>。上面可以查看react的生命周期(新版)。</p>
<p>react的组件的生命周期在react16.3及以后的版本中已经不一样了。但是总的几个阶段是不变的，不管是新的版本还是老的版本，都分为</p>
<ul>
<li>组件挂载</li>
<li>组件更新</li>
<li>组件卸载</li>
</ul>
<p>这样的几个阶段。</p>
<h3 id="React16-3以前的生命周期-作为了解"><a href="#React16-3以前的生命周期-作为了解" class="headerlink" title="React16.3以前的生命周期(作为了解)"></a>React16.3以前的生命周期(作为了解)</h3><h4 id="1-组件挂载"><a href="#1-组件挂载" class="headerlink" title="1.组件挂载"></a>1.组件挂载</h4><ol>
<li>getDefaultProps()：加载的时候调用一次，设置默认的<code>props</code>，也可以使用<code>组件名.defaultProps = {}</code>设置默认属性。</li>
<li>getInitialState()：加载的时候调用一次，可以初始化<code>state</code>。</li>
<li>componentWillMount()：只在组件挂载的时候调用，且整个生命周期只调用一次，此时可以修改<code>state</code>。但是一般不使用</li>
<li>render()：react的最重要的步骤，创建虚拟DOM，进行<code>diff算法</code>,更新DOM树都在此运行</li>
<li>componentDidMount()：组件渲染之后（执行rendeer后）调用一次</li>
</ol>
<h4 id="2-组件更新"><a href="#2-组件更新" class="headerlink" title="2.组件更新"></a>2.组件更新</h4><ol>
<li>componentWillReceiveProps(nextProps)：组件加载时不使用，组件接收新的<code>props</code>是调用</li>
<li>shouldComponentUpdate(nextProps, nextState)：组件接收到新的props或state时调用，函数<strong>必须</strong>有一个返回值（true or false），为<code>true</code>的时候组件更新，为 <code>flase</code> 的时候组件不更新。默认返回的是<code>true</code>。这个方法很重要，一个组件的优化都在这里面进行。</li>
<li>componentWillUpdata(nextProps, nextState)</li>
<li>render()：react的最重要的步骤，创建虚拟DOM，进行<code>diff算法</code>,更新DOM树都在此运行</li>
<li>componentDidUpdate()：组件挂载时不调用，组件更新完成调用</li>
</ol>
<h3 id="3-卸载阶段"><a href="#3-卸载阶段" class="headerlink" title="3.卸载阶段"></a>3.卸载阶段</h3><ol>
<li>componentWillUnmount()：组件将要移除时候调用。一般在这个函数里面清除定时器，异步操作等</li>
</ol>
<h3 id="React16-3以后的生命周期"><a href="#React16-3以后的生命周期" class="headerlink" title="React16.3以后的生命周期"></a>React16.3以后的生命周期</h3><h3 id="1-挂载阶段"><a href="#1-挂载阶段" class="headerlink" title="1.挂载阶段"></a>1.挂载阶段</h3><ol>
<li>constructor()：在这个构造函数中一般处理初始化state或者进行方法的绑定，如不需要，则可以不使用此方法</li>
<li>static getDerivedStateFromProps()：会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</li>
<li>render()</li>
<li>componentDidMount()</li>
</ol>
<p>*.componentWillMount方法在新的生命周期中已经过期，应该替换成<code>UNSAFE_componentWillMount</code>，不过也将在react17中移除</p>
<h3 id="2-更新阶段"><a href="#2-更新阶段" class="headerlink" title="2.更新阶段"></a>2.更新阶段</h3><ol>
<li>static getDerivedStateFromProps()</li>
<li>shouldComponentUpdate()</li>
<li>render()</li>
<li>getSnapshotBeforeUpdate(prevProps, prevState)：此方法并不常使用</li>
<li>componentDidUpdate()</li>
</ol>
<p>*. 老方法的<code>componentWillUpdate</code>以及<code>componentWillReceiveProps</code>即将过期，应该避免使用它们</p>
<h3 id="3-卸载阶段-1"><a href="#3-卸载阶段-1" class="headerlink" title="3.卸载阶段"></a>3.卸载阶段</h3><ol>
<li>componentWillUnmount()</li>
</ol>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol>
<li>static getDerivedStateFromProps()</li>
<li>componentDidCatch(error, info)：此生命周期在后代组件抛出错误后被调用</li>
</ol>
<p>总的来说新的生命周期移除了一些不必要的函数。具体的可以查看<a href="https://zh-hans.reactjs.org/docs/react-component.html" target="_blank" rel="noopener">React.Component</a></p>
<h2 id="对-React-时间操作节流与防抖"><a href="#对-React-时间操作节流与防抖" class="headerlink" title="对 React 时间操作节流与防抖"></a>对 React 时间操作节流与防抖</h2><ul>
<li>节流：节流阻止函数在给定时间窗口内被调不能超过一次。</li>
<li>防抖：防抖确保函数不会在上一次被调用之后一定量的时间内被执行。当必须进行一些费时的计算来响应快速派发的事件时（比如鼠标滚动或键盘事件时），防抖是非常有用的。</li>
</ul>
<p>以前在进行按钮提交，鼠标滚动等操作的时候，都会进行截留或者是防抖。但是都是自己写的，有时候或者是有的地方会忘记添加。</p>
<p><a href="https://lodash.com" target="_blank" rel="noopener">lodash</a>中已经有相关的函数了</p>
<ul>
<li><a href="https://lodash.com/docs/4.17.15#throttle" target="_blank" rel="noopener">throttle</a></li>
<li><a href="https://lodash.com/docs/4.17.15#debounce" target="_blank" rel="noopener">debounce</a></li>
</ul>
<p>但是，整个 lodash 的库应用进来有1.4M，太大了。不过还好，npm 上面已经有 throttle 和 debounce 的提取包了。</p>
<ul>
<li><p><a href="https://www.npmjs.com/package/lodash.throttle" target="_blank" rel="noopener">https://www.npmjs.com/package/lodash.throttle</a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i --save lodash.throttle</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.npmjs.com/package/lodash.debounce" target="_blank" rel="noopener">https://www.npmjs.com/package/lodash.debounce</a></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i --save lodash.debounce</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>都接收两个参数，第一个是操作的函数，第二个是时间间隔(ms)。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react项目报错集锦</title>
    <url>/%E6%8A%80%E6%9C%AF/react%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A6.html</url>
    <content><![CDATA[<h2 id="Warning-Can’t-perform-a-React-state-update-on-an-unmounted-component-This-is-a-no-op-but-it-indicates-a-memory-leak-in-your-application-To-fix-cancel-all-subscriptions-and-asynchronous-tasks-in-the-componentWillUnmount-method"><a href="#Warning-Can’t-perform-a-React-state-update-on-an-unmounted-component-This-is-a-no-op-but-it-indicates-a-memory-leak-in-your-application-To-fix-cancel-all-subscriptions-and-asynchronous-tasks-in-the-componentWillUnmount-method" class="headerlink" title="Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method."></a>Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.</h2><p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20200103111012.png" alt="错误截图"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方法上面其实以及说到了。只需要找到对象的文件，在 <code>componentWillUnmount</code> 中取消所有的订阅以及异步执行即可。</p>
<p>下面是代码<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Avatar <span class="keyword">from</span> <span class="string">'@img/common/avatar.jpeg'</span></span><br><span class="line"><span class="keyword">import</span> Stance <span class="keyword">from</span> <span class="string">'@img/common/stance.png'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CusImage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> defaultImage = props.isAvatar ? Avatar : Stance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      src: defaultImage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">const</span> THIS = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123;imgSrc&#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">    img.src = imgSrc</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      THIS.setState(&#123;</span><br><span class="line">        src: imgSrc</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加以下代码</span></span><br><span class="line">  componentWillUnmount()&#123;</span><br><span class="line">    <span class="comment">// 如果有定时器需要清除</span></span><br><span class="line">    <span class="comment">// clearTimeout(this.timer)</span></span><br><span class="line">    <span class="keyword">this</span>.setState = <span class="function">(<span class="params">state, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render ()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;src&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> &#123;className, alt = <span class="string">"cus-img"</span>&#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;img className=&#123;className&#125; src=&#123;src&#125; alt=&#123;alt&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CusImage</span><br></pre></td></tr></table></figure></p>
<h2 id="react-dom-development-js-12427-Warning-componentWillMount-has-been-renamed-and-is-not-recommended-for-use-See-https-fb-me-react-unsafe-component-lifecycles-for-details"><a href="#react-dom-development-js-12427-Warning-componentWillMount-has-been-renamed-and-is-not-recommended-for-use-See-https-fb-me-react-unsafe-component-lifecycles-for-details" class="headerlink" title="react-dom.development.js:12427 Warning: componentWillMount has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details."></a>react-dom.development.js:12427 Warning: componentWillMount has been renamed, and is not recommended for use. See <a href="https://fb.me/react-unsafe-component-lifecycles" target="_blank" rel="noopener">https://fb.me/react-unsafe-component-lifecycles</a> for details.</h2><p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20200103143951.png" alt="错误截图"></p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>在 react 16.8 之后的版本中，修改了一下生命周期，移除了一些方法，<code>componentWillMount</code>就是其中一个。现在如果要使用这个，使用 <code>UNSAFE_componentWillMount</code> 替换。但是不建议使用这个方法</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>前端中的直播</title>
    <url>/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E7%9B%B4%E6%92%AD.html</url>
    <content><![CDATA[<p>因为公司是做在线抓娃娃的，涉及到直播推流这一部分的工作。之前一直都是在App上面进行游戏，所以关于直播这一部分也是与安卓与IOS有关，与前端是没有关系的。但是现在新的需求就是要求这个在线抓娃娃要能够在网页上面进行游戏。所以，我的事情来了。对于没有涉及到前端音视频的这部分的需求，所以初入这一行，还是有点马马虎虎，花了一周多的时间终于是弄明白了。</p>
<p>要了解前端视频方面的东西，还是要从基础的说起。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>2019年了，HTML5已经走进千家万户，同时，直播也在全球盛行。App端的姑且不说，web端的使用视频播放的话，一般都是在用HTML5中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video" target="_blank" rel="noopener">video</a> 标签了。然而，video标签的限制实在是太多了，尤其是对于播放格式这一项，仅仅是支持 <code>MP4</code> <code>OGG</code> <code>WebM</code> 格式，现在可能还支持 <code>m3u8</code> 格式的视频。</p>
<p>但是，再来看看现在的直播方面的知识</p>
<h2 id="直播简介"><a href="#直播简介" class="headerlink" title="直播简介"></a>直播简介</h2><p>关于直播，大概的过程是：<strong>推流—&gt;源站—&gt;客户端拉流—&gt;客户端播放</strong></p>
<ol>
<li>推流：指的是把采集阶段封包好的内容传输到服务器的过程。</li>
<li>拉流：一般是一个URL地址，即播放地址，有多种类型的流。</li>
</ol>
<p>视频直播服务目前常用的包含三种协议（当前时间阿里云的直播推流也是这三种协议），分别是RTML， HLS， (HTTP-)FLV。</p>
<p>下面附上一张知乎上面的推流拉流图</p>
<p><img src="https://pic2.zhimg.com/80/7cb543431f65ddc2d328856f1fcc47fc_hd.jpg" alt="推流拉流图"></p>
<p>###<br>RTMP: RTMP是Real Time Messaging Protocol（实时消息传输协议）的缩写，是Adobe公司为Flash/AIR平台和服务器之间音、视频及数据传输开发的实时消息传送协议。RTMP协议基于TCP，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP协议中，视频必须是H264编码，音频必须是AAC或MP3编码，且多以flv格式封包。RTMP是目前最主流的流媒体传输协议，对CDN支持良好，实现难度较低，是大多数的直播平台的选择。不过RTMP有着一个最大的不足——不支持浏览器，且Adobe已不再更新。因此直播服务要支持浏览器的话，需要另外的推送协议支持。</p>
<p>优点：</p>
<ul>
<li>延时低，稳定性好，支持摄像头格式多</li>
</ul>
<p>缺点：</p>
<ul>
<li>浏览器需要加载flash才可以播放（预计2020年底所有浏览器最新版本都不在支持flash）</li>
<li>RTMP是私有协议（Adobe的私有协议），很多设备无法播放。同时移动端不支持flash。所以，这种格式的视频基本无法再移动端使用。</li>
<li>安全性问题</li>
</ul>
<h3 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h3><p><a href="https://www.jianshu.com/p/426425cad08a" target="_blank" rel="noopener">HLS</a>（Http Live Streaming) 是一个由苹果公司提出的基于HTTP的流媒体网络传输协议，直接把流媒体切片成一段段，信息保存到<code>m3u(m3u8)</code>列表文件中， 可以将不同速率的版本切成相应的片；播放器可以直接使用http协议请求流数据。</p>
<p>优点：</p>
<ul>
<li>可以在不同速率的版本间自由切换，实现无缝播放</li>
<li>省去使用其他协议的烦恼</li>
</ul>
<p>缺点：</p>
<ul>
<li>延时高，不适合做直播</li>
<li>因为采用ts切片，所以一个文件可能会被切成成百上千个小文件，对存储和缓存都有一定的挑战</li>
</ul>
<p>这个流一般用于苹果web浏览器的直播，因为FLV和RMTP都不支持IOS的移动端（手机与平板）</p>
<h3 id="HTTP-FLV"><a href="#HTTP-FLV" class="headerlink" title="HTTP-FLV"></a>HTTP-FLV</h3><p>关于FLV在目前来说还是一个更好的方案，关于FLV方面的介绍可以查看<a href="https://github.com/gwuhaolin/blog/issues/3" target="_blank" rel="noopener">使用flv.js做直播</a>。上面有详细的介绍。</p>
<p>因为bilibili开源flv.js的原因，使得flv在目前的直播中用的更多，尤其是在移动端中使用flv流。</p>
<p>上面的三种方案RTMP是最好的，不管是延时还是性能问题。所以，最好的方案就是PC端采用RTMP，移动端采用HTTP-FLV。但是要考虑一点就是2020年的flash的问题。</p>
<h2 id="前端做直播"><a href="#前端做直播" class="headerlink" title="前端做直播"></a>前端做直播</h2><p>在视频播放方面，前端有一个开源的插件<a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">videojs</a>。可以播放HTML5的视频格式以及Flash方面的视频。但是，在6.X开始的版本后，videojs不在支持flash，需要单独引用<a href="https://github.com/videojs/videojs-flash" target="_blank" rel="noopener">videojs-flash</a>插件，或者是使用6.X以下的版本。</p>
<p><strong>重点注意：videojs+flash不支持移动端</strong>。当初在这里纠结了两天的时间，实在是没有办法。</p>
<p>我使用的是react框架开发的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> videojs <span class="keyword">from</span> <span class="string">'video.js'</span></span><br><span class="line"><span class="comment">// import videozhCN from 'video.js/dist/lang/zh-CN.json'; //播放器中文，不能使用.js文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'video.js/dist/video-js.css'</span>;  <span class="comment">//样式文件注意要加上</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'videojs-flash'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoPlayer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// console.log(flvjs);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// instantiate Video.js</span></span><br><span class="line">    <span class="comment">//这里的this.props是上级传进来的video的options</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.player = videojs(<span class="keyword">this</span>.videoNode, <span class="keyword">this</span>.props, <span class="function"><span class="keyword">function</span> <span class="title">onPlayerReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'onPlayerReady'</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    videojs.addLanguage(<span class="string">'zh-CN'</span>, videozhCN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this.player.liveTracker.on('liveedgechange', () =&gt; &#123;</span></span><br><span class="line">      <span class="comment">// console.log('跟随直播');</span></span><br><span class="line">      <span class="comment">// this.player.liveTracker.seekToLiveEdge();</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// destroy player on unmount</span></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.player) &#123;</span><br><span class="line">      <span class="keyword">this</span>.player.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wrap the player in a div with a `data-vjs-player` attribute</span></span><br><span class="line">  <span class="comment">// so videojs won't create additional wrapper in the DOM</span></span><br><span class="line">  <span class="comment">// see https://github.com/videojs/video.js/pull/3856</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt; </span><br><span class="line">        &lt;div data-vjs-player&gt;  &#123;<span class="comment">/*这个带有属性的div目前没看到作用，可以去掉*/</span>&#125;</span><br><span class="line">          &lt;video ref=&#123; node =&gt; <span class="keyword">this</span>.videoNode = node &#125; className=<span class="string">"video-js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VideoPlayer</span><br></pre></td></tr></table></figure>
<p>引用 VideoPlayer</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; storage &#125; <span class="keyword">from</span> <span class="string">'@utils'</span></span><br><span class="line"><span class="keyword">import</span> &#123; constant &#125; <span class="keyword">from</span> <span class="string">'@data/constant'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      videoSrc: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.videoJsOptions = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">const</span> THIS = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> token = storage.getItem(constant.TOKEN)</span><br><span class="line">    <span class="keyword">var</span> toyid = <span class="number">913</span></span><br><span class="line">    <span class="keyword">var</span> URL = <span class="string">`wss://XXX.XXX.com//websocket/1.0.0/WEB/<span class="subst">$&#123;toyid&#125;</span>/<span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">    <span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(URL);</span><br><span class="line">    socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(msg.data)</span><br><span class="line">      <span class="comment">// var cmd = data.cmd</span></span><br><span class="line">      <span class="comment">// var code = data.code</span></span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 没有登录</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> data.data === <span class="string">"string"</span>) <span class="keyword">return</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// users  data.data.room.users.users</span></span><br><span class="line">      <span class="keyword">let</span> users = data.data.room.users.users</span><br><span class="line">      <span class="keyword">let</span> currentPlayer = users.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.play === <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">let</span> waitingPlayers = users.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.play === <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">let</span> videoSrc = data.data.room.video.split(<span class="string">','</span>)[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">let</span> newState = &#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> (currentPlayer.length) &#123;</span><br><span class="line">        newState.currentPlayer = currentPlayer[<span class="number">0</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (waitingPlayers.length) &#123;</span><br><span class="line">        newState.waitingPlayers = waitingPlayers</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (videoSrc) &#123;</span><br><span class="line">        <span class="comment">// videoSrc = videoSrc.replace("rtmp", "http") + ".flv"</span></span><br><span class="line">        <span class="built_in">console</span>.log(videoSrc);</span><br><span class="line">        </span><br><span class="line">        newState.videoSrc = videoSrc</span><br><span class="line">        THIS.setOptions(videoSrc)</span><br><span class="line">      &#125;</span><br><span class="line">      THIS.setState(newState)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setOptions(videoSrc) &#123;</span><br><span class="line">    <span class="keyword">const</span> videoContainer = <span class="keyword">this</span>.refs[<span class="string">"video-container"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 播放器的配置</span></span><br><span class="line">    <span class="keyword">const</span> videoJsOptions = &#123;</span><br><span class="line">      autoplay: <span class="literal">true</span>,  <span class="comment">//自动播放</span></span><br><span class="line">      language: <span class="string">'zh-CN'</span>, </span><br><span class="line">      <span class="comment">// controls: true,  //控制条</span></span><br><span class="line">      preload: <span class="literal">true</span>,  <span class="comment">//自动加载</span></span><br><span class="line">      <span class="comment">// errorDisplay: true,  //错误展示</span></span><br><span class="line">      width: videoContainer.clientWidth,  <span class="comment">//宽</span></span><br><span class="line">      height: videoContainer.clientHeight,  <span class="comment">//高</span></span><br><span class="line">      <span class="comment">// fluid: true,  //跟随外层容器变化大小，跟随的是外层宽度</span></span><br><span class="line">      <span class="comment">// controlBar: false,  // 设为false不渲染控制条DOM元素，只设置controls为false虽然不展示，但还是存在</span></span><br><span class="line">      <span class="comment">// textTrackDisplay: false,  // 不渲染字幕相关DOM</span></span><br><span class="line">      userActions: &#123;</span><br><span class="line">        <span class="comment">// hotkeys: true  //是否支持热键</span></span><br><span class="line">      &#125;,</span><br><span class="line">      sources: [</span><br><span class="line">        &#123;</span><br><span class="line">          src: videoSrc,</span><br><span class="line">          <span class="comment">// src: 'http://live2.get.cpxlive.com/live2/front124.m3u8',</span></span><br><span class="line">          <span class="comment">// src: "http://snowman.mobilecpx.com/video/wifi-socket.mp4",</span></span><br><span class="line">          <span class="comment">// type: "rmtp/flv"</span></span><br><span class="line">          type: <span class="string">"application/x-mpegURL"</span>,  <span class="comment">//类型可加可不加，目前未看到影响</span></span><br><span class="line">          <span class="comment">// type: 'video/mp4',</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.videoJsOptions = videoJsOptions</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; videoSrc &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"cpx-game flex-content"</span>&gt;</span><br><span class="line">        &lt;section ref=<span class="string">"video-container"</span> className=<span class="string">"cpx-game-video"</span>&gt;</span><br><span class="line">          &#123;videoSrc &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">VideoPlayer</span> &#123;<span class="attr">...this.videoJsOptions</span>&#125;/&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Game</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意注意：上面的视频能够播放了，但是。播放的时候中间会出现一个<img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20191108150821.png" alt="我还要自己去点击播放？">。没错，自己点击播放。真没意思。如果要解决这个问题，需要引入 <code>video-js.swf</code> 。这个在 <code>node_modules/videojs-swf</code> 下面有一个 video-js.swf 文件。我是直接把把他引入到了<img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20191108151102.png" alt="同级目录">下面。这样处理完成后就可以自动播放了。真是操蛋了。</p>
</blockquote>
<p>VidePlayer.js修改如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> videojs <span class="keyword">from</span> <span class="string">'video.js'</span></span><br><span class="line"><span class="comment">// import videozhCN from 'video.js/dist/lang/zh-CN.json'; //播放器中文，不能使用.js文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'video.js/dist/video-js.css'</span>;  <span class="comment">//样式文件注意要加上</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'videojs-flash'</span>  <span class="comment">//如果要播放RTMP要使用flash 需要先npm i videojs-flash</span></span><br><span class="line"><span class="comment">// 引用这个中间就不会出现那个 SB 的Flash播放按钮</span></span><br><span class="line">+ <span class="keyword">import</span> swf <span class="keyword">from</span> <span class="string">'./video-js.swf'</span></span><br><span class="line">+ videojs.options.flash.swf = swf</span><br></pre></td></tr></table></figure>
<p>上面的PC的，采用的是RTMP的流</p>
<p>如果是flv的流，react可以使用<a href="https://github.com/gwuhaolin/reflv" target="_blank" rel="noopener">reflv</a>这个插件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Reflv <span class="keyword">from</span> <span class="string">'reflv'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoPlayer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;url&#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Reflv</span><br><span class="line">        url=&#123;url&#125;</span><br><span class="line">        type=<span class="string">"flv"</span></span><br><span class="line">        isLive</span><br><span class="line">        cors</span><br><span class="line">      /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VideoPlayer</span><br></pre></td></tr></table></figure>
<p>更多的配置参数查看<a href="https://gwuhaolin.github.io/reflv/" target="_blank" rel="noopener">https://gwuhaolin.github.io/reflv/</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>直播</tag>
        <tag>前端直播</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端web页面开发的一些问题</title>
    <url>/%E6%8A%80%E6%9C%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>前端涉及到的领域不单单只是PC浏览器了，现在是移动为王的时代，所以大部分的时候还是在做移动端的页面适配。所以这里记录一下在移动端开发的时候遇到的一些问题。</p>
<h1 id="1、移动端隐藏手机浏览器的地址栏以及底部的菜单栏"><a href="#1、移动端隐藏手机浏览器的地址栏以及底部的菜单栏" class="headerlink" title="1、移动端隐藏手机浏览器的地址栏以及底部的菜单栏"></a>1、移动端隐藏手机浏览器的地址栏以及底部的菜单栏</h1><p>在设置移动端页面的宽高为100%的时候，里面的元素设置<code>flex:1</code>的时候，因为浏览器的地址栏以及下面的工具栏的问题会导致在有的手机上面的页面显示不全的问题。因为我们不好计算每一个浏览器的地址栏以及工具栏的高度，所以我们直接把它隐藏起来即可，下面的隐藏的代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- webApp全屏显示，IOS设备 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">'apple-mobile-web-app-capable'</span> <span class="attr">content</span>=<span class="string">'yes'</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通用的浏览器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">'full-screen'</span> <span class="attr">content</span>=<span class="string">'true'</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ浏览器（X5内核）独有的META --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">'x5-fullscreen'</span> <span class="attr">content</span>=<span class="string">'true'</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 360浏览器独有的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">'360-fullscreen'</span> <span class="attr">content</span>=<span class="string">'true'</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="2、移动端网页自适应"><a href="#2、移动端网页自适应" class="headerlink" title="2、移动端网页自适应"></a>2、移动端网页自适应</h1><p>在开发网页的时候适配是一个老生常谈的话题。现在的适配基本都是使用的rem布局。而跟标签（html标签）的自己大小根据手机的屏幕大小来设置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  (<span class="function"><span class="keyword">function</span> <span class="params">(doc, win)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> docEl = doc.documentElement,</span></span><br><span class="line"><span class="javascript">        resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</span></span><br><span class="line"><span class="actionscript">        recalc = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> clientWidth = docEl.clientWidth;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span>(clientWidth&gt;=<span class="number">640</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                docEl.style.fontSize = <span class="string">'100px'</span>;</span></span><br><span class="line"><span class="actionscript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">                docEl.style.fontSize = <span class="number">100</span> * (clientWidth / <span class="number">640</span>) + <span class="string">'px'</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="actionscript">    win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span></span><br><span class="line"><span class="actionscript">    doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">  &#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的一段代码则是自动修的HTML的跟标签的字体大小的标签，然后就可以使用rem来设置元素的宽高了。但是，rem不能设置字体的自适应。</p>
<p>对于我而言，现在都是9102了，vw,vh,vmin,vmax这几个属性。来看看<a href="https://caniuse.com/#search=vw" target="_blank" rel="noopener">can i use</a>上面的兼容性检测。</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20191030100525.png" alt="Viewport units: vw, vh, vmin, vmax"></p>
<p>其实可以看到还是挺不错的，安卓4.4以上的都是兼容的。所以在9102这个年代了，可以放心大胆的使用了，就算是华为手机自带的浏览器也没有毛病。关于华为浏览器的问题可以查看我的另一篇文章 <a href="./关于使用react16以上在华为手机上面显示出现问题的解决方法.html">关于使用react16以上在华为手机上面显示出现问题的解决方法</a></p>
<p>关于rem以及vw, vh, vmin, vmax的具体可以查看<a href="https://yanhaijing.com/css/2017/09/29/principle-of-rem-layout/" target="_blank" rel="noopener">Rem布局的原理解析</a>。本来想放大漠的文章，今天去看突然就要付费才可以看了。</p>
<h1 id="3、移动端-a-标签点击会有蓝色的背景色"><a href="#3、移动端-a-标签点击会有蓝色的背景色" class="headerlink" title="3、移动端 a 标签点击会有蓝色的背景色"></a>3、移动端 a 标签点击会有蓝色的背景色</h1><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>添加<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">-webkit-tap-highlight-color</span>:transparent; &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>移动端web</tag>
      </tags>
  </entry>
  <entry>
    <title>关于使用react16以上在华为手机上面显示出现问题的解决方法</title>
    <url>/%E6%8A%80%E6%9C%AF/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8react16%E4%BB%A5%E4%B8%8A%E5%9C%A8%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<p>项目的网站开发了一段时间了，最近也忙着华为应用市场的上架。所以关于华为的事情也是需要着手考虑一下。</p>
<h1 id="问题一：使用16-8的react以及reactDOM华为自带浏览器白屏"><a href="#问题一：使用16-8的react以及reactDOM华为自带浏览器白屏" class="headerlink" title="问题一：使用16.8的react以及reactDOM华为自带浏览器白屏"></a>问题一：使用16.8的react以及reactDOM华为自带浏览器白屏</h1><p>在使用react开发的项目中，所有的浏览器（自己用的，公司没有测试）都能够跑起来。但是在使用华为手机自带的浏览器的时候，却出现了一片空白的情况。</p>
<p>开发用到的依赖如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"axios": "^0.18.0",</span><br><span class="line">"babel-polyfill": "^6.26.0",</span><br><span class="line">"core-js": "^3.3.5",</span><br><span class="line">"customize-cra": "^0.5.0",</span><br><span class="line">"firebase": "^6.1.0",</span><br><span class="line">"i18next": "^15.1.3",</span><br><span class="line">"i18next-browser-languagedetector": "^3.0.1",</span><br><span class="line">"i18next-xhr-backend": "^2.0.1",</span><br><span class="line">"js-cookie": "^2.2.0",</span><br><span class="line">"mescroll.js": "^1.4.1",</span><br><span class="line">"moment": "^2.24.0",</span><br><span class="line">"node-sass": "^4.12.0",</span><br><span class="line">"payment": "^2.3.0",</span><br><span class="line">"prerender-spa-plugin": "^3.4.0",</span><br><span class="line">"qs": "^6.7.0",</span><br><span class="line">"react": "^16.8.6",</span><br><span class="line">"react-app-rewired": "^2.1.3",</span><br><span class="line">"react-confirm-alert": "^2.4.1",</span><br><span class="line">"react-credit-cards": "^0.7.0",</span><br><span class="line">"react-dom": "^16.8.6",</span><br><span class="line">"react-ga": "^2.6.0",</span><br><span class="line">"react-i18next": "^10.10.0",</span><br><span class="line">"react-paypal-express-checkout": "^1.0.5",</span><br><span class="line">"react-redux": "^7.0.3",</span><br><span class="line">"react-router-dom": "^5.0.0",</span><br><span class="line">"react-scripts": "3.0.1",</span><br><span class="line">"react-switch": "^5.0.0",</span><br><span class="line">"react-toastify": "^5.1.1",</span><br><span class="line">"redux": "^4.0.1"</span><br></pre></td></tr></table></figure>
<p>版本是 <code>16.8</code> 的react以及reactDOM。</p>
<p>查询很多资料，最后得知 reactDOM 在16开始的时候就是使用的ES6的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">Map</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">Set</a>。而华为浏览器以及其他的一些未知浏览器使用的还是低版本的浏览器内核。</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/华为自带浏览器UA.jpg" alt="华为自带浏览器UA"></p>
<p>37.0.0.0.0 这可是4年轻的内核了。所以是不兼容了。</p>
<p>React官方给出了<a href="https://reactjs.org/docs/javascript-environment-requirements.html" target="_blank" rel="noopener">说明</a></p>
<p>但是使用<code>babel-polyfill</code>仍然无法解决</p>
<p>所以，这里使用 <code>core-js</code>,使用如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'core-js/es/map'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js/es/set'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样就可以解决华为手机无法显示（或者说是显示空白的问题）。</p>
<h1 id="问题二：使用fixed定位的时候没有显示出来"><a href="#问题二：使用fixed定位的时候没有显示出来" class="headerlink" title="问题二：使用fixed定位的时候没有显示出来"></a>问题二：使用fixed定位的时候没有显示出来</h1><p>项目中有一个支付需求需要在页面弹出支付通道选择（信用卡，paypal等），但是设置显示的时候出现了没有弹出选择界面的情况，但是实际上又确实有这个页面（只显示它的时候）。修的定位层级的时候也是无法显示。最后发现，<strong>在华为等低端浏览器内核的手机上面同时需要设置定位的位置才可以（left:0, top:0）</strong>，高版本的内核的浏览器没有这个问题，我猜想是自己默认就是（left:0, top:0）了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react项目预渲染开发</title>
    <url>/%E6%8A%80%E6%9C%AF/react%E9%A1%B9%E7%9B%AE%E9%A2%84%E6%B8%B2%E6%9F%93%E5%BC%80%E5%8F%91.html</url>
    <content><![CDATA[<p>react越来越火了，是开react开发的人员而是越来越多。但是因为单页应用SEO的问题，我们也不得不去解决这个问题。不管是哪里，都提供了两种方案，一种是SSR服务端渲染，另一种则是预渲染方式。本篇文章主要是阐述预渲染的方案。</p>
<h2 id="什么是预渲染"><a href="#什么是预渲染" class="headerlink" title="什么是预渲染"></a>什么是预渲染</h2><p>在一般的react项目中（比如使用create-react-app创建的项目），我们在最后打包的时候只会生成一个HTML，JS与CSS文件，或许你会采用一些方法，比如公共文件拆分，路由懒加载等等生成多个文件，但是也无法从根本上解决这个问题，所有的资源还是通过JS动态的生成渲染的。</p>
<p>所以，<strong>所谓的预渲染</strong>就是在单页应用中，将用户交互不多，同时需要SEO的页面单独提取出来的一种方法，提取出来的就是一个HTML文件。</p>
<h2 id="怎么使用预渲染"><a href="#怎么使用预渲染" class="headerlink" title="怎么使用预渲染"></a>怎么使用预渲染</h2><p>开发react项目的时候，一般都是结合者webpack使用的。目前用的最多的预渲染的方法，就是使用webpack插件<a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a>。这是一个webpack插件，所以使用直接在webpack的插件配置项中添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">  routes: [<span class="string">"/"</span>, <span class="string">"/download"</span>, <span class="string">"/prize"</span>, <span class="string">"/news"</span>, <span class="string">"/news/detail?id=1"</span>, <span class="string">"/support"</span>],</span><br><span class="line">  staticDir: path.join(__dirname, <span class="string">'build'</span>),</span><br><span class="line">  renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">    renderAfterTime: <span class="number">50000</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>其中<code>routes</code>是需要预渲染的route，一般都是react-router-dom配置的路由。 <code>staticDir</code>是输出的目录。因为这里使用了create-react-app，默认的输出目录是build，所以，这里也是build，如果你是自己搭建或者使用的是其他的方式，或许目录名字会有所不同。</p>
<p>更多具体的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 摘取自github</span></span><br><span class="line"><span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">  <span class="comment">// Required - The path to the webpack-outputted app to prerender.</span></span><br><span class="line">  staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional - The path your rendered app should be output to.</span></span><br><span class="line">  <span class="comment">// (Defaults to staticDir.)</span></span><br><span class="line">  outputDir: path.join(__dirname, <span class="string">'prerendered'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional - The location of index.html</span></span><br><span class="line">  indexPath: path.join(__dirname, <span class="string">'dist'</span>, <span class="string">'index.html'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Required - Routes to render.</span></span><br><span class="line">  routes: [ <span class="string">'/'</span>, <span class="string">'/about'</span>, <span class="string">'/some/deep/nested/route'</span> ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional - Allows you to customize the HTML and output path before</span></span><br><span class="line">  <span class="comment">// writing the rendered contents to a file.</span></span><br><span class="line">  <span class="comment">// renderedRoute can be modified and it or an equivelant should be returned.</span></span><br><span class="line">  <span class="comment">// renderedRoute format:</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   route: String, // Where the output file will end up (relative to outputDir)</span></span><br><span class="line">  <span class="comment">//   originalRoute: String, // The route that was passed into the renderer, before redirects.</span></span><br><span class="line">  <span class="comment">//   html: String, // The rendered HTML for this route.</span></span><br><span class="line">  <span class="comment">//   outputPath: String // The path the rendered HTML will be written to.</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  postProcess (renderedRoute) &#123;</span><br><span class="line">    <span class="comment">// Ignore any redirects.</span></span><br><span class="line">    renderedRoute.route = renderedRoute.originalRoute</span><br><span class="line">    <span class="comment">// Basic whitespace removal. (Don't use this in production.)</span></span><br><span class="line">    renderedRoute.html = renderedRoute.html.split(<span class="regexp">/&gt;[\s]+&lt;/gmi</span>).join(<span class="string">'&gt;&lt;'</span>)</span><br><span class="line">    <span class="comment">// Remove /index.html from the output path if the dir name ends with a .html file extension.</span></span><br><span class="line">    <span class="comment">// For example: /dist/dir/special.html/index.html -&gt; /dist/dir/special.html</span></span><br><span class="line">    <span class="keyword">if</span> (renderedRoute.route.endsWith(<span class="string">'.html'</span>)) &#123;</span><br><span class="line">      renderedRoute.outputPath = path.join(__dirname, <span class="string">'dist'</span>, renderedRoute.route)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> renderedRoute</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional - Uses html-minifier (https://github.com/kangax/html-minifier)</span></span><br><span class="line">  <span class="comment">// To minify the resulting HTML.</span></span><br><span class="line">  <span class="comment">// Option reference: https://github.com/kangax/html-minifier#options-quick-reference</span></span><br><span class="line">  minify: &#123;</span><br><span class="line">    collapseBooleanAttributes: <span class="literal">true</span>,</span><br><span class="line">    collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">    decodeEntities: <span class="literal">true</span>,</span><br><span class="line">    keepClosingSlash: <span class="literal">true</span>,</span><br><span class="line">    sortAttributes: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Server configuration options.</span></span><br><span class="line">  server: &#123;</span><br><span class="line">    <span class="comment">// Normally a free port is autodetected, but feel free to set this if needed.</span></span><br><span class="line">    port: <span class="number">8001</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The actual renderer to use. (Feel free to write your own)</span></span><br><span class="line">  <span class="comment">// Available renderers: https://github.com/Tribex/prerenderer/tree/master/renderers</span></span><br><span class="line">  renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">    <span class="comment">// Optional - The name of the property to add to the window object with the contents of `inject`.</span></span><br><span class="line">    injectProperty: <span class="string">'__PRERENDER_INJECTED'</span>,</span><br><span class="line">    <span class="comment">// Optional - Any values you'd like your app to have access to via `window.injectProperty`.</span></span><br><span class="line">    inject: &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional - defaults to 0, no limit.</span></span><br><span class="line">    <span class="comment">// Routes are rendered asynchronously.</span></span><br><span class="line">    <span class="comment">// Use this to limit the number of routes rendered in parallel.</span></span><br><span class="line">    maxConcurrentRoutes: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional - Wait to render until the specified event is dispatched on the document.</span></span><br><span class="line">    <span class="comment">// eg, with `document.dispatchEvent(new Event('custom-render-trigger'))`</span></span><br><span class="line">    renderAfterDocumentEvent: <span class="string">'custom-render-trigger'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional - Wait to render until the specified element is detected using `document.querySelector`</span></span><br><span class="line">    renderAfterElementExists: <span class="string">'my-app-element'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional - Wait to render until a certain amount of time has passed.</span></span><br><span class="line">    <span class="comment">// NOT RECOMMENDED</span></span><br><span class="line">    renderAfterTime: <span class="number">5000</span>, <span class="comment">// Wait 5 seconds.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other puppeteer options.</span></span><br><span class="line">    <span class="comment">// (See here: https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions)</span></span><br><span class="line">    headless: <span class="literal">false</span> <span class="comment">// Display the browser window when rendering. Useful for debugging.</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>renderAfterTime</code> 这个属性最好配置，可以在等待一定时间后在来导出另一个路由文件，如果不添加，可能会出<code>Unable to perrender all routes</code>的错误。</p>
<h2 id="上线到服务器"><a href="#上线到服务器" class="headerlink" title="上线到服务器"></a>上线到服务器</h2><p>打包后可以先在本地的服务器上面测试，这里推荐一个npm包： <a href="https://www.npmjs.com/package/serve" target="_blank" rel="noopener">serve</a> 安装后通过 <code>serve 文件夹名字</code>启动一个本地服务。</p>
<p>需要注意的是：</p>
<ol>
<li><p>当项目正常运行，同时包含多个路由的时候，当我们在除了首页以外的其他的目录刷新页面的时候都是404，这是因为服务器的配置问题。本地这里无法实现。</p>
</li>
<li><p>开发的时候必须使用 History 路由而不能使用 Hash 路由。</p>
</li>
</ol>
<p>1, 2 文件的解决方法就是修改nginx的配置如下</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> /&#123;</span><br><span class="line">    <span class="keyword">index</span>  <span class="keyword">index</span>.html <span class="keyword">index</span>.htm;</span><br><span class="line">    <span class="keyword">if</span> (!-e $request_filename) &#123;</span><br><span class="line">        rewrite ^/(.*) /<span class="keyword">index</span>.html last;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>对于动态路由，如<code>/news/detail/:id</code>是不支持的，推荐使用query路由，如<code>/new/detail?id=</code></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础算法</title>
    <url>/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>对于前端初学者而言，这样的一个功能你做出来了那就很好，慢慢的，我们的工作年限越来越长，如果我们还继续那样做，这样，迟早会淘汰。这个时候，就需要对你的项目进行优化。之前讲到过对于<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/react%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96.html">react项目的优化</a>。这更多是针对于单页应用的优化，避免首页时间加载过长，打包文件加载过大，是针对于打包后文件来说的。这篇文章主要是针对于算法相关的代码进行优化，从而是程序的运行速度更快，已达到程序的优化。</p>
<p>算法更多的是针对于数据的增删改查，或许你认为前端涉及不到，如果这样想，那你就错了。前端可能用的不多，但不会涉及不到，同时，了解算法，那么对于以后的职业道路也会有所帮助。</p>
<h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><p><a href="https://zh.wikipedia.org/wiki/二分搜索算法" target="_blank" rel="noopener">二分查找</a>在进行查找<strong>有序数组</strong>中某一项数据的时候非常有用，可以加快程序的运行速度，尤其是在具有大量数据的时候。</p>
<p>二分查找的原理是从数组的中间开始查找，如果被查找对象刚好就是中间这一项，那直接退出查找。如果被查找对象大于中间，那么所需要的对象是在<em>中间-最后</em>这一区间，所以有针对于这一区间再次进行二分。如此下去，找到所需要的即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; list  待查找的有序数组</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; item 待查找的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">list, item</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果list不是数组返回list</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(list)) <span class="keyword">return</span> list</span><br><span class="line">    <span class="comment">// 定义查找的起始位置</span></span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> high = list.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="comment">// 定义中间的位置</span></span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> midValue = list[mid]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( midValue == item ) <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midValue &lt; item)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midValue &gt; item)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来看看一个具体的效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    arr.push(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> need = <span class="number">6734</span></span><br><span class="line"><span class="keyword">let</span> res;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"for"</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ele = arr[i];</span><br><span class="line">  <span class="keyword">if</span>( ele === need ) &#123;</span><br><span class="line">    res = i</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"for"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"binarySearch"</span>)</span><br><span class="line">res = binarySearch(arr, need)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"binarySearch"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190910163005.png" alt></p>
<p>可以看到很明显二分查找比普通的循环遍历快了许多。</p>
<p>可视化链接</p>
<p><a href="https://algorithm-visualizer.org/branch-and-bound/binary-search" target="_blank" rel="noopener">https://algorithm-visualizer.org/branch-and-bound/binary-search</a></p>
<p>时间复杂度 <strong>O(\log n)</strong></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>上面讲到的二分查找虽然性能很好，当时有一个必要的条件就是这个list需要是一个有序数组，否则使用二分查找则是不成立的。所以，对于一个无序的数组，我们首先就是需要把它重新排序。<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">选择排序</a>就是其中一种。</p>
<p>选择排序的原理是从数组中选出一个最大（小）的数，放在另一个数组的开始，然后从剩余数组中继续选择最大（小）的数进行操作，如此重复，直到数组重组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(list)) <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个数组存放排序后的数组</span></span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> smallestIndex = findSmallest(list)</span><br><span class="line">    arr.push(list.splice(smallestIndex, <span class="number">1</span>)[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找最小的数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findSmallest</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> smallest = list[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> smallestIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ele = list[i];</span><br><span class="line">    <span class="keyword">if</span> (ele &lt; smallest) &#123;</span><br><span class="line">      smallest = ele</span><br><span class="line">      smallestIndex = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> smallestIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>通过自己实现函数 call,apply,bind 来了解他们的原理</title>
    <url>/%E6%8A%80%E6%9C%AF/%E9%80%9A%E8%BF%87%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0-call-apply-bind-%E6%9D%A5%E4%BA%86%E8%A7%A3%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<p>我们知道函数中的call，apply，bind都是可以修改函数的this指向。关于函数的this指向问题可以转到<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/javascript-this%E7%9A%84%E6%8C%87%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98.html">Javascript this 指向问题</a>这篇文章。</p>
<p>在<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/javascript-this%E7%9A%84%E6%8C%87%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98.html">Javascript this 指向问题</a>一篇中我们知道函数运行时候this是取决于调用这个函数的对象。如果一个函数定义在了全局，那么这个this就指向window。</p>
<p>来看一段代码<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"tal"</span></span><br><span class="line"><span class="keyword">var</span> sex = <span class="string">"boy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tal = &#123;</span><br><span class="line">  name: <span class="string">"踏浪"</span>,</span><br><span class="line">  sex: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br><span class="line">person() <span class="comment">// tal boy</span></span><br></pre></td></tr></table></figure></p>
<p>上面的<code>person</code>是定义在全局中的一个函数，<code>person()</code>调用的时候相当于是<code>window.person()</code>，是由window调用的，所以，<code>this.name</code>和<code>this.sex</code>都需要在window对象中寻找，即全局变量中找。所以，最后的值会是<code>tal</code>与<code>boy</code>。</p>
<p>再来。我们来调用一下原生的<code>call</code>函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"tal"</span></span><br><span class="line"><span class="keyword">var</span> sex = <span class="string">"boy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tal = &#123;</span><br><span class="line">  name: <span class="string">"踏浪"</span>,</span><br><span class="line">  sex: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br><span class="line">person.call(tal) <span class="comment">// 踏浪 男</span></span><br></pre></td></tr></table></figure>
<p>在调用了<code>call</code>函数以后，最后的值是<code>踏浪 男</code>。得到的是对象<code>tal</code>中的两个属性值。此时函数中的this指向了对象<code>tal</code>。结合上面的例子，直接调用<code>person</code>函数的时候，相当于是<code>window.person()</code>的执行，所以那时this指向了window。那现在既然指向了<code>tal</code>，换言之，就是相当于<code>tal.person()</code>执行了。</p>
<h2 id="call-的实现"><a href="#call-的实现" class="headerlink" title="call 的实现"></a>call 的实现</h2><p>所以我们可以这样实现<code>mycall</code>函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  context.fn()</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mycall</code>接收一个参数，即一个对象，最终的this指向这个对象。函数内部实现在这个传入的对象中绑定上我们需要执行的这个函数，即<code>context.fn = this</code>一行。最后调用<code>context.fn()</code>。因为我们这样操作修改了传入对象的属性（添加了一个fn属性），所以最后需要删除这个fn属性。这样，第一版的call的实现已经完成。</p>
<p>接下来，原生 call 函数是可以接收参数的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tal = &#123;</span><br><span class="line">  name: <span class="string">"踏浪"</span>,</span><br><span class="line">  sex: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br><span class="line">person.call(tal, <span class="number">18</span>) <span class="comment">// 踏浪 男</span></span><br></pre></td></tr></table></figure>
<p>那我们自己实现的mycall要想能够接收参数，怎么实现呢</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args.join(<span class="string">","</span>) + <span class="string">')'</span>)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们需要在 mycall 调用的时候传递参数，而且参数的个数不确定，所以需要使用 arguments 。同时因为第一个参数以及确定了是我们需要的一个对象，this指向这个对象。所以 arguments 需要从 <strong>1</strong> 开始。我们用一个数组把需要的东西存放起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [];</span><br><span class="line"><span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">  args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是这样的话，我传递过去后数组 <code>args = [18, &quot;成都&quot;]</code> 里面的每一项要怎么传递到 <code>context.fn()</code> 里面并且执行呢？或许你会想到时候 <code>join(&quot;,&quot;)</code> 方法，OK，没有问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = args.join(<span class="string">","</span>);</span><br><span class="line">context.fn(res);</span><br></pre></td></tr></table></figure>
<p>这样么？不是。res的值是 <code>18,成都</code> 没问题，但是这就是一个字符串而已，我们要实现传递两个参数，所以，想到了把字符串与函数拼接。即有了 <code>&#39;context.fn(&#39; + args.join() + &#39;)&#39;</code>。这样最后就可以了。但是这只是一个字符串，怎么运行呢？这个时候就需要用到 <strong>ES3中的eval</strong> 直接传递这个参数进度即可。</p>
<p>上面的 join 方法其实就是把一个数组转换成了字符串，除了 join，你还能想到什么呢？对。可以使用字符转换来实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res = <span class="string">""</span> + args + <span class="string">""</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">res = args.toString()</span><br></pre></td></tr></table></figure>
<p>因为每一个隔开的方式是 <code>,</code> 所以可以使用上面的两种，其他的就不行咯。</p>
<p>所以最终的 mycall</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args.join(<span class="string">","</span>) + <span class="string">')'</span>)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="apply的实现"><a href="#apply的实现" class="headerlink" title="apply的实现"></a>apply的实现</h2><p>有个实现call的过程，在来实现apply就容易多了。唯一不同的就是apply传递的参数是一个数组，而call是具体的每一项。只需要在参数上面做处理即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> array = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> array !== <span class="string">"object"</span> || !(array <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"The 2'rd args must be Array."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; len = array.length, i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="string">'array['</span> + i + <span class="string">']'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args.toString() + <span class="string">')'</span>)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>arguments[1]</code> 是一个数组了。我们需要对它遍历，并且判断它是不是一个数组。其余的与 call 一样。</p>
<h2 id="bind的实现"><a href="#bind的实现" class="headerlink" title="bind的实现"></a>bind的实现</h2><p>原生的bind有两种方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tal = &#123;</span><br><span class="line">  name: <span class="string">"踏浪"</span>,</span><br><span class="line">  sex: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.bind(tal)(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">person.bind(tal, <span class="number">18</span>)()</span><br></pre></td></tr></table></figure>
<p>所以。使用bind都需要调用两次，而第一次就是返回一个函数。原函数的参数可以在bind中调用，也可以在第二次运行时候调用。所以，根据调用bind时候传递的参数的个数确定最后是返回那种函数，有了下面的这段代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span> (len === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 mybind 的参数的个数只有一个，那么剩余参数在调用的时候传入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> sub_args = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; len = <span class="built_in">arguments</span>.length, i &lt; len; i++) &#123;</span><br><span class="line">        sub_args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + sub_args.toString() + <span class="string">')'</span>)</span><br><span class="line">      <span class="keyword">delete</span> context.fn</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 这里不能使用 arguments，这里面的 arguments 是这个 return 函数的而不是最开始的。</span></span><br><span class="line">      <span class="keyword">var</span> str = <span class="string">'context.fn('</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; len = args.length, i &lt; len; i++) &#123;</span><br><span class="line">        str += <span class="string">"args["</span>+i+<span class="string">"],"</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> newStr = str.replace(<span class="regexp">/,$/</span>, <span class="string">")"</span>)</span><br><span class="line">      <span class="built_in">eval</span>(newStr)</span><br><span class="line">      <span class="keyword">delete</span> context.fn</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过自己实现 call， apply， bind 这三种方法，能够更深刻的理解到这三个函数的原理，同时涉及到的只是点也多：this指向，arguments类数组，每一个对象都要的toSting方法（另一个是valueOf），eval方法的使用（不是滥用，webpack中就使用了这个方法），函数对象可以使用 delete 删除（使用var 定义的无法使用delete删除）。或许你已经明白了，但是代码种东西，还是自己动动手，印象更深刻。</p>
<h2 id="补充于2020年5月12日"><a href="#补充于2020年5月12日" class="headerlink" title="补充于2020年5月12日"></a>补充于2020年5月12日</h2><p>因为我们已经实现了 <code>bind</code>，所以之前的 <code>call</code> 和 <code>apply</code> 就可以直接使用 bind 来实现了。</p>
<p>new call</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> otherArgs = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'this.mybind(context)('</span> + otherArgs.join(<span class="string">','</span>) + <span class="string">')'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new apply</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arguments_1_length = <span class="built_in">arguments</span>[<span class="number">1</span>].length;</span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>[<span class="number">1</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The 2rd argument must be an Array. But get '</span> + type);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arguments_1_length; i++) &#123;</span><br><span class="line">    args.push(<span class="built_in">arguments</span>[<span class="number">1</span>][i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'this.myBind(context)('</span> + args.join(<span class="string">','</span>) + <span class="string">')'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>手写源码分析原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解析CSS样式优先级</title>
    <url>/%E6%8A%80%E6%9C%AF/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90CSS%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7.html</url>
    <content><![CDATA[<p>作为前端多多少少都会对CSS样式的权重有一定的了解。最常用的方法就是对不同的选择器分配不同的权重比，常见的就是</p>
<table>
<thead>
<tr>
<th style="text-align:center">选择器</th>
<th style="text-align:center">权重值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">!important标识</td>
<td style="text-align:center">10000</td>
</tr>
<tr>
<td style="text-align:center">行内样式</td>
<td style="text-align:center">1000</td>
</tr>
<tr>
<td style="text-align:center">id选择器</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">类选择器</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">标签选择器</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">通配符 *</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>具体的判断我们可以用一个矩阵来表示：(0, 0, 0, 0, 0)。那这里面的每一个矩阵的0表示的是</p>
<ul>
<li>第一个：<code>!important</code> 的个数</li>
<li>第二个：行内的个数</li>
<li>第三个：id选择器的个数</li>
<li>第四个：类选择器的个数</li>
<li>第五个：标签选择器的个数</li>
</ul>
<p>行内除了<code>!important</code>高于其他的样式。<strong>同时，这里的这个矩阵实际上是不存在的，是认为的构建出来的。</strong>因为<code>!important</code>始终最高，所以这里可以忽略第一个，最后矩阵为(0, 0, 0, 0)。</p>
<p>上面表格中是我们在写css样式的时候需要了解最的基本的知识，也是最为普通的选择器权重分配。权重值越高，权重越高，那么样式的优先级就越高。所以，<code>!important</code>的权重是最高的。正式因为这一点，所以<code>!important</code>在编写css样式的时候一般都不建议使用，因为使用了<code>!important</code>后，要想在修改样式，几乎是不可能的，即，样式会变得不好控制。</p>
<p>其次是行内样式。在现在前端开发中，为了更好的阅读代码，是代码调理更清晰，一般都会把CSS代码以及JS代码从HTML中分离，采用外链的方式引入CSS以及JS。所以，行内样式在一般的开发中，用的也不多。但是，在使用前端三大框架或者是需要使用JS来控制样式的时候，多多少少的都会涉及到把样式写在HTML元素行内的情况。</p>
<p>接着是ID选择器。在编写样式的时候，我们一般都不会使用ID选择器来控制样式，同时也不会在HTML文档中添加过多的ID选择器。ID选择器一般更多的是用于获取元素，而不是用来控制CSS样式。</p>
<p>再者是类选择器。这个在CSS样式的编写中用的算是最多的一种，因为一个标签可以添加多个类名，不像ID只能添加一个，编写不同的类名来控制不同的样式显示，同时根据权重来控制样式的覆盖。</p>
<p>然后是标签选择器，这个在开发中也是不建议使用，更多的是建议添加一个类名来控制，以实现复用，同时方便控制。</p>
<p>最后是通配符选择器，这个选择器的使用一般就是初始化文档结构。例如<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是更多的公司采取的是具有针对的样式重置，比如<a href="https://github.com/tal007/tools/blob/master/css/reset.css" target="_blank" rel="noopener">reset.css</a>。</p>
<p>以上就是常用的样式选择器以及他们的权重。</p>
<h2 id="主要选择器的权重比较"><a href="#主要选择器的权重比较" class="headerlink" title="主要选择器的权重比较"></a>主要选择器的权重比较</h2><p><strong>权重累加</strong></p>
<p>上面的权重值我们已经知道了，那么具体怎么来算呢？个人认为，需要记住一这点就OK了。<code>相同类型的权重值累加，然后在比较相同类型选择器的值</code>。举个🌰</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">class</span>=<span class="string">"box div"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，来看看这个div盒子的颜色应该是什么呢？分析一下CSS样式：</p>
<p>根据上面的矩阵(0, 0, 0, 0)来分析。</p>
<p><code>#div</code>的矩阵为(0, 0, 1, 0, 0)，最后的权重值为：1*100 = 100。</p>
<p><code>div.div</code>的矩阵为(0, 0, 0, 1, 1)，最后的权重值为：1 <em> 10 + 1 </em>1 = 11。</p>
<p>所以最后的样式显示 <code>background: green;</code></p>
<p>有了这样的结论，我这里又做了一个测试。有下面的一段html代码与样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box4"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box5"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box6"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box7"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box8"</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box9"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box10"</span> <span class="attr">class</span>=<span class="string">"box10"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#box10</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.box1</span> <span class="selector-class">.box2</span> <span class="selector-class">.box3</span> <span class="selector-class">.box4</span> <span class="selector-class">.box5</span> <span class="selector-class">.box6</span> <span class="selector-class">.box7</span> <span class="selector-class">.box8</span> <span class="selector-class">.box9</span> <span class="selector-class">.box10</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按理说 <code>#box10</code> 的权重为 100 * 1 = 100</p>
<p><code>.box .box1 .box2 .box3 .box4 .box5 .box6 .box7 .box8 .box9 .box10</code> 的权重为 10 * 11 = 110</p>
<p>下面使用多个类的权重值理论上是高于上面只使用一个id选择器的情况，但是最后的结构却不是我们想象的那样。结果还是 <span style="color: green;">green</span> 。没错，后面的11个类的样式无效。经过这样的测试，我们可以猜想，在一个元素使用了ID选择器修饰了样式以后，如果在使用类选择器，这时候是是没有办法使相同的样式属性生效，生效的依然是那个ID选择器修饰的样式。为什么权重值大也没有用呢？我猜或许是因为写了太多类名的时候再和ID相比的话，浏览器会自己去判断，选择最优的那个，毕竟10多个类名在实际的开发中是不存在的。在张鑫旭大神的<a href="https://www.zhangxinxu.com/wordpress/2012/08/256-class-selector-beat-id-selector/" target="_blank" rel="noopener">有趣：256个class选择器可以干掉1个id选择器</a>有一个实验，但是这个实验室在2012年的时候，那个时候，还是使用的IE浏览器能够呈现出来。但是现在大部分的浏览器都不能够呈现出256个class干掉一个id的情况了。同时，也证明了，上面我们定义的矩阵(0, 0, 0, 0)其实并不严谨，id与class之前的差距我们这里以10作为一个标准，但是实际上可能达到100，或者1000。即1000个class干掉一个ID。但是由于现代编码一般要求class的层级书写的时候不要超过四层，所以，目前这个问题也就没有什么意义了。</p>
<p>因此，上面的矩阵也可以作为我们判断的标准。</p>
<h2 id="其他类型选择器的权重比较"><a href="#其他类型选择器的权重比较" class="headerlink" title="其他类型选择器的权重比较"></a>其他类型选择器的权重比较</h2><p>上面说了几种常用的选择器了，但是还有一些选择器也是在开发中会出现，但是不是太常用的一些选择器。那么，有哪些呢？</p>
<p>w3c中样式选择器的权重优先级的排序如下</p>
<blockquote>
<p>important &gt; 内嵌样式 &gt; ID &gt; 类 | 伪类 | 属性选择  &gt; 标签 | 伪元素 &gt; 伪对象 &gt; 继承 &gt; 通配符 | 子选择器 | 相邻选择器</p>
</blockquote>
<ul>
<li>伪类选择器，如<code>:hover</code></li>
<li>属性选择器，如<code>[type=&quot;text&quot;]</code></li>
<li>伪元素选择器，如<code>::first-letter</code></li>
<li>子选择器<code>&gt;</code>，相邻兄弟选择器<code>+</code>等等</li>
</ul>
<h3 id="伪类的优先级"><a href="#伪类的优先级" class="headerlink" title="伪类的优先级(:)"></a>伪类的优先级(:)</h3><p>首先来看看伪类选择器的优先级。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    div &#123;</span></span><br><span class="line"><span class="undefined">      margin-top: 10px;</span></span><br><span class="line"><span class="undefined">      height: 100px;</span></span><br><span class="line"><span class="undefined">      width: 100px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="undefined">      background: lime;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="undefined">      background: pink;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="undefined">      background: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码在<a href="https://codepen.io/Anthony-Wilson/pen/ZEzOeLW" target="_blank" rel="noopener">codePen</a>中的具体效果，可以看到</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/伪类与类的优先级.gif" alt="伪类与类的优先级"></p>
<p>当将鼠标分别移动到两个div盒子上面的时候，前面的绿色盒子的背景色会发生变化，而红色盒子不会。但是，都是 <code>:hover</code> 的一盒伪类。所以判定，<strong>伪类的权重与类的权重是相同的</strong>。</p>
<h3 id="属性选择器的优先级"><a href="#属性选择器的优先级" class="headerlink" title="属性选择器的优先级"></a>属性选择器的优先级</h3><p>同样是上面的代码，我们把样式改为<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[class="box1"]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: lime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[class="box2"]</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: purple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>唯一不同的就是样式中添加了属性选择器<code>[class=&quot;box1&quot;]</code>与<code>[class=&quot;box2&quot;]</code>。同时顺序发生了改变。</p>
<p>代码可看[<a href="https://codepen.io/Anthony-Wilson/pen/YzKWZpL]https://codepen.io/Anthony-Wilson/pen/YzKWZpL" target="_blank" rel="noopener">https://codepen.io/Anthony-Wilson/pen/YzKWZpL]https://codepen.io/Anthony-Wilson/pen/YzKWZpL</a></p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/伪类，类与属性选择器的优先级.gif" alt="伪类，类与属性选择器的优先级">。</p>
<p>所以，<strong>属性选择的权重 = 类的权重 = 伪类的权重</strong>。三者是相等的，都是(0, 0, 1, 0);</p>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器(::)"></a>伪元素选择器(::)</h3><p>伪元素作为一种特殊的存在，我认为它不应该放在优先级里面同其他的选择器相比。比如 <code>::before</code> 和 <code>::after</code> 这两种伪元素都是在文档中添加一个假的元素，并不能够设置 id class 等属性。所以这里可以把它作为一个唯一的存在。那么他的权重我们可以看为1。同时没有和他比较的。</p>
<h3 id="子选择器-gt-，相邻兄弟选择器"><a href="#子选择器-gt-，相邻兄弟选择器" class="headerlink" title="子选择器&gt;，相邻兄弟选择器+"></a>子选择器<code>&gt;</code>，相邻兄弟选择器<code>+</code></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.box1</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="undefined">      color: yellow;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &gt; <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="undefined">      color: blue;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box2</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="undefined">      color: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box1"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>我<span class="tag">&lt;/<span class="name">span</span>&gt;</span>是一个盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box2"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>我<span class="tag">&lt;/<span class="name">span</span>&gt;</span>是一个盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的例子在codePen中的<a href="https://codepen.io/Anthony-Wilson/pen/pozbPgP" target="_blank" rel="noopener">运行结果</a></p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190817170254.png" alt="运行结果"></p>
<p>可以看到，第一个我是蓝色，第二个我是红色。结合上面的代码，可以看出来子元素选择器和普通的空格其实没有太多的区别，同理兄弟选择器其实也是一样的。遇到这种情况，直接比较 class 与 标签的个数就可以了。即同基本的权重判断是相同的。</p>
<h2 id="结果总结"><a href="#结果总结" class="headerlink" title="结果总结"></a>结果总结</h2><p>经过上面的推想测试，可以大致的得出一个优先级的结论：</p>
<blockquote>
<p>!important &gt; ID &gt; class = 属性 = 伪类 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器自带属性</p>
</blockquote>
<p>在使用选择器的时候尽可能的选择使用 class选择器或者属性选择器（针对于input这一类）来对元素设置样式。一个是使用class可以复用，第二个可以更好的控制元素样式。同时，关于class命名的规范建议使用<a href="https://www.cnblogs.com/imwtr/p/8521031.html" target="_blank" rel="noopener">BEM</a>命名规范。</p>
<h2 id="补充：2019年08月22日"><a href="#补充：2019年08月22日" class="headerlink" title="补充：2019年08月22日"></a>补充：2019年08月22日</h2><p>在网上看到这样的一道题</p>
<p>问题：已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。</p>
<blockquote>
<p>&lt;img src=”1.jpg” style=”width:480px!important;”&gt;</p>
</blockquote>
<p>期初看到这段代码一下子就想到这都 <code>!important</code> 了还有办法限制它的宽度？真的是被无知限制了想象力。</p>
<p>这里提供几种方法实现修改宽度：</p>
<h3 id="1、使用max-width"><a href="#1、使用max-width" class="headerlink" title="1、使用max-width"></a>1、使用max-width</h3><p>虽然使用了 <code>important</code> ，但是也只是添加到了 <code>width</code> 属性上面，并不影响 max-width 。所以这里设置了 max-width 即可生效。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、使用-transform-scale"><a href="#2、使用-transform-scale" class="headerlink" title="2、使用 transform:scale"></a>2、使用 transform:scale</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(0.625);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、使用-zoom"><a href="#3、使用-zoom" class="headerlink" title="3、使用 zoom"></a>3、使用 zoom</h3><p>这个和CSS3的缩放是一样的效果</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">0.625</span>：</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、使用-js"><a href="#4、使用-js" class="headerlink" title="4、使用 js"></a>4、使用 js</h3><p>这个和CSS3的缩放是一样的效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>)[<span class="number">0</span>].setAttribute(<span class="string">"style"</span>,<span class="string">"width:300px!important;"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5、使用弹性盒模型"><a href="#5、使用弹性盒模型" class="headerlink" title="5、使用弹性盒模型"></a>5、使用弹性盒模型</h3><p>这个和CSS3的缩放是一样的效果</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">90px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6、使用animation"><a href="#6、使用animation" class="headerlink" title="6、使用animation"></a>6、使用animation</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: width <span class="number">0s</span> forwards;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> width &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用socket实现即时通讯聊天室</title>
    <url>/%E6%8A%80%E6%9C%AF/%E4%BD%BF%E7%94%A8socket%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E8%81%8A%E5%A4%A9%E5%AE%A4.html</url>
    <content><![CDATA[<p>websocket早在几年前就已经很流行了，主要就是用于即时通讯这一方面应用，可以是聊天，也可使是直播流传输等等。</p>
<p>今天，就来说说如何使用 create-react-app + socket.io 实现简单的即时聊天。</p>
<p><a href="http://118.24.6.33:2000" target="_blank" rel="noopener">Demo地址</a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>想要实现即时通讯，还是需要有服务器的支持，这里我使用的是一个简单配置的服务器</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190806095919.png" alt="服务器配置"></p>
<p>还是去年腾讯搞活动买的，还不错，有机会你们也可以去看看。阿里云腾讯云都会时不时的出一些活动，买一个服务器自己玩玩还是可以的。如果有活动，我可以在后面不断更新。</p>
<p>有了服务器以后就是敲代码了。</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190806100242.png" alt="大爷，咋又是你啊"></p>
<h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>服务端我这里使用的是Nodejs作为后端语言，使用express+socket.io作为技术支持，具体的代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>).createServer(app)</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(http);</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/dist'</span>))</span><br><span class="line">app.get(<span class="string">"/"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>); </span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type, Content-Length, Authorization, Accept, X-Requested-With'</span>);</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT, POST, GET, DELETE, OPTIONS'</span>);</span><br><span class="line">  <span class="comment">// res.send(`&lt;h1&gt;Hello World!!!&lt;/h1&gt;`)</span></span><br><span class="line">  res.send(__dirname + <span class="string">'/dist/index.html'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userList = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> userCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> messageList = []</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">"connection"</span>, socket =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  socket.on(<span class="string">"login"</span>, data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;data.username&#125;</span> 登录`</span>);</span><br><span class="line">    socket.uid = data.uid</span><br><span class="line">    userList[data.uid] = data.username</span><br><span class="line">    userCount++</span><br><span class="line"></span><br><span class="line">    io.emit(<span class="string">'users'</span>, &#123;</span><br><span class="line">      userCount,</span><br><span class="line">      userList</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发给自己</span></span><br><span class="line">    socket.emit(<span class="string">"receive_message"</span>, messageList)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  socket.on(<span class="string">"disconnect"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !socket.uid ) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> user = &#123;</span><br><span class="line">      uid: socket.uid,</span><br><span class="line">      username: userList[socket.uid]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> userList[socket.uid]</span><br><span class="line">    userCount--</span><br><span class="line">    <span class="comment">// 发送给所有用户 使用 io.emit  </span></span><br><span class="line">    <span class="comment">// 发送给自己 使用 socket.emit</span></span><br><span class="line">    io.emit(<span class="string">'users'</span>, &#123;</span><br><span class="line">      userCount,</span><br><span class="line">      userList</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;user.username&#125;</span> 登出了`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  socket.on(<span class="string">"message"</span>, data =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !data ) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// console.log(`发送信息 -- $&#123;data&#125;`);</span></span><br><span class="line">    messageList.push(&#123;</span><br><span class="line">      username: userList[socket.uid],</span><br><span class="line">      message: data</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>( messageList.length &gt; <span class="number">30</span> )&#123;</span><br><span class="line">      messageList.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送给除了自己以外的其他所有用户</span></span><br><span class="line">    <span class="comment">// socket.broadcast.emit("receive_message", messageList)</span></span><br><span class="line">    io.emit(<span class="string">"receive_message"</span>, messageList)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.listen(<span class="number">2000</span>, _ =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'This server is running: http://localhost:2000'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>静态的文件是使用 create-react-app 开发的页面，build之后放到了服务器上面dist目录下面。</p>
<p>要使用socket.io，首先需要创建socket服务<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(http);</span><br></pre></td></tr></table></figure></p>
<p>接下来就是连接服务端与客户端了。服务端如果想要连接到客户端的用户，那么就需要有方法一直监听到客户端用户访问网站的方法。socket.io中就为我们提供了一个 <code>connection</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">io.on(<span class="string">"connection"</span>, socket =&gt; &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>connection</code> 之后所有的操作都是写在这个 <strong>connection</strong> 的监听之中。</p>
<p>上面的 connection 中的代码需要注意的有几点，知道了这几点，那么socket.io对你就不是难事</p>
<ol>
<li><code>io.on(&#39;监听事件名字&#39;, () =&gt; {})</code>方法是监听所有的用户。</li>
<li><code>connection</code>方法中的 <code>socket</code> 值得是当前用户，所以<code>socket.on(&#39;监听事件名字&#39;, () =&gt; {})</code>是监听当前用户的操作。</li>
<li><code>io.emit(&#39;监听事件名字&#39;, 参数)</code>是发送消息给客户端，此时客户端会有一个监听的事件，监听事件名字服务端需要与客户端相同。</li>
<li><code>socket.broadcast.emit(&quot;监听事件名字&quot;, 参数)</code> 这个方法可以发送消息给除了自已以外的其他的所有的用户。</li>
</ol>
<p>客户端与服务端一样。</p>
<p>记住以上四点秘诀，玩转socket不是梦。</p>
<h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>客户端使用create-react-app写的页面实现，下面贴出逻辑，就不放样式了</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"><span class="keyword">import</span> io <span class="keyword">from</span> <span class="string">'socket.io-client'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Input, Button, Avatar, message &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = io(<span class="string">'http://118.24.6.33:2000'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      showLogin: <span class="literal">true</span>,</span><br><span class="line">      users: &#123;</span><br><span class="line">        userCount: <span class="number">0</span>,</span><br><span class="line">        userList: &#123;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      messageList: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> username = <span class="keyword">this</span>.refs.input.input.value.trim()</span><br><span class="line">    <span class="keyword">const</span> &#123; userList &#125; = <span class="keyword">this</span>.state.users</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( username.length )&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> userList) &#123;</span><br><span class="line">        <span class="keyword">if</span>( userList[k] === username )&#123;</span><br><span class="line">          message.info(<span class="string">"聊天室已经有这个用户了，请重新起一个名字"</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>.uid = <span class="keyword">this</span>.get_uid()</span><br><span class="line">      socket.emit(<span class="string">"login"</span>, &#123;</span><br><span class="line">        username,</span><br><span class="line">        uid: <span class="keyword">this</span>.uid</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        showLogin: <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      message.info(<span class="string">"请输入一个用户名！！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get_uid = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&#125;</span><span class="subst">$&#123;<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">89999</span>)&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.message = <span class="keyword">this</span>.refs.message.input.value</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.message.trim().length === <span class="number">0</span>) &#123;</span><br><span class="line">      message.info(<span class="string">"你还啥子都还没有输入就行发送了嘛"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&#125;</span><span class="subst">$&#123;<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">9999</span>)&#125;</span>`</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">      message: <span class="keyword">this</span>.message.trim(),</span><br><span class="line">      uid: <span class="keyword">this</span>.uid,</span><br><span class="line">      id</span><br><span class="line">    &#125;</span><br><span class="line">    socket.emit(<span class="string">'message'</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ant design 中清空输入的内容</span></span><br><span class="line">    <span class="keyword">this</span>.refs.message.state.value = <span class="string">''</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">this</span>.refs.messages.scrollBy(<span class="number">0</span>, <span class="number">999999</span>), <span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    socket.on(<span class="string">"users"</span>, data =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">users</span>: data&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">"receive_message"</span>, data =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">messageList</span>: data&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; showLogin, users, messageList &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> &#123; userCount, userList &#125; = users</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (showLogin) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">          &lt;Input placeholder=<span class="string">"输入一个名字撒"</span> allowClear ref=<span class="string">'input'</span> onPressEnter=&#123;<span class="keyword">this</span>.login&#125;/&gt;</span><br><span class="line">          &lt;Button onClick=&#123;<span class="keyword">this</span>.login&#125; className=<span class="string">"login"</span>&gt;登录&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"room"</span>&gt;</span><br><span class="line">          &lt;div className=<span class="string">'inner'</span>&gt;</span><br><span class="line">            &lt;header&gt;欢迎来到踏浪聊天室，当前聊天室共&#123;userCount&#125;人&lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div className="content"&gt;</span></span><br><span class="line"><span class="regexp">              &lt;ul className="user-list"&gt;</span></span><br><span class="line"><span class="regexp">                &#123;</span></span><br><span class="line"><span class="regexp">                  Object.entries(userList).map(v =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                    return &lt;li</span></span><br><span class="line"><span class="regexp">                      className="user-list-item"</span></span><br><span class="line"><span class="regexp">                      key=&#123;v[0]&#125;</span></span><br><span class="line"><span class="regexp">                    &gt;</span></span><br><span class="line"><span class="regexp">                      &lt;Avatar style=&#123;&#123; color: '#f56a00', backgroundColor: '#fde3cf' &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">                        &#123;v[1].substring(0, 2)&#125;</span></span><br><span class="line"><span class="regexp">                      &lt;/</span>Avatar&gt;</span><br><span class="line">                      &#123;v[<span class="number">1</span>]&#125;</span><br><span class="line">                    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                  &#125;)</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">              &lt;/u</span>l&gt;</span><br><span class="line">              </span><br><span class="line">              &lt;ul className=<span class="string">"message-list"</span> ref=<span class="string">"messages"</span>&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                  messageList.map(<span class="function"><span class="params">v</span> =&gt;</span> &lt;li</span><br><span class="line">                    key=&#123;v.message.id&#125;</span><br><span class="line">                    className=&#123;v.message.uid === <span class="keyword">this</span>.uid ? <span class="string">"message-list-item me"</span> : <span class="string">"message-list-item"</span>&#125;</span><br><span class="line">                  &gt;</span><br><span class="line">                    &#123;v.message.uid === <span class="keyword">this</span>.uid &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"message-content"</span>&gt;</span>&#123;v.message.message&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">                    &lt;Avatar style=&#123;&#123; <span class="attr">color</span>: <span class="string">'#f56a00'</span>, <span class="attr">backgroundColor</span>: <span class="string">'#fde3cf'</span> &#125;&#125;&gt;</span><br><span class="line">                      &#123;v.username &amp;&amp; v.username.substring(<span class="number">0</span>, <span class="number">2</span>)&#125;</span><br><span class="line">                    &lt;<span class="regexp">/Avatar&gt;</span></span><br><span class="line"><span class="regexp">                    &#123;v.message.uid !== this.uid &amp;&amp; &lt;span className="message-content"&gt;&#123;v.message.message&#125;&lt;/</span>span&gt;&#125;</span><br><span class="line">                  &lt;<span class="regexp">/li&gt;)</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">              &lt;/u</span>l&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;footer&gt;</span></span><br><span class="line"><span class="regexp">              &lt;Input</span></span><br><span class="line"><span class="regexp">                placeholder="请输入消息"</span></span><br><span class="line"><span class="regexp">                ref='message'</span></span><br><span class="line"><span class="regexp">                onPressEnter=&#123;this.send&#125;</span></span><br><span class="line"><span class="regexp">              /</span>&gt;</span><br><span class="line">              &lt;Button className=<span class="string">"send"</span> onClick=&#123;<span class="keyword">this</span>.send&#125;&gt;发送&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>footer&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>
<p>客户端可是使用的socket.io。不过使用的是专门为客户端提供的<code>socket.io-client</code>。客户端首先需要连接到服务器，通过 <code>const socket = io(&#39;http://118.24.6.33:2000&#39;);</code> 就可以创建一个与服务端链接的 socket 请求。</p>
<p>接下来就是在 <code>componentDidMount</code> 中编写监听事件，同时 <code>socket.on()</code> 实现监听。</p>
<p>在事件中使用 <code>socket.emit()</code> 实现向后端发送消息。</p>
<p>整的逻辑的实现就是如此，摸清逻辑，后面的就不难了。</p>
<p>上面只是使用可socket.io的一些简单的API，关于更多的方法可以前往<a href="https://socket.io/docs/" target="_blank" rel="noopener">socket.io官网</a></p>
<p>最后，可以前往github查看<a href="https://github.com/tal007/socket_chat" target="_blank" rel="noopener">源码</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>websocket</tag>
        <tag>即时通讯</tag>
      </tags>
  </entry>
  <entry>
    <title>递归与尾递归</title>
    <url>/%E6%8A%80%E6%9C%AF/%E9%80%92%E5%BD%92%E4%B8%8E%E5%B0%BE%E9%80%92%E5%BD%92.html</url>
    <content><![CDATA[<p>在介绍递归与尾递归之前，我们来看看递归的定义：<strong>程序调用自身的编程技巧称为递归（ recursion）</strong></p>
<p>百度对递归的定义：<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92/1740695" target="_blank" rel="noopener">递归</a></p>
<p>接着，我们再来看看一道题</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">编写一个函数fn，接收一个或者多个参数，其中一个参数为n，若 n=<span class="number">0</span> 或者 n=<span class="number">1</span>，函数返回 <span class="number">1</span>， 否则函数返回 <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+...+(n<span class="number">-1</span>)+n 的总和</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>按照我们一般的思维，很快就能想到使用递归函数来解决这个问题，所以来看看递归是怎么解决的呢</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>( n === <span class="number">0</span> || n === <span class="number">1</span> )&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> n + fn(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 n=5 那么上面的函数运行流程</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">n = <span class="number">5</span> ==&gt; <span class="number">5</span> + fn(<span class="number">5</span> - <span class="number">1</span>)</span><br><span class="line">n = <span class="number">4</span> ==&gt; <span class="number">5</span> + <span class="number">4</span> + fn(<span class="number">4</span> - <span class="number">1</span>)</span><br><span class="line">n = <span class="number">3</span> ==&gt; <span class="number">5</span> + <span class="number">4</span> + <span class="number">3</span> + fn(<span class="number">3</span> - <span class="number">1</span>)</span><br><span class="line">n = <span class="number">2</span> ==&gt; <span class="number">5</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">2</span> + fn(<span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">n = <span class="number">1</span> ==&gt; <span class="number">5</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>即：最后的结果是 <code>5 + 4 + 3 + 2 + 1 = 15</code></p>
<p>可以看到，一般的递归，每一级递归都需要调用函数，同时这个函数还与其他的表达式运算，那这样的递归每一次都会创建新的栈。</p>
<p>随着递归深度的增加，创建的栈越来越多，最终造成爆栈</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/boom.jpeg" alt="boom"></p>
<p>所以，递归虽然可以解决很多问题，但是也需要注意一下使用限制。</p>
<p>#尾递归<br>如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。</p>
<p>百度定义：<a href="https://baike.baidu.com/item/%E5%B0%BE%E9%80%92%E5%BD%92/554682?fr=aladdin" target="_blank" rel="noopener">尾递归</a></p>
<p>尾递归基于函数的尾调用（尾调用：返回一个函数并且调用这个函数）, <code>每一级调用直接返回函数的返回值更新调用栈,而不用创建新的调用栈, 类似迭代的实现, 时间和空间上均优化了一般递归!</code></p>
<p>同样的问题，使用尾递归的来看看</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n, total = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n === <span class="number">1</span> || n === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn(n <span class="number">-1</span>, total + n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是 n=5，来看看运行过程</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">n = <span class="number">5</span> ==&gt; fn(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">n = <span class="number">4</span> ==&gt; fn(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">n = <span class="number">3</span> ==&gt; fn(<span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">n = <span class="number">2</span> ==&gt; fn(<span class="number">2</span>, <span class="number">13</span>)</span><br><span class="line">n = <span class="number">1</span> ==&gt; fn(<span class="number">1</span>, <span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<p>上面的运行每一次都是返回的一个单独的函数，没有其他的表达式与这个函数的结果运行，每一级递归的函数调用变成”线性”的形式。</p>
<p>上面就是关于一般递归与尾递归的说明。但是这里存在一个很大的问题，<strong>那就是JavaScript的 V8引擎 对尾递归的优化做的并不好，上面的代码尾递归还不如一般的递归</strong>。虽然在JavaScript中无法运行，但是其他的语言例如Java，C，C++等，使用尾递归的好处多余一般递归。</p>
<h2 id="手动优化"><a href="#手动优化" class="headerlink" title="手动优化"></a>手动优化</h2><p>既然我们在JavaScript中无法使用尾递归，使用递归也害怕爆栈，那我们可以自己来一些方法实现相同的效果，例如上面的多个值相加</p>
<h3 id="方案一：修改函数内部，使用循环"><a href="#方案一：修改函数内部，使用循环" class="headerlink" title="方案一：修改函数内部，使用循环"></a>方案一：修改函数内部，使用循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n 是 正整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n, a=<span class="number">0</span>, b=<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    [a, b] = [b, a + b]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法采用了<a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">ES6中</a>的<a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">解构赋值</a>。如果你不了解结构复制，可以去看看，如果你了解结构复制，那么上面的你就很容易理解了。</p>
<p>其实这种优化方法就是支持尾递归运行的这些引擎对相应语言的优化，使用循环优化，只是JavaScript V8 中没有相应的优化。说白了，就是想Java等语言已经有人帮你做了这一步。</p>
<h3 id="方案二：蹦床函数"><a href="#方案二：蹦床函数" class="headerlink" title="方案二：蹦床函数"></a>方案二：蹦床函数</h3><p>这是上面的尾递归的变形</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾递归代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n, total = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n === <span class="number">1</span> || n === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn(n <span class="number">-1</span>, total + n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们来求一下 n=3 的时候的值，如果是使用尾递归，那么 <code>n = 3 ==&gt; 6</code></p>
<p>首先来了解一下什么是蹦床函数，先来看一段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n, total = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n === <span class="number">1</span> || n === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(n <span class="number">-1</span>, total + n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是 n=3</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n = 3</span></span><br><span class="line">fn(<span class="number">3</span>) ==&gt; <span class="built_in">Function</span></span><br><span class="line">fn(<span class="number">3</span>)() ==&gt; <span class="built_in">Function</span></span><br><span class="line">fn(<span class="number">3</span>)()() ==&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>从上面可以看到，如果 n 不是3而是一个很大的数字，那么我们就需要调用很多次函数调用来实现。为了简便，我们可以把这种调用形式写成函数，这样的函数就是<strong>蹦床函数</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 蹦床函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">func, n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = func.call(func, n)</span><br><span class="line">  <span class="keyword">while</span> ( <span class="keyword">typeof</span> result === <span class="string">'function'</span> )&#123;</span><br><span class="line">    result = result()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个蹦床函数有两个参数，第一个参数是一个函数，即我们需要实现逻辑的函数，本例中就是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n, total = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n === <span class="number">1</span> || n === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(n <span class="number">-1</span>, total + n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用蹦床函数代码耗时相对较长。</p>
<p>以上就是关于递归与尾递归的说明以及优化，当然，如果你要更好的方案，欢迎在评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>递归</tag>
        <tag>尾递归</tag>
      </tags>
  </entry>
  <entry>
    <title>switch...case与if...else执行能力分析</title>
    <url>/%E6%8A%80%E6%9C%AF/switch-case%E4%B8%8Eif-else%E6%89%A7%E8%A1%8C%E8%83%BD%E5%8A%9B%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<p><code>switch...case</code>与<code>if...else</code>作为条件判断语句在程序中用的是非常多的。</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>基本用法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="keyword">switch</span>( 条件表达式 )&#123;</span><br><span class="line">  <span class="keyword">case</span> a:</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> b:</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> c:</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if else</span></span><br><span class="line"><span class="keyword">if</span> ( 条件表达式<span class="number">1</span> ) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( 条件表达式<span class="number">2</span> ) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( 条件表达式 <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了写法上的差异，两者在执行上面也是不同的。使用<code>switch</code>进行判断，执行的时间可能会更短，但是所消耗的空间会更多。</p>
<p>switch语句根据一个整数索引值进行多重分支，底层采用跳转表这种数据结构。跳转表是一个数组，表项 i 对应代码段的地址，当switch索引值等于表项i时采取对应的程序操作。</p>
<p>简单可理解为：执行switch时生成一个长度为最大case常量＋1的数组，程序首先判断switch变量是否大于最大case 常量，若大于，则跳到default分支处理；否则取得数组索引号为switch变量值大小，取得数组对应值即为相应case代码块地址，程序接着跳到此地址执行，完成分支的跳转。</p>
<p>所以，switch语句的执行速度相对于if语句执行速度会更快。但是因为switch会生成一个临时的数组，所以，占用的内存可能会更大。</p>
<p>对于if语句，则是系统自上而下的按照条件逐个去判断，知道匹配到合适的条件，否则会执行完整个if语句，所以执行的时间可能会很长，速断会更慢。因此，也得出，在编写代码的时候，需要将几率大的条件置于条件判断的最前面。</p>
<p>但是，switch在对于非常量的情况下面是无能为力的，比如 <code>if(x &gt; 1 &amp;&amp; x &lt; 100)</code> 这样的条件，使用switch是无法处理的，case语句不支持一个判断类型的表达式。但是，if语句就对这个就毫无压力。</p>
<p>所以，在只是处理常量的时候，推荐使用 switch 语句判断，如果涉及到了表达式，那么推荐使用 if…else 语句进行判断。</p>
<p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=2ijs33h17bi8k" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=2ijs33h17bi8k</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript中的单线程运行，宏任务与微任务，EventLoop</title>
    <url>/%E6%8A%80%E6%9C%AF/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C.html</url>
    <content><![CDATA[<p>在前端的面试中经常会问到关于代码执行顺序的问题，尤其是下面的一段代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">5</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>问题是</strong>：在浏览器上面 1 2 3 4 5 的打印的顺序。</p>
<p>上面这个问题看起来对有的同学可能很简单，到有的同学可能会比较复杂。对你不管是复杂还是简单，这其中涉及到的只是点都是一样的。JavaScript单线程，宏任务与微任务，EventLoop。这些就是这个题目的考点，理解了这些，那么上面的这道题对你来说那就是信手拈来，游刃有余。</p>
<p>我猜你应该知道，JavaScript除了在浏览器环境中运行，还可以在Node环境中运行，虽说都是JavaScript代码，但是在这两种环境下面执行的结果是可能不一样的。所以，我们需要分两种情况来分析他们的EventLoop。</p>
<h1 id="什么是EventLoop"><a href="#什么是EventLoop" class="headerlink" title="什么是EventLoop"></a>什么是EventLoop</h1><p>EventLoop是一个执行模型，在不同的有不同的实现，浏览器和NodeJS基于不同的技术实现了各自的EventLoop。</p>
<ul>
<li>浏览器的EventLoop是在<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" target="_blank" rel="noopener">HTML5规范</a>中明确定义了的</li>
<li>NodeJS的EventLoop是基于<a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a>实现的。可以在<a href="http://docs.libuv.org/en/v1.x/" target="_blank" rel="noopener">libuv官网</a>和<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" target="_blank" rel="noopener">NodeJS官网</a>查看</li>
<li>libuv已经对NodeJS的EventLoop做出了实现，但是浏览器的HTML5规范只是定义了EventLoop的实现模型，具体的实现留给了浏览器厂商。</li>
</ul>
<h1 id="JavaScript中的单线程"><a href="#JavaScript中的单线程" class="headerlink" title="JavaScript中的单线程"></a>JavaScript中的单线程</h1><p>JavaScript是单线程脚本语言。所以，在一行代码的执行过程过，必然不会执行另一行代码的，就行你在使用了<code>alert(1)</code>以后在后面疯狂的<code>console.log()</code>，如果执行到 <code>alert(1)</code>，你没有关闭这个弹窗，后面的<code>console.log()</code>是永远都不会执行的，因为 <code>alert()</code> 这个任务还没有执行完成，下面的代码没法执行。通俗一点就是：如果你去食堂打饭，前面排了很长的队，如果你想要打到饭，那么你需要等前面的小可爱都能够顺利的打完饭才可以，你是不能够插队的。那什么是宏任务，什么又是微任务呢？</p>
<p>同样是打饭的例子，你要打饭这件事请就是宏任务。这是一个大的事件。当轮到你打饭的时候，事件执行到你这里了，这个时候阿姨开始给你打饭，后面的同学还在等待着。但是你去打饭不单单的就是打饭，你会询问每种菜是什么，价格是多少，有没有XXX菜，有没有汤一样，那这些询问可以比作是微任务。当你的宏任务与微任务都执行完成了，相当于你的这一轮时间执行完成，这个时候开始执行下一轮事件，也就是下一个同学开始打饭了。同样的，下面的一轮循环中也可能存在微任务。</p>
<p>通过上面的例子，如果能有大概的明白了什么是宏任务，什么是微任务了。</p>
<h1 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h1><p>macrotask，也叫 tasks，主要的工作如下</p>
<ul>
<li>创建主文档对象,解析HTML,执行主线或者全局的javascript的代码,更改url以及各种事件。</li>
<li>页面加载,输入，网络事件，定时器。从浏览器角度看，宏任务是一个个离散的，独立的工作单元。</li>
<li>运行完成后，浏览器可以继续其他调度，重新渲染页面的UI或者去执行垃圾回收</li>
</ul>
<p>一些异步任务的回调会以此进入 <code>macrotask queue(宏任务队列)</code>，等等后续被调用，这些异步函数包括：</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate (Node)</li>
<li>requestAnimationFrame (浏览器)</li>
<li>I/O</li>
<li>UI rendering (浏览器)</li>
</ul>
<h1 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h1><p>microtask，也叫 jobs，注意的工作如下</p>
<ul>
<li>微任务是更小的任务，微任务更新应用程序的状态，但是必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。</li>
<li>微任务包括Promise的回调函数，DOM发生变化等，微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。</li>
<li>微任务能使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使得应用状态不连续</li>
</ul>
<p>另一些异步回调会进入 <code>microtask queue(微任务队列)</code> ，等待后续被调用，这些异步函数包括：</p>
<ul>
<li>process.nextTick (Node)</li>
<li>Promise.then()</li>
<li>catch</li>
<li>finally</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<blockquote>
<p>这里有一点需要注意的：<code>Promise.then()</code> 与 <code>new Promise(() =&gt; {}).then()</code> 是不同的，前面的是一个微任务，后面的 <code>new Promise()</code> 这一部分是一个构造函数，这是一个同步任务，后面的 <code>.then()</code> 才是一个微任务，这一点是非常重要的。</p>
</blockquote>
<h1 id="浏览器中的EventLoop"><a href="#浏览器中的EventLoop" class="headerlink" title="浏览器中的EventLoop"></a>浏览器中的EventLoop</h1><p>关于宏任务与微任务我们看看下面的执行流程<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190820105509.png" alt="JavaScript EventLoop"></p>
<p>最开始有一个执行栈，当执行到带有异步操作的宏任务的时候，比如 setTimeout 的时候就会将这个异步任务存在背景线程里面，待本次的事件执行完成以后再去执行微任务。即图中 <code>Stack --&gt; Background Thread</code>。但是需要注意到，从 <code>Stack --&gt; Microtask Queue</code> 还有一条路线，意思就是在当前这轮的任务中还有执行微任务的操作。当前轮的微任务优先于宏任务异步操作先执行，执行完成到 <code>loop</code> 中，进入到下一轮。下一轮执行之前的宏任务的异步操作，比如 <code>setTimeout</code> 。此时，如果这个异步任务中还有微任务，那么就会执行完成这个微任务，在执行下一个异步任务。就这样一次的循环。</p>
<p>回到最开始的那道题上面<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">5</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>整个这一串代码我们所在的层级我们看做一个任务，其中我们先执行同步代码。第一行的 <code>setTimeout</code> 是异步代码，跳过，来到了 <code>new Promise(...)</code> 这一段代码。前面提到过，这种方式是一个构造函数，是一个同步代码，所以执行同步代码里面的函数，即 <code>console.log(1)</code>，接下来是一个 <code>then</code> 的异步，跳过。在往下，是一个<code>Promise.then()</code> 的异步，跳过。最后一个是一段同步代码 <code>console.log(2)</code>。所以，这一轮中我们知道打印了<code>1, 2</code>两个值。接下来进入下一步，即之前我们跳过的异步的代码。从上午下，第一个是 <code>setTimeout</code>，还有两个是 <code>Promise.then()</code>。<code>setTimeout</code> 是宏任务的异步，<code>Promise.then()</code>是微任务的异步，微任务是优先于宏任务执行的，所以，此时会先跳过 <code>setTimeout</code> 任务，执行两个 <code>Promise.then()</code> 的微任务。所以此时会执行 <code>console.log(3)</code> 和 <code>console.log(5)</code> 两个函数。最后就只剩下 <code>setTimeout</code> 函数没有执行，所以最后执行 <code>console.log(4)</code>。</p>
<p>综上：最后的执行结果是 <code>1, 2, 3, 5, 4</code>。</p>
<p>这只是我们的推测的结果，我们来看看在浏览器中的实际的打印结果是什么？<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190710152407.png" alt="浏览器中的执行结果"></p>
<p>从图中可以看到，实际的运行结果与我们推测的结果是一一致的。所以，我们上面的分析步骤是正确的。</p>
<p>但是有一个问题，什么呢？可以看到，在浏览器中，会有一个 <code>undefined</code> 的返回值。为什么呢？这是因为浏览器将上面的一整段代码当成一个函数，而这个函数<strong>执行完成</strong>以后返回了 <code>undefined</code>。那么？这就完了吗？没有。我们看看浏览器返回的截图中，<code>3,5</code> 两个数字其实是在 <code>undefined</code> 前面。<code>3,5</code>两个数是两个 <code>Promise.then()</code> 中的 <code>console.log()</code> 的打印值，而 <code>undefined</code> 在这里可以作为一轮任务的结束。这表明的意思就是，<strong>微任务会在下一轮任务开始前执行</strong>。</p>
<p>这一切都是针对于浏览器的EventLoop。在NodeJS的环境中，可能就会有不同的结果。至于结果如何，我们暂时先不讨论，在来看一段代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">6</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">6</span>))</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">5</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>在浏览器中执行结果：<button id="evnetloop-btn">点击查看</button></p>
<p><div id="evnetloop-result"></div></p>
<script>
  var eventloopBtn = document.getElementById("evnetloop-btn");
  var eventloopResult = document.getElementById("evnetloop-result");
  eventloopBtn.addEventListener("click", () => {
    eventloopResult.innerHTML = "1，2，3，5，4，7，8，6，9"
  })
</script>

<p>上面就是关于在浏览器中的EventLoop。附上浏览器上面的<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly" target="_blank" rel="noopener">可视化操作</a></p>
<h1 id="NodeJS中的EventLoop"><a href="#NodeJS中的EventLoop" class="headerlink" title="NodeJS中的EventLoop"></a>NodeJS中的EventLoop</h1><p>虽然NodeJS中的JavaScript运行环境也是V8，也是单线程，但是，还是有一些与浏览器中的表现是不一样的。<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190710160659.png" alt="NodeJS中的EventLoop"></p>
<p>上面的图片的上半部分来自<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" target="_blank" rel="noopener">NodeJS官网</a>。下面的图片来自互联网。</p>
<p>同样的两段代码，我们在node环境中执行一下，看看结果。<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190710155941.png" alt="第一段代码的运行结构"></p>
<p>从上面的图中可以看到，实际的运行结果与浏览器中的运行结果并无二致。</p>
<p>在来看看另一段代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">6</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">6</span>))</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">5</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>他的执行结果是：<code>1，2，3，5，4，8，7，6，9</code>。<br>与浏览器的<code>1，2，3，5，4，7，8，6，9</code>不同。</p>
<h2 id="对比浏览器与NodeJS的不同"><a href="#对比浏览器与NodeJS的不同" class="headerlink" title="对比浏览器与NodeJS的不同"></a>对比浏览器与NodeJS的不同</h2><p>在大部分情况下，浏览器与NodeJS的运行没有区别，唯一有区别的是在第二轮事件执行的时候，如果有多个宏任务(<code>setTimeout</code>)，浏览器会依次的执行宏任务，<strong>上一个宏任务执行完成了在执行下一个宏任务</strong>。在NodeJS中，则是相当于并行执行，相当于把所有的宏任务组合到一个宏任务中，再在这个组合后宏任务中，依次执行<code>同步代码 --&gt; 微任务 --&gt; 宏任务</code>。</p>
<h2 id="NodeJS中的process-nextTick"><a href="#NodeJS中的process-nextTick" class="headerlink" title="NodeJS中的process.nextTick"></a>NodeJS中的process.nextTick</h2><p>关于 <code>process.nextTick</code>，就只需要记住一点，那就是 <strong><code>process.nextTick</code> 优先于其他的微任务执行</strong>。</p>
<p>所以，下面的代码中：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>分析（以Node作为运行环境，因为process在node中才存在）：</p>
<p>第一轮事件循环流程：</p>
<ul>
<li>整体的script代码作为第一个宏任务进入主线程，执行同步代码，遇到<code>console.log(1)</code>，输出 <code>1</code></li>
<li>遇到setTimeout，其回调函数被分发到宏任务的 Event Queue 中，等待执行。这里标记为<code>setTimeout1</code></li>
<li>遇到<code>process.nextTick</code>，其回调函数被分发到微任务的 Event Queue 中，等待执行。</li>
<li>遇到new Promise，这是一个构造函数，new Promise构造函数直接执行，遇到<code>console.log(7)</code>，输出 <code>7</code>。接着Promise.then()函数被分发到微任务的 Event Queue 中，等待执行。<br>遇到setTimeout，其回调函数被分发到宏任务的 Event Queue 中，等待执行。这里标记为<code>setTimeout2</code></li>
</ul>
<p>将上面的统计一下</p>
<table>
<thead>
<tr>
<th style="text-align:center">宏任务Event Queue</th>
<th style="text-align:center">微任务Event Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">setTimeout1</td>
<td style="text-align:center">process.nextTick</td>
</tr>
<tr>
<td style="text-align:center">setTimeout2</td>
<td style="text-align:center">Promise.then()</td>
</tr>
</tbody>
</table>
<p>第一轮事件循环同步代码执行完成，接下来<code>执行微任务</code>。</p>
<p>微任务有两个，一个是 <code>process.nextTick</code> ，里一个是 <code>Promise.then()</code>。</p>
<p>前面说了，<code>process.nextTick</code>优先于其他的微任务执行，所以</p>
<ul>
<li>执行process.nextTick：输出 <code>6</code></li>
<li>执行Promise.then()：输出 <code>8</code></li>
</ul>
<p>到此，第一轮事件循环结束，最终第一轮事件的输出为 <code>1,7,6,8</code>。开始执行第二轮事件循环（setTimeout）。</p>
<p>第二轮事件循环分析</p>
<ul>
<li>在 <code>setTimeout1</code> 与 <code>setTimeout2</code> 中先找同步代码</li>
<li>setTimeout1 中遇到 console.log(2),输出<code>2</code></li>
<li>setTimeout1 中遇到 process.nextTick，放在第二轮的微任务的Event Queue中，等待执行。这里标记为<code>process_1</code></li>
<li>setTimeout1 中遇到 new Promise ，执行同步代码，输出 <code>4</code>, Promise.then() 放到微任务的Event Queue中，等待执行。这里标记为<code>Promise_1</code></li>
<li>setTimeout2 中遇到 console.log(9),输出<code>9</code></li>
<li>setTimeout2 中遇到 process.nextTick，放在第二轮的微任务的Event Queue中，等待执行。这里标记为<code>process_2</code></li>
<li>setTimeout2 中遇到 new Promise ，执行同步代码，输出 <code>11</code>, Promise.then() 放到微任务的Event Queue中，等待执行。这里标记为<code>Promise_2</code></li>
</ul>
<p>第二轮的统计</p>
<table>
<thead>
<tr>
<th style="text-align:center">第二轮宏任务Event Queue</th>
<th style="text-align:center">第二轮微任务Event Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">process_1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">Promise_1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">process_2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">Promise_2</td>
</tr>
</tbody>
</table>
<p>第二轮没有事件循环中没有宏任务，有四个微任务。</p>
<p>四个微任务中，有两个 <code>process</code> </p>
<ul>
<li>依次执行 <code>process_1</code> 和 <code>process_2</code>。输出：<code>3, 10</code></li>
<li>一次执行 <code>Promise_1</code> 和 <code>Promise_2</code>。输出：<code>5, 12</code></li>
</ul>
<p>所以第二轮输出：<code>2，4，9，11，3，10，5，12</code></p>
<p>最终的输出为：<code>1，7，6，8，2，4，9，11，3，10，5，12</code>。</p>
<p>如果是在浏览器中，排除掉<code>process</code>的输出，结果为：<code>1，7，8，2，4，5，9，11，12</code></p>
<h2 id="NodeJS中-setImmediate-与-setTimeout-的区别"><a href="#NodeJS中-setImmediate-与-setTimeout-的区别" class="headerlink" title="NodeJS中 setImmediate 与 setTimeout 的区别"></a>NodeJS中 setImmediate 与 setTimeout 的区别</h2><p>在官方文档中的定义，<strong>setImmediate 为一次Event Loop执行完毕后调用。setTimeout 则是通过计算一个延迟时间后进行执行。</strong></p>
<p>但是同时还提到了如果在主进程中直接执行这两个操作，很难保证哪个会先触发。因为如果主进程中先注册了两个任务，然后执行的代码耗时超过XXs，而这时定时器已经处于可执行回调的状态了。所以会先执行定时器，而执行完定时器以后才是结束了一次Event Loop，这时才会执行setImmediate。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>))</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>))</span><br></pre></td></tr></table></figure>
<p>node环境下执行上面的代码，可以看到如下结果<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190710165932.png" alt="执行结构"></p>
<p>这两个console的结果是随机的。</p>
<p>我们可以通过一些处理，使得我们可以先执行 <code>setTimeout</code> 或者是 <code>setImmediate</code>。</p>
<p>但是如果后续添加一些代码以后，就可以保证setTimeout一定会在setImmediate之前触发了：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>))</span><br><span class="line">setImmediate(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> countdown = <span class="number">1e9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(countdonn--) &#123; &#125; <span class="comment">// 我们确保这个循环的执行速度会超过定时器的倒计时，导致这轮循环没有结束时，setTimeout已经可以执行回调了，所以会先执行`setTimeout`再结束这一轮循环，也就是说开始执行`setImmediate`</span></span><br></pre></td></tr></table></figure></p>
<p>如果在另一个宏任务中，必然是setImmediate先执行：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'fs'</span>).readFile(__dirname, _ =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'timeout'</span>))</span><br><span class="line">  setImmediate(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'immediate'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用一个设置了延迟的setTimeout也可以实现相同的效果</span></span><br></pre></td></tr></table></figure></p>
<p>上面的为什么有这样的解决方法，从上面的定义中就可以看出来。</p>
<h1 id="关于-async-await-函数"><a href="#关于-async-await-函数" class="headerlink" title="关于 async/await 函数"></a>关于 async/await 函数</h1><p>因为，async/await本质上还是基于Promise的一些封装，而Promise是属于微任务的一种。所以在使用await关键字与Promise.then效果类似</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>输出的结果是：<code>1，2，3，4</code>。</p>
<p>可以理解为，<code>await</code> 以前的代码，相当于与 <code>new Promise</code> 的同构代码，以后的代码相当于 <code>Promise.then</code>。到<code>await</code>的时候就会执行<code>await</code>后面的函数（相当于和前面的代码同步执行）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>之前了解过JavaScript单线程，也了解过JavaScript代码的执行顺序，但是宏任务与微任务也是最近才听说的，这对于一个从事两年前端的开发者真的是，我自己的过失。或需又是因为我是转行的，没有过相关的基础，没有接触到这方面的只是。不过现在我很高兴，因为我对JavaScript的执行有了更多的了解，相比于之前的只是，真的是了解了很多。学习永远都不晚，就怕你从来都不想去了解。在了解EventLoop，宏任务与微任务，JavaScript单线程的时候，参考了一些文档</p>
<ul>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a></li>
<li><a href="https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40" target="_blank" rel="noopener">Understanding JS: The Event Loop</a></li>
<li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" target="_blank" rel="noopener">NodeJS EventLoop</a></li>
<li><a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" target="_blank" rel="noopener">HTML5 EventLoop 标准</a></li>
<li><a href="https://www.cnblogs.com/jiasm/p/9482443.html" target="_blank" rel="noopener">博客园的一位大佬</a>，最后的ES7的 async/await 就是从这里看到的</li>
<li><a href="https://www.bilibili.com/video/av37759434/" target="_blank" rel="noopener">到底什么是时间循环 Event loop in JavaScript</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter lesson 9: Flutter的网络（HTTP）请求</title>
    <url>/%E6%8A%80%E6%9C%AF/Flutter-lesson-9-Flutter%E7%9A%84%E7%BD%91%E7%BB%9C%EF%BC%88HTTP%EF%BC%89%E8%AF%B7%E6%B1%82.html</url>
    <content><![CDATA[<p>Flutter中网络请求有两种，一个是使用Flutter自带的网络请求，另一种则是使用第三方HTTP请求插件<a href="https://pub.dev/packages/dio" target="_blank" rel="noopener">dio</a></p>
<h1 id="Flutter中自带的HTTP请求"><a href="#Flutter中自带的HTTP请求" class="headerlink" title="Flutter中自带的HTTP请求"></a>Flutter中自带的HTTP请求</h1><p>如果要使用Flutter自带的HTTP请求，需要引入下面两个库<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>dart:io</code> 用于发起http请求。这个库里面才有 <code>HttpClient</code>。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br></pre></td></tr></table></figure></p>
<p>因为网络请求需要时间，我们需要在网络请求成功后在来更新数据，所以，我们需要使用到异步。Flutter 官网建议我们使用 <code>async/await</code> 来进行处理异步（借鉴了前端中的ES7的异步处理）。</p>
<p>使用Flutter自带的HTTP请求一般包含以下几个步骤：</p>
<ol>
<li>创建 client。 <code>new HttpClient()</code>，这个对象下面有许多方法，get，post等等。见下图<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190709172359.png" alt="HttpClient 对象"></li>
<li>构造 Uri。不同于前端（HTML）的网页请求，直接一个 URL 链接就可以了。在Flutter中，请求需要使用 Uri 而不是 Url。关于 URL 与 URI 的区别，可以<a href="https://www.zhihu.com/question/21950864" target="_blank" rel="noopener">HTTP 协议中 URI 和 URL 有什么区别？</a>。</li>
<li>发起请求，等待请求，同时您也可以配置请求的headers，body等等。</li>
<li>关闭请求。等待响应。</li>
<li>解码响应的内容。</li>
</ol>
<p>看看下面的代码，代码来源于<a href="https://flutterchina.club/networking/" target="_blank" rel="noopener">Flutter中文网</a><br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">  <span class="keyword">var</span> uri = <span class="keyword">new</span> <span class="built_in">Uri</span>.http(</span><br><span class="line">      <span class="string">'example.com'</span>, <span class="string">'/path1/path2'</span>, &#123;<span class="string">'param1'</span>: <span class="string">'42'</span>, <span class="string">'param2'</span>: <span class="string">'foo'</span>&#125;);</span><br><span class="line">  <span class="keyword">var</span> request = <span class="keyword">await</span> httpClient.getUrl(uri);</span><br><span class="line">  <span class="keyword">var</span> response = <span class="keyword">await</span> request.close();</span><br><span class="line">  <span class="keyword">var</span> responseBody = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为在请求中，返回的数据一般都是 JSON 格式的数据，但是在Flutter中不能直接拿出来就用，这里需要转一下，这时候就需要用到 <code>dart:convert</code>。</p>
<p>使用dart:convert库可以简单解码和编码JSON。 有关其他的JSON文档，请参阅<a href="https://flutterchina.club/json/" target="_blank" rel="noopener">JSON和序列化</a>。</p>
<p>看看最后的代码，下面两个都是get，使用了不同的方式，第二个还带了参数。如果要使用post或者其他请求，可以自己尝试<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(LocaleHttp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocaleHttp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  LocaleHttp(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  _LocaleHttpState createState() =&gt; _LocaleHttpState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LocaleHttpState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LocaleHttp</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data;</span><br><span class="line">  <span class="built_in">Map</span> _person = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"点击按钮开始请求"</span>,</span><br><span class="line">    <span class="string">"joinTime"</span>: <span class="string">"点击按钮开始请求"</span>,</span><br><span class="line">    <span class="string">"email"</span>: <span class="string">"点击按钮开始请求"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  _getData() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">"http://rap2api.taobao.org/app/mock/162174/common/content"</span>;</span><br><span class="line">    <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> request = <span class="keyword">await</span> httpClient.getUrl(<span class="built_in">Uri</span>.parse(url));</span><br><span class="line">      <span class="keyword">var</span> response = <span class="keyword">await</span> request.close();</span><br><span class="line">      <span class="comment">// 上面的两个一步执行完成后在来执行下面的判断</span></span><br><span class="line">      <span class="keyword">if</span>( response.statusCode == HttpStatus.ok ) &#123;</span><br><span class="line">        <span class="comment">// 如果返回的状态是 200 那么请求成功</span></span><br><span class="line">        <span class="keyword">var</span> json = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br><span class="line">        <span class="keyword">var</span> data = jsonDecode(json);</span><br><span class="line">        result = data[<span class="string">'data'</span>][<span class="number">0</span>][<span class="string">"description"</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      result = <span class="string">"Some Error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    setState(() &#123;</span><br><span class="line">      data = result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _getPerson() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    <span class="keyword">var</span> uri = <span class="keyword">new</span> <span class="built_in">Uri</span>.http(<span class="string">'rap2api.taobao.org'</span>, <span class="string">"app/mock/162174/common/get-test"</span>, &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="string">"1"</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Map</span> result = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _person = &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"请求中"</span>,</span><br><span class="line">        <span class="string">"joinTime"</span>: <span class="string">"请求中"</span>,</span><br><span class="line">        <span class="string">"email"</span>: <span class="string">"请求中"</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> request = <span class="keyword">await</span> httpClient.getUrl(uri);</span><br><span class="line">      <span class="keyword">var</span> response = <span class="keyword">await</span> request.close();</span><br><span class="line">      <span class="comment">// 上面的两个一步执行完成后在来执行下面的判断</span></span><br><span class="line">      <span class="keyword">if</span>( response.statusCode == HttpStatus.ok ) &#123;</span><br><span class="line">        <span class="comment">// 如果返回的状态是 200 那么请求成功</span></span><br><span class="line">        <span class="comment">// 将返回的数据转一次格式，下面一行代码写法可以固定了</span></span><br><span class="line">        <span class="keyword">var</span> json = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br><span class="line">        <span class="keyword">var</span> data = jsonDecode(json)[<span class="string">"res"</span>];</span><br><span class="line">        result = data;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      result = &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"请求失败"</span>,</span><br><span class="line">        <span class="string">"joinTime"</span>: <span class="string">"请求失败"</span>,</span><br><span class="line">        <span class="string">"email"</span>: <span class="string">"请求失败"</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _person = result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          RaisedButton(</span><br><span class="line">            child: Text(<span class="string">'获取数据'</span>),</span><br><span class="line">            onPressed: _getData,</span><br><span class="line">          ),</span><br><span class="line">          Text(data == <span class="keyword">null</span> ? <span class="string">"空"</span> : data),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            child: Text(<span class="string">'获取人物信息'</span>),</span><br><span class="line">            onPressed: _getPerson,</span><br><span class="line">          ),</span><br><span class="line">          Text(_person[<span class="string">"name"</span>]),</span><br><span class="line">          Text(_person[<span class="string">"joinTime"</span>]),</span><br><span class="line">          Text(_person[<span class="string">"email"</span>]),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中用到了 Map 对象，注意注意的是 Map 中的对象的每一个字段的值在最开始如果已经确定好了（比如都是字符串），在后面 setState 中，如果返回的数据中有其他的数据类型（比如 number ），那这个时候你在设置的时候就会报错 <code>type int is not a subtype of type &quot;String&quot;</code>。或者你会遇到其他的错误，这个不会像在 JavaScript 中那样随意。</p>
<h1 id="使用-dio"><a href="#使用-dio" class="headerlink" title="使用 dio"></a>使用 dio</h1><p>使用 <a href="https://pub.dev/packages/dio" target="_blank" rel="noopener">dio</a> 需要修安装 dio 插件，当前我使用的是最新的版本 2.1.11</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  flutter:</span></span><br><span class="line"><span class="attr">    sdk:</span> <span class="string">flutter</span></span><br><span class="line"><span class="attr">  flutter_webview_plugin:</span> <span class="string">^0.3.5</span></span><br><span class="line"><span class="attr">  image_picker:</span> <span class="number">0.6</span><span class="number">.0</span><span class="string">+9</span></span><br><span class="line"><span class="attr">  fluttertoast:</span> <span class="string">^3.1.0</span></span><br><span class="line"><span class="attr">  dio:</span> <span class="number">2.1</span><span class="number">.11</span></span><br></pre></td></tr></table></figure>
<p>dio 具体的时候方法可以去 <a href="https://github.com/flutterchina/dio" target="_blank" rel="noopener">dio-github</a> 上面查看，很简单，这里就不做过多说明。总之，相比于原生的 HTTP 请求，dio可谓是方便实用了需要，从下面的代码中就可以看出来。就绪在前端中，原生的 <code>XMLHttpRequest</code>几乎看不见，实际开发用的基本都是 <a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a> 一样。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:dio/dio.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(DioHttp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DioHttp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  DioHttp(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  _DioHttpState createState() =&gt; _DioHttpState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DioHttpState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">DioHttp</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data;</span><br><span class="line">  <span class="built_in">Map</span> _person = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"点击按钮开始请求"</span>,</span><br><span class="line">    <span class="string">"sex"</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="string">"joinTime"</span>: <span class="string">"点击按钮开始请求"</span>,</span><br><span class="line">    <span class="string">"email"</span>: <span class="string">"点击按钮开始请求"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  _getData() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">"http://rap2api.taobao.org/app/mock/162174/common/content"</span>;</span><br><span class="line">    Dio dio = <span class="keyword">new</span> Dio();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response response = <span class="keyword">await</span> dio.<span class="keyword">get</span>(url);</span><br><span class="line">      <span class="built_in">print</span>(response.data[<span class="string">"data"</span>]);</span><br><span class="line">      <span class="comment">// 不要使用 response.data.data[0].description 这样的形势，获取不到</span></span><br><span class="line">      result = response.data[<span class="string">"data"</span>][<span class="number">0</span>][<span class="string">"description"</span>];</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      result = <span class="string">"Some Error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    setState(() &#123;</span><br><span class="line">      data = result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          RaisedButton(</span><br><span class="line">            child: Text(<span class="string">'获取数据'</span>),</span><br><span class="line">            onPressed: _getData,</span><br><span class="line">          ),</span><br><span class="line">          Text(data == <span class="keyword">null</span> ? <span class="string">"空"</span> : data)</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的App的<a href="https://github.com/tal007/FlutterApp" target="_blank" rel="noopener">源码地址</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>linux的简单介绍以及常用简单命令</title>
    <url>/%E6%8A%80%E6%9C%AF/linux%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180920180117.png" alt="基本"></p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"># 关机</span><br><span class="line">正常关机</span><br><span class="line"><span class="function"><span class="title">shutdown</span><span class="params">(腾讯云使用这个就关机了)</span></span></span><br><span class="line"><span class="function"><span class="title">shutdown</span> -<span class="title">h</span> <span class="title">now</span><span class="params">(虚拟机上是这样的 centOS <span class="number">6.5</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">halt</span><span class="params">(关闭内存)</span> 因为计算机没有内存无法开机，因此等同于关机</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">init</span> 0<span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h2><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">Bin：全称<span class="built_in">binary</span>，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。</span><br><span class="line">Dev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似windows下的分配盘符）。</span><br><span class="line">Etc：该目录主要存储一些配置文件。</span><br><span class="line">Home：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的User/用户目录。</span><br><span class="line">Proc:process，表示进程，该目录中存储的是Linux运行时候的进程。</span><br><span class="line">Root：该目录是root用户自己的家目录。</span><br><span class="line">Sbin：全称<span class="keyword">super</span> <span class="built_in">binary</span>，该目录也是存储一些可以被执行的二进制文件，但是必须得有<span class="keyword">super</span>权限的用户才能执行。</span><br><span class="line">Imp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。</span><br><span class="line">Usr：存放的是用户自己安装的软件。类似于windows 下的program files。</span><br><span class="line">Var：存放的程序/系统的日志文件的目录。</span><br><span class="line">Mnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。</span><br></pre></td></tr></table></figure>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p><code>注：文中所有的 中括号 [] 表示可选</code></p>
<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><blockquote>
<p>commond not found 指令没有找到</p>
</blockquote>
<p>一个完整的指令的基本格式<br><code># 指令 [选项] [操作对象]</code></p>
<ol>
<li>一个指令可以包含多个选项</li>
<li>操作对象也可以是多个</li>
</ol>
<p>例如：需要让张三同学帮忙去楼下小卖铺买一瓶农夫山泉水和清风餐巾纸，在这个指令中“买东西”是指令的主体，买的水和餐巾纸是操作的对象，农夫山泉、清风是操作的选项。|</p>
<h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><h3 id="ls-指令"><a href="#ls-指令" class="headerlink" title="ls 指令"></a>ls 指令</h3><p>含义：ls（list） 列表清单的意思<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">用法1</span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">含义：列出当前工作目录下的所有文件/文件夹的名称</span><br><span class="line"></span><br><span class="line">用法2</span><br><span class="line"><span class="comment"># ls 路径</span></span><br><span class="line">含义：列出指定路径下的所有文件/文件夹的名称</span><br><span class="line">路径可以是相对路径（<span class="string">../</span>上一级目录 || <span class="string">./</span>当前目录）也可以是绝对路径<span class="params">(/)</span></span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180921001852.png" alt><br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">用法3 </span><br><span class="line"># <span class="keyword">ls</span> 选项 路径</span><br><span class="line">含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示。</span><br><span class="line">常见的语法：</span><br><span class="line">    # <span class="keyword">ls</span> -<span class="keyword">l</span> 路径   --》 以列表的形式，列出当前目录的文件，不包含隐藏文件</span><br><span class="line">    # <span class="keyword">ls</span> -<span class="keyword">la</span> 路径  --》 以列表的形式，列出当前目录的文件，包含隐藏文件</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180921002310.png" alt></p>
<p>上述列表中的第一列字符表示文档的类型，其中“-”表示改行对应的文档类型为文件，“d”<br>表示文档类型为文件夹。隐藏的文档<code>.</code>开头<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">用法<span class="number">4</span></span><br><span class="line"><span class="meta"># ls -lh 路径v</span></span><br><span class="line">含义：列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候</span><br><span class="line">以可读性较高的形式显示</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180921002950.png" alt></p>
<h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">用法</span><br><span class="line"><span class="comment"># pwd</span></span><br><span class="line">含义：<span class="literal">print</span> working <span class="literal">directory</span>，打印当前工作目录  打印的是绝对路径</span><br></pre></td></tr></table></figure>
<h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><p>作用：change directory 切换当前的工作目录<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">语法 <span class="meta"># cd 路径</span></span><br></pre></td></tr></table></figure></p>
<p>补充：<br>在Linux中有一个特殊的符号<code>“~”</code>，表示<code>当前用户的家目录</code>。<br>切换的方式：# cd ~</p>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>作用： make directory，创建目录<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">语法<span class="number">1</span></span><br><span class="line"><span class="meta"># mkdir 路径</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180921004207.png" alt></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">语法<span class="number">2</span></span><br><span class="line"><span class="meta"># mkdir -p</span></span><br><span class="line">作用：多层创建文件夹</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180921004820.png" alt></p>
<p>上图如果不使用<code>-p</code>，name则无法创建文件夹</p>
<p>在使用<code>-p</code>后则可以创建<strong>多层</strong>文件夹</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">语法<span class="number">3</span></span><br><span class="line">mkdir 路径<span class="number">1</span> 路径<span class="number">2</span> 路径<span class="number">3</span></span><br><span class="line">含义：在同一个目录下创建多个文件夹</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180921005125.png" alt></p>
<p>上图创建了<code>css</code>，<code>js</code>，<code>images</code>三个文件夹</p>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>作用：创建文件<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line"># <span class="section">touch</span> 文件路径</span><br><span class="line">路径可以是文件名或者是路径</span><br><span class="line"></span><br><span class="line"># <span class="section">touch</span> 路径<span class="number">1</span> 路径<span class="number">2</span> ...</span><br><span class="line">创建多个文件</span><br></pre></td></tr></table></figure></p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>作用：复制文件或者文件夹到指定的位置  copy<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">用法<span class="number">1</span> 复制文件</span><br><span class="line"><span class="meta"># cp 被复制的文件路径 文件被复制到的路径</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180921103130.png" alt></p>
<p><em>注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致。</em></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">用法<span class="number">2</span> 复制目录</span><br><span class="line"><span class="meta"># cp -r 被复制的目录路径 目录被复制到的路径</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180921103532.png" alt></p>
<p>注意：当使用cp命令进行文件夹复制操作的时候需要添加选项“-r”【-r表示递归复制】<br>否则目录将被忽略</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>作用1：移动，剪切文档到新的位置，语法与cp类似，移动文件夹不需要加 <code>-r</code></p>
<p>作用2：重命名<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># mv 需要移动的文档路径 需要保存的路径</span></span><br></pre></td></tr></table></figure></p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>作用：remove 移除或者删除一个或者多个文档<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># rm 选项 需要移除的文档路径</span></span><br><span class="line"></span><br><span class="line">选项：  -f 强制删除，这样就没有提示了</span><br><span class="line">       -r 删除文件夹</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180921111954.png" alt></p>
<p>上图输入 y（yes） n（no） 删除文件，如果添加了<code>-f</code>则不会删除</p>
<p>注意：删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询间，所以移除目录的时候一般需要使用<code>-rf</code>选项。</p>
<p>其中<code>*</code>称之为通配符，意思表示任意的字符，Linux*，则表示只要文件以Linux开头，后续字符则不管。<br><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180921112852.png" alt></p>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>作用：打开文件，创建文件<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim 文件路径</span></span><br><span class="line"></span><br><span class="line">退出文件</span><br><span class="line"><span class="symbol">:q</span> 回车</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180921113254.png" alt></p>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。</p>
<p><code>&gt;：覆盖输出，会覆盖掉原先的文件内容</code></p>
<p><code>&gt;&gt;：追加输出，不会覆盖原始文件内容，会在原始内容未尾继续输出</code></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 正常的命令 &gt; 文件的路径</span></span><br><span class="line"><span class="meta"># 正常的命令 &gt;&gt; 文件的路径</span></span><br><span class="line">如果后面的文件路径不存在则会创建</span><br></pre></td></tr></table></figure>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">作用1：直接打开一个文件，与<span class="code">`vim`</span>相比，他不需要使用 <span class="code">`:q`</span> 退出</span><br><span class="line"><span class="section"># cat 文件的路径</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">作用<span class="number">2</span>：对多个文件进行合并</span><br><span class="line"># cat 文件的路径<span class="number">1</span> 文件的路径<span class="number">2</span> 文件的路径<span class="number">3</span> ... &gt; 输出的文件路径</span><br></pre></td></tr></table></figure>
<h2 id="进阶指令"><a href="#进阶指令" class="headerlink" title="进阶指令"></a>进阶指令</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>作用：查看磁盘空间<br><figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df -h</span></span><br><span class="line"><span class="literal">-h表示以可读性较高的形式展示大小</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180927160620.png" alt></p>
<h3 id="free指令"><a href="#free指令" class="headerlink" title="free指令"></a>free指令</h3><p>作用：查看内存使用情况<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># free -m</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180927161159.png" alt><br>一般使用<code>-m</code>即可，单位是<strong>mb</strong></p>
<p>Swap：用于临时内存，当系统真实内存不够用的时候可以临时使用磁盘空间来充当内存。|</p>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>作用：查看一个文件的前 n 行，如果不指定 n，则默认显示前10行<br><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"># head  -<span class="built_in">n</span> 文件路径 <span class="built_in">n</span>表示数字</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180927164326.png" alt></p>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">作用<span class="number">1</span>：查看一个文件的末尾 <span class="built_in">n</span> 行 ，如果不指定 <span class="built_in">n</span>，则默认显示末尾<span class="number">10</span>行</span><br><span class="line"># tail -<span class="built_in">n</span> 文件路径 <span class="built_in">n</span>表示数字  如果<span class="built_in">n</span>=-<span class="number">1</span> 则显示最后一行</span><br></pre></td></tr></table></figure>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">作用<span class="number">2</span>：用过<span class="keyword">tail</span>查看一个文件的动态变化</span><br><span class="line"># <span class="keyword">tail</span> -f 文件路径</span><br></pre></td></tr></table></figure>
<p><code>退出按 q</code></p>
<h3 id="less-指令"><a href="#less-指令" class="headerlink" title="less 指令"></a>less 指令</h3><p>作用：查看文件，以较少的内容进行输出，按下辅助功能键查看更多</p>
<p>辅助键：数字+回车，空格（翻页），上下键<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># less 需要查看的文件路径</span></span><br></pre></td></tr></table></figure></p>
<h3 id="wc-指令"><a href="#wc-指令" class="headerlink" title="wc 指令"></a>wc 指令</h3><p>作用：用于统计文件内容信息（行数 -l，单词数 -w，字节数 -c）<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># wc -lwc 文件路径</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180927165542.png" alt></p>
<h3 id="date-（重点）"><a href="#date-（重点）" class="headerlink" title="date （重点）"></a>date （重点）</h3><p>作用：表示操作时间日期（读取与设置）<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># date</span></span><br><span class="line"><span class="meta"># date +%F</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180928141946.png" alt></p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">F</span></span>：表示完整的年月日</span><br><span class="line"><span class="tag">%<span class="selector-tag">T</span></span>：表示完整的时分秒</span><br><span class="line"><span class="tag">%<span class="selector-tag">Y</span></span>：表示四位年份</span><br><span class="line"><span class="tag">%<span class="selector-tag">m</span></span>：表示两位月份（带前导0）</span><br><span class="line"><span class="tag">%<span class="selector-tag">d</span></span>：表示日期（带前导0）</span><br><span class="line">H：表示小时（带前导0）</span><br><span class="line">M：表示分钟（带前导0）</span><br><span class="line"><span class="tag">%<span class="selector-tag">S</span></span>：表示秒数（带前导0）</span><br></pre></td></tr></table></figure>
<p>更多的命令可以查看：<a href="http://man.linuxde.net/date" target="_blank" rel="noopener">http://man.linuxde.net/date</a></p>
<h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>作用：用来操作日历<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">语法<span class="number">1</span>：<span class="selector-id">#cal</span> 等价于 <span class="selector-id">#cal</span> -<span class="number">1</span> 直接输出当前月份的日历</span><br><span class="line">语法<span class="number">2</span>：<span class="selector-id">#cal</span> -<span class="number">3</span> 表示输出上一个月+本月+下个月的日历</span><br><span class="line">语法<span class="number">3</span>：<span class="selector-id">#cal</span> y 年份 表示输出某一个年份的日历</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180928143417.png" alt></p>
<h3 id="clear、CRTL-L"><a href="#clear、CRTL-L" class="headerlink" title="clear、CRTL+L"></a>clear、CRTL+L</h3><p>作用：清屏<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># clear</span></span><br><span class="line">快捷键：crtl+l</span><br></pre></td></tr></table></figure></p>
<h3 id="管道-重要"><a href="#管道-重要" class="headerlink" title="管道(重要)"></a>管道(重要)</h3><p>管道符号：<code>|</code></p>
<p>作用：用于过滤，特殊用法，一些扩展用法。不能单独使用，需要配合前面所讲的那些</p>
<p>过滤案例：需要通过管道查询出根目录下包含“y”字母的文档名称。<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">ls</span> 路径 |<span class="keyword">grep</span> <span class="keyword">y</span>   <span class="keyword">grep</span> 的作用就是过滤</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>过滤当前路径下面有 <code>0</code> 的文件<br><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180928144401.png" alt></p>
</li>
<li><p>特殊用法案例：通过管道的操作方法来实现less的等价效果（了解）</p>
</li>
</ol>
<p>之前通过less查看一个文件，可以 <code># less 路径</code></p>
<p>现在通过管道还可以这么：<code># cat 路径 | less</code></p>
<ol start="3">
<li>扩展处理：请使用学过的命令，来统计某个目录下的文档的总个数？</li>
</ol>
<p>答：#s/Iwc-|</p>
<h2 id="高级指令"><a href="#高级指令" class="headerlink" title="高级指令"></a>高级指令</h2><h3 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h3><p>作用：操作服务器的主机名（<code>读取</code>，设置），一般只是读取，不会去修改<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">语法<span class="number">1</span>：</span><br><span class="line"><span class="meta"># hostname   含义：表示输出完整的主机名</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">语法<span class="number">2</span>：</span><br><span class="line"><span class="meta"># hostname -f  含义：表示输出当前主机名中的FQDN（全限定域名）,本地服务器的localhost</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180929142356.png" alt></p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>作用：用于查看一个用户的一些基本信息（用户ID，用户组ID，附加组ID等），如果不指定用户则默认当前用户<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># id</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># id 用户名</span></span><br></pre></td></tr></table></figure>
<h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><p>作用：获取当前用户的用户名，<code>一部用于shell脚本，用户获取当前操作的用户名方便记录日志。</code><br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># whoami</span></span><br></pre></td></tr></table></figure></p>
<h3 id="ps-ef-重点"><a href="#ps-ef-重点" class="headerlink" title="ps -ef(重点)"></a>ps -ef(重点)</h3><p>作用：主要查看服务器的进程信息<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">选项含义：</span><br><span class="line">    -<span class="ruby">e：等价于 -A 表示列出全部的进程</span></span><br><span class="line"><span class="ruby">    -f：显示全部的列（显示器全字段）</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180929150419.png" alt></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">列的含义：</span><br><span class="line"><span class="built_in">UID</span>：该进程执行的用户<span class="keyword">id</span>；</span><br><span class="line">PID：进程<span class="keyword">id</span>；</span><br><span class="line">PPID：该进程的父级进程<span class="keyword">id</span>，如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程；</span><br><span class="line">C:Cpu的占用率，其形式是百分数；</span><br><span class="line">STIME：进行的启动时间；</span><br><span class="line">TTY：终端设备，发起该进程的设备识别符号，如果显示“？”则表示该进程并不是由终端设备发起；</span><br><span class="line">TIME：进程的执行时间；</span><br><span class="line"><span class="built_in">CMD</span>：该进程的名称或者对应的路径；</span><br></pre></td></tr></table></figure>
<h3 id="top（重点）"><a href="#top（重点）" class="headerlink" title="top（重点）"></a>top（重点）</h3><p>作用：查看服务器的进程占用的资源<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">进入命令：<span class="meta"># top</span></span><br><span class="line">退出：按 q</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/Anthony-Wilson/PicGo/master/20180929151819.png" alt></p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">表头含义：</span><br><span class="line">PID：进程id；</span><br><span class="line">USER：该进程对应的用户；</span><br><span class="line">PR：优先级；</span><br><span class="line">VIRT：虚拟内存；</span><br><span class="line">RES：常驻内存；</span><br><span class="line">SHR：共享内存；</span><br><span class="line">    计算一个进程实际使用的内存=常驻内存（RES）-共享内存（SHR）</span><br><span class="line">s：表示进行的状态（sleeping，其中s表示睡眠，R表示运行）；</span><br><span class="line"><span class="tag">%<span class="selector-tag">CPU</span></span>：表示CPU的占用百分比；</span><br><span class="line"><span class="tag">%<span class="selector-tag">MEM</span></span>：表示内存的占用百分比；</span><br><span class="line">TIME+：执行的时间；</span><br><span class="line">COMMAND：进程的名称或者路径；</span><br></pre></td></tr></table></figure>
<p>在运行top的时候，可以按下方便的快捷键：<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">M：表示将结果按照内存（MEM）从高到低进行降序排列；</span><br><span class="line">P：表示将结果按照<span class="meta">CPU</span>使用率从高到低进行降序排列；</span><br><span class="line"><span class="number">1</span>：当服务器拥有多个<span class="meta">cpu</span>的时候可以使用“<span class="number">1</span>”快捷键来切换是否展示显示各个<span class="meta">cpu</span>的详细信息</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>云服务器安装node+nginx+MongoDB</title>
    <url>/%E6%8A%80%E6%9C%AF/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85node-nginx-MongoDB.html</url>
    <content><![CDATA[<p>很早就买了一个云服务器，在腾讯云上面买的，当时买了好几年，用了几百块吧。具体的配置如下</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190705094639.png" alt="服务器配置"></p>
<p>本来就是想用来练手node+nginx+MongoDB的，一直没时间（其实是太懒了），所以没有着手做此项目。以前也弄过，不过总是断断续续的，而且没有记录，现在再想搭建的时候，已经忘得差不多了。写这篇文章的目的纯粹是为了记录下我搭建的步骤，以供以后查询。</p>
<h1 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h1><p>首先就是需要购买一个服务器，不管是1+1+1（1G1核1M）还是其他的配置，只有有服务器就行，因为就是个练手的，没必要那么好。当然，如果你有钱，你可以选择黄金配置。腾讯云阿里云时不时的会有一些活动出来，如果有活动，我会放在本文的下方，以供你们参考。</p>
<h1 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h1><p>云服务器也是需要安装系统的，以腾讯云的云服务器为例</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190705095459.png" alt="安装系统"></p>
<blockquote>
<p>点击右边更多 ==&gt; 重装（安装）系统 ==&gt; 选择系统配置，输入密码开始重装</p>
</blockquote>
<p>我这里是用的centerOS系统，你可以使用别的系统，当然，如果是其他的系统，那么安装工具的方法可能会有不同。</p>
<p>Tip：密码可能在第一次使用的时候需要重置。</p>
<h1 id="进入服务器安装工具"><a href="#进入服务器安装工具" class="headerlink" title="进入服务器安装工具"></a>进入服务器安装工具</h1><p>上面的配置好了基本上就可以进入服务器安装工具（node+nginx+MongoDB等等）了。</p>
<p>那么，怎么进入呢？同样是腾讯云服务器</p>
<h2 id="链接服务器"><a href="#链接服务器" class="headerlink" title="链接服务器"></a>链接服务器</h2><p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190705095810.png" alt="点击登录进入服务器"></p>
<p>登录方式不同的操作系统是不同的，具体的操作系统可在在相关云服务器网站上面找到。</p>
<p>mac和linux用自带的终端或者使用 <a href="https://www.iterm2.com/" target="_blank" rel="noopener">Item2</a> ，windows使用 <a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/download.html" target="_blank" rel="noopener">Putty</a> 是不错的选择。</p>
<p>以下操作按照mac的来</p>
<p>使用Item2连接服务器</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh</span> 用户名<span class="variable">@IP</span>地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">ssh 用户名<span class="variable">@IP</span>地址 -p 端口号</span><br></pre></td></tr></table></figure>
<p>链接错误</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-<span class="keyword">in</span>-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint <span class="keyword">for</span> the ECDSA key sent by the remote host is</span><br><span class="line">SHA256:Ppgtgxjj3hnHqRH19D0hz5Vl34vUW0Dah1AJdpLoX6M.</span><br><span class="line">Please contact your <span class="keyword">system</span> administrator.</span><br><span class="line">Add correct host key <span class="keyword">in</span> /Users/cpx/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending ECDSA key <span class="keyword">in</span> /Users/cpx/.ssh/known_hosts:<span class="number">6</span></span><br><span class="line">ECDSA host key <span class="keyword">for</span> <span class="number">118.24</span><span class="number">.6</span><span class="number">.33</span> has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure>
<p>解决：删除之前的 <code>known_hosts</code> 文件</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">rm -rf ~<span class="string">/.ssh/known_hosts</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者更靠谱的方法</span></span><br><span class="line">ssh-keygen -f <span class="string">.ssh/known_hosts</span> -R 192.168.2.108<span class="params">(你的IP)</span></span><br></pre></td></tr></table></figure>
<p>之后重新执行命令就可以链接成功</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190705115826.png" alt="连接成功"></p>
<h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><p>安装可以使用centerOS中的 yum 工具，不过使用之前最好先 <code>yum update</code> 一波（可选操作）</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node官网</a>复制linux包（Linux Binaries (x64)）链接，我当前版本的链接是 <code>https://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.xz</code> 。不是<code>Source Code</code>。</p>
<p>下载<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v10.<span class="number">16.0</span>/<span class="keyword">node</span><span class="title">-v10</span>.<span class="number">16.0</span>-linux-x64.tar.xz</span><br></pre></td></tr></table></figure></p>
<p>解压<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果是 tar.gz 结尾的，使用 tar xvzf 解压</span></span><br><span class="line">tar xvzf <span class="keyword">node</span><span class="title">-v10</span>.<span class="number">16.0</span>-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是 tar.xz 结尾的，使用 tar xvJf 解压 注意 J 是大写的</span></span><br><span class="line">tar xvJf <span class="keyword">node</span><span class="title">-v10</span>.<span class="number">16.0</span>-linux-x64.tar.zx</span><br></pre></td></tr></table></figure></p>
<p>进入解压的node文件夹<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">cd <span class="keyword">node</span><span class="title">-v10</span>.<span class="number">16.0</span></span><br></pre></td></tr></table></figure></p>
<p>安装必要的运行文件<br><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">sudo</span> <span class="comment">yum</span> <span class="comment">install</span> <span class="comment">gcc</span> <span class="comment">gcc</span><span class="literal">-</span><span class="comment">c</span><span class="literal">+</span><span class="literal">+</span></span><br></pre></td></tr></table></figure></p>
<p>配置node，npm软连接，这样就可以在所有目录下使用，注意 <code>-s</code> 不要忘记了，不然会报错。<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">ln -s /root/<span class="keyword">node</span><span class="title">-v10</span>.<span class="number">16.0</span>-linux-x64/bin/<span class="keyword">node</span> <span class="title">/usr</span>/local/bin/<span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">ln</span> -s /root/<span class="keyword">node</span><span class="title">-v10</span>.<span class="number">16.0</span>-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></p>
<p>如果你不小心写错了软链，那么你可能会把它删除<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190705145355.png" alt="删除软链"></p>
<p>查看 node, npm 版本<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></p>
<p>出现如下请求，即创建成功<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190705145033.png" alt="创建成功"></p>
<h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> nginx</span><br></pre></td></tr></table></figure>
<p>启动nginx<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">service nginx <span class="literal">start</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190705155955.png" alt="启动成功"></p>
<p>每一次修改了 nginx.conf 文件后都需要停止 nginx 并重启</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">强制停止： pkill <span class="number">-9</span> nginx</span><br><span class="line">重启：service nginx restart</span><br></pre></td></tr></table></figure>
<p>这里我使用的是<code>yum</code>安装的nginx，默认的安装目录是在 <code>/etc/nginx</code> 这个目录，nginx的配置文件也是在 <code>/etc/nginx/nginx.conf</code> 这里</p>
<p>配置 nginx 代理，编辑 <code>nginx.conf</code></p>
<p>nginx 默认的服务配置只有一个80端口，配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80 default_server;</span><br><span class="line">    listen       [::]:80 default_server;</span><br><span class="line">    server_name  _;</span><br><span class="line">    root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候我想要添加一个8090端口，我的配置代码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8090;</span><br><span class="line">    server_name  _;</span><br><span class="line">    root         /data/www/test/index.html;</span><br><span class="line"></span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时报了错了，访问 118.24.6.33:8090 的时候出现了 <code>403 Forbidden</code> 的错误。</p>
<p>我们知道 HTTP 状态码中，403表示的是没有权限的意思，意思是上面的 <code>/data/www/test/index.html;</code> 我们没有权限访问</p>
<p>这个是因为nginx默认的配置文件中，第 5 行的代码中 <code>user nginx;</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br></pre></td></tr></table></figure></p>
<p>我们需要将 <code>user nginx;</code> 改成 <code>user root;</code></p>
<p>接着停止重启nginx服务。</p>
<p>这时候访问 118.24.6.33:8090 的时候出现了 <code>404 Not Found</code> 的错误。</p>
<p>再来看看HTTP协议中 404 表示的是没有资源，WHAT？WHY？</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190705170937.png" alt="查看test文件夹"></p>
<p>里面明明就有这个东西啊？</p>
<p>既然里面已经放了东西了，还是 404， 值得我们思考。我们看看默认的 80 端口的 <code>root</code> 配置为 <code>/usr/share/nginx/html</code>。在看看里面呢</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190705171241.png" alt="/usr/share/nginx/html"></p>
<p>里面是有一个html文件的。所以。这个 root 的值是一个目录而不是一个文件，所以，把 <code>/data/www/test/index.html;</code> 改成 <code>/data/www/test</code> 即可。这时候就可以访问 <a href="http://118.24.6.33:8090" target="_blank" rel="noopener">118.24.6.33:8090</a> 了。</p>
<p><strong>nginx接触的不多，所以会出现一些问题，不过都是在问题中慢慢摸索。当然，你也可以看看<a href="http://www.nginx.cn/doc/" target="_blank" rel="noopener">nginx的配置官网</a>。不过东西有点多，大部分可能涉及不到，所以还是采坑了。</strong></p>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>或许你会用到git clone以前的项目练手，或许你不会。不过还是说一下</p>
<p>使用 yum 安装（推荐。这个安装方便）,安装后可直接使用<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> git</span><br></pre></td></tr></table></figure></p>
<p>到网站<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/" target="_blank" rel="noopener">git linux</a> 下载你需要的git版本。</p>
<p>下载解压与 node 相同，不在过多说明。</p>
<p>安装 git 的时候你可能还需要安装 curl-devel<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> curl-devel</span><br></pre></td></tr></table></figure></p>
<p>你还需要生成一个 key 用于git的识别</p>
<p>生成 sshkey，敲三次回车即可<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-C</span>"<span class="selector-tag">xxxxx</span>@<span class="keyword">xxxxx</span>.<span class="keyword">com</span>"</span><br></pre></td></tr></table></figure></p>
<p>查看你的 public key，并把他添加到github<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cat ~<span class="regexp">/.ssh/i</span>d_rsa.pub</span><br></pre></td></tr></table></figure></p>
<h3 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h3><p>前往<a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">MongoDB官网</a>选择对应版本，复制下面的链接<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>fastdl.mongodb.org<span class="regexp">/linux/m</span>ongodb-linux-x86_64-<span class="number">3.4</span>.<span class="number">21</span>.tgz</span><br></pre></td></tr></table></figure></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 解压</span></span><br><span class="line">tar vxzf mongodb-linux-x86_64<span class="number">-3.4</span><span class="number">.21</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 重命名</span></span><br><span class="line">mv mongodb-linux-x86_64<span class="number">-3.4</span><span class="number">.21</span> mongodb</span><br><span class="line"></span><br><span class="line"><span class="meta"># 进入文件夹，变量创建 data 和 logs 文件夹</span></span><br><span class="line">cd mongodb</span><br><span class="line">mkdir -p logs</span><br><span class="line">mkdir -p data</span><br></pre></td></tr></table></figure>
<p>进入bin文件夹创建 <code>mongodb.conf</code>，并配置此文件。注意：mongodb 3.6以上版本不支持下面的配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置数据文件的存放目录</span><br><span class="line">dbpath = /mongodb/data</span><br><span class="line"></span><br><span class="line"># 设置日志文件的存放目录及其日志文件名</span><br><span class="line">logpath = /mongodb/logs/mongodb.log</span><br><span class="line"></span><br><span class="line"># 设置端口号（默认的端口号是 27017）</span><br><span class="line">port = 27017</span><br><span class="line"></span><br><span class="line"># 设置为以守护进程的方式运行，即在后台运行</span><br><span class="line">fork = true</span><br><span class="line"></span><br><span class="line"># nohttpinterface = true</span><br><span class="line">nohttpinterface = true</span><br></pre></td></tr></table></figure></p>
<p>启动：在bin文件夹下执行<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./mongod</span> <span class="params">--config</span> mongodb.conf</span><br><span class="line"></span><br><span class="line">以修复模式启动 mongodb：</span><br><span class="line"><span class="string">./mongod</span> <span class="params">--repair</span> -f mongodb.conf</span><br></pre></td></tr></table></figure></p>
<h3 id="安装yarn（可选）"><a href="#安装yarn（可选）" class="headerlink" title="安装yarn（可选）"></a>安装yarn（可选）</h3><p>因为在本地使用npm的时候老是出问题，在本地基本上都是使用的是yarn。我怕在服务器上面如果安装依赖包的时候使用npm也像在本地一样出问题，所以还是觉得使用yarn更好</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">curl <span class="params">--silent</span> <span class="params">--location</span> https:<span class="string">//dl.yarnpkg.com/rpm/yarn.repo</span> | sudo tee <span class="string">/etc/yum.repos.d/yarn.repo</span></span><br><span class="line"></span><br><span class="line">sudo yum install yarn</span><br></pre></td></tr></table></figure>
<h3 id="安装pm2"><a href="#安装pm2" class="headerlink" title="安装pm2"></a>安装pm2</h3><p>这个依赖是可以在服务器上面运行node项目的，相比于原生的node启动的文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g pm2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置软链</span></span><br><span class="line"><span class="keyword">ln</span> -s node的具体路径/<span class="keyword">bin</span>/pm2 /usr/<span class="keyword">local</span>/<span class="keyword">bin</span>/pm2</span><br></pre></td></tr></table></figure>
<p><strong>PM2 的主要特性</strong></p>
<ul>
<li>内建负载均衡（使用 Node cluster 集群模块）</li>
<li>后台运行</li>
<li>0 秒停机重载，我理解大概意思是维护升级的时候不需要停机.</li>
<li>具有 Ubuntu 和 CentOS 的启动脚本</li>
<li>停止不稳定的进程（避免无限循环）</li>
<li>控制台检测</li>
<li>提供 HTTP API</li>
<li>远程控制和实时的接口 API ( Nodejs 模块,允许和 PM2 进程管理器交互 )</li>
</ul>
<p>具体的使用方法<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">pm2 <span class="keyword">start</span> xxx.js</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止 (AppName|id) 如下放图</span></span><br><span class="line">pm2 <span class="keyword">stop</span> (AppName|<span class="keyword">id</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190708155810.png" alt="启动成功"></p>
<p>注意：这里pm2启动的是node的项目。而不是react，vue这些项目。我刚开始犯错了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter lesson 8:输入框,时间日期选择</title>
    <url>/%E6%8A%80%E6%9C%AF/Flutter-lesson-8-%E8%BE%93%E5%85%A5%E6%A1%86-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9.html</url>
    <content><![CDATA[<h1 id="日期时间选择"><a href="#日期时间选择" class="headerlink" title="日期时间选择"></a>日期时间选择</h1><p>Flutter自带的 <code>showDatePicker</code> 和 <code>showTimePicker</code> 两个方法可以进行时间和日期的选择。</p>
<p>使用的时候直接使用者两个方法即可，不过有一点需要注意：在使用的时候，一般不要在 <code>onPress</code> 下直接调用，而是需要单独写一个方法。同时，因为这两个方法是异步实现的，所以，这里使用了<a href="https://medium.com/@madasamy/javascript-brief-history-and-ecmascript-es6-es7-es8-features-673973394df4" target="_blank" rel="noopener">ES8</a>中的 <code>async...await</code></p>
<p>下面我们来看看具体的代码实现</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _chooseDate;</span><br><span class="line"><span class="keyword">var</span> _chooseTime;</span><br><span class="line"></span><br><span class="line">_showDatePicker() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> date = <span class="keyword">await</span> showDatePicker(</span><br><span class="line">    context: context,</span><br><span class="line">    initialDate: <span class="built_in">DateTime</span>.now(),</span><br><span class="line">    firstDate: <span class="built_in">DateTime</span>(<span class="number">1970</span>),</span><br><span class="line">    lastDate: <span class="built_in">DateTime</span>(<span class="number">2050</span>)</span><br><span class="line">  );</span><br><span class="line">  setState(()&#123;</span><br><span class="line">    <span class="keyword">this</span>._chooseDate = date.toString().split(<span class="string">" "</span>)[<span class="number">0</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_showTimePicker() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="keyword">await</span> showTimePicker(</span><br><span class="line">    context: context,</span><br><span class="line">    initialTime: TimeOfDay.now()</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">print</span>(time);</span><br><span class="line"></span><br><span class="line">  setState(() &#123;</span><br><span class="line">    <span class="keyword">this</span>._chooseTime = time.toString().split(<span class="string">"TimeOfDay("</span>)[<span class="number">1</span>].split(<span class="string">")"</span>)[<span class="number">0</span>];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/2.gif" alt="选择时间日期"></p>
<p>选择时间日期还是挺简单的，不过需要注意的是<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flutter</span>: 选择的日期是：2019<span class="selector-tag">-07-30</span> 00<span class="selector-pseudo">:00</span><span class="selector-pseudo">:00.000</span></span><br><span class="line"><span class="selector-tag">flutter</span>: 选择的时间是：<span class="selector-tag">TimeOfDay</span>(21<span class="selector-pseudo">:34)</span></span><br></pre></td></tr></table></figure></p>
<p>两个方法选择时间，日期后，时间日期的格式是上面那样的，如果你要使用，或许你需要处理一下。</p>
<p>选择时间是使用的 <code>TimeOfDay</code>，选择日期使用的是 <code>DateTime</code> ，两个是不同的方法，没有选择日期又选择时间的，或许在<code>dart.pub</code>上面有一些第三方的插件可以。</p>
<h1 id="输入框-TextField"><a href="#输入框-TextField" class="headerlink" title="输入框 TextField"></a>输入框 TextField</h1><p><strong>TextField</strong> 是Flutter中的用户输入框，属性挺多的，不同的配置出不同的效果，就像是HTML中的 input 一样。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextField(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.controller, <span class="comment">//编辑框的控制器，跟文本框的交互一般都通过该属性完成，如果不创建的话默认会自动创建</span></span><br><span class="line">  <span class="keyword">this</span>.focusNode, <span class="comment">//用于管理焦点</span></span><br><span class="line">  <span class="keyword">this</span>.decoration = <span class="keyword">const</span> InputDecoration(), <span class="comment">//输入框的装饰器，用来修改外观</span></span><br><span class="line">  TextInputType keyboardType, <span class="comment">//设置输入类型，不同的输入类型键盘不一样</span></span><br><span class="line">  <span class="keyword">this</span>.textInputAction,  <span class="comment">//用于控制键盘动作（一般位于右下角，默认是完成），搜送，下一步等</span></span><br><span class="line">  <span class="keyword">this</span>.textCapitalization = TextCapitalization.none,</span><br><span class="line">  <span class="keyword">this</span>.style, <span class="comment">//输入的文本样式</span></span><br><span class="line">  <span class="keyword">this</span>.strutStyle,</span><br><span class="line">  <span class="keyword">this</span>.textAlign = TextAlign.start, <span class="comment">//输入的文本位置</span></span><br><span class="line">  <span class="keyword">this</span>.textDirection,  <span class="comment">//输入的文字排列方向，一般不会修改这个属性</span></span><br><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>, <span class="comment">//是否自动获取焦点</span></span><br><span class="line">  <span class="keyword">this</span>.obscureText = <span class="keyword">false</span>, <span class="comment">//是否隐藏输入的文字，一般用在密码输入框中</span></span><br><span class="line">  <span class="keyword">this</span>.autocorrect = <span class="keyword">true</span>, <span class="comment">//是否自动校验</span></span><br><span class="line">  <span class="keyword">this</span>.maxLines = <span class="number">1</span>, <span class="comment">//最大行</span></span><br><span class="line">  <span class="keyword">this</span>.minLines,</span><br><span class="line">  <span class="keyword">this</span>.expands = <span class="keyword">false</span>,</span><br><span class="line">  <span class="keyword">this</span>.maxLength, <span class="comment">//能输入的最大字符个数</span></span><br><span class="line">  <span class="keyword">this</span>.maxLengthEnforced = <span class="keyword">true</span>, <span class="comment">//配合maxLength一起使用，在达到最大长度时是否阻止输入</span></span><br><span class="line">  <span class="keyword">this</span>.onChanged, <span class="comment">//输入文本发生变化时的回调</span></span><br><span class="line">  <span class="keyword">this</span>.onEditingComplete, <span class="comment">//点击键盘完成按钮时触发的回调，该回调没有参数，()&#123;&#125;</span></span><br><span class="line">  <span class="keyword">this</span>.onSubmitted, <span class="comment">//同样是点击键盘完成按钮时触发的回调，该回调有参数，参数即为当前输入框中的值。(String)&#123;&#125;</span></span><br><span class="line">  <span class="keyword">this</span>.inputFormatters, <span class="comment">//对输入文本的校验</span></span><br><span class="line">  <span class="keyword">this</span>.enabled, <span class="comment">//输入框是否可用</span></span><br><span class="line">  <span class="keyword">this</span>.cursorWidth = <span class="number">2.0</span>, <span class="comment">//光标的宽度</span></span><br><span class="line">  <span class="keyword">this</span>.cursorRadius, <span class="comment">//光标的圆角</span></span><br><span class="line">  <span class="keyword">this</span>.cursorColor, <span class="comment">//光标的颜色</span></span><br><span class="line">  <span class="keyword">this</span>.keyboardAppearance,</span><br><span class="line">  <span class="keyword">this</span>.scrollPadding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span><br><span class="line">  <span class="keyword">this</span>.enableInteractiveSelection,</span><br><span class="line">  <span class="keyword">this</span>.onTap, <span class="comment">//点击输入框时的回调()&#123;&#125;</span></span><br><span class="line">  <span class="keyword">this</span>.buildCounter,</span><br><span class="line">  <span class="keyword">this</span>.scrollPhysics,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>TextField最简单的使用方法就是无参数调用，你可以看到上面的参数，没有一个参数是必传的。但是，没有经过修饰的输入框真的好丑。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190704145803.png" alt="无参数调用"></p>
<p>但是问题来了，我们只是输入，但是我们怎么获取到输入的值呢？这时候就需要用到 <code>controller</code> 属性，也难怪会排在最前面。</p>
<p>两种方法</p>
<h2 id="使用-controller-进行监听"><a href="#使用-controller-进行监听" class="headerlink" title="使用 controller 进行监听"></a>使用 controller 进行监听</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GetInputValueState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">GetInputValue</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _controllerValue;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    TextEditingController controller = TextEditingController();</span><br><span class="line">    controller.addListener(()&#123;</span><br><span class="line">      <span class="built_in">print</span>(controller.text);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          TextField(</span><br><span class="line">            controller: controller,</span><br><span class="line">          ),</span><br><span class="line">          TextField(</span><br><span class="line">            onChanged: (text)&#123;</span><br><span class="line">              setState(() &#123;</span><br><span class="line">                _controllerValue = text;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">          Text(_controllerValue == <span class="keyword">null</span> ? <span class="string">"输入框没有值"</span> : _controllerValue),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法有几个问题需要注意：</p>
<ol>
<li>用于常用的获取值与赋值的操作</li>
<li>在使用 <code>controller.addListener</code> 的时候，我无法在里面设置 setState 方法修改状态，或者说是达不到预期的效果。因为如果在 <code>controller.addListener</code> 里面设置了 <code>setState</code> 方法，每一次状态值都会更新两次，第一次是输入的值，第二次则是清空的值。所以，如果要使用这种方式，那么你可能是要直接处理这个值，用于搜索接口的调用，而不是进行数据绑定。</li>
</ol>
<h2 id="使用-onChange-方法"><a href="#使用-onChange-方法" class="headerlink" title="使用 onChange 方法"></a>使用 onChange 方法</h2><p>同样是上面的代码，我把它提取出来</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  onChanged: (text)&#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _controllerValue = text;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p>这样的好处就是我可以获取数据并且能够进行数据双向绑定。</p>
<h2 id="decoration-》-InputDecoration"><a href="#decoration-》-InputDecoration" class="headerlink" title="decoration ==》 InputDecoration"></a>decoration ==》 InputDecoration</h2><p><code>decoration</code> 用于对输入框进行样式修饰，这个属性很重要，下面图中的修饰都是使用了 <code>decoration</code></p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190704172610.png" alt="使用 decoration 对输入框进行修饰"></p>
<p>我们来看看源码<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:fluttertoast/fluttertoast.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(InuptStyle());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InuptStyle</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  InuptStyle(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  _InuptStyleState createState() =&gt; _InuptStyleState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InuptStyleState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">InuptStyle</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 输入字数限制</span></span><br><span class="line">  <span class="keyword">var</span> _inputLength = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> _maxWords = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          TextField(</span><br><span class="line">            decoration: InputDecoration(</span><br><span class="line">              icon: Icon(Icons.person),</span><br><span class="line">              labelText: <span class="string">'手机号'</span>,</span><br><span class="line">              labelStyle: TextStyle(</span><br><span class="line">                color: Colors.red</span><br><span class="line">              ),</span><br><span class="line">              helperText: <span class="string">"用于下方的提示：请输入手机号"</span>,</span><br><span class="line">              prefixText: <span class="string">"+86"</span></span><br><span class="line">            ),</span><br><span class="line">            textInputAction: TextInputAction.next,</span><br><span class="line">            keyboardType: TextInputType.phone</span><br><span class="line">          ),</span><br><span class="line">          TextField(</span><br><span class="line">            decoration: InputDecoration(</span><br><span class="line">              icon: Icon(Icons.lock),</span><br><span class="line">              labelText: <span class="string">'密码'</span>,</span><br><span class="line">              <span class="comment">// 帮助信息</span></span><br><span class="line">              helperText: <span class="string">"用于下方的提示：请输入密码"</span>,</span><br><span class="line">              helperStyle: TextStyle(</span><br><span class="line">                color: Colors.green</span><br><span class="line">              ),</span><br><span class="line">              hintText: <span class="string">"输入框的提示文字"</span>,</span><br><span class="line">              suffixIcon: Icon(Icons.remove_red_eye)</span><br><span class="line">            ),</span><br><span class="line">            keyboardType: TextInputType.text</span><br><span class="line">          ),</span><br><span class="line">          TextField(</span><br><span class="line">            decoration: InputDecoration(</span><br><span class="line">              <span class="comment">// border 还有一个 UnderlineInputBorder 就是默认的</span></span><br><span class="line">              <span class="comment">// InputBorder.none 可以设置为没有边框，可以去掉边框</span></span><br><span class="line">              border: OutlineInputBorder(</span><br><span class="line">                borderSide: BorderSide(</span><br><span class="line">                  color: Colors.red,</span><br><span class="line">                  width: <span class="number">10</span></span><br><span class="line">                )</span><br><span class="line">              ),</span><br><span class="line">              icon: Icon(Icons.recent_actors),</span><br><span class="line">              labelText: <span class="string">'输入字数限制'</span>,</span><br><span class="line">              hintText: <span class="string">"输入框的提示文字"</span>,</span><br><span class="line">              suffixIcon: Icon(Icons.remove_red_eye),</span><br><span class="line">              <span class="comment">// 右下角显示输入的字数</span></span><br><span class="line">              counterText: <span class="string">"<span class="subst">$_inputLength</span>/<span class="subst">$_maxWords</span>"</span></span><br><span class="line">            ),</span><br><span class="line">            maxLength: _maxWords,</span><br><span class="line">            onChanged: (text)&#123;</span><br><span class="line">              <span class="keyword">if</span>( text.length &gt; <span class="number">16</span> )&#123;</span><br><span class="line">                Fluttertoast.showToast(</span><br><span class="line">                  msg: <span class="string">"输入超出长度限制"</span></span><br><span class="line">                );</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  _inputLength = text.length;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            keyboardType: TextInputType.text</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体的说明就不多说了，常用的属性也就是上面涉及到的属性</p>
<p>关于 <code>TextField</code> 的其他的属性，可以自己尝试一下，比如自动聚焦，光标设置等等，在最上面的属性列表中都有注释，可以自行研究。</p>
<p>最近工作有点忙，加上要准备自考了，没有太多时间来写博客写文章，或者说很多东西可能没有涉及到，讲的不是很清楚，欢迎在下方留言，有时间我们一起探讨。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>react项目打包优化</title>
    <url>/%E6%8A%80%E6%9C%AF/react%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96.html</url>
    <content><![CDATA[<p>新公司所有的项目基本上都是使用 <code>react</code> 进行开发，之前的工程师是自己使用 <code>webpack</code> 搭建的项目，因为涉及到的东西不多，而且存在一些问题，已经启用。同时因为项目时间原因没有太多时间自己搭建，而且自己较懒，所以选择了使用 <code>create-react-app</code> 进行项目的开发。</p>
<p>其实开发还是很简单的，主要就是优化的问题，这篇文章主要就是讲关于页面优化的问题，同时也是为了记录一下，避免下次使用的时候在到处找（因为之前写过，最近一次项目又去找之前的配置去了）</p>
<p><img src="http://img.mp.itc.cn/upload/20170302/bb44075a48c0425dbb3277b19b612151_th.jpeg" alt="工作使我快乐"></p>
<h2 id="问题产生原因"><a href="#问题产生原因" class="headerlink" title="问题产生原因"></a>问题产生原因</h2><p>使用 create-react-app 打包项目后，本地运行还可以，但是在服务器上面特别的卡，看了一下文件大小。一个JS文件，打包出来有1.4M的大小</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190629090900.png" alt="打包后的文件大小"></p>
<p>这样大的js可能真的有点大了。包括打包后的CSS文件也有500多KB。这两个文件都很大，用户在访问浏览器请求数据的时候这两个文件请求的时间较长，加上使用react的原意，造成首次加载的时候大部分时间页面是白屏的。这里我们怎么优化呢？</p>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p>第一次看见按需加载这个词的时候是在使用 <a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Ant Design</a> 的时候。获取是因为我比较落后吧，之前一直都不知道这个东西，但是学习永远不要嫌晚，不然你会没有动力的。它里面讲到了为什么要使用按需加载：如果我们在使用一个组件的时候，默认是没有样式的，需要把样式也引用进来才会生效。但是如果你在使用 antd 的时候，用的组件并不多，可是却引入了全部的样式，所以会导致打包出来的文件特别的大。怎么解决呢？如果你使用了 antd ，那么官网上面已经有了很好的说明。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> react-app-rewired customize-cra</span></span><br></pre></td></tr></table></figure>
<p>因为这里讲的是使用 create-react-app 创建的项目，此时我们需要对 create-react-app 的默认配置进行自定义，这里我们使用 <a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener">react-app-rewired</a> （一个对 create-react-app 进行自定义配置的社区解决方案）。</p>
<p>引入 react-app-rewired 并修改 package.json 里的启动配置。由于新的 <a href="mailto:react-app-rewired@2.x" target="_blank" rel="noopener">react-app-rewired@2.x</a> 版本的关系，你还需要安装 <a href="https://github.com/timarney/react-app-rewired#alternatives" target="_blank" rel="noopener">customize-cra</a>。</p>
<p>将默认的 package.json 里面的 scripts 代码修改为一下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "react-app-rewired start",</span><br><span class="line">  "build": "react-app-rewired build",</span><br><span class="line">  "test": "react-app-rewired test",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在根目录创建一个 <code>config-overrides.js</code> 用于修改默认配置。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config, env</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do stuff with the webpack config...</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用-babel-plugin-import"><a href="#使用-babel-plugin-import" class="headerlink" title="使用 babel-plugin-import"></a>使用 babel-plugin-import</h3><p><a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a> 是一个用于按需加载组件代码和样式的 babel 插件（原理），现在我们尝试安装它并修改 <code>config-overrides.js</code> 文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; override, fixBabelImports &#125; = <span class="built_in">require</span>(<span class="string">'customize-cra'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addCustom = <span class="function"><span class="params">()</span> =&gt;</span> config =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> plugins = []</span><br><span class="line"></span><br><span class="line">  config.plugins = [...config.plugins, ...plugins]</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  webpack: override(</span><br><span class="line">    addCustom(),</span><br><span class="line">    fixBabelImports(<span class="string">'import'</span>, &#123;</span><br><span class="line">      libraryName: <span class="string">'antd'</span>,</span><br><span class="line">      libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">      style: <span class="string">'css'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码经过一些处理，可以添加一部分其他的 Plugin。</p>
<p>antd 官网上面有这样的一段说明</p>
<blockquote>
<p>注意：antd 默认支持基于 ES module 的 tree shaking，js 代码部分不使用这个插件也会有按需加载的效果。</p>
</blockquote>
<p>所以，在你使用 <code>import { Button } from &#39;antd&#39;;</code> 这种语法的时候可以不用这个插件。但是如果你是用的是 <code>import Button from &#39;antd/es/button&#39;;</code> 这种语法，那么就需要了。同时可以不用引入整个CSS静态文件了。</p>
<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>使用react开发一般使用的路由模块都是<code>react-router-dom</code>这个插件。当然，如果你使用其他的插件，我想应该也是可以的，不过具体的用法可能需要你自己探索。</p>
<p>正常情况下在使用路由的时候，你多半是按照下面的代码进行配置的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Suspense &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Loading &#125; <span class="keyword">from</span> <span class="string">'../components/common'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../components'</span></span><br><span class="line"><span class="keyword">import</span> Download <span class="keyword">from</span> <span class="string">'../components/download/'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../components/login'</span></span><br><span class="line"><span class="keyword">import</span> Prize <span class="keyword">from</span> <span class="string">'../components/prize'</span></span><br><span class="line"><span class="keyword">import</span> News <span class="keyword">from</span> <span class="string">'../components/news'</span></span><br><span class="line"><span class="keyword">import</span> NewsDetail <span class="keyword">from</span> <span class="string">'../components/news/detail'</span></span><br><span class="line"><span class="keyword">import</span> Support <span class="keyword">from</span> <span class="string">'../components/support'</span></span><br><span class="line"><span class="keyword">import</span> Me <span class="keyword">from</span> <span class="string">'../components/me'</span></span><br><span class="line"><span class="keyword">import</span> Pay <span class="keyword">from</span> <span class="string">'../components/pay'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  <span class="comment">// 使用 BrowserRouter 的 basename 确保在服务器上也可以运行 basename 为服务器上面文件的路径</span></span><br><span class="line">  &lt;BrowserRouter basename=<span class="string">'/'</span>&gt;</span><br><span class="line">    &lt;Route path=<span class="string">'/'</span> exact component=&#123;Home&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">'/download'</span> exact component=&#123;Download&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">'/prize'</span> exact component=&#123;Prize&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">'/news'</span> exact component=&#123;News&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">'/news/detail'</span> exact component=&#123;NewsDetail&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">'/support'</span> exact component=&#123;Support&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">'/me'</span> component=&#123;Me&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">'/pay'</span> component=&#123;Pay&#125; /&gt;</span><br><span class="line">    &lt;Login /&gt;</span><br><span class="line">  &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 因为使用了多语言配置，react-i18next 邀请需要返回一个函数</span></span><br><span class="line"><span class="regexp">export default function Main() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Suspense fallback=&#123;&lt;Loading /</span>&gt;&#125;&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种写法也是官网上面的写法。这样写可以，但是有一个问题，就是上面的所有引入也会直接打包在 <code>bundle.js</code> 里面，导致整个js与CSS特别的大。这里我们可以做路由的懒加载：即这个路由页面在使用到的时候在进行引入加载，而不是一开始就加载。有点类似于上面所说的按需加载</p>
<p><span style="color: red;">修改于 2019年11月14日</span></p>
<p><code>react 16.8 已经提供 React.lazy 方法实现路由懒加载。</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Suspense &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Loading &#125; <span class="keyword">from</span> <span class="string">'../components/common'</span></span><br><span class="line"></span><br><span class="line">+ <span class="keyword">const</span> Home = React.lazy(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@pages/home'</span>))</span><br><span class="line">+ <span class="keyword">const</span> Download =  React.lazy(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@pages/download/'</span>))</span><br><span class="line">+ <span class="keyword">const</span> Login = React.lazy(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@containers/Login/SetIsShowLoginModal'</span>))</span><br><span class="line">+ <span class="keyword">const</span> Prize = React.lazy(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@pages/prize'</span>))</span><br><span class="line">+ <span class="keyword">const</span> News = React.lazy(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@pages/news'</span>))</span><br><span class="line">+ <span class="keyword">const</span> NewsDetail = React.lazy(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@pages/news/detail'</span>))</span><br><span class="line">+ <span class="keyword">const</span> Support = React.lazy(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@pages/support'</span>))</span><br><span class="line">+ <span class="keyword">const</span> GameRoom = React.lazy(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@pages/GameRoom'</span>))</span><br><span class="line">+ <span class="keyword">const</span> Me = React.lazy(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@pages/me'</span>))</span><br><span class="line"></span><br><span class="line">- <span class="keyword">const</span> Home = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components'</span>))</span><br><span class="line">- <span class="keyword">const</span> Download =  asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/download/'</span>))</span><br><span class="line">- <span class="keyword">const</span> Login = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/login'</span>))</span><br><span class="line">- <span class="keyword">const</span> Prize = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/prize'</span>))</span><br><span class="line">- <span class="keyword">const</span> News = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/news'</span>))</span><br><span class="line">- <span class="keyword">const</span> NewsDetail = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/news/detail'</span>))</span><br><span class="line">- <span class="keyword">const</span> Support = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/support'</span>))</span><br><span class="line">- <span class="keyword">const</span> Me = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/me'</span>))</span><br><span class="line">- <span class="keyword">const</span> Pay = asyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/pay'</span>))</span><br><span class="line"></span><br><span class="line">- <span class="comment">// 异步按需加载component</span></span><br><span class="line">- <span class="function"><span class="keyword">function</span> <span class="title">asyncComponent</span>(<span class="params">getComponent</span>) </span>&#123;</span><br><span class="line">-   <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">-     <span class="keyword">static</span> Component = <span class="literal">null</span>;</span><br><span class="line">-     state = &#123; <span class="attr">Component</span>: AsyncComponent.Component &#125;;</span><br><span class="line"></span><br><span class="line">-     componentDidMount() &#123;</span><br><span class="line">-       <span class="keyword">if</span> (!<span class="keyword">this</span>.state.Component) &#123;</span><br><span class="line">-         getComponent().then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: Component &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">-           AsyncComponent.Component = Component</span><br><span class="line">-           <span class="keyword">this</span>.setState(&#123; Component &#125;)</span><br><span class="line">-         &#125;)</span><br><span class="line">-       &#125;</span><br><span class="line">-     &#125;</span><br><span class="line">-     <span class="comment">//组件将被卸载</span></span><br><span class="line">-     componentWillUnmount() &#123;</span><br><span class="line">-       <span class="comment">//重写组件的setState方法，直接返回空</span></span><br><span class="line">-       <span class="keyword">this</span>.setState = <span class="function">(<span class="params">state, callback</span>) =&gt;</span> &#123;</span><br><span class="line">-         <span class="keyword">return</span>;</span><br><span class="line">-       &#125;;</span><br><span class="line">-     &#125;</span><br><span class="line">-     render() &#123;</span><br><span class="line">-       <span class="keyword">const</span> &#123; Component &#125; = <span class="keyword">this</span>.state</span><br><span class="line">-       <span class="keyword">if</span> (Component) &#123;</span><br><span class="line">-         <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">-       &#125;</span></span><br><span class="line"><span class="xml">-       return null</span></span><br><span class="line"><span class="xml">-     &#125;</span></span><br><span class="line"><span class="xml">-   &#125;</span></span><br><span class="line"><span class="xml">- &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const App = () =&gt; (</span></span><br><span class="line"><span class="xml">  // 使用 BrowserRouter 的 basename 确保在服务器上也可以运行 basename 为服务器上面文件的路径</span></span><br><span class="line">  &lt;BrowserRouter basename='/'&gt;</span><br><span class="line">    &lt;Route path='/' exact component=&#123;Home&#125; /&gt;</span><br><span class="line">    &lt;Route path='/download' exact component=&#123;Download&#125; /&gt;</span><br><span class="line">    &lt;Route path='/prize' exact component=&#123;Prize&#125; /&gt;</span><br><span class="line">    &lt;Route path='/news' exact component=&#123;News&#125; /&gt;</span><br><span class="line">    &lt;Route path='/news/detail' exact component=&#123;NewsDetail&#125; /&gt;</span><br><span class="line">    &lt;Route path='/support' exact component=&#123;Support&#125; /&gt;</span><br><span class="line">    &lt;Route path='/me' component=&#123;Me&#125; /&gt;v</span><br><span class="line">    &lt;Route path='/pay' component=&#123;Pay&#125; /&gt;</span><br><span class="line">    &lt;Login /&gt;</span><br><span class="line">  &lt;/BrowserRouter&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 因为使用了多语言配置，react-i18next 邀请需要返回一个函数</span><br><span class="line">export default function Main() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面编写了一个一步加载路由的方法 <code>asyncComponent</code>。方法接收一个函数，这个函数可以从上面的引入看到，是返回一个 <code>import</code> 的函数。<code>import &#39;XXX&#39;</code> 最后返回的是一个Promise，所以下面使用了 <code>.then()</code> 方法。之后就是修改这个组件了。不过需要注意的是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; Component &#125; = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="keyword">if</span> (Component) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  return null</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>render</code> 中如果 <code>Component</code> 是null。即还没有引入的时候，返回的是一个null</p>
<p>因为返回一个null，所以会有一个闪屏，第二次加载的时候就没有了。这里可以做一个Loading。不过想过可能不大，或者说设置一个定时器延时修改Component状态，或许效果就不那么明显了。这个这样做的好处就是可以把异步加载的这些组件的js以及CSS单独的打包出来，这样就不用一次加载过大的js文件了。</p>
<p>这也和之前讲到的<a href="https://blog.lyt007.cn/技术/桌面浏览器前端优化策略.html">桌面浏览器前端优化策略</a>中说到的<code>消除阻塞页面渲染的CSS以及Javascript</code>和<code>避免运行耗时的 Javascript</code>中说到的相符合。</p>
<h2 id="使用SSR渲染"><a href="#使用SSR渲染" class="headerlink" title="使用SSR渲染"></a>使用SSR渲染</h2><p>使用SSR渲染不仅可以对SEO优化有一定的帮助，同时，还可以对react项目首屏优化的项目有一定的优化作用，所以，如果有需要，可以采用SSR渲染的模式进行开发。关于SSR渲染你可以自己在create-react-app项目中写同构应用，也可以使用现有的服务端渲染的框架，如 <a href="http://nextjs.frontendx.cn/" target="_blank" rel="noopener">nextjs</a>等。这里不做过多说明。</p>
<h2 id="补充-2019-07-16-10-00-54"><a href="#补充-2019-07-16-10-00-54" class="headerlink" title="补充 2019-07-16 10:00:54"></a>补充 2019-07-16 10:00:54</h2><h3 id="webpack-提取公共代码"><a href="#webpack-提取公共代码" class="headerlink" title="webpack 提取公共代码"></a>webpack 提取公共代码</h3><p>webpack打包<strong>自带了</strong>提供公共代码的功能，在<code>webpack 3</code>中可以使用 <code>CommonsChunkPlugin</code> 进行公共代码的提取，使用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 plugin 中添加，下面代码是提取 node_modules 里面的代码</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name:<span class="string">'vender'</span>, <span class="comment">// 提取出来的JS的文件的名字，注意不要.js后缀</span></span><br><span class="line">  minChunks: <span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this assumes your vendor imports exist in the node_modules directory</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.context &amp;&amp; <span class="built_in">module</span>.context.includes(<span class="string">'node_modules'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>具体的使用可以查看 <a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener">https://webpack.js.org/plugins/commons-chunk-plugin/</a></p>
<p>上面的是 <code>webpack 3</code> 的使用方法。在 <code>webpack 4</code> 中，配置发生了改变。</p>
<p>在 <code>webpack 4</code> 中，提取代码不在放在 <code>plugin</code> 数组下面，而是单独成为了一个属性（与plugin同级了）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">optimization.splitChunks = &#123;</span><br><span class="line">  <span class="comment">// 修改于2020年4月23日16:45:14</span></span><br><span class="line">  -  cacheGroups:  &#123;</span><br><span class="line">  -    <span class="comment">// 其次: 打包业务中公共代 码</span></span><br><span class="line">  -    common:  &#123;</span><br><span class="line">  -      name: <span class="string">"common"</span> ,</span><br><span class="line">  -      chunks: <span class="string">"all"</span> ,</span><br><span class="line">  -      minSize: <span class="number">1</span> ,</span><br><span class="line">  -      priority:  <span class="number">0</span></span><br><span class="line">  -    &#125; ,</span><br><span class="line">  -    <span class="comment">// 首先: 打包node_modules中的文 件</span></span><br><span class="line">  -    vender:  &#123;</span><br><span class="line">  -      name: <span class="string">"vendor"</span> ,</span><br><span class="line">  -      test: <span class="regexp">/[\\/]node_modules[\\/]/</span> ,</span><br><span class="line">  -      chunks: <span class="string">"all"</span> ,</span><br><span class="line">  -      priority: <span class="number">1</span> <span class="number">0</span></span><br><span class="line">  -     &#125;</span><br><span class="line">  -  &#125; ,</span><br><span class="line">    <span class="comment">// 修改后</span></span><br><span class="line">  +  cacheGroups: &#123;</span><br><span class="line">  +    vendors: &#123;</span><br><span class="line">  +      test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">  +      name: <span class="string">'vendors'</span>,</span><br><span class="line">  +      minSize: <span class="number">50000</span>,</span><br><span class="line">  +      minChunks: <span class="number">1</span>,</span><br><span class="line">  +      chunks: <span class="string">'initial'</span>,</span><br><span class="line">  +      priority: <span class="number">1</span>, <span class="comment">// 该配置项是设置处理的优先级，数值越大越优先处理，处理后优先级低的如果包含相同模块则不再处理</span></span><br><span class="line">  +    &#125;,</span><br><span class="line">  +    commons: &#123;</span><br><span class="line">  +      test: <span class="regexp">/[\\/]src[\\/]/</span>,</span><br><span class="line">  +      name: <span class="string">'commons'</span>,</span><br><span class="line">  +      minSize: <span class="number">50000</span>,</span><br><span class="line">  +      minChunks: <span class="number">2</span>,</span><br><span class="line">  +      chunks: <span class="string">'initial'</span>,</span><br><span class="line">  +      priority: <span class="number">-1</span>,</span><br><span class="line">  +      reuseExistingChunk: <span class="literal">true</span>, <span class="comment">// 这个配置允许我们使用已经存在的代码块</span></span><br><span class="line">  +    &#125;,</span><br><span class="line">  +    antdDesign: &#123;</span><br><span class="line">  +      name: <span class="string">'antd-design'</span>, <span class="comment">// 单独将 antd-design 拆包</span></span><br><span class="line">  +      priority: <span class="number">20</span>, </span><br><span class="line">  +      test: <span class="regexp">/[\\/]node_modules[\\/]@ant-design[\\/]/</span>,</span><br><span class="line">  +      chunks: <span class="string">'all'</span>,</span><br><span class="line">  +    &#125;,</span><br><span class="line">  +    lodash: &#123;</span><br><span class="line">  +      name: <span class="string">'lodash'</span>, <span class="comment">// 单独将 lodash 拆包</span></span><br><span class="line">  +      priority: <span class="number">20</span>, </span><br><span class="line">  +      test: <span class="regexp">/[\\/]node_modules[\\/]lodash[\\/]/</span>,</span><br><span class="line">  +      chunks: <span class="string">'all'</span>,</span><br><span class="line">  +    &#125;,</span><br><span class="line">  +    reactLib: &#123;</span><br><span class="line">  +      name: <span class="string">'react-lib'</span>, <span class="comment">// 单独将 lodash 拆包</span></span><br><span class="line">  +      priority: <span class="number">20</span>, </span><br><span class="line">  +      test: <span class="regexp">/[\\/]node_modules[\\/](react|react-dom|react-router-dom)[\\/]/</span>,</span><br><span class="line">  +      chunks: <span class="string">'all'</span>,</span><br><span class="line">  +    &#125;,</span><br><span class="line">  +  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cacheGroups</code> 下面添加你要提取的代码的属性，<code>vender</code> 一般提取的就是 <code>node_modules</code> 目录中的js代码，而且<code>node_modules</code>中插件的版本不会轻易的变化，这样，这个 vender 就可以一直缓存在浏览器中，除非特殊情况发生。你可可以添加其他的，有限打包权使用<code>priority</code>区分就行，权重越高，越优先打包。具体的其他的属性配置查看<a href="https://webpack.js.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener">https://webpack.js.org/plugins/split-chunks-plugin/</a></p>
<p>关于<code>cacheGroups</code>的理解可以看 <a href="https://www.cnblogs.com/kwzm/p/10315080.html" target="_blank" rel="noopener">理解webpack4.splitChunks之cacheGroups</a> </p>
<h3 id="使用-webpack-bundle-analyzer"><a href="#使用-webpack-bundle-analyzer" class="headerlink" title="使用 webpack-bundle-analyzer"></a>使用 webpack-bundle-analyzer</h3><p>使用 <code>webpack-bundle-analyzer</code> 对现有项目打包文件进行分析</p>
<p>安装 <code>webpack-bundle-analyzer</code> 插件</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> -D webpack-bundle-analyzer</span></span><br></pre></td></tr></table></figure>
<p>使用就直接在 plugin 中添加插件使用即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">"webpack-bundle-analyzer"</span>).BundleAnalyzerPlugin;</span><br><span class="line"><span class="keyword">new</span> BundleAnalyzerPlugin();</span><br></pre></td></tr></table></figure>
<p>打包后你会看到如下分析图</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190716103744.png" alt="打包后的分析图"></p>
<p>如果有过大的文件，可以继续进行拆分</p>
<h2 id="补充-2019-11-13"><a href="#补充-2019-11-13" class="headerlink" title="补充 2019-11-13"></a>补充 2019-11-13</h2><h3 id="大型库外链"><a href="#大型库外链" class="headerlink" title="大型库外链"></a>大型库外链</h3><p>通过上面的打包后的分析图可以看出来总的大小是1.58M，vendorjs是1.37M。其他的都是几十K，如果是通过gzip压缩，那么大小在合理的范围内。但是那个1.37M的就过于庞大了。这时候在看看图上面。大的区域有</p>
<ul>
<li>ant-design</li>
<li>firebase</li>
<li>react-dom</li>
<li>swiper</li>
<li>momentjs</li>
<li>etc……</li>
</ul>
<p>这个时候，可以将一些大型库外链。即通过script的方式引入这些库。</p>
<p>webpack 提供了一个属性 <code>externals</code> 可以配置我们需要外链的库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  config.externals = &#123;</span><br><span class="line">    <span class="string">"react"</span>: <span class="string">"React"</span>,</span><br><span class="line">    <span class="string">"react-dom"</span>: <span class="string">"ReactDOM"</span>,</span><br><span class="line">    <span class="string">"Swiper"</span>: <span class="string">"swiper"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我配置了外链react，react-dom，swiper三个库</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.production.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/Swiper/4.5.0/js/swiper.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/Swiper/4.5.0/css/swiper.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，是打包的时候添加外链，<code>externals</code> 属性与entry，output属于同级。</p>
<p>这样处理后，打包就不会把需要外链的库打包进去</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20191113152444.png" alt="使用 externals 后"></p>
<p>至于 ant-design ，因为配置了按需加载，可以不用使用外链。</p>
<h3 id="合理使用第三方模块"><a href="#合理使用第三方模块" class="headerlink" title="合理使用第三方模块"></a>合理使用第三方模块</h3><p>上面看到有一个momentjs还是挺大的。但是我的项目中使用momentjs就是用来处理了时间格式，仅仅是着一个小功能就用这样大的一个库，确实是有一点过分了。所以合理的选择第三方库也是一个优化办法。最终我把 <a href="https://www.npmjs.com/package/moment" target="_blank" rel="noopener">momentjs</a> 替换成了 <a href="https://www.npmjs.com/package/dateformat" target="_blank" rel="noopener">dateformat</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">补充于2020年4月23日16:54:45</span><br><span class="line"></span><br><span class="line">momentjs 可以 替换成 [dayjs](https://github.com/iamkun/dayjs)</span><br></pre></td></tr></table></figure>
<p>这样处理后，既解决了问题，有减少了不必要的处理。</p>
<h3 id="使用-HappyPack-和-DllPlugin"><a href="#使用-HappyPack-和-DllPlugin" class="headerlink" title="使用 HappyPack 和 DllPlugin"></a>使用 HappyPack 和 DllPlugin</h3><p>这个方法我这里还没有试过，不过网上有很多这方面的博客，需要的可以去google。以后用到了在进行补充</p>
<h2 id="现成-webpack-antd-react-的架子（补充于2020-4-23-16-59-20）"><a href="#现成-webpack-antd-react-的架子（补充于2020-4-23-16-59-20）" class="headerlink" title="现成 webpack+antd+react 的架子（补充于2020-4-23 16:59:20）"></a>现成 webpack+antd+react 的架子（补充于2020-4-23 16:59:20）</h2><p>写了一个 <code>webpack+antd+react</code> 的架子，可以查看 <a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/react-antd-webpack4%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6.html">react+antd+webpack4 构建项目框架</a> 。不断完善中……</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>create-react-app</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter lesson 7: Flutter组件之基础组件（三）</title>
    <url>/%E6%8A%80%E6%9C%AF/Flutter-lesson-7-Flutter%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89.html</url>
    <content><![CDATA[<p><a href="https://blog.lyt007.cn/技术/Flutter-lesson-6-Flutter组件之基础组件（二）.html">上一节</a>我们介绍了<code>Row, Column, Image, Text</code>四个基础组件，这一节我们来看看下面几个组件。</p>
<h1 id="Icon"><a href="#Icon" class="headerlink" title="Icon"></a>Icon</h1><p>Icon就是图标，字体图标，矢量图。在web前端中我们使用图标可以自己定义字体与SVG，使用<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里图标</a>上面的图标。在Flutter中，google则为我们集成了一些常用的图标。</p>
<p>看看Icon的属性有哪些<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Icon(</span><br><span class="line">  <span class="keyword">this</span>.icon, &#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.size,</span><br><span class="line">  <span class="keyword">this</span>.color,</span><br><span class="line">  <span class="keyword">this</span>.semanticLabel,</span><br><span class="line">  <span class="keyword">this</span>.textDirection,</span><br><span class="line">&#125;) : <span class="keyword">super</span>(key: key);</span><br></pre></td></tr></table></figure></p>
<p>我们能够用到的就是 <code>size</code> 与 <code>color</code> 两个属性，第一个是字体。使用<code>Icons</code>类。下面有很多图标。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: Column(</span><br><span class="line">  crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Icon(</span><br><span class="line">      Icons.speaker,</span><br><span class="line">      color: Colors.red,</span><br><span class="line">      size: <span class="number">100</span>,</span><br><span class="line">    ),Icon(</span><br><span class="line">      Icons.star_half,</span><br><span class="line">      color: Colors.blue,</span><br><span class="line">      size: <span class="number">100</span>,</span><br><span class="line">    ),Icon(</span><br><span class="line">      Icons.volume_up,</span><br><span class="line">      color: Colors.red,</span><br><span class="line">      size: <span class="number">100</span>,</span><br><span class="line">    )</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当然，这些都是 Flutter material 中自带的一些图标，如果我们需要自己定义图标怎么弄呢？这也是可以的，就像我们在web中使用 iconfont 一样。</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190620085952.png" alt="自定义的微信与QQ图标"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Icon(</span><br><span class="line">  MyIcons.weChat,</span><br><span class="line">  color: Colors.green,</span><br><span class="line">  size: <span class="number">100</span>,</span><br><span class="line">),Icon(</span><br><span class="line">  MyIcons.qq,</span><br><span class="line">  color: Colors.blue,</span><br><span class="line">  size: <span class="number">100</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面的代码中出现了 <code>MyIcons</code> 这个类。哪里来的呢？其实这个是我们自己创建的类，怎么创建的来看看。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIcons</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 微信图标</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> IconData weChat = <span class="keyword">const</span> IconData(</span><br><span class="line">    <span class="number">0xe63d</span>,</span><br><span class="line">    fontFamily: <span class="string">"MyIcons"</span>,</span><br><span class="line">    matchTextDirection: <span class="keyword">true</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> IconData qq = <span class="keyword">const</span> IconData(</span><br><span class="line">    <span class="number">0xe6ca</span>,</span><br><span class="line">    fontFamily: <span class="string">"MyIcons"</span>,</span><br><span class="line">    matchTextDirection: <span class="keyword">true</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MyIcons</code> 是我们自己创建的类，里面定义了两个Icon，一个名字是<code>weChat</code>，另一个是<code>qq</code>。使用的是<code>IconData</code>这个类创建，里面有三个参数。Icon的<code>Unicode</code>编码，这个在阿里图标上表示在这里</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190620090425.png" alt="Unicode"></p>
<p>我们把上面的 <strong>&amp;#</strong> 换成 0 就可以了。</p>
<p>fontFamily呢？是我们自己定义的字体</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190620090749.png" alt="配置字体"></p>
<p>字体呢就是我们在<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里图标</a>上面下载下来的文件。</p>
<p>这些就是关于 <code>Icon</code> 的简单介绍。</p>
<h1 id="RaisedButton"><a href="#RaisedButton" class="headerlink" title="RaisedButton"></a>RaisedButton</h1><p>其实这就是一个按钮，一个凸起的材质矩形的按钮。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RaisedButton(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="meta">@required</span> VoidCallback onPressed, <span class="comment">// 按钮点击事件，必选</span></span><br><span class="line">  ValueChanged&lt;<span class="built_in">bool</span>&gt; onHighlightChanged, <span class="comment">//水波纹高亮变化回调,按下返回true,抬起返回false 使用默认值就可以</span></span><br><span class="line">  ButtonTextTheme textTheme, <span class="comment">//按钮的主题</span></span><br><span class="line">  Color textColor, <span class="comment">//按钮文字的颜色</span></span><br><span class="line">  Color disabledTextColor, <span class="comment">//按钮禁用时候文字颜色</span></span><br><span class="line">  Color color, <span class="comment">//按钮背景色</span></span><br><span class="line">  Color disabledColor, <span class="comment">//按钮禁用时候背景色</span></span><br><span class="line">  Color highlightColor, <span class="comment">// 点击或者toch控件高亮的时候显示在控件上面，水波纹下面的颜色</span></span><br><span class="line">  Color splashColor, <span class="comment">//水波纹的颜色</span></span><br><span class="line">  Brightness colorBrightness, <span class="comment">//按钮主题高亮</span></span><br><span class="line">  <span class="built_in">double</span> elevation, <span class="comment">//按钮下面的阴影</span></span><br><span class="line">  <span class="built_in">double</span> highlightElevation, <span class="comment">//高亮时候的阴影</span></span><br><span class="line">  <span class="built_in">double</span> disabledElevation, <span class="comment">//禁用时候的阴影</span></span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line">  ShapeBorder shape, <span class="comment">//设置形状</span></span><br><span class="line">  Clip clipBehavior = Clip.none,</span><br><span class="line">  MaterialTapTargetSize materialTapTargetSize,</span><br><span class="line">  <span class="built_in">Duration</span> animationDuration,</span><br><span class="line">  Widget child, <span class="comment">// 子元素，一般是文字，如果是icon，有专门的icon图标</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>属性有很多，能用到的也就那么几个，大部分都是使用的默认值。</p>
<p>下面是<a href="https://github.com/tal007/FlutterApp" target="_blank" rel="noopener">App</a>中的源码<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: Column(</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    RaisedButton(</span><br><span class="line">      onPressed: () &#123;&#125;,</span><br><span class="line">      child: Text(<span class="string">"textColor文本的颜色，color背景颜色，highlightColor按钮按下的颜色"</span>),</span><br><span class="line">      textColor: Color(<span class="number">0xffff0000</span>),</span><br><span class="line">      color: Color(<span class="number">0xfff1f1f1</span>),</span><br><span class="line">      highlightColor: Color(<span class="number">0xff00ff00</span>),</span><br><span class="line">    ),</span><br><span class="line">    RaisedButton(</span><br><span class="line">      onPressed: () &#123;&#125;,</span><br><span class="line">      child: Text(<span class="string">"disabledTextColor禁用时文本颜色，disabledColor禁用时背景颜色"</span>),</span><br><span class="line">      disabledTextColor: Color(<span class="number">0xff999999</span>),</span><br><span class="line">      disabledColor: Color(<span class="number">0xffff0000</span>),</span><br><span class="line">    ),</span><br><span class="line">    RaisedButton(</span><br><span class="line">      onPressed: () &#123;&#125;,</span><br><span class="line">      child: Text(<span class="string">"splashColor水波的颜色，disabledColor禁用时背景颜色"</span>),</span><br><span class="line">      splashColor: Color(<span class="number">0xffff0000</span>),</span><br><span class="line">    ),</span><br><span class="line">    RaisedButton(</span><br><span class="line">      onPressed: () &#123;&#125;,</span><br><span class="line">      child: Text(<span class="string">"colorBrightness按钮主题高亮 Brightness.light"</span>),</span><br><span class="line">      colorBrightness: Brightness.light,</span><br><span class="line">    ),</span><br><span class="line">    RaisedButton(</span><br><span class="line">      onPressed: () &#123;&#125;,</span><br><span class="line">      child: Text(<span class="string">"colorBrightness按钮主题高亮 Brightness.dark"</span>),</span><br><span class="line">      colorBrightness: Brightness.dark,</span><br><span class="line">    ),</span><br><span class="line">    Container(</span><br><span class="line">      margin: EdgeInsets.only(top: <span class="number">20.0</span>),</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: () &#123;&#125;,</span><br><span class="line">        child: Text(</span><br><span class="line">            <span class="string">"elevation按钮下面的阴影,highlightElevation高亮时候的阴影,disabledElevation按下的时候的阴影"</span>),</span><br><span class="line">        elevation: <span class="number">5.0</span>,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    Container(</span><br><span class="line">      margin: EdgeInsets.only(top: <span class="number">20.0</span>),</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: () &#123;&#125;,</span><br><span class="line">        child: Text(</span><br><span class="line">            <span class="string">"elevation按钮下面的阴影,highlightElevation高亮时候的阴影,disabledElevation按下的时候的阴影"</span>),</span><br><span class="line">        highlightElevation: <span class="number">5</span>,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    Container(</span><br><span class="line">      margin: EdgeInsets.only(top: <span class="number">20.0</span>),</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: () &#123;&#125;,</span><br><span class="line">        child: Text(</span><br><span class="line">            <span class="string">"elevation按钮下面的阴影,highlightElevation高亮时候的阴影,disabledElevation按下的时候的阴影"</span>),</span><br><span class="line">        disabledElevation: <span class="number">5.0</span>,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    RaisedButton(</span><br><span class="line">      onPressed: () &#123;&#125;,</span><br><span class="line">      child: Text(</span><br><span class="line">          <span class="string">"onHighlightChanged 水波纹高亮变化回调,按下返回true,抬起返回false"</span>),</span><br><span class="line">      onHighlightChanged: (<span class="built_in">bool</span> b) =&gt; Fluttertoast.showToast(</span><br><span class="line">        msg: <span class="string">'<span class="subst">$b</span>'</span>,</span><br><span class="line">        toastLength: Toast.LENGTH_LONG,</span><br><span class="line">        fontSize: <span class="number">12</span></span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    RaisedButton(</span><br><span class="line">      onPressed: () =&gt; Fluttertoast.showToast(</span><br><span class="line">        msg: <span class="string">'你点击了按钮'</span>,</span><br><span class="line">        toastLength: Toast.LENGTH_LONG,</span><br><span class="line">        fontSize: <span class="number">12</span></span><br><span class="line">      ),</span><br><span class="line">      child: Text(<span class="string">"onPressed点击事件"</span>),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">)v</span><br></pre></td></tr></table></figure></p>
<p>就像上面的代码中看到的，除了<code>onPressed</code>是必选以外，其余的属性基本上用的不是特别的多，有一些没有涉及到的属性，有兴趣可以自己下来了解。</p>
<h1 id="Scaffold"><a href="#Scaffold" class="headerlink" title="Scaffold"></a>Scaffold</h1><p>之前简单提到过<code>Scaffold</code>，因为我们用到这个Widget的时候实在是太多了。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scaffold(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.appBar,</span><br><span class="line">  <span class="keyword">this</span>.body,</span><br><span class="line">  <span class="keyword">this</span>.floatingActionButton,</span><br><span class="line">  <span class="keyword">this</span>.floatingActionButtonLocation,</span><br><span class="line">  <span class="keyword">this</span>.floatingActionButtonAnimator,</span><br><span class="line">  <span class="keyword">this</span>.persistentFooterButtons,</span><br><span class="line">  <span class="keyword">this</span>.drawer,</span><br><span class="line">  <span class="keyword">this</span>.endDrawer,</span><br><span class="line">  <span class="keyword">this</span>.bottomNavigationBar,</span><br><span class="line">  <span class="keyword">this</span>.bottomSheet,</span><br><span class="line">  <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">  <span class="keyword">this</span>.resizeToAvoidBottomPadding,</span><br><span class="line">  <span class="keyword">this</span>.resizeToAvoidBottomInset,</span><br><span class="line">  <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line">  <span class="keyword">this</span>.drawerDragStartBehavior = DragStartBehavior.start,</span><br><span class="line">  <span class="keyword">this</span>.extendBody = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Scaffold</code>可以说是一个容器，里面可以设置很多地方的Widget，比如<code>AppBar</code>，<code>drawer</code>，<code>bottomNavigationBar</code>等等。下面的每一部分又有自己单独的设置方法。还是来看看怎么使用。</p>
<h2 id="AppBar"><a href="#AppBar" class="headerlink" title="AppBar"></a>AppBar</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AppBar(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.leading,</span><br><span class="line">  <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span><br><span class="line">  <span class="keyword">this</span>.title,</span><br><span class="line">  <span class="keyword">this</span>.actions,</span><br><span class="line">  <span class="keyword">this</span>.flexibleSpace,</span><br><span class="line">  <span class="keyword">this</span>.bottom,</span><br><span class="line">  <span class="keyword">this</span>.elevation,</span><br><span class="line">  <span class="keyword">this</span>.shape,</span><br><span class="line">  <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">  <span class="keyword">this</span>.brightness,</span><br><span class="line">  <span class="keyword">this</span>.iconTheme,</span><br><span class="line">  <span class="keyword">this</span>.actionsIconTheme,</span><br><span class="line">  <span class="keyword">this</span>.textTheme,</span><br><span class="line">  <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line">  <span class="keyword">this</span>.centerTitle,</span><br><span class="line">  <span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class="line">  <span class="keyword">this</span>.toolbarOpacity = <span class="number">1.0</span>,</span><br><span class="line">  <span class="keyword">this</span>.bottomOpacity = <span class="number">1.0</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>来看看AppBar中每一部分的布局，下面图片来自<a href="https://api.flutter.dev/flutter/material/AppBar-class.html" target="_blank" rel="noopener">Flutter官网</a></p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621084119.png" alt="AppBar"></p>
<h3 id="leading"><a href="#leading" class="headerlink" title="leading"></a>leading</h3><p>正如上面的图片中看到的，这个属性可以设置AppBar左侧的内容</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621083751.png" alt="leading"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">appBar: AppBar(</span><br><span class="line">  title: Text(<span class="string">'AppBar'</span>),</span><br><span class="line">  leading: IconButton(</span><br><span class="line">    onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">    icon: Icon(</span><br><span class="line">      Icons.nature</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p>这里设置的是一个 <code>nature</code> 图标，当然，你也可以设置其他的图标，或者是其他的Widget，文字，图片等等。</p>
<h3 id="automaticallyImplyLeading"><a href="#automaticallyImplyLeading" class="headerlink" title="automaticallyImplyLeading"></a>automaticallyImplyLeading</h3><p>官方的解释为</p>
<blockquote>
<p>Controls whether we should try to imply the leading widget if null</p>
</blockquote>
<p>我理解为：如果没有设置<code>leading</code>属性，是否需要将leading默认设置为<strong>null</strong>。左右可能就是做一个站位。默认是<em>true</em>，使用默认值就行。</p>
<h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><p>标题。不用多说。</p>
<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>正如上面的图片中看到的，这个属性可以设置AppBar中右侧的显示。上面图片中显示了三个，说明这是一个Widget List。</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621084945.png" alt="actions"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">actions: &lt;Widget&gt;[Icon(Icons.book), Icon(Icons.satellite),Center(child: Text(<span class="string">'action'</span>))]</span><br></pre></td></tr></table></figure>
<h3 id="flexibleSapce"><a href="#flexibleSapce" class="headerlink" title="flexibleSapce"></a>flexibleSapce</h3><p>这个最上面的图也有解释。整个AppBar相当于采用flex布局，flexibleSapce空间属于AppBar中除了整个空间。包含了leading，title以及bottom区间。值是一个Widget。</p>
<p>为什么这样说呢？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">flexibleSpace: Container(</span><br><span class="line">  color: Colors.green,</span><br><span class="line">  <span class="comment">// alignment: Alignment.center,</span></span><br><span class="line">  child: Text(<span class="string">"flexibleSpace"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面的代码中我们把<code>alignment</code>属性注释掉了，结果如下<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621085819.png" alt="alignment没有设置或者说是alignment使用了默认值"></p>
<p>接着我们取消注释</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621090056.png" alt="设置 alignment: Alignment.center 后"></p>
<p>这就是原因。不过这个属性好像不怎么用得着啊。整个AppBar可能用得多的地方就是leading，title和actions了吧。</p>
<h3 id="bottom"><a href="#bottom" class="headerlink" title="bottom"></a>bottom</h3><p>一个 AppBarBottomWidget 对象，通常是 TabBar。用来在 Toolbar 标题下面显示一个 Tab 导航栏</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">bottom: PreferredSize(</span><br><span class="line">  child: Text(<span class="string">'bottom区间'</span>),</span><br><span class="line">  preferredSize: Size.fromHeight(<span class="number">100</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621090513.png" alt="bottom"></p>
<p>你还可以在bottom中添加<code>TabBar</code>，这样就更加充分利用了bottom这个属性</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/1.gif" alt="在AppBar下面设置TabBar"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(ScaffoldInfo());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScaffoldInfo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  ScaffoldInfo(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(title),</span><br><span class="line">      ),</span><br><span class="line">      bottomNavigationBar: Text(<span class="string">'1'</span>),</span><br><span class="line">      body: Container(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">20</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">10</span>),</span><br><span class="line">        child: DefaultTabController(</span><br><span class="line">          length: <span class="number">6</span>,</span><br><span class="line">          child: Scaffold(</span><br><span class="line">            appBar: AppBar(</span><br><span class="line">              title: Text(<span class="string">'AppBar'</span>),</span><br><span class="line">              leading: IconButton(</span><br><span class="line">                onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">                icon: Icon(</span><br><span class="line">                  Icons.nature</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">              automaticallyImplyLeading: <span class="keyword">true</span>,</span><br><span class="line">              actions: &lt;Widget&gt;[Icon(Icons.book), Icon(Icons.satellite),Center(child: Text(<span class="string">'action'</span>))],</span><br><span class="line">              flexibleSpace: Container(</span><br><span class="line">                color: Colors.green,</span><br><span class="line">                alignment: Alignment.center, </span><br><span class="line">                child: Text(<span class="string">"flexibleSpace"</span>)</span><br><span class="line">              ),</span><br><span class="line">              bottom: TabBar(</span><br><span class="line">                isScrollable: <span class="keyword">true</span>,</span><br><span class="line">                tabs: &lt;Widget&gt;[</span><br><span class="line">                  Tab(text: <span class="string">'Tab 1'</span>),</span><br><span class="line">                  Tab(text: <span class="string">'Tab 2'</span>),</span><br><span class="line">                  Tab(text: <span class="string">'Tab 3'</span>),</span><br><span class="line">                  Tab(text: <span class="string">'Tab 4'</span>),</span><br><span class="line">                  Tab(text: <span class="string">'Tab 5'</span>),</span><br><span class="line">                  Tab(text: <span class="string">'Tab 6'</span>),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">              <span class="comment">// elevation: 20,</span></span><br><span class="line">              backgroundColor: Colors.red,</span><br><span class="line">              brightness: Brightness.dark,</span><br><span class="line">              <span class="comment">// centerTitle: true,</span></span><br><span class="line">            ),</span><br><span class="line">            body: TabBarView(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Center(child: Text(<span class="string">'Tab 1'</span>)),</span><br><span class="line">                Center(child: Text(<span class="string">'Tab 2'</span>)),</span><br><span class="line">                Center(child: Text(<span class="string">'Tab 3'</span>)),</span><br><span class="line">                Center(child: Text(<span class="string">'Tab 4'</span>)),</span><br><span class="line">                Center(child: Text(<span class="string">'Tab 5'</span>)),</span><br><span class="line">                Center(child: Text(<span class="string">'Tab 6'</span>)),</span><br><span class="line">              ],</span><br><span class="line">            )</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里收涉及到了<code>TabBar</code>以及<code>TabBarView</code>两个类。这里不多讲，需要注意的是这两个都需要设置一个<code>controller</code>属性，如果不设置，可以使用<code>DefaultTabController</code>创建默认的容器。</p>
<h3 id="elevation"><a href="#elevation" class="headerlink" title="elevation"></a>elevation</h3><p>这个属性是设置整个AppBar的阴影的大小，值是一个<code>double</code>。</p>
<p>下面是设置了<code>elevation: 20,</code>的前后对比，还是使用默认的就可以了</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621091021.png" alt="设置了 elevation: 20"></p>
<h3 id="backgroundColor"><a href="#backgroundColor" class="headerlink" title="backgroundColor"></a>backgroundColor</h3><p>AppBar的背景色。如果<code>flexibleSapce</code>设置了背景色，这个背景色将会被覆盖。</p>
<h3 id="brightness"><a href="#brightness" class="headerlink" title="brightness"></a>brightness</h3><p>AppBar的主题，有两个选择，<code>Brightness.dark</code> 或者 <code>Brightness.light</code>。</p>
<h3 id="centerTitle"><a href="#centerTitle" class="headerlink" title="centerTitle"></a>centerTitle</h3><p>标题是否居中显示，默认值根据不同的操作系统，显示方式不一样。安卓可能在左侧，IOS则是居中。</p>
<h2 id="body"><a href="#body" class="headerlink" title="body"></a>body</h2><p>主题内容区域，这个区域就不介绍了，body可以设置各种Widget。</p>
<h2 id="floatingActionButton"><a href="#floatingActionButton" class="headerlink" title="floatingActionButton"></a>floatingActionButton</h2><p>这是一个浮动按钮，注意参数就是一个child（一般是一个Icon），其次就是 onPressed 点击事件。其余的可以使用默认属性，或者你修改一下背景色等等。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FloatingActionButton(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.child,</span><br><span class="line">  <span class="keyword">this</span>.tooltip, <span class="comment">// 长按时显示的提示</span></span><br><span class="line">  <span class="keyword">this</span>.foregroundColor,</span><br><span class="line">  <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">  <span class="keyword">this</span>.heroTag = <span class="keyword">const</span> _DefaultHeroTag(), <span class="comment">//hero效果使用的tag,系统默认会给所有FAB使用同一个tag,方便做动画效果</span></span><br><span class="line">  <span class="keyword">this</span>.elevation,</span><br><span class="line">  <span class="keyword">this</span>.highlightElevation,</span><br><span class="line">  <span class="keyword">this</span>.disabledElevation,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onPressed,</span><br><span class="line">  <span class="keyword">this</span>.mini = <span class="keyword">false</span>,</span><br><span class="line">  <span class="keyword">this</span>.shape,</span><br><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none,</span><br><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span><br><span class="line">  <span class="keyword">this</span>.isExtended = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621143749.png" alt="FloatingActionButton"></p>
<p>在右下角增加一个浮动按钮<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">floatingActionButton: FloatingActionButton(</span><br><span class="line">  child: Icon(Icons.add),</span><br><span class="line">  onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure></p>
<h3 id="floatingActionButtonLocation"><a href="#floatingActionButtonLocation" class="headerlink" title="floatingActionButtonLocation"></a>floatingActionButtonLocation</h3><p>前面讲的是设置一个浮动按钮，这个浮动按钮的位置默认是在右下角。如果是要设置这个浮动按钮的位置，就需要用到<code>FloatingActionButtonLocation</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,</span><br></pre></td></tr></table></figure>
<h2 id="persistentFooterButtons"><a href="#persistentFooterButtons" class="headerlink" title="persistentFooterButtons"></a>persistentFooterButtons</h2><p>在footer设置一系列的button，值是一个Widget list</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">persistentFooterButtons: &lt;Widget&gt;[</span><br><span class="line">  Icon(Icons.satellite),</span><br><span class="line">  Icon(Icons.save),</span><br><span class="line">  Icon(Icons.share),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621144708.png" alt="persistentFooterButtons"></p>
<p>在设置<code>bottomNavigationBar</code>的时候，可能页面会很丑，我们可以放弃使用这个属性</p>
<h2 id="drawer-与-endDrawer"><a href="#drawer-与-endDrawer" class="headerlink" title="drawer 与 endDrawer"></a>drawer 与 endDrawer</h2><p>这两个都是抽屉盒子，<code>drawer</code>是从左往右滑动的时候出现，<code>endDrawer</code>是从右往左画的时候出现<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">drawer: Container(</span><br><span class="line">  child: Text(<span class="string">'drawer'</span>),</span><br><span class="line">),</span><br><span class="line">endDrawer: Container(</span><br><span class="line">  child: Text(<span class="string">'endDrawer'</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure></p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621145318.png" alt="drawer"></p>
<p>具体的内容还要自己实现。</p>
<h2 id="bottomNavigationBar"><a href="#bottomNavigationBar" class="headerlink" title="bottomNavigationBar"></a>bottomNavigationBar</h2><p>在底部设置一个导航组件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">bottomNavigationBar: BottomAppBar(</span><br><span class="line">  shape: CircularNotchedRectangle(),</span><br><span class="line">  child: Row(</span><br><span class="line">    children: [</span><br><span class="line">      IconButton(icon: Icon(Icons.home), onPressed: () =&gt; &#123;&#125;),</span><br><span class="line">      SizedBox(), <span class="comment">//中间位置空出</span></span><br><span class="line">      IconButton(icon: Icon(Icons.business), onPressed: () =&gt; &#123;&#125;),</span><br><span class="line">    ],</span><br><span class="line">    mainAxisAlignment: MainAxisAlignment.spaceAround, <span class="comment">//均分底部导航栏横向空间</span></span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621150005.png" alt="bottomNavigationBar"></p>
<p>可以看到这样出来的效果很丑，这是因为我们之前设置了<code>persistentFooterButtons</code>这个属性，占据了上面一部分空间。一般这个属性我们都不会设置的，我们把<code>persistentFooterButtons</code>属性注释掉在来看看。</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621150227.png" alt="去掉 persistentFooterButtons 后"></p>
<p>这样看起来好看多了。</p>
<h2 id="bottomSheet"><a href="#bottomSheet" class="headerlink" title="bottomSheet"></a>bottomSheet</h2><p>底部划出组件，一般很少直接使用，而是使用<code>showModalBottomSheet</code>弹出，比如从底部弹出分享框。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">floatingActionButton: FloatingActionButton(</span><br><span class="line">  child: Icon(Icons.add),</span><br><span class="line">  onPressed: () =&gt; showModalBottomSheet(</span><br><span class="line">    context: context,</span><br><span class="line">    builder: (BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">            height: <span class="number">300.0</span>,</span><br><span class="line">            child: Text(<span class="string">'弹出的东东'</span>),</span><br><span class="line">        );</span><br><span class="line">    &#125;,</span><br><span class="line">  ).then((val) &#123;</span><br><span class="line">    <span class="built_in">print</span>(val);</span><br><span class="line">  &#125;),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p>点击 + 按钮会弹出这个</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190621152122.png" alt="showModalBottomSheet"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Flutter的基础的组件就讲到这里，涉及到的大都是常用的组件，部分东西没有涉及到或者说没有详细说明，可能是因为我认为不用过多说明，可能是因为没有太多时间，也可能是因为我自己也不看明白，如果你不懂，我们可以一起探讨，在评论框留言，有问题我们一起探讨。</p>
<p>在下面的课程中，我们将会介绍一些Flutter的中高级的Widget。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>桌面浏览器前端优化策略</title>
    <url>/%E6%8A%80%E6%9C%AF/%E6%A1%8C%E9%9D%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5.html</url>
    <content><![CDATA[<p>在前端项目开发完成，我们肯定是需要对前端的项目进行测试优化。我们可以先用一些第三方工具对网站进行分析。工具例如</p>
<ul>
<li>YSlow：YaHoo发布的一款Firefox的浏览器插件</li>
<li><a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener">Google页面访问速度测试</a>，需要小飞机</li>
<li><a href="https://whatwg.org/validator/" target="_blank" rel="noopener">WHATWG Html 代码检测</a>，这个是关于HTML代码书写规范的检测，算作是补充</li>
<li>其他</li>
</ul>
<p>这些工具可以对网站的性能进行分析，并提相关的优化建议。</p>
<p>下图是博客在<a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener">Google页面访问速度测试</a>上面的分析结果以及优化建议，如果你是在做企业的项目，建议你按照上面的建议尽可能的进行优化</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190603231009.png" alt="结果分析"><br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190603231102.png" alt="优化建议"></p>
<p>那么我们需要说的优化策略总体上分为两大类</p>
<ul>
<li>网络加载类</li>
<li>页面渲染类</li>
</ul>
<h2 id="网络加载类"><a href="#网络加载类" class="headerlink" title="网络加载类"></a>网络加载类</h2><h3 id="减少HTTP请求次数"><a href="#减少HTTP请求次数" class="headerlink" title="减少HTTP请求次数"></a>减少HTTP请求次数</h3><p>在前端页面中，通常建议尽可能的合并静态资源图片（雪碧图）、javascript或者CSS代码，减少页面请求数量和资源消耗请求，这样可以缩短页面首次访问的用户等待时间。还要尽量的避免重复的资源，防止增加多余的请求。</p>
<h3 id="减少HTTP请求大小"><a href="#减少HTTP请求大小" class="headerlink" title="减少HTTP请求大小"></a>减少HTTP请求大小</h3><p>减少没必要的图片（使用雪碧图）、javascript、CSS以及HTML代码（移出代码中的注释），对文件进行压缩优化，或者使用gzip有所传输内容等都可以用来减小文件大小，缩短网络传输等待延时。减小文件的大小，就减小了HTTP请求的大小。</p>
<h3 id="将CSS或者javascript代码放到外部文件，通过外链的方式引用，避免直接使用-lt-style-gt-或者-lt-script-gt-标签直接引入"><a href="#将CSS或者javascript代码放到外部文件，通过外链的方式引用，避免直接使用-lt-style-gt-或者-lt-script-gt-标签直接引入" class="headerlink" title="将CSS或者javascript代码放到外部文件，通过外链的方式引用，避免直接使用&lt;style&gt;或者&lt;script&gt;标签直接引入"></a>将CSS或者javascript代码放到外部文件，通过外链的方式引用，避免直接使用<code>&lt;style&gt;</code>或者<code>&lt;script&gt;</code>标签直接引入</h3><p>在HTML中使用外链的的方式引用资源可以有效的利用浏览器的静态资源缓存。</p>
<p>如果是移动端，有时候若是CSS或者javascript比较简单的情况下为了减少HTTP的请求，也建议将CSS或者javascript代码直接写到<code>&lt;style&gt;</code>或者<code>&lt;script&gt;</code>标签中，放到HTML中。移动端需要根据具体的文件大小以及业务场景来分析。PC端因为网络的原因可以直接通过外链的方式。</p>
<h3 id="避免页面中出现空的-href-和-src"><a href="#避免页面中出现空的-href-和-src" class="headerlink" title="避免页面中出现空的 href 和 src"></a>避免页面中出现空的 href 和 src</h3><p>当然，这个问题基本上不会出现，但是有时候你可能会一不注意就犯错了。虽说一般不会出现，但还是要说说。</p>
<p>当<code>link</code>标签的<code>href</code>属性为空或者是<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;ifram&gt;</code>标签的<code>src</code>属性为空时，浏览器在渲染的过程中仍会将<code>href</code>属性或者<code>src</code>属性中的空内容进行加载，直到加载失败，这样就阻塞了页面中其他资源的下载进程，可以最总加载的资源又是无效的，所以要避免出现这样的错误。</p>
<h3 id="为HTML指定Cache-control或Expires"><a href="#为HTML指定Cache-control或Expires" class="headerlink" title="为HTML指定Cache-control或Expires"></a>为HTML指定<code>Cache-control</code>或<code>Expires</code></h3><p>为HTML设置<code>Cache-control</code>或<code>Expires</code>都可以将HTML页面内容进行缓存，避免重复的想服务器端发送请求</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置缓存时间 7200ms --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-control"</span> <span class="attr">content</span>=<span class="string">"max-age=7200"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置过期时间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Expires"</span> <span class="attr">content</span>=<span class="string">"Mon, 1 Dec 2020 00:00:00 GMT"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果页面缓存了，浏览器将直接从缓存中读取，不再向服务器发送请求。</p>
<h3 id="合理的设置Etag和Last-Modified"><a href="#合理的设置Etag和Last-Modified" class="headerlink" title="合理的设置Etag和Last-Modified"></a>合理的设置<code>Etag</code>和<code>Last-Modified</code></h3><p>合理的设置<code>Etag</code>和<code>Last-Modified</code>使用浏览器缓存，对于未修改的文件，静态资源服务器会向浏览器返回304，让浏览器从缓存中读取文件，减少web资源下载的带宽并降低服务器的负载。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Expires"</span> <span class="attr">content</span>=<span class="string">"Mon, 1 Dec 2020 00:00:00 GMT"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用方法类似于上面的<code>Cache-control</code>或<code>Expires</code></p>
<h3 id="减少页面重定向"><a href="#减少页面重定向" class="headerlink" title="减少页面重定向"></a>减少页面重定向</h3><p>页面每次重定向都会延长页面内容返回的等待延时，一次重定向大约需要<strong>600ms</strong>的开销，为了保证用户尽快看到页面内容，需要尽量避免页面重定向。</p>
<h3 id="使用静态资源分域存放来增加下载并行数"><a href="#使用静态资源分域存放来增加下载并行数" class="headerlink" title="使用静态资源分域存放来增加下载并行数"></a>使用静态资源分域存放来增加下载并行数</h3><p>浏览器在同一时间向同一个域名请求文件的并行下载数量是有限的，因此可以利用多个域名的主机来存放不同的静态资源，增大页面加载时资源的并行下载数，缩短页面资源加载的时间。<strong>通常根据多个域名来分别存储Javascript、CSS和图片文件，尤其是图片文件</strong></p>
<h3 id="使用静态资源CND来存储文件"><a href="#使用静态资源CND来存储文件" class="headerlink" title="使用静态资源CND来存储文件"></a>使用静态资源CND来存储文件</h3><p>如果条件允许（公司能够支付这一笔费用等），可以利用CND网络加快同一个地区内重复静态资源文件的响应下载速度，缩短资源请求时间。</p>
<h3 id="使用CND-Combo-下载传输内容"><a href="#使用CND-Combo-下载传输内容" class="headerlink" title="使用CND Combo 下载传输内容"></a>使用CND Combo 下载传输内容</h3><p>CDN Combo是在CDN服务器端将多个文件请求打包成一个文件的形式来返回的技术，这样可以实现HTTP连续传输的一次性复用，减少浏览器的HTTP请求数，加快资源下载速度。</p>
<p>写法<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"//g.alicdn.com/msui/sm/0.6.2/css/??sm.min.css,sm-extend.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">'text/javascript'</span> <span class="attr">src</span>=<span class="string">'//g.alicdn.com/msui/sm/0.6.2/js/??sm.min.js,sm-extend.min.js'</span> <span class="attr">charset</span>=<span class="string">'utf-8'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的一个CSS请求同时返回了<code>sm.min.css,sm-extend.min.css</code>，js请求同时返回了<code>sm.min.js,sm-extend.min.js</code></p>
<p>下面是淘宝上面的写法<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190604221936.png" alt="2019年6月4日 22:19:51 淘宝截图"></p>
<p>其实这个原理也是在同一并发的时候增加了文件的请求数量。</p>
<h3 id="使用可缓存的AJAX"><a href="#使用可缓存的AJAX" class="headerlink" title="使用可缓存的AJAX"></a>使用可缓存的AJAX</h3><p>对于返回内容相同的请求，没必要每次都直接才服务器上面拉取，合理的使用AJAX的缓存能加快AJAX的响应素的并减轻服务器的压力。</p>
<p>在发起AJAX请求的时候，添加上<code>cache: true</code>属性即可。</p>
<h3 id="使用GET来完成AJAX请求"><a href="#使用GET来完成AJAX请求" class="headerlink" title="使用GET来完成AJAX请求"></a>使用GET来完成AJAX请求</h3><p>你可能不知道，使用GET请求比使用POST请求的效率更高。</p>
<p>在使用XMLHttpRequest的时候，浏览器中的POST方法发送请求首先发送文件头，然后发送HTTP正文数据。而使用GET请求时只发送头部信息，所以在拉取服务器端数据时候使用GET的效率更高。</p>
<h3 id="减少Cookie的大小并进行Cookie隔离"><a href="#减少Cookie的大小并进行Cookie隔离" class="headerlink" title="减少Cookie的大小并进行Cookie隔离"></a>减少Cookie的大小并进行Cookie隔离</h3><p>HTTP请求通常情况下<strong>默认会带上浏览器端的Cookie一起发送给服务器</strong>，所以在非必要的情况下，要尽量减少Cookie来减小HTTP请求的大小。对于静态资源，尽量使用不同的域名来存放，因为<strong>Cookie默认是不能够跨域的</strong>，这样就做到了不同域名下静态资源请求的Cookie隔壁。</p>
<h3 id="缩小favicon-ico并缓存"><a href="#缩小favicon-ico并缓存" class="headerlink" title="缩小favicon.ico并缓存"></a>缩小favicon.ico并缓存</h3><p>有利用重复加载<code>favicon.ico</code>，因为一般一个web应用的 <code>favicon.ico</code> 是很少发生变化的。</p>
<h3 id="推荐使用异步加载javascript资源"><a href="#推荐使用异步加载javascript资源" class="headerlink" title="推荐使用异步加载javascript资源"></a>推荐使用异步加载javascript资源</h3><p>异步加载Javascript资源不会阻塞文档解析，所以允许在浏览器中有限渲染页面，延时加载脚本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'main.js'</span> <span class="attr">async</span>/&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'main.js'</span> <span class="attr">defer</span>/&gt;</span><span class="undefined"></span></span></span></span><br></pre></td></tr></table></figure>
<p>使用<code>async</code>时候，加载和渲染后续文档元素的过程和<strong>main.js加载与执行</strong>是并行的。</p>
<p>使用<code>defer</code>时候，加载和渲染后续文档元素的过程和<strong>main.js加载</strong>是并行的，<code>main.js</code>的<strong>执行</strong>要的所有页面元素解析完成后才开始执行。</p>
<h3 id="消除阻塞页面渲染的CSS以及Javascript"><a href="#消除阻塞页面渲染的CSS以及Javascript" class="headerlink" title="消除阻塞页面渲染的CSS以及Javascript"></a>消除阻塞页面渲染的CSS以及Javascript</h3><p>对于页面中加载时间过长的CSS以及Javascript文件，需要进行合理拆分或延后加载，保证关键路径的资源能快速加载完成。</p>
<h3 id="避免使用-CSS-import-引用加载-CSS-资源"><a href="#避免使用-CSS-import-引用加载-CSS-资源" class="headerlink" title="避免使用 CSS import 引用加载 CSS 资源"></a>避免使用 CSS import 引用加载 CSS 资源</h3><p>在CSS中使用<code>@import</code>可以冲另一个样式文件中引入文件，但是这样会增加CSS资源加载的关键路径长度，带有<code>@import</code>的CSS样式需要在CSS文件串行解析到<code>@import</code>时才会加载另外的CSS文件，大大延后CSS渲染完成对的时间。</p>
<p>推荐使用<code>&lt;link/&gt;</code>外链的方式加载CSS文件。如果是在使用<code>SCSS、LESS</code>的CSS预处理工具的时候可以使用<code>@import</code>，因为最后的样式是会被编译的。</p>
<h2 id="页面渲染类"><a href="#页面渲染类" class="headerlink" title="页面渲染类"></a>页面渲染类</h2><h3 id="把-CSS-资源引用放在HTML文件头部"><a href="#把-CSS-资源引用放在HTML文件头部" class="headerlink" title="把 CSS 资源引用放在HTML文件头部"></a>把 CSS 资源引用放在HTML文件头部</h3><p>把CSS资源引用放在HTML文件头部，即<code>&lt;head&gt;</code>中，这样浏览器可以优先加载CSS并尽早完成页面渲染。</p>
<h3 id="把-Javascript-资源引用放在HTML文件地底部"><a href="#把-Javascript-资源引用放在HTML文件地底部" class="headerlink" title="把 Javascript 资源引用放在HTML文件地底部"></a>把 Javascript 资源引用放在HTML文件地底部</h3><p>把CSS资源引用放在HTML文件头部，即<code>&lt;/body&gt;</code>之前，这样防止因为 Javascript 的加载与解析造成的页面阻塞。当然，你也可以使用前面说到的<code>async 和 defer</code>。</p>
<h3 id="不要在HTML中直接缩放图片"><a href="#不要在HTML中直接缩放图片" class="headerlink" title="不要在HTML中直接缩放图片"></a>不要在HTML中直接缩放图片</h3><p>在HTML中直接缩放图片会导致页面内容的重排重绘，此时可能会使页面中其他的操作产生卡顿。这里的缩放一般指的是用过Javascript代码改变图片的宽高而不是使用CSS3的scale进行缩放，使用CSS3的scale进行缩放不会改变图片占据空间的大小，从而不会造成也，， 重排重绘。</p>
<h3 id="减少DOM元素的数量和深度"><a href="#减少DOM元素的数量和深度" class="headerlink" title="减少DOM元素的数量和深度"></a>减少DOM元素的数量和深度</h3><p>HTML中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花费的时间就越长，所以要尽可能保持DOM元素简洁和层级较少。</p>
<p>eg.<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 较差，可以直接使用 img 标签而不需要在嵌套一层 div --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'XXX.svg'</span> <span class="attr">alt</span>=<span class="string">'图片'</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="尽量避免使用table和iframe等慢元素"><a href="#尽量避免使用table和iframe等慢元素" class="headerlink" title="尽量避免使用table和iframe等慢元素"></a>尽量避免使用<code>table</code>和<code>iframe</code>等慢元素</h3><p><code>&lt;table&gt;</code>内容的渲染是将table的DOM渲染树全部生成并一次性绘制到页面上，所以在绘制长表格渲染时会很消耗性能，因该尽量避免使用它，可以考虑使用<code>&lt;ul&gt;</code>代替。</p>
<p>尽量使用异步的方式动态的添加<code>iframe</code>，因为<code>iframe</code>内资源的下载进程会阻塞父页面静态资源的下载与CSS以及HTML DOM的解析。</p>
<h3 id="避免运行耗时的-Javascript"><a href="#避免运行耗时的-Javascript" class="headerlink" title="避免运行耗时的 Javascript"></a>避免运行耗时的 Javascript</h3><p>长时间运行的Javascript会阻塞浏览器构建DOM树、DOM树渲染、页面渲染。所以，任何与页面初次渲染无关的逻辑功能都应该延时加载。</p>
<h3 id="避免使用CSS表达式或者CSS滤镜"><a href="#避免使用CSS表达式或者CSS滤镜" class="headerlink" title="避免使用CSS表达式或者CSS滤镜"></a>避免使用CSS表达式或者CSS滤镜</h3><p>CSS表达式或者CSS滤镜的解析渲染速度是比较慢的，在有其他解决方案的情况下要尽量避免使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于PC端前端的优化策略，可能有的地方有错或者你有更好的建议，欢迎在文章下面留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter lesson 6: Flutter组件之基础组件（二）</title>
    <url>/%E6%8A%80%E6%9C%AF/Flutter-lesson-6-Flutter%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content><![CDATA[<p>上一篇介绍了<a href="https://blog.lyt007.cn/技术/Flutter-lesson-5-Flutter组件之基础组件（一）.html">Container</a></p>
<p>这一篇我们来看看别的Widget。</p>
<h1 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h1><p><strong>Row</strong>这个Widget其实就是一个布局组件，类似于前端中<code>flex-direction: row;</code>。作用就是可以使Row中的子元素在水平方向上面排列，可以用来做走马灯轮播等效果。</p>
<p>Row可以设置一下几种属性<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">  MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">  TextDirection textDirection,</span><br><span class="line">  VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">  TextBaseline textBaseline,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="mainAxisAlignment"><a href="#mainAxisAlignment" class="headerlink" title="mainAxisAlignment"></a>mainAxisAlignment</h2><p>这个属性在上一节介绍<code>Container</code>的时候已经涉及到了，他就是设置子元素<strong>在主轴方向上面</strong>的对其方式的。取值的话也是前端中对其方式的几种取值</p>
<ul>
<li>start</li>
<li>end</li>
<li>center</li>
<li>spaceBetween</li>
<li>spaceAround</li>
<li>spaceEvenly</li>
</ul>
<p>唯一不同的是，在Flutter中新增加了一个<code>spaceEvenly</code>属性，即均匀的分配空间</p>
<h2 id="crossAxisAlignment"><a href="#crossAxisAlignment" class="headerlink" title="crossAxisAlignment"></a>crossAxisAlignment</h2><p>同<code>mainAxisAlignment</code>,不同的是他设置的是<strong>从轴方向</strong>。取值也有一点不同</p>
<ul>
<li>start</li>
<li>end</li>
<li>center</li>
<li>stretch : 垂直方向上面拉伸了</li>
<li>baseline</li>
</ul>
<blockquote>
<p>补充：上面说到了主轴从轴，那究竟是什么方向呢？以<code>Row</code>为例，这是一个水平方向上排列的Widget，那么他的主轴就是 horizontal（水平） ，从轴就是 vertical（垂直）。</p>
</blockquote>
<h2 id="mainAxisSize"><a href="#mainAxisSize" class="headerlink" title="mainAxisSize"></a>mainAxisSize</h2><p>这个设置的是<strong>主轴</strong>的区间大小，值包含<code>min</code>和<code>max</code>两个。</p>
<h2 id="textDirection"><a href="#textDirection" class="headerlink" title="textDirection"></a>textDirection</h2><p>顾名思义，这个属性设置的是文字的方向，值包含</p>
<ul>
<li>ltr : 从左往右排列</li>
<li>rtl : 从右往左排列</li>
</ul>
<p>两个。或许有的朋友觉得没有，那是因为你还没有涉及到从右往左的一个排列的方式。当你遇到阿拉伯语，希伯来语等语言的时候，那这个属性就是一个神器了。关于左右布局的方案可以查看我之前写的<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%B7%A6%E5%8F%B3%E5%B8%83%E5%B1%80%E9%80%82%E9%85%8D.html">关于网站左右布局适配</a>。</p>
<h2 id="verticalDirection"><a href="#verticalDirection" class="headerlink" title="verticalDirection"></a>verticalDirection</h2><p>这个也是设置文字的方向，不过我觉得这个属性可能用的更少了，值包含</p>
<ul>
<li>up : 从上往下排列</li>
<li>down : 从下往上排列</li>
</ul>
<h2 id="textBaseline"><a href="#textBaseline" class="headerlink" title="textBaseline"></a>textBaseline</h2><p>设置文字的基线。这里的值没有前端中多。仅仅只有两个</p>
<ul>
<li>alphabetic : 用于对齐字母字符底部的水平线。</li>
<li>ideographic : 用于对齐表意字符的水平线。</li>
</ul>
<p>这个属性一般不会用到的，<strong>但是，如果你要设置 crossAxisAlignment 属性，那么可能需要设置 textBaseline 属性</strong></p>
<h2 id="children"><a href="#children" class="headerlink" title="children"></a>children</h2><p>这个属性需要牢记，这个是设置<strong>Row</strong>子元素的属性，值是一个List集合（即数组），每一项都是一个Widget。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: Column(</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Center(child: CustomTitle(title: <span class="string">"说明"</span>)),</span><br><span class="line">    Text(<span class="string">"Row是一个布局Widget，相当于是前端CSS3中弹性盒模型布局中：flex-direction: row;作用就是使内容水平方向排列。"</span>),</span><br><span class="line">    Row(</span><br><span class="line">      </span><br><span class="line">    )</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<h1 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h1><p>如果你掌握了<code>Row</code>，那么<code>Column</code>对你来说就是易如反掌。<code>Row</code>是水平方向上面排列的，而<code>Column</code>则是垂直方向上面排列的。这是他们之前唯一的区别，他们的属性一模一样。这里就不在做过多说明。</p>
<h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><p>图片Widget。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Image(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.image, <span class="comment">// 图片</span></span><br><span class="line">  <span class="keyword">this</span>.semanticLabel,</span><br><span class="line">  <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span><br><span class="line">  <span class="keyword">this</span>.width, <span class="comment">// 用来指定显示图片区域的宽，并不是图片的宽度，默认图片的宽度</span></span><br><span class="line">  <span class="keyword">this</span>.height, <span class="comment">// 用来指定显示图片区域的高，并不是图片的高度，默认图片的高度</span></span><br><span class="line">  <span class="keyword">this</span>.color, <span class="comment">// 图片颜色，这个可以直接修改图片的颜色，相当于前端设置字体图标</span></span><br><span class="line">  <span class="keyword">this</span>.colorBlendMode, <span class="comment">// 颜色和图片混合，需要配合color使用才会生效</span></span><br><span class="line">  <span class="keyword">this</span>.fit, <span class="comment">// 设置图片填充</span></span><br><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center, <span class="comment">// 用来控制图片摆放的位置</span></span><br><span class="line">  <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat, <span class="comment">// 用来设置图片重复显示（repeat-x水平重复，repeat-y垂直重复，repeat两个方向都重复，no-repeat默认情况不重复）</span></span><br><span class="line">  <span class="keyword">this</span>.centerSlice, <span class="comment">// 设置图片内部拉伸，相当于在图片内部设置了一个.9图，但是需要注意的是，要在显示图片的大小大于原图的情况下才可以使用这个属性，要不然会报错</span></span><br><span class="line">  <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span><br><span class="line">  <span class="keyword">this</span>.gaplessPlayback = <span class="keyword">false</span>, <span class="comment">// 当图片发生改变之后，重新加载图片过程中的样式（1、原图片保留）</span></span><br><span class="line">  <span class="keyword">this</span>.filterQuality = FilterQuality.low, <span class="comment">// 图片 filter 质量，用的不多</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Image-1"><a href="#Image-1" class="headerlink" title="Image"></a>Image</h2><p>必须有一个<code>image</code>参数，设置图片，可以是网络图片可以是本地图片。</p>
<ul>
<li>Image.asset：用来加载本地资源图片，等同于<code>new AssetImage</code></li>
<li>Image.file：用来加载本地（File文件）图片，等同于<code>new FileImage</code></li>
<li>Image.network：用来加载网络图片，等同于<code>new NetworkImage</code></li>
<li>Image.memory：用来加载Uint8List资源（byte数组）图片，等同于<code>new MemoryImage</code></li>
</ul>
<h3 id="Image-asset（or-AssetImage）"><a href="#Image-asset（or-AssetImage）" class="headerlink" title="Image.asset（or AssetImage）"></a>Image.asset（or AssetImage）</h3><p>加载一个本地的<strong>资源图片</strong>。这里的本地的图片资源指的是什么呢？即你项目中用到的图片，比如logo。<strong>注意和接下来讲到的 Image.file 区分</strong>。</p>
<p>如果我们需要使用<code>asset</code>类的东西，需要在<code>pubspec.yaml</code>文件中进行配置。如果我们没有修改过初始化后的<strong>pubspec.yaml</strong>，你会在注释中看到这样的一段注释<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># To add assets to your application, add an assets section, like this:</span></span><br><span class="line"><span class="comment"># assets:</span></span><br><span class="line"><span class="comment">#  - images/a_dot_burr.jpeg</span></span><br><span class="line"><span class="comment">#  - images/a_dot_ham.jpeg</span></span><br></pre></td></tr></table></figure></p>
<p>So。如果我们要使用图片，我们需要两个步骤：</p>
<ol>
<li>在根目录下面新建<code>images</code>文件夹用来存放图片，也可以是其他地方，但是更推荐在根目录中</li>
<li>配置<code>pubspec.yaml</code></li>
</ol>
<p>为了更好的适配图片，还是建议使用多套图片，比如<code>images/2.0x</code>和<code>images/3.0x</code>两种类型的图片</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190610175413.png" alt="具体的目录结构"></p>
<p><code>pubspec.yaml</code>中配置如下<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">assets:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">images/logo.png</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">images/2.0x/logo.png</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">images/3.0x/logo.png</span></span><br></pre></td></tr></table></figure></p>
<p>具体使用就是<code>AssetImage(&#39;images/logo.png)</code></p>
<h3 id="Image-file"><a href="#Image-file" class="headerlink" title="Image.file"></a>Image.file</h3><p>这个也是设置本地图片，不用于上面的<code>asset</code>，这个一般不会是项目中存在的图片。可以使相册中的图片或者是相机拍照的图片。</p>
<p>还有，你可能需要<a href="https://pub.dev/packages/image_picker" target="_blank" rel="noopener">image_picker</a>这个插件来完成图片的选择以及拍照。这个插件IOS需要配置一下，安卓不用。</p>
<p><strong>注意：</strong>在Info.plist中设置权限的时候需要使用英文<br><figure class="highlight plist"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSPhotoLibraryUsageDescription<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Use the gallery to select phonts<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSCameraUsageDescription<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Use the camare to take phonts<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSMicrophoneUsageDescription<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Use the Microphone to get voice<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Image-network"><a href="#Image-network" class="headerlink" title="Image.network"></a>Image.network</h3><p>设置网络图片，使用就是直接传入一个网络图片的地址即可<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Image.network(<span class="string">'/img/favicon-32x32.png'</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用网络图的时候因为是请求的网络上面的资源，有的时候可能会出现请求失败或者是请求错误的情况，这个时候我们需要使用一个占位图或者说是加载出错显示的图片，那么需要使用到<code>FadeInImage</code></p>
<h4 id="占位图"><a href="#占位图" class="headerlink" title="占位图"></a>占位图</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FadeInImage.assetNetwork(</span><br><span class="line">  placeholder: <span class="string">'images/logo.png'</span>,</span><br><span class="line">  image: <span class="string">'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=324769017,4079415235&amp;fm=26&amp;gp=0.jpg'</span>,</span><br><span class="line">  width: <span class="number">120</span>,</span><br><span class="line">  fit: BoxFit.fitWidth,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>placeholder</code>属性就是站位属性，站位的图片是一个静态资源图片，你还可以设置透明的占位图。</p>
<p>但是我们无法设置网络图片加载出错显示的图片，这里可是使用第三方的工具<a href="https://pub.dev/packages/cached_network_image" target="_blank" rel="noopener">cached_network_image</a><br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CachedNetworkImage(</span><br><span class="line">  width: <span class="number">120</span>,</span><br><span class="line">  fit: BoxFit.fitWidth,</span><br><span class="line">  placeholder: <span class="keyword">new</span> CircularProgressIndicator(),</span><br><span class="line">  imageUrl: imageUrl,</span><br><span class="line">  errorWidget: <span class="keyword">new</span> Icon(Icons.error),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="Image-memory"><a href="#Image-memory" class="headerlink" title="Image.memory"></a>Image.memory</h3><p>加载 <code>Uint8List</code> 图片。用来将一个 <code>byte</code> 数组加载成图片，用法如下：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Image.memory(bytes)</span><br></pre></td></tr></table></figure></p>
<h2 id="width-lt-Double-gt-and-height-lt-Double-gt"><a href="#width-lt-Double-gt-and-height-lt-Double-gt" class="headerlink" title="width&lt;Double&gt; and height&lt;Double&gt;"></a>width<code>&lt;Double&gt;</code> and height<code>&lt;Double&gt;</code></h2><p>这里的 <code>width</code> 和 <code>height</code> 并不是设置图片的宽高，而是设置这个Image容器的宽高，用来显示图片的宽高。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image(</span><br><span class="line">  image: AssetImage(<span class="string">'images/logo.png'</span>),</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">100</span>,</span><br><span class="line">  alignment: Alignment.center,</span><br><span class="line">  repeat: ImageRepeat.repeat,</span><br><span class="line">  <span class="comment">// fit: BoxFit.cover,</span></span><br><span class="line">  filterQuality: FilterQuality.low,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>比如App上面的<a href="https://github.com/tal007/FlutterApp" target="_blank" rel="noopener">AssetImage</a>案例</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190611175934.png" alt="设置了widht以及height"></p>
<p>上面设置的图片<em>width</em>和<em>height</em>。但是图片其实是很小的，因为设置了repeat（重复）属性，所以可以看到很多个小图片。如果要设置图片的宽高，可以设置了<em>width</em>和<em>height</em>后在设置<code>fit:BoxFit.cover</code>属性。</p>
<h2 id="semanticLabel-lt-String-gt"><a href="#semanticLabel-lt-String-gt" class="headerlink" title="semanticLabel&lt;String&gt;"></a>semanticLabel<code>&lt;String&gt;</code></h2><p>图像的语义描述，用于向<code>Andoid上的TalkBack</code>和<code>iOS上的VoiceOver</code>提供图像描述</p>
<p><code>talkback</code>是一款由谷歌官方开发的系统软件,它的定位是帮助盲人或者视力有障碍的用户提供语言辅助</p>
<p><code>Voiceover</code>功能是APPLE公司在2009年4月新推出的一种语音辅助程序</p>
<h2 id="excludeFromSemantics-lt-Bool-gt"><a href="#excludeFromSemantics-lt-Bool-gt" class="headerlink" title="excludeFromSemantics&lt;Bool&gt;"></a>excludeFromSemantics<code>&lt;Bool&gt;</code></h2><p>是否启用图像的语义描述。</p>
<h2 id="color-lt-Colors-gt"><a href="#color-lt-Colors-gt" class="headerlink" title="color&lt;Colors&gt;"></a>color<code>&lt;Colors&gt;</code></h2><p>颜色。设置图片的颜色，会覆盖图片原有的颜色，像是前端中的字体图标，可以指定颜色。一般会和<code>colorBlendMode</code>配合使用</p>
<h2 id="colorBlendMode-lt-BlendMode-gt"><a href="#colorBlendMode-lt-BlendMode-gt" class="headerlink" title="colorBlendMode&lt;BlendMode&gt;"></a>colorBlendMode<code>&lt;BlendMode&gt;</code></h2><p>用于将color与此图像组合。</p>
<p>默认为BlendMode.srcIn。在混合模式方面，color是来源，此图像是目的地。</p>
<h2 id="fit-lt-FixBox-gt"><a href="#fit-lt-FixBox-gt" class="headerlink" title="fit&lt;FixBox&gt;"></a>fit<code>&lt;FixBox&gt;</code></h2><p>图片如何在Image控件中显示，有以下几个值可选<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> BoxFit &#123;</span><br><span class="line">  fill, <span class="comment">// 填充整个容器，宽高都不超出容器</span></span><br><span class="line">  contain, <span class="comment">// 按宽高中最小的那个来放大</span></span><br><span class="line">  cover, <span class="comment">// 按宽高中最大的那个来放大</span></span><br><span class="line">  fitWidth, <span class="comment">// 按照width放大</span></span><br><span class="line">  fitHeight, <span class="comment">// 按照高度方法</span></span><br><span class="line">  none, <span class="comment">// 不填充</span></span><br><span class="line">  scaleDown,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体的效果可以查看[]<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/1.gif" alt="效果演示"></p>
<p><a href="https://github.com/tal007/FlutterApp" target="_blank" rel="noopener">FlutterApp</a>案例源码</p>
<h2 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h2><p>用来控制图片的对齐方式，这个属性在介绍<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/Flutter-lesson-5-Flutter%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89.html#Alignment">Container</a>的时候已经介绍过了，如果你忘了，可以回头看看</p>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h2><p>设置图片的重复。这个属性就像是CSS中设置背景重复一样<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190612100629.png" alt="图片重复属性"><br>包含以上几种属性，一般很少设置重复属性的。</p>
<ul>
<li>noRepeat: 不设置重复。默认值</li>
<li>repeat: 重复X轴与Y轴</li>
<li>repeatX： 重复X轴</li>
<li>repeatY： 重复Y轴</li>
</ul>
<p>Image其他的几个属性基本上都用不到。可能会用到的就是上面介绍到的，如果你有兴趣，可以自行了解。以上就是关于<code>Image Widget</code>的简单说明。</p>
<h1 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h1><p><strong>Text</strong> Widget用的是非常多的一个组件，要显示文字就需要用到这个组件。使用也是很简单的。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Text(</span><br><span class="line">  <span class="keyword">this</span>.data, &#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.style,</span><br><span class="line">  <span class="keyword">this</span>.strutStyle,</span><br><span class="line">  <span class="keyword">this</span>.textAlign,</span><br><span class="line">  <span class="keyword">this</span>.textDirection,</span><br><span class="line">  <span class="keyword">this</span>.locale,</span><br><span class="line">  <span class="keyword">this</span>.softWrap,</span><br><span class="line">  <span class="keyword">this</span>.overflow,</span><br><span class="line">  <span class="keyword">this</span>.textScaleFactor,</span><br><span class="line">  <span class="keyword">this</span>.maxLines,</span><br><span class="line">  <span class="keyword">this</span>.semanticsLabel,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>首先需要传一个data，即我们需要显示的文字。接下来就是其中的每一项属性了</p>
<h2 id="textAlign"><a href="#textAlign" class="headerlink" title="textAlign"></a>textAlign</h2><p>对其方式</p>
<ul>
<li>left 左对齐</li>
<li>right 右对齐</li>
<li>center 居中</li>
<li>justify 两端对齐</li>
<li>statr 开始对齐，大部分条件下等同于 left</li>
<li>end 结束对齐，大部分条件下等同于 right</li>
</ul>
<h2 id="textDirection-1"><a href="#textDirection-1" class="headerlink" title="textDirection"></a>textDirection</h2><p>文字方向，就两个值 <strong>ltr</strong> 与 <strong>rtl</strong></p>
<h2 id="locale"><a href="#locale" class="headerlink" title="locale"></a>locale</h2><p>此属性很少设置，用于选择区域特定字形的语言环境</p>
<h2 id="softWrap"><a href="#softWrap" class="headerlink" title="softWrap"></a>softWrap</h2><p>某一行中文本过长，是否需要换行。默认为true，如果为false，则文本中的字形将被定位为好像存在无限的水平空间</p>
<h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>超出文本的显示方式</p>
<ul>
<li>TextOverflow.clip 超出部分裁剪</li>
<li>TextOverflow.ellipsis 超出部分显示省略号，用的更多</li>
<li>TextOverflow.fade 超出部分显示透明</li>
</ul>
<h2 id="textScaleFactor-lt-double-gt"><a href="#textScaleFactor-lt-double-gt" class="headerlink" title="textScaleFactor&lt;double&gt;"></a>textScaleFactor<code>&lt;double&gt;</code></h2><p>每个逻辑像素的字体像素数。有点像是把文字放大多少倍。</p>
<h2 id="maxLines-lt-int-gt"><a href="#maxLines-lt-int-gt" class="headerlink" title="maxLines&lt;int&gt;"></a>maxLines<code>&lt;int&gt;</code></h2><p>显示的文本的行数</p>
<h2 id="semanticsLabel"><a href="#semanticsLabel" class="headerlink" title="semanticsLabel"></a>semanticsLabel</h2><p>图像的语义描述，用于向<strong>Andoid上的TalkBack</strong>和<strong>iOS上的VoiceOver</strong>提供图像描述</p>
<p><code>talkback</code>是一款由谷歌官方开发的系统软件,它的定位是帮助盲人或者视力有障碍的用户提供语言辅助</p>
<p><code>Voiceover</code>功能是APPLE公司在2009年4月新推出的一种语音辅助程序</p>
<h2 id="style"><a href="#style" class="headerlink" title="style"></a>style</h2><p>这个属性才是用的更多的一个属性，主要是设置字体的样式，包括但不限于字体，字体大小，颜色，字体类型等。</p>
<p>使用的是<code>TextStyle</code>下面的类<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextStyle(&#123;</span><br><span class="line">  <span class="keyword">this</span>.inherit = <span class="keyword">true</span>, <span class="comment">// 集成父级样式</span></span><br><span class="line">  <span class="keyword">this</span>.color, <span class="comment">// 设置颜色</span></span><br><span class="line">  <span class="keyword">this</span>.backgroundColor, <span class="comment">// 设置背景颜色</span></span><br><span class="line">  <span class="keyword">this</span>.fontSize, <span class="comment">// 设置字体大小</span></span><br><span class="line">  <span class="keyword">this</span>.fontWeight, <span class="comment">// 设置字体粗细 FontWeight.bold</span></span><br><span class="line">  <span class="keyword">this</span>.fontStyle, <span class="comment">// 设置字体样式 FontStyle.normal  FontStyle.italic斜体</span></span><br><span class="line">  <span class="keyword">this</span>.letterSpacing, <span class="comment">// 设置字间距</span></span><br><span class="line">  <span class="keyword">this</span>.wordSpacing, <span class="comment">// 设置词间距</span></span><br><span class="line">  <span class="keyword">this</span>.textBaseline, <span class="comment">// 文本基线</span></span><br><span class="line">  <span class="keyword">this</span>.height, <span class="comment">// 设置行高</span></span><br><span class="line">  <span class="keyword">this</span>.locale, <span class="comment">// 此属性很少设置，用于选择区域特定字形的语言环境</span></span><br><span class="line">  <span class="keyword">this</span>.foreground, <span class="comment">// 文字的前景色</span></span><br><span class="line">  <span class="keyword">this</span>.background, <span class="comment">// 文字的背景色</span></span><br><span class="line">  <span class="keyword">this</span>.shadows, <span class="comment">// 设置字体阴影</span></span><br><span class="line">  <span class="keyword">this</span>.decoration, <span class="comment">// 上划线，下划线以及删除线</span></span><br><span class="line">  <span class="keyword">this</span>.decorationColor, <span class="comment">// 划线的颜色</span></span><br><span class="line">  <span class="keyword">this</span>.decorationStyle, <span class="comment">// 划线的样式 这个style可能控制画实线，虚线，两条线，点, 波浪线等</span></span><br><span class="line">  <span class="keyword">this</span>.decorationThickness,</span><br><span class="line">  <span class="keyword">this</span>.debugLabel,</span><br><span class="line">  <span class="built_in">String</span> fontFamily, <span class="comment">// 字体</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; fontFamilyFallback, <span class="comment">// 多个字体，是一个数组</span></span><br><span class="line">  <span class="built_in">String</span> package,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>文字下划线<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">children: &lt;Widget&gt;[</span><br><span class="line">  Center(child: CustomTitle(title: <span class="string">"Text Widget"</span>)),</span><br><span class="line">  TextDemo(),</span><br><span class="line">  Center(child: Text(text, style: TextStyle(</span><br><span class="line">    decoration: TextDecoration.lineThrough,</span><br><span class="line">    decorationColor: Colors.red,</span><br><span class="line">    decorationStyle: TextDecorationStyle.dotted,</span><br><span class="line">    fontSize: <span class="number">20</span>,</span><br><span class="line">  ))),</span><br><span class="line">  Center(child: Text(text, style: TextStyle(</span><br><span class="line">    decoration: TextDecoration.overline,</span><br><span class="line">    decorationStyle: TextDecorationStyle.dashed,</span><br><span class="line">    fontSize: <span class="number">20</span>,</span><br><span class="line">  ))),</span><br><span class="line">  Center(child: Text(text, style: TextStyle(</span><br><span class="line">    decoration: TextDecoration.underline,</span><br><span class="line">    decorationStyle: TextDecorationStyle.wavy,</span><br><span class="line">    fontSize: <span class="number">20</span>,</span><br><span class="line">    decorationColor: Colors.green</span><br><span class="line">  ))),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>大部分的文字样式<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(TextDemo());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextDemo</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  TextDemo(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  _TextDemoState createState() =&gt; _TextDemoState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TextDemoState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TextDemo</span>&gt; </span>&#123;</span><br><span class="line">  TextAlign _textAlign = TextAlign.left;</span><br><span class="line">  TextDirection _textDirection = TextDirection.ltr;</span><br><span class="line">  TextOverflow _textOverflow = TextOverflow.visible;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      margin: EdgeInsets.only(top: <span class="number">20</span>),</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Container(</span><br><span class="line">            width: <span class="number">200</span>,</span><br><span class="line">            height: <span class="number">100</span>,</span><br><span class="line">            decoration: BoxDecoration(</span><br><span class="line">              border: Border.all(</span><br><span class="line">                color: Colors.blue,</span><br><span class="line">                width: <span class="number">1</span>,</span><br><span class="line">                style: BorderStyle.solid</span><br><span class="line">              )</span><br><span class="line">            ),</span><br><span class="line">            child: Text(</span><br><span class="line">              <span class="string">'踏浪-所谓天才，不过是每一天的积累成才'</span>,</span><br><span class="line">              textAlign: _textAlign,</span><br><span class="line">              textDirection: _textDirection,</span><br><span class="line">              maxLines: <span class="number">1</span>,</span><br><span class="line">              overflow: _textOverflow,</span><br><span class="line">              textScaleFactor: <span class="number">2</span>,</span><br><span class="line">              style: TextStyle(</span><br><span class="line">                color: Colors.blue,</span><br><span class="line">                backgroundColor: Colors.red</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          ListTile(</span><br><span class="line">            title: Text(<span class="string">'textAlign'</span>),</span><br><span class="line">            trailing: DropdownButton(</span><br><span class="line">              value: _textAlign,</span><br><span class="line">              items: TextAlign.values.map((value) =&gt; DropdownMenuItem(</span><br><span class="line">                child: Text(value.toString().substring(<span class="string">'TextAlign.'</span>.length)),</span><br><span class="line">                value: value</span><br><span class="line">              )).toList(),</span><br><span class="line">              onChanged: (newVal)&#123;</span><br><span class="line">                <span class="keyword">if</span>( newVal != <span class="keyword">null</span> )&#123;</span><br><span class="line">                  setState(() &#123;</span><br><span class="line">                    _textAlign = newVal;</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">            )</span><br><span class="line">          ),</span><br><span class="line">          ListTile(</span><br><span class="line">            title: Text(<span class="string">'textDirection'</span>),</span><br><span class="line">            trailing: DropdownButton(</span><br><span class="line">              value: _textDirection,</span><br><span class="line">              items: TextDirection.values.map((value) =&gt; DropdownMenuItem(</span><br><span class="line">                child: Text(value.toString().substring(<span class="string">'TextDirection.'</span>.length)),</span><br><span class="line">                value: value</span><br><span class="line">              )).toList(),</span><br><span class="line">              onChanged: (newVal)&#123;</span><br><span class="line">                <span class="keyword">if</span>( newVal != <span class="keyword">null</span> )&#123;</span><br><span class="line">                  setState(() &#123;</span><br><span class="line">                    _textDirection = newVal;</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">            )</span><br><span class="line">          ),</span><br><span class="line">          ListTile(</span><br><span class="line">            title: Text(<span class="string">'overflow'</span>),</span><br><span class="line">            trailing: DropdownButton(</span><br><span class="line">              value: _textOverflow,</span><br><span class="line">              items: TextOverflow.values.map((value) =&gt; DropdownMenuItem(</span><br><span class="line">                child: Text(value.toString().substring(<span class="string">'TextOverflow.'</span>.length)),</span><br><span class="line">                value: value</span><br><span class="line">              )).toList(),</span><br><span class="line">              onChanged: (newVal)&#123;</span><br><span class="line">                <span class="keyword">if</span>( newVal != <span class="keyword">null</span> )&#123;</span><br><span class="line">                  setState(() &#123;</span><br><span class="line">                    _textOverflow = newVal;</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190612115047.png" alt="效果图"></p>
<p>以上就是关于<code>Text Widget</code>的简单介绍。</p>
<p>这一节就介绍这四种Widget，后续再来介绍其他的Widget。</p>
<p>如果你喜欢文本，请支持一下博主，谢谢。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter lesson 5: Flutter组件之基础组件（一）</title>
    <url>/%E6%8A%80%E6%9C%AF/Flutter-lesson-5-Flutter%E7%BB%84%E4%BB%B6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content><![CDATA[<p>说明：在介绍Widget的出后可能会涉及到一些属性，例如 <code>Color</code>, <code>EdgeInsets</code>等等。我会在其中穿插的说明，以后遇到这样的问题就不会再次说明。</p>
<h1 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h1><p><code>Container</code>：一个拥有绘制，定位，调整大小的widget。</p>
<p><code>Container</code>在使用的时候一般不会直接使用其作为容器组件，通常需要有一个父控件。例如：<code>Center</code>, <code>Padding</code>, <code>Colunm</code>, <code>Row</code>, <code>Scaffold</code>等等。</p>
<p>下面是Dart中Container的属性参数<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.alignment,</span><br><span class="line">  <span class="keyword">this</span>.padding,</span><br><span class="line">  Color color,</span><br><span class="line">  Decoration decoration,</span><br><span class="line">  <span class="keyword">this</span>.foregroundDecoration,</span><br><span class="line">  <span class="built_in">double</span> width,</span><br><span class="line">  <span class="built_in">double</span> height,</span><br><span class="line">  BoxConstraints constraints,</span><br><span class="line">  <span class="keyword">this</span>.margin,</span><br><span class="line">  <span class="keyword">this</span>.transform,</span><br><span class="line">  <span class="keyword">this</span>.child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><blockquote>
<p>Object -&gt; Diagnosticable -&gt; DiagnosticableTree -&gt; Widget -&gt; StatelessWidget Container</p>
</blockquote>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>color这个属性在大多数的Widget中都是可以设置的，表示的就是颜色的意思，无论是组件的背景色还是文字的颜色，都是需要用到color属性。但是这里如果要和color属性设置值的话，不会像在前端中一样设置字符串(例如<code>red</code>)或者16进制(例如<code>#FFF</code>)又或者是rgba这样的形式，需要转变一下思维。在Flutter中，这些常用颜色值以及用一个对象保存下来了，那就是<code>Colors</code>。所以我穿插的来讲讲<code>Colors</code>这个对象，看看他的用法。如果<code>foregroundDecoration</code>设置的话，可能会遮盖color效果。</p>
<h4 id="Colors"><a href="#Colors" class="headerlink" title="Colors"></a>Colors</h4><p>第一种使用方法就是直接调用<code>Colors</code>这个对象，我们可以看到会有提示，提示我们有哪些值</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190528095820.png" alt="Colors black"></p>
<p>例如上图中的black的值就有好几种。但是我们并不能确定其中的12，26，38这些是什么。其实这些是颜色的透明度（Alpha Or Opacity）</p>
<p>第二种就是使用Color属性自己构建颜色，这里有三种表示方式。下面我们使用这三种方式来表示一个完全不透明的白色</p>
<ol>
<li><p>8位16进制表示：<code>0xFFFFFFFF</code>。或许你没有接触过这种表示方式，更多的是使用<code>#FFF</code>或者<code>#FFFFFF</code>的形式表示。这种事ARGB的颜色表示形式，前面的A表示的就是透明度（Alpha Or Opacity），后面的就不用多说了。那前面的A是使用的FF，那是怎么算的哪？简单说明一下。透明度分为256阶（0-255），计算机上面使用16进制表示为（ 00 -ff ）。透明就是0阶，完全不透明就是255阶。加入透明度是50%，那就是256阶的一半。<code>256 / 2 = 128</code>，所以，你以为就是128了么，错了，因为256阶是从0开始的而不是从1开始的，所以还需要减一，就是<code>128 - 1 = 127</code>阶。那127在用16进制表示就是<code>7F</code>。关于10进制与16进制的转行可以前往<a href="http://tool.oschina.net/hexconvert/" target="_blank" rel="noopener">在线进制转换</a>。Colors中提供的颜色值就是这种方式写的。</p>
</li>
<li><p><strong>.formARGB()</strong> : 第二个方法就是使用<code>Color.formARGB()</code>,接收四个参数，A，R，G，B，都是<code>int</code>整型的数字。取值范围都是[0, 255]。第一个<code>A</code>就是上面说到的透明度。</p>
</li>
<li><p><strong>.formRGBO()</strong> : 与第二个方法的区别就是透明度放在了最后一个参数，而且值是<code>double</code>类型的。取值范围是[0.0, 1.0]。</p>
</li>
</ol>
<p>这就是Flutter中颜色的集中设置方法。</p>
<h2 id="Child"><a href="#Child" class="headerlink" title="Child"></a>Child</h2><p>顾名思义，就是设置他的子元素，可以设置也可以不设置，如果不设置，前面也已经说了结果了。</p>
<h2 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h2><p>这个属性是可以设置子元素在Container容器中的对齐方式，值包含以下几种<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190528110516.png" alt="Alignment取值"></p>
<p>上面的固定值不做过多说明，来谈谈<code>lerp</code>这个方法。<br><code>Alignment.lerp(a, b, c)</code>。这个方法相当于是区间取值，方法接收三个参数，前两个就是<code>Alignment</code>的固定的取值，比如说<code>Alignment.center</code>，第三个是一个<code>double</code>类型的数值，取值范围是[0.0, 1.0]。如果值是0.0，那么取<code>a</code>值，如果是1.0，那么取<code>b</code>值。</p>
<p>上面说到了<code>lerp</code>方法，不是那几个固定的值那么她是怎么取值的呢？其实就是取坐标中的点。附上一个图，在举个例子你就明白了<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/7911324-2ed655dcf8487dba.webp" alt="Alignment 坐标系"></p>
<p>Alignment.topLeft 等价于 Alignment(-1.0, -1.0)。</p>
<p>需要注意的是<code>Alignment</code>直接使用的话，两个参数的取值范围是[-1.0, 1.0]。</p>
<p>下面是App中的源码<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(AlignmentInfo());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlignmentInfo</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AlignmentInfo();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AlignmentInfo</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AlignmentInfo</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span> position = Alignment.center;</span><br><span class="line">  <span class="built_in">double</span> _X = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">double</span> _Y = <span class="number">0.0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Container(</span><br><span class="line">            width: <span class="number">100</span>,</span><br><span class="line">            height: <span class="number">100</span>,</span><br><span class="line">            alignment: position,</span><br><span class="line">            margin: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">            child: Text(<span class="string">'踏浪'</span>, style: TextStyle(</span><br><span class="line">              color: Colors.white,</span><br><span class="line">              fontSize: <span class="number">20</span></span><br><span class="line">            )),</span><br><span class="line">          ),</span><br><span class="line">          Row(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.spaceAround,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              RaisedButton(</span><br><span class="line">                child: Text(<span class="string">'topLeft'</span>),</span><br><span class="line">                onPressed: () =&gt; setState(() &#123;</span><br><span class="line">                  <span class="keyword">this</span>.position = Alignment.topLeft;</span><br><span class="line">                  <span class="keyword">this</span>._X = <span class="number">-1.0</span>;</span><br><span class="line">                  <span class="keyword">this</span>._Y = <span class="number">-1.0</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">              ),</span><br><span class="line">              RaisedButton(</span><br><span class="line">                child: Text(<span class="string">'topCenter'</span>),</span><br><span class="line">                onPressed: () =&gt; setState(() &#123;</span><br><span class="line">                  <span class="keyword">this</span>.position = Alignment.topCenter;</span><br><span class="line">                  <span class="keyword">this</span>._X = <span class="number">0.0</span>;</span><br><span class="line">                  <span class="keyword">this</span>._Y = <span class="number">-1.0</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">              ),</span><br><span class="line">              RaisedButton(</span><br><span class="line">                child: Text(<span class="string">'topRight'</span>),</span><br><span class="line">                onPressed: () =&gt; setState(() &#123;</span><br><span class="line">                  <span class="keyword">this</span>.position = Alignment.topRight;</span><br><span class="line">                  <span class="keyword">this</span>._X = <span class="number">1.0</span>;</span><br><span class="line">                  <span class="keyword">this</span>._Y = <span class="number">-1.0</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">              )</span><br><span class="line">            ]</span><br><span class="line">          ),</span><br><span class="line">          Row(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.spaceAround,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              RaisedButton(</span><br><span class="line">                child: Text(<span class="string">'centerLeft'</span>),</span><br><span class="line">                onPressed: () =&gt; setState(() &#123;</span><br><span class="line">                  <span class="keyword">this</span>.position = Alignment.centerLeft;</span><br><span class="line">                  <span class="keyword">this</span>._X = <span class="number">-1.0</span>;</span><br><span class="line">                  <span class="keyword">this</span>._Y = <span class="number">0.0</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">              ),</span><br><span class="line">              RaisedButton(</span><br><span class="line">                child: Text(<span class="string">'center'</span>),</span><br><span class="line">                onPressed: () =&gt; setState(() &#123;</span><br><span class="line">                  <span class="keyword">this</span>.position = Alignment.center;</span><br><span class="line">                  <span class="keyword">this</span>._X = <span class="number">0.0</span>;</span><br><span class="line">                  <span class="keyword">this</span>._Y = <span class="number">0.0</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">              ),</span><br><span class="line">              RaisedButton(</span><br><span class="line">                child: Text(<span class="string">'centerRight'</span>),</span><br><span class="line">                onPressed: () =&gt; setState(() &#123;</span><br><span class="line">                  <span class="keyword">this</span>.position = Alignment.centerRight;</span><br><span class="line">                  <span class="keyword">this</span>._X = <span class="number">1.0</span>;</span><br><span class="line">                  <span class="keyword">this</span>._Y = <span class="number">0.0</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">              )</span><br><span class="line">            ]</span><br><span class="line">          ),</span><br><span class="line">          Row(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.spaceAround,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              RaisedButton(</span><br><span class="line">                child: Text(<span class="string">'bottomLeft'</span>),</span><br><span class="line">                onPressed: () =&gt; setState(() &#123;</span><br><span class="line">                  <span class="keyword">this</span>.position = Alignment.bottomLeft;</span><br><span class="line">                  <span class="keyword">this</span>._X = <span class="number">-1.0</span>;</span><br><span class="line">                  <span class="keyword">this</span>._Y = <span class="number">1.0</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">              ),</span><br><span class="line">              RaisedButton(</span><br><span class="line">                child: Text(<span class="string">'bottomCenter'</span>),</span><br><span class="line">                onPressed: () =&gt; setState(() &#123;</span><br><span class="line">                  <span class="keyword">this</span>.position = Alignment.bottomCenter;</span><br><span class="line">                  <span class="keyword">this</span>._X = <span class="number">0.0</span>;</span><br><span class="line">                  <span class="keyword">this</span>._Y = <span class="number">1.0</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">              ),</span><br><span class="line">              RaisedButton(</span><br><span class="line">                child: Text(<span class="string">'bottomRight'</span>),</span><br><span class="line">                onPressed: () =&gt; setState(() &#123;</span><br><span class="line">                  <span class="keyword">this</span>.position = Alignment.bottomRight;</span><br><span class="line">                  <span class="keyword">this</span>._X = <span class="number">1.0</span>;</span><br><span class="line">                  <span class="keyword">this</span>._Y = <span class="number">1.0</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">              )</span><br><span class="line">            ]</span><br><span class="line">          ),</span><br><span class="line">          Container(margin: EdgeInsets.all(<span class="number">10</span>)),</span><br><span class="line">          Text(<span class="string">'Alignment X 的坐标'</span>),</span><br><span class="line">          Container(</span><br><span class="line">            margin: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">            child: Slider(</span><br><span class="line">              value: _X,</span><br><span class="line">              min: <span class="number">-1.0</span>,</span><br><span class="line">              max: <span class="number">1.0</span>,</span><br><span class="line">              onChanged: (<span class="built_in">double</span> value) &#123;</span><br><span class="line">                <span class="keyword">this</span>.setState(() &#123;</span><br><span class="line">                  <span class="keyword">this</span>._X = value;</span><br><span class="line">                  <span class="keyword">this</span>.position = Alignment(value, _Y);</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          Text(<span class="string">'Alignment Y 的坐标'</span>),</span><br><span class="line">          Container(</span><br><span class="line">            margin: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">            child: Slider(</span><br><span class="line">              value: _Y,</span><br><span class="line">              min: <span class="number">-1.0</span>,</span><br><span class="line">              max: <span class="number">1.0</span>,</span><br><span class="line">              onChanged: (<span class="built_in">double</span> value) &#123;</span><br><span class="line">                <span class="keyword">this</span>.setState(() &#123;</span><br><span class="line">                  <span class="keyword">this</span>._Y = value;</span><br><span class="line">                  <span class="keyword">this</span>.position = Alignment(_X, value);</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="constraints"><a href="#constraints" class="headerlink" title="constraints"></a>constraints</h2><p><code>constraints</code>可以对Container元素设置最大最小宽高，使用的是<code>BoxConstraint</code>这个对象</p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190528163556.png" alt="BoxConstraint"></p>
<p>上图中的四个属性就是分别设置最大最小宽高，看属性名字就可以知道，不多说</p>
<h2 id="padding-与-margin"><a href="#padding-与-margin" class="headerlink" title="padding 与 margin"></a>padding 与 margin</h2><p>在前端中这两个属性可是用的最多的两个属性了。<code>padding</code>是设置元素的内边距，<code>margin</code>是设置元素的外边距。以一个矩形盒子为例，四条边框为边界，边框以外的是外边距，边框以内的是内边距。</p>
<p>不同于前端的是，Flutter中添加边距需要使用到<code>EdgeInsets</code>对象。他有如下几个使用方法</p>
<ol>
<li>EdgeInsets.all()</li>
<li>EdgeInsets.symmetric()</li>
<li>EdgeInsets.fromLTRB()</li>
<li>EdgeInsets.only()</li>
</ol>
<h3 id="EdgeInsets-all"><a href="#EdgeInsets-all" class="headerlink" title="EdgeInsets.all()"></a>EdgeInsets.all()</h3><p>参数接收一个<code>number</code>类型的值，设置为四周。比如<code>margin: EdgeInsets.all(10.0)</code>就是给元素设置一个10.0的外间距。</p>
<h3 id="EdgeInsets-symmetric"><a href="#EdgeInsets-symmetric" class="headerlink" title="EdgeInsets.symmetric()"></a>EdgeInsets.symmetric()</h3><p>这个可以分别设置水平方向与垂直方向上面的间距<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">margin: EdgeInsets.symmetric(</span><br><span class="line">  vertical: <span class="number">20</span>,</span><br><span class="line">  horizontal: <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中就是设置垂直方向上下间距是20，水平方向上面是0</p>
<h3 id="EdgeInsets-fromLTRB"><a href="#EdgeInsets-fromLTRB" class="headerlink" title="EdgeInsets.fromLTRB()"></a>EdgeInsets.fromLTRB()</h3><p>接收四个参数，分别设置L(left), T(top), R(right), B(bottom)的间距</p>
<h3 id="EdgeInsets-only"><a href="#EdgeInsets-only" class="headerlink" title="EdgeInsets.only()"></a>EdgeInsets.only()</h3><p>设置四个方向上面哪一个不是0，换句话说，没有设置的就是0<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">margin: EdgeInsets.only(</span><br><span class="line">  left: <span class="number">10</span>,</span><br><span class="line">  top: <span class="number">20</span></span><br><span class="line">)</span><br><span class="line">``` </span><br><span class="line">上面的代码中，就是设置元素左，上的间距是<span class="number">10</span>，<span class="number">20</span>，而没有设置的右，下的间距都是<span class="number">0</span></span><br><span class="line"></span><br><span class="line">**padding与margin的用法是一样的**</span><br><span class="line"></span><br><span class="line">## width 与 height</span><br><span class="line">这两个属性就不多说了，设置宽高的两个属性，值是`number`</span><br><span class="line"></span><br><span class="line">## transform</span><br><span class="line">`transform`在CSS3中使用的也是非常多的，也包含位移，旋转，缩放等功能。但是使用方法也是和CSS3中略有不同。CSS3中不仅支持关键词还支持`Matrix`矩阵，而Flutter中一般就使用`Matrix4`。</span><br><span class="line"></span><br><span class="line">![transform](https:<span class="comment">//pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/transform-flutter.gif)</span></span><br><span class="line"></span><br><span class="line">属性太多，就不一个一个介绍了，不过大部分的值的参数都是`number`类型的值。</span><br><span class="line"></span><br><span class="line">更多的属性以及关于矩阵的介绍可以查看[https:<span class="comment">//juejin.im/post/5be2fd9e6fb9a04a0e2cace0](https://juejin.im/post/5be2fd9e6fb9a04a0e2cace0)。在这里感谢掘金大佬提供的线索。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## decoration</span><br><span class="line">`decoration`是修饰，装饰的意思，所以，这个属性也是对容器的一个修饰装饰的属性。比如背景图，边框等等这些就是修饰。</span><br><span class="line"></span><br><span class="line">`decoration`可以使用以下几种，分别介绍一下一下几种修饰的使用方法</span><br><span class="line"></span><br><span class="line">- BoxDecoration</span><br><span class="line">- FlutterLogoDecoration</span><br><span class="line">- ShapeDecoration</span><br><span class="line">- UnderlineTabIndicator</span><br><span class="line"></span><br><span class="line">### BoxDecoration</span><br><span class="line">BoxDecoration 可以设置一下几种属性</span><br><span class="line"></span><br><span class="line">```dart</span><br><span class="line"><span class="keyword">const</span> BoxDecoration(&#123;</span><br><span class="line">  <span class="keyword">this</span>.color, <span class="comment">// 设置元素背景色</span></span><br><span class="line">  <span class="keyword">this</span>.image, <span class="comment">// 设置元素背景图</span></span><br><span class="line">  <span class="keyword">this</span>.border,</span><br><span class="line">  <span class="keyword">this</span>.borderRadius,</span><br><span class="line">  <span class="keyword">this</span>.boxShadow,</span><br><span class="line">  <span class="keyword">this</span>.gradient,</span><br><span class="line">  <span class="keyword">this</span>.backgroundBlendMode,</span><br><span class="line">  <span class="keyword">this</span>.shape = BoxShape.rectangle,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="color-1"><a href="#color-1" class="headerlink" title="color"></a>color</h4><p>设置背景颜色</p>
<p>有一点需要注意的地方，那就是如果你给元素设置了修饰属性，那么你就不能给元素设置color属性了，因为<code>decoration</code>属性中也是可以设置背景颜色的。<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190529092502.png" alt="重复设置报错"></p>
<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>设置背景图片，使用的类是<code>DecorationImage</code>。这个图片会出现在背景色和渐变上层。通常使用<code>NetworkImage</code>(网络图片)和<code>AssetImage</code>(本地图片)。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">image: DecorationImage(</span><br><span class="line">  image: NetworkImage(<span class="string">'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=324769017,4079415235&amp;fm=26&amp;gp=0.jpg'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>再来看看<code>DecorationImage</code>可以设置的属性<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DecorationImage(&#123;</span><br><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.image,</span><br><span class="line">  <span class="keyword">this</span>.colorFilter,</span><br><span class="line">  <span class="keyword">this</span>.fit,</span><br><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">  <span class="keyword">this</span>.centerSlice,</span><br><span class="line">  <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat,</span><br><span class="line">  <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>唯一要求的就是<code>image</code>这个属性，而<code>image</code>属性如何设置值上面已经提到了。那下面几个属性呢？<br><code>colorFilter</code>这个属性主要是对图片做处理，比如高亮，改变饱和度等等，这个属性用的不多。使用的话就是<code>ColorFilter</code>这个对象，有很多个值，有兴趣的可以自己试一试。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">image: DecorationImage(</span><br><span class="line">  image: NetworkImage(<span class="string">'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=324769017,4079415235&amp;fm=26&amp;gp=0.jpg'</span>),</span><br><span class="line">  colorFilter: ColorFilter.mode(Colors.red, BlendMode.screen)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190529100535.png" alt="设置colorFilter前后对比"></p>
<p>还可能用到的属性就是<code>fit</code>属性。这个有点像CSS3中的<code>background-size</code>属性，可以设置<code>BoxFit.cover</code>，用到的类就是<code>BoxFit</code>。其他的属性就不多说，基本使用默认的值就可以。</p>
<h4 id="border"><a href="#border" class="headerlink" title="border"></a>border</h4><p><code>border</code>设置边框，用到的就是<code>Border</code>这个类<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">border: Border.all(</span><br><span class="line">  color: Colors.black,</span><br><span class="line">  width: <span class="number">10</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>你可以使用Flutter给我们封装好的方法比如<code>Border.all</code>，也可以使用Border设置每一个边<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">border: Border(</span><br><span class="line">  left: BorderSide(</span><br><span class="line">    color: Colors.red,</span><br><span class="line">    width: <span class="number">1</span>,</span><br><span class="line">    style: BorderStyle.solid</span><br><span class="line">  ),</span><br><span class="line">  <span class="comment">// other side</span></span><br><span class="line">),</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>BorderSide</code>,<code>BorderStyle</code>都是Border中的分类。</p>
<h4 id="borderRadius"><a href="#borderRadius" class="headerlink" title="borderRadius"></a>borderRadius</h4><p>设置容器的圆角<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">borderRadius: BorderRadius.all(Radius.circular(<span class="number">50</span>))</span><br></pre></td></tr></table></figure></p>
<p>你还可以使用<code>BorderRadius.horizontal</code>，<code>BorderRadius.vertical</code>，<code>BorderRadius.only</code>来设置那个角是圆角。</p>
<p>这里关于<code>BoxDecoration</code>的见到介绍就到这里对了，如果你想了解<code>gradient</code>以及更多的其他属性，可以查看简书<a href="https://www.jianshu.com/p/9012bc9e2feb" target="_blank" rel="noopener">Flutter之BoxDecoration用法详解</a>，感谢<a href="https://www.jianshu.com/u/a5efff8c2b15" target="_blank" rel="noopener">huoshe2019</a>提供的优质文章。</p>
<h3 id="FlutterLogoDecoration"><a href="#FlutterLogoDecoration" class="headerlink" title="FlutterLogoDecoration"></a>FlutterLogoDecoration</h3><p><code>FlutterLogoDecoration</code>在盒子修饰中用的不多，更多的是用在Logo的修饰中。而且，如果你一使用这个属性，那么就会出来一个Flutter的图标。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">  width: <span class="number">300</span>,</span><br><span class="line">  height: <span class="number">300</span>,</span><br><span class="line">  decoration: FlutterLogoDecoration(</span><br><span class="line">    darkColor: Colors.red,</span><br><span class="line">    lightColor: Colors.green,</span><br><span class="line">    textColor: Colors.green</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190529103753.png" alt="FlutterLogoDecoration"></p>
<h3 id="ShapeDecoration"><a href="#ShapeDecoration" class="headerlink" title="ShapeDecoration"></a>ShapeDecoration</h3><p><code>ShapeDecoration</code>的大部分用法和<code>BoxDecoration</code>一直，需要注意的是他没有了设置圆角的功能，但是，border可是设置多个。每一个Border之间用 <strong>+</strong> 号链接。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">decoration: ShapeDecoration(</span><br><span class="line">  color: Colors.red,</span><br><span class="line">  shape: Border.all(</span><br><span class="line">    color: Colors.black,</span><br><span class="line">    width: <span class="number">10</span></span><br><span class="line">  ) + Border.all(</span><br><span class="line">    color: Colors.blue,</span><br><span class="line">    width: <span class="number">10</span></span><br><span class="line">  ) + Border.all(</span><br><span class="line">    color: Colors.green,</span><br><span class="line">    width: <span class="number">10</span></span><br><span class="line">  ),</span><br><span class="line">  image: DecorationImage(</span><br><span class="line">    image: NetworkImage(<span class="string">'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=324769017,4079415235&amp;fm=26&amp;gp=0.jpg'</span>),</span><br><span class="line">    colorFilter: ColorFilter.mode(Colors.red, BlendMode.screen),</span><br><span class="line">    fit: BoxFit.cover</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190529103421.png" alt="ShapeDecoration-Border"></p>
<h3 id="UnderlineTabIndicator"><a href="#UnderlineTabIndicator" class="headerlink" title="UnderlineTabIndicator"></a>UnderlineTabIndicator</h3><p>这个属性也是基本上是不会使用的，只是给盒子添加一个下边框线<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Text(<span class="string">'UnderlineTabIndicator'</span>),</span><br><span class="line">Container(</span><br><span class="line">  width: <span class="number">300</span>,</span><br><span class="line">  height: <span class="number">300</span>,</span><br><span class="line">  decoration: UnderlineTabIndicator(</span><br><span class="line">    borderSide: BorderSide(</span><br><span class="line">      width: <span class="number">10</span>,</span><br><span class="line">      color: Colors.red</span><br><span class="line">    )</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>所以，关于<code>decoration</code>这个属性，需要掌握的更多的还是<code>BoxDecoration</code>这个类，功能比较多，但是常用的属性上面已经介绍到了，如果要想了解更多关于渐变以及图片滤镜方面的知识，可以查看<a href="https://www.jianshu.com/p/9012bc9e2feb" target="_blank" rel="noopener">Flutter之BoxDecoration用法详解</a>。</p>
<h2 id="foregroundDecoration"><a href="#foregroundDecoration" class="headerlink" title="foregroundDecoration"></a>foregroundDecoration</h2><p><code>foregroundDecoration</code>的使用与<code>decoration</code>的使用时一样的，这里就不做过多的解释。</p>
<h1 id="Container的绘制流程"><a href="#Container的绘制流程" class="headerlink" title="Container的绘制流程"></a>Container的绘制流程</h1><p>上面了解了Container的一些常用的属性，当时有的可能我们还处于一脸懵逼的状态，比如上面有了<code>decoration</code>，为什么还有使用方法一模一样的<code>foregroundDecoration</code>呢？其实这就和Container的绘制流程有关系。</p>
<p>Container的回执流程如下：</p>
<ul>
<li>首先会绘制transform效果；</li>
<li>接着绘制decoration；</li>
<li>然后绘制child；</li>
<li>最后绘制foregroundDecoration。</li>
</ul>
<p>记住这个流程，然后再记住后面的回执的样式会覆盖前面绘制的样式。</p>
<p>关于Container的介绍接到这里，Container是Flutter中非常重要的一个Widget，一定要掌握。</p>
<p>关于同步代码可以查看<a href="https://github.com/tal007/FlutterApp" target="_blank" rel="noopener">https://github.com/tal007/FlutterApp</a>。</p>
<p>获取更多关于Flutter的知识点，点击<a href="https://blog.lyt007.cn/">踏浪博客</a>查看。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter Lesson 4: Flutter组件之App布局组件</title>
    <url>/%E6%8A%80%E6%9C%AF/Flutter-Lesson-4-Flutter%E7%BB%84%E4%BB%B6%E4%B9%8BApp%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6.html</url>
    <content><![CDATA[<p>首先来看一下我怎么来学习<code>Flutter</code>，我要了解每一个组件，同时，这又是一个App，所以，我的目标是直接生产一个App，里面就是对Flutter组件的介绍，同时写上一些demo以及源代码，这一个点子源于<a href="https://play.google.com/store/apps/details?id=name.ratson.uiexplorer&amp;hl=zh-CN" target="_blank" rel="noopener">React Native With Code</a>这一款App，在我学习React Native的时候给予了我很大的帮助。如果要构建这样的一款App，我需要先构建一个App首页，包含了一个可以滚动的列表，如果可以，还可以添加一些其他的组件。以及基础的布局组件。</p>
<h1 id="BuildContext"><a href="#BuildContext" class="headerlink" title="BuildContext"></a>BuildContext</h1><p>官方文档中说到: <code>A handle to the location of a widget in the widget tree.</code>。这是对<code>BuildContext</code>的解释，他就是字面意思就是：它是整个<code>widget tree</code>中的某一个<code>widget</code>的把手。既然有把手，那么就有位置了，所以说的高深一点就是<code>对构建的所有窗口小部件的树结构中的窗口小部件的位置的引用。</code></p>
<p>一个 BuildContext 只属于一个小部件。所有你会看到每一个Dart文件中的每一个类都只会有一个<code>BuildContext</code>。</p>
<p>一般 BuildContext 是和 <code>StateLessWidget</code> 使用，下面的写法算得上是一个固定的写法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StateLessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// @override 验证 @override 下面的方法名是否是你父类中所有的，如果没有则报错 </span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="comment">// build方法是StateLessWidget的构建方法，传递一个BuildContent暴露其在文档流中的位置</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="MaterialApp"><a href="#MaterialApp" class="headerlink" title="MaterialApp"></a>MaterialApp</h1><p><code>MaterialApp</code>是Google给我们封装好的一个UI库，如果要是有<code>MaterialApp</code>，我们需要在Dart文件的开头引用 <code>import &#39;package:flutter/material.dart&#39;;</code></p>
<p>使用<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StateLessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// @override 验证 @override 下面的方法名是否是你父类中所有的，如果没有则报错 </span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="comment">// build方法是StateLessWidget的构建方法，传递一个BuildContent暴露其在文档流中的位置</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      <span class="comment">// 配置属性</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>MaterialApp 的<a href="https://api.flutter.dev/flutter/material/MaterialApp-class.html" target="_blank" rel="noopener">属性</a>挺多的，不过常用的可能也就是 <code>home</code> , <code>initialRoute</code> 和 <code>routes</code>。 <code>routes</code> 就有点像react-router-dom，每一个route配置其对应的渲染页面。</p>
<p>下面是<code>MaterialApp</code>支持的属性<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MaterialApp(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.navigatorKey,</span><br><span class="line">  <span class="keyword">this</span>.home,</span><br><span class="line">  <span class="keyword">this</span>.routes = <span class="keyword">const</span> &lt;<span class="built_in">String</span>, WidgetBuilder&gt;&#123;&#125;,</span><br><span class="line">  <span class="keyword">this</span>.initialRoute,</span><br><span class="line">  <span class="keyword">this</span>.onGenerateRoute,</span><br><span class="line">  <span class="keyword">this</span>.onUnknownRoute,</span><br><span class="line">  <span class="keyword">this</span>.navigatorObservers = <span class="keyword">const</span> &lt;NavigatorObserver&gt;[],</span><br><span class="line">  <span class="keyword">this</span>.builder,</span><br><span class="line">  <span class="keyword">this</span>.title = <span class="string">''</span>,</span><br><span class="line">  <span class="keyword">this</span>.onGenerateTitle,</span><br><span class="line">  <span class="keyword">this</span>.color,</span><br><span class="line">  <span class="keyword">this</span>.theme,</span><br><span class="line">  <span class="keyword">this</span>.darkTheme,</span><br><span class="line">  <span class="keyword">this</span>.locale,</span><br><span class="line">  <span class="keyword">this</span>.localizationsDelegates,</span><br><span class="line">  <span class="keyword">this</span>.localeListResolutionCallback,</span><br><span class="line">  <span class="keyword">this</span>.localeResolutionCallback,</span><br><span class="line">  <span class="keyword">this</span>.supportedLocales = <span class="keyword">const</span> &lt;Locale&gt;[Locale(<span class="string">'en'</span>, <span class="string">'US'</span>)],</span><br><span class="line">  <span class="keyword">this</span>.debugShowMaterialGrid = <span class="keyword">false</span>,</span><br><span class="line">  <span class="keyword">this</span>.showPerformanceOverlay = <span class="keyword">false</span>,</span><br><span class="line">  <span class="keyword">this</span>.checkerboardRasterCacheImages = <span class="keyword">false</span>,</span><br><span class="line">  <span class="keyword">this</span>.checkerboardOffscreenLayers = <span class="keyword">false</span>,</span><br><span class="line">  <span class="keyword">this</span>.showSemanticsDebugger = <span class="keyword">false</span>,</span><br><span class="line">  <span class="keyword">this</span>.debugShowCheckedModeBanner = <span class="keyword">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      initialRoute: <span class="string">'/'</span>,</span><br><span class="line">      home:Scaffold(</span><br><span class="line">        <span class="comment">//创建一个Bar，并添加文本</span></span><br><span class="line">        appBar:AppBar(</span><br><span class="line">          title:Text(<span class="string">'Welcome to Flutter'</span>),</span><br><span class="line">          centerTitle: <span class="keyword">true</span>,</span><br><span class="line">          <span class="comment">// backgroundColor: Colors.purple,</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">//在主体的中间区域，添加一个hello world 的文本</span></span><br><span class="line">        body:Center(</span><br><span class="line">          child: <span class="keyword">new</span> HomeList(),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Scaffold"><a href="#Scaffold" class="headerlink" title="Scaffold"></a>Scaffold</h1><p><code>Scaffold</code>的中文意思是脚手架的意思，顾名思义，这个是一个可以快速帮我们构建一个App的脚手架，从而我们不需要自己动手去搭建页面的头部底部或者是右下角按钮等等。悄悄告诉你，其实<code>MaterialApp</code>等大多数Widget中的Child属性返回的都是一个<code>Scaffold</code>。</p>
<p>下面是<code>Scaffold</code>中的一些属性<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scaffold(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.appBar, <span class="comment">// 标题栏</span></span><br><span class="line">  <span class="keyword">this</span>.body, <span class="comment">// 内容</span></span><br><span class="line">  <span class="keyword">this</span>.floatingActionButton, <span class="comment">// 悬浮按钮</span></span><br><span class="line">  <span class="keyword">this</span>.floatingActionButtonLocation, <span class="comment">// 悬浮按钮位置</span></span><br><span class="line">  <span class="keyword">this</span>.floatingActionButtonAnimator, <span class="comment">// 悬浮按钮动画</span></span><br><span class="line">  <span class="keyword">this</span>.persistentFooterButtons, <span class="comment">// 底部持久化现实按钮</span></span><br><span class="line">  <span class="keyword">this</span>.drawer, <span class="comment">// 侧滑菜单 左侧</span></span><br><span class="line">  <span class="keyword">this</span>.endDrawer, <span class="comment">// 侧滑菜单 右侧</span></span><br><span class="line">  <span class="keyword">this</span>.bottomNavigationBar, <span class="comment">// 底部导航</span></span><br><span class="line">  <span class="keyword">this</span>.bottomSheet,</span><br><span class="line">  <span class="keyword">this</span>.backgroundColor, <span class="comment">// 背景色</span></span><br><span class="line">  <span class="keyword">this</span>.resizeToAvoidBottomPadding, <span class="comment">//自动适应底部padding</span></span><br><span class="line">  <span class="keyword">this</span>.resizeToAvoidBottomInset,</span><br><span class="line">  <span class="keyword">this</span>.primary = <span class="keyword">true</span>, <span class="comment">// 使用App主色，App主色在 MaterialApp 中可以设置</span></span><br><span class="line">  <span class="keyword">this</span>.drawerDragStartBehavior = DragStartBehavior.start, <span class="comment">// 抽屉拖拽表现</span></span><br><span class="line">  <span class="keyword">this</span>.extendBody = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>因为<code>Scaffold</code>更多的相当于一个容器，主要的还是在于里面的内容，所以我们更多的是要去看看它里面的这些属性的用法，因为每一个属性我们都是需要单独的进行配置的。</p>
<h1 id="AppBar"><a href="#AppBar" class="headerlink" title="AppBar"></a>AppBar</h1><p>这个是可以创建一个App标题栏的Widget，也支持很多的属性<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AppBar(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.leading, <span class="comment">// 导航widget，一般就是标题栏左侧的返回键</span></span><br><span class="line">  <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span><br><span class="line">  <span class="keyword">this</span>.title, <span class="comment">// 标题</span></span><br><span class="line">  <span class="keyword">this</span>.actions, <span class="comment">// 右侧附属，比如菜单或者是下拉</span></span><br><span class="line">  <span class="keyword">this</span>.flexibleSpace,</span><br><span class="line">  <span class="keyword">this</span>.bottom,</span><br><span class="line">  <span class="keyword">this</span>.elevation,</span><br><span class="line">  <span class="keyword">this</span>.shape,</span><br><span class="line">  <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">  <span class="keyword">this</span>.brightness,</span><br><span class="line">  <span class="keyword">this</span>.iconTheme,</span><br><span class="line">  <span class="keyword">this</span>.actionsIconTheme,</span><br><span class="line">  <span class="keyword">this</span>.textTheme,</span><br><span class="line">  <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line">  <span class="keyword">this</span>.centerTitle,</span><br><span class="line">  <span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class="line">  <span class="keyword">this</span>.toolbarOpacity = <span class="number">1.0</span>,</span><br><span class="line">  <span class="keyword">this</span>.bottomOpacity = <span class="number">1.0</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>先来了解一下<code>title</code>和<code>centerTitle</code>属性，其余的我们可以在AppBar中详细的了解。</p>
<p>顾名思义，title就是标题的意思，centerTitle就是标题居中的意思。</p>
<h1 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h1><p>很简单，Text就是文本的意思，我们要显示的文本都是放在Text Widget中的。Text属性也有很多<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Text(</span><br><span class="line">  <span class="keyword">this</span>.data, &#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.style,</span><br><span class="line">  <span class="keyword">this</span>.strutStyle,</span><br><span class="line">  <span class="keyword">this</span>.textAlign,</span><br><span class="line">  <span class="keyword">this</span>.textDirection,</span><br><span class="line">  <span class="keyword">this</span>.locale,</span><br><span class="line">  <span class="keyword">this</span>.softWrap,</span><br><span class="line">  <span class="keyword">this</span>.overflow,</span><br><span class="line">  <span class="keyword">this</span>.textScaleFactor,</span><br><span class="line">  <span class="keyword">this</span>.maxLines,</span><br><span class="line">  <span class="keyword">this</span>.semanticsLabel,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h1><p><code>Container</code>是容器的意思，主要是负责容器的布局，有点类似HTML中的div标签，可以设置padding和margin。<code>需要注意的是，在Flutter中，少数Widget才可以设置padding和margin，大部分Widget是不行的，所以如果要设置这些属性，我们需要使用Container进行包裹。而不是像HTML中一样，大部分都可以设置padding与margin</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.alignment,</span><br><span class="line">  <span class="keyword">this</span>.padding,</span><br><span class="line">  Color color,</span><br><span class="line">  Decoration decoration,</span><br><span class="line">  <span class="keyword">this</span>.foregroundDecoration,</span><br><span class="line">  <span class="built_in">double</span> width,</span><br><span class="line">  <span class="built_in">double</span> height,</span><br><span class="line">  BoxConstraints constraints,</span><br><span class="line">  <span class="keyword">this</span>.margin,</span><br><span class="line">  <span class="keyword">this</span>.transform,</span><br><span class="line">  <span class="keyword">this</span>.child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>部分代码展示<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首页的ListView组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MaterialAppInfo());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaterialAppInfo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  MaterialAppInfo(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(title),</span><br><span class="line">        ),</span><br><span class="line">        body: Container(</span><br><span class="line">          <span class="comment">// padding: const EdgeInsets.fromLTRB(20, 10, 20, 10),</span></span><br><span class="line">          child: RaisedButton(</span><br><span class="line">            onPressed: ()&#123;</span><br><span class="line">              Navigator.pop(context);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(</span><br><span class="line">              <span class="string">'踏浪'</span></span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h1><p>因为首页我们要显示的是一个长列表，所以我们需要使用<code>ListView</code>，这个在Flutter是一个简单的列表组件，Flutter中还包含了其余的多种列表组件，这些以后再介绍。</p>
<p>ListView有三种创建方式，最简单的就是直接使用ListView<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView(</span><br><span class="line">  padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Container(</span><br><span class="line">      height: <span class="number">50</span>,</span><br><span class="line">      color: Colors.amber[<span class="number">600</span>],</span><br><span class="line">      child: <span class="keyword">const</span> Center(child: Text(<span class="string">'Entry A'</span>)),</span><br><span class="line">    ),</span><br><span class="line">    Container(</span><br><span class="line">      height: <span class="number">50</span>,</span><br><span class="line">      color: Colors.amber[<span class="number">500</span>],</span><br><span class="line">      child: <span class="keyword">const</span> Center(child: Text(<span class="string">'Entry B'</span>)),</span><br><span class="line">    ),</span><br><span class="line">    Container(</span><br><span class="line">      height: <span class="number">50</span>,</span><br><span class="line">      color: Colors.amber[<span class="number">100</span>],</span><br><span class="line">      child: <span class="keyword">const</span> Center(child: Text(<span class="string">'Entry C'</span>)),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>因为使用了ListView Widget，接收的不在是一个简单的子元素而是一堆数据，使用是<code>children</code>属性而不再是<code>child</code>了。<code>children</code>接收的是一个<code>&lt;Widget&gt;数组</code>。这是最简单的，但是也是死的。</p>
<p>但是如我我们要进行动态的产生数据，那么就不能一个一个的写死，所以需要使用到<code>ListView.builder</code>。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; entries = &lt;<span class="built_in">String</span>&gt;[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; colorCodes = &lt;<span class="built_in">int</span>&gt;[<span class="number">600</span>, <span class="number">500</span>, <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">ListView.builder(</span><br><span class="line">  padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">  itemCount: entries.length,</span><br><span class="line">  itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      height: <span class="number">50</span>,</span><br><span class="line">      color: Colors.amber[colorCodes[index]],</span><br><span class="line">      child: Center(child: Text(<span class="string">'Entry <span class="subst">$&#123;entries[index]&#125;</span>'</span>)),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><code>itemCount</code>属性是生成的数据条数，一般就是我们ajax请求的数据了。<code>itemBuilder</code>就是构建我们的每一条数据，需要<code>return</code>一个Widget。</p>
<p><code>ListView</code>还有一个方法<code>ListView.separated</code>。与<code>builder</code>的区别就是他可以画一条分割线，使用这个方法必须给他设置一个<code>separatorBuilder</code>属性，否则会报错。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; entries = &lt;<span class="built_in">String</span>&gt;[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; colorCodes = &lt;<span class="built_in">int</span>&gt;[<span class="number">600</span>, <span class="number">500</span>, <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">ListView.separated(</span><br><span class="line">  padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">  itemCount: entries.length,</span><br><span class="line">  itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      height: <span class="number">50</span>,</span><br><span class="line">      color: Colors.amber[colorCodes[index]],</span><br><span class="line">      child: Center(child: Text(<span class="string">'Entry <span class="subst">$&#123;entries[index]&#125;</span>'</span>)),</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  separatorBuilder: (BuildContext context, <span class="built_in">int</span> index) =&gt; <span class="keyword">const</span> Divider(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h1><p>最后就是关于路由的部分，来看看下面这张图<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/1.gif" alt="路由跳转"></p>
<p>首页展示了列表，我们可以点击每一项进入到子页面，这个时候我们就需要使用到路由组件。</p>
<p>我们是点击，然后退出或是返回上一个页面，但是如果我们要添加点击事件，一般的组件还是不行的，需要使用<code>Button</code>才可以添加点击事件，却是没有<code>web前端</code>来的利索。我们这里使用了<code>RaisedButton</code>这个Widget<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  onPressed: ()&#123;</span><br><span class="line">    Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">      builder: (context) =&gt; <span class="keyword">new</span> MaterialAppInfo(title: text)</span><br><span class="line">    ));</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(</span><br><span class="line">    text,</span><br><span class="line">    style: TextStyle(</span><br><span class="line">      fontSize: <span class="number">26</span>,</span><br><span class="line">      color: Colors.blue</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>先来了解两个方法，<code>push</code>和<code>pop</code>。</p>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>推出下一个页面，使用方法就是<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onPressed: ()&#123;</span><br><span class="line">  Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">    builder: (context) =&gt; <span class="keyword">new</span> MaterialAppInfo(title: text)</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要有两个参数，第一个参数<code>context</code>即可，可以理解为context关联上下文，和下一级页面关联起来，以便之后返回。第二个参数需要使用到<code>new MaterialPageRoute</code>调用一个组件，传递一个<code>builder</code>，这是一个函数，返回需要显示的组件即可。关于传值，就在返回的组件中传值即可。</p>
<h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p>pop很简单<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onPressed: ()&#123;</span><br><span class="line">  Navigator.pop(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接使用即可。但是同样需要绑定在按钮Widget下面才可以。</p>
<h2 id="使用固定的路由名"><a href="#使用固定的路由名" class="headerlink" title="使用固定的路由名"></a>使用固定的路由名</h2><p>上面说到的路由其实只是Navigator的一种，还有一种就是使用固定的路由名，有点像<code>react-router</code><br>中我们定义一个Router把所有的路由都放在里面</p>
<p>下面看看主入口文件<code>main.dart</code><br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./home/index.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'MaterialApp/index.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，入口函数</span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      <span class="comment">// title: "Learn Flutter",</span></span><br><span class="line">      routes: &#123;</span><br><span class="line">        <span class="string">"materialAppInfo"</span>: (BuildContext context) =&gt; MaterialAppInfo(title: <span class="string">'materialAppInfo'</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      home: HomeList()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中的<code>routes</code>就是路由，如果要跳转到<code>MaterialAppInfo</code>这个页面<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onPressed: ()&#123;</span><br><span class="line">  Navigator.pushNamed(context, <span class="string">'materialAppInfo'</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>使用<code>Navigator.pushNamed</code>方法，第二个参数就是我们需要跳转的路由。</p>
<h1 id="补充说明（very-important）"><a href="#补充说明（very-important）" class="headerlink" title="补充说明（very important）"></a>补充说明（very important）</h1><p>前文们提到了<code>MaterialApp</code>组件，这个组件其实一般就在<code>main.dart</code>中使用一次就可以了，因为如果在一个项目中使用了多次<code>MaterialApp</code>，同时你使用了固定路由配置，即<code>routes</code>配置路由，那么这个配置会以最后一个为参考，可能会出现不可控的错误。</p>
<p>子组件中，你如果首先想到的是时候<code>MaterialApp</code>，那么你可以考虑换成<code>Scaffold</code>或者其他的容器组件</p>
<h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>上面就是关于搭建这样一个App需要了解的一些基本的Widget以及其属性，上面并没有涉及到全部的属性，这些属性我们将在介绍每一个Widget的时候在详细说明，还请持续关注本博客。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter Lesson 3：Flutter组件（widget）前篇</title>
    <url>/%E6%8A%80%E6%9C%AF/Flutter-Lesson-3%EF%BC%9AFlutter%E7%BB%84%E4%BB%B6%EF%BC%88widget%EF%BC%89%E5%89%8D%E7%AF%87.html</url>
    <content><![CDATA[<p>介绍完<code>Flutter</code>开发环境的搭建以及<code>Dart</code>基础语法，我们就可以着手进行开发了。一般我们开始学习一门技术或者是一门语言的时候，都会写一个<strong>Hello World</strong>的Demo。所以，撸起袖子开始干。不过在职之前，我们先来看看Flutter项目的默认文件以及目录结构。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/Snipaste_2019-05-17_09-40-40.png" alt="Flutter项目的默认目录结构"></p>
<p>图中有几个关键的地方，我们首相来看看这个<code>lib</code>文件夹。这个文件夹里面主要就是存放我们自己编写的的代码了，其中默认有一个<code>main.dart</code>，这个文件是整个项目的入口文件，而且名字就是要是<code>main.dart</code>。还有就是项目的配置文件<code>pubspec.yaml</code>以及<code>Android</code>，<code>IOS</code>两个文件夹，我们在修改一些配置的时候会用到，但是目前用不到。</p>
<p>下面，我们就来看看项目中默认的<code>main.dart</code>文件吧</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目的入口文件</span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This widget is the root of your application.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: MyHomePage(title: <span class="string">'Flutter Demo Home Page'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">'You have pushed the button this many times:'</span>,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">'<span class="subst">$_counter</span>'</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">'Increment'</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ), <span class="comment">// This trailing comma makes auto-formatting nicer for build methods.</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们已经介绍过了<code>Dart</code>的基本的语法，所以上面的代码，大部分你应该是能够看懂的。如果你没有看前面的文章，可以看看<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/Flutter-Lesson-2-Dart-%E8%AF%AD%E6%B3%95%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html">Dart语法简介</a>。我们看不明白的可能就是类继承时使用到的 <code>StatelessWidget</code> 和 <code>StatefulWidget</code> 两个类（组件）以及一些Flutter Widget。</p>
<h2 id="StatelessWidget-与-StatefulWidget"><a href="#StatelessWidget-与-StatefulWidget" class="headerlink" title="StatelessWidget 与 StatefulWidget"></a>StatelessWidget 与 StatefulWidget</h2><p>我们可以根据名字来看，<code>StatelessWidget</code> 和 <code>StatefulWidget</code> 两个组件中都包含 <em>state</em> 和 <code>widget</code> 这两个单词。 state 是状态的意思， widget 是(小)部件的意思。</p>
<ul>
<li>StatelessWidget : 不可变状态窗口部件，也就是你在使用时不可以改变，比如固定的文字（写上后就在那里了，死也不会变了）。像上面代码中<code>MyApp</code>类就是继承的这个组件，<code>MyApp</code>中也就是固定的文字，主题色等等，这些一般我们都不会改变的。</li>
<li>StatefulWidget : 具有可变状态的窗口部件，也就是你在使用应用的时候就可以随时变化，比如我们常见的进度条，随着进度不断变化。像上面代码中<code>MyHomePage</code>类就是继承的这个组件，因为HomePage中有一个计数的(+号点击)，这个是一个动态的组件，所以我们使用了<code>StatefulWidget</code>。</li>
</ul>
<p>不管是<code>StatelessWidget</code>,<code>StatefulWidget</code>，还是代码中看到的<code>Center</code>，<code>Column</code>，<code>Text</code>等都是Flutter为我们封装好的<code>Widget</code>，我们可以直接使用，这些组件我们会在以后介绍。</p>
<h2 id="编写Hello-World"><a href="#编写Hello-World" class="headerlink" title="编写Hello World"></a>编写Hello World</h2><p>我们修改我们的<code>main.dart</code>文件。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，入口函数</span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home:Scaffold(</span><br><span class="line">        <span class="comment">//创建一个Bar，并添加文本</span></span><br><span class="line">        appBar:AppBar(</span><br><span class="line">          title:Text(<span class="string">'Welcome to Flutter'</span>),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">//在主体的中间区域，添加一个hello world 的文本</span></span><br><span class="line">        body:Center(</span><br><span class="line">          child:Text(<span class="string">'Hello World'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>import &#39;package:flutter/material.dart&#39;;</code>这行代码基本上每一个组件都会用到，因为所有的<code>Widget</code>都在这个包里面。</p>
<p>接下来的日子里，我们就来看看Flutter中都有哪些实用好看的Widget吧</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter Lesson 2: Dart 语法简单介绍</title>
    <url>/%E6%8A%80%E6%9C%AF/Flutter-Lesson-2%EF%BC%9ADart-%E8%AF%AD%E6%B3%95%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html</url>
    <content><![CDATA[<p><a href="https://Dart.dev/" target="_blank" rel="noopener">Dart语法</a>【<a href="http://Dart.goodev.org/" target="_blank" rel="noopener">Dart中文</a>】可以说是Google因为为Flutter量身定做的一门语言，所以，我们之前基本上都没有接触过这门语言，在入手Flutter坑的时候，还必须了解一下Dart的语言特性。</p>
<p><a href="https://Dart.dev/" target="_blank" rel="noopener">Dart官网</a>【<a href="http://Dart.goodev.org/" target="_blank" rel="noopener">Dart中文</a>】上面已经有了很详细的说明，我这里只是见多的说说，提取一些重点，以便自己复习以及你们学习。<br>v</p>
<h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>每一个<code>.Dart</code>文件都会有一个<code>mian()</code>函数，这个称之为程序的入口文件，这就像是<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">前端ES6</a>语法中的<code>export</code>一样，都要有一个输出。其实，Dart的设计就有一点遵循前端的ES6语法，不过他还结合了一些c语言<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序的入口文件</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">/* 或者用这种注释 */</span></span><br><span class="line">  <span class="comment">// main函数输出了一点东西，print 控制台输出</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'我是main函数，我是程序执行的入口'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码都可以在<a href="https://Dartpad.Dartlang.org/" target="_blank" rel="noopener">DartPad</a>上面运行，你也可以自行修改代码，不过不可能需要开着VPN才可以访问这个网站。</p>
<h1 id="Dart关键字"><a href="#Dart关键字" class="headerlink" title="Dart关键字"></a>Dart关键字</h1><p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190514085407.png" alt="关键字"></p>
<p>关键字的意思就不用多说了，注意上图中的关键字，在变量命名的时候不要使用就行了。</p>
<h1 id="重要的概念（重要）"><a href="#重要的概念（重要）" class="headerlink" title="重要的概念（重要）"></a>重要的概念（重要）</h1><ul>
<li>在Dart中，所有的能够使用变量引用的都是对象，每一个对象都有一个实例，包括但不限于数字，方法，字符串，null。所有的对象都集成于Object类。这个需要注意，这个和JavaScript中的变量还是有很大的差别的</li>
<li>虽然Dart是强类型语言，但变量类型是可选的因为Dart可以自动推断变量类型</li>
<li>Dart支持顶层方法（如main方法），也支持类方法或对象方法，同时你也可以在方法内部创建方法</li>
<li>Dart支持顶层变量，也支持类变量或对象变量</li>
<li>Dart中的私有变量用<code>_</code>开头，有点像JS中我们自定义函数的时候默认<code>_</code>开头的为私有变量</li>
<li>Dart中变量可以以字母或下划线开头，后面跟着任意组合的字符或数字，不能使用<code>$</code>，这里面的<code>$</code>一般用于字符串拼接</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>每一种编程语言都会有变量，Dart也不例外，不过Dart的区别就是其声明变量的方式有多种。</p>
<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p>最简单的就是使用<code>var</code>关键字，你也可以使用<code>dynamic</code>,表示没有指定变量类型</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'tal'</span>;</span><br><span class="line"><span class="keyword">dynamic</span> number = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>
<p>使用<code>var</code>定义变量，最好是定义局部变量</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>如果你在定义了一个变量以后，同时并没有对其进行赋值，那么，这个变量最终的类型会是<code>null</code>(注意不是<code>undefined</code>)。</p>
<p>因为前面我已以及说过了，Dart中所有的变量引用都是对象。</p>
<h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>在声明变量的时候我们可以加上他的类型，这个是google从TS中吸取到的经验<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> name = <span class="string">'tal'</span>;</span><br></pre></td></tr></table></figure></p>
<p>使用这种方式定义变量可以是全局变量和局部变量，但是如果是使用<code>var</code>定义变量，最好是用于定义局部变量。</p>
<p>Dart中内置了以下几种类型</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>List ( means array )</li>
<li>Map</li>
<li>Rune ( 用于在字符串中表示 Unicode 字符 )</li>
<li>Symbol</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">dynamic</span> a = <span class="string">'没有指定变量类型'</span>;</span><br><span class="line">  <span class="built_in">print</span>(a); <span class="comment">// 没有指定变量类型</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//   number</span></span><br><span class="line">  <span class="keyword">var</span> na = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int</span> nb = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">double</span> nc = <span class="number">1.2</span>;</span><br><span class="line">  <span class="built_in">print</span>(na); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">print</span>(nb); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">print</span>(nc); <span class="comment">// 1.2</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">//   String</span></span><br><span class="line">  <span class="keyword">var</span> sa = <span class="string">'hello'</span>;</span><br><span class="line">  <span class="built_in">String</span> sb = <span class="string">'world'</span>;</span><br><span class="line">  <span class="built_in">print</span>(sa); <span class="comment">// hello</span></span><br><span class="line">  <span class="built_in">print</span>(sb); <span class="comment">// world</span></span><br><span class="line"><span class="comment">//   字符串插值，当然，你也可以使用 + 进行字符串拼接</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$sa</span> <span class="subst">$&#123;sb&#125;</span>'</span>); <span class="comment">// hello world</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//   bool</span></span><br><span class="line">  <span class="keyword">var</span> bt = <span class="keyword">true</span>;</span><br><span class="line">  <span class="built_in">bool</span> bf = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//   list</span></span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="string">'a'</span>, <span class="keyword">false</span>];</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="keyword">dynamic</span>&gt; arr2 = [<span class="number">1</span>, <span class="string">'a'</span>, <span class="keyword">true</span>];</span><br><span class="line">  <span class="built_in">print</span>(arr); <span class="comment">// [1, a, false]</span></span><br><span class="line">  <span class="built_in">print</span>(arr1); <span class="comment">// [a, b, c]</span></span><br><span class="line">  <span class="built_in">print</span>(arr2); <span class="comment">// [1, a, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map Map 是一个键值对相关的对象，有点像JS中的Object</span></span><br><span class="line">  <span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">'踏浪'</span>,</span><br><span class="line">    <span class="string">"sex"</span>: <span class="string">'男'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">print</span>(person); <span class="comment">// &#123;name: 踏浪, sex: 男&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> company = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  company[<span class="string">'leader'</span>] = <span class="string">'踏浪'</span>;</span><br><span class="line">  company[<span class="string">'money'</span>] = <span class="number">10000</span>;</span><br><span class="line">  <span class="built_in">print</span>(company); <span class="comment">// &#123;leader: 踏浪, money: 10000&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// runes，Dart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符</span></span><br><span class="line">  <span class="keyword">var</span> clapping = <span class="string">'\u&#123;1f44f&#125;'</span>;</span><br><span class="line">  <span class="built_in">print</span>(clapping); <span class="comment">// 打印的是拍手emoji的表情</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// symbols  使用 # 符号获取你 new 的这一个 symbol</span></span><br><span class="line"><span class="comment">// 类似于JS中的Symbol，获取方式有点不同。在Dart项目中，获取你从来用不到Symbol</span></span><br><span class="line">  <span class="built_in">print</span>(#s == <span class="keyword">new</span> <span class="built_in">Symbol</span>(<span class="string">"s"</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是，在Dart中，每一个语句结束必须加上 ; 以表示语句结束</strong></p>
<h2 id="final-与-const"><a href="#final-与-const" class="headerlink" title="final 与 const"></a>final 与 const</h2><p><code>const</code> 就是JS中的const，声明一个变量(一般是常量)，从此不再修改。这里把<code>final</code>也放到这里，当然功效也是一样的<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">final</span> b = a;</span><br><span class="line">  <span class="keyword">const</span> c = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">  c = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你执行了上面的代码，你将会看到如下的错误</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190514231345.png" alt="错误提示"></p>
<p><code>final</code> 在声明的时候更多的声明一个变量，而 <code>const</code> 更多的时候声明的是一个常量，有点像JS中的 <code>let</code> 与 <code>const</code>，例如在Flutter初始化项目的时候有一个这样的代码。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This widget is the home page of your application. It is stateful, meaning</span></span><br><span class="line">  <span class="comment">// that it has a State object (defined below) that contains fields that affect</span></span><br><span class="line">  <span class="comment">// how it looks.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This class is the configuration for the state. It holds the values (in this</span></span><br><span class="line">  <span class="comment">// case the title) provided by the parent (in this case the App widget) and</span></span><br><span class="line">  <span class="comment">// used by the build method of the State. Fields in a Widget subclass are</span></span><br><span class="line">  <span class="comment">// always marked "final".</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="final-与-const的区别"><a href="#final-与-const的区别" class="headerlink" title="final 与 const的区别"></a>final 与 const的区别</h3><ol>
<li><code>final</code> 要求变量只能初始化一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。而 <code>const</code> 要求在声明时初始化，并且赋值必需为编译时常量</li>
<li><code>final</code> 是惰性初始化，即在运行时第一次使用前才初始化。而 <code>const</code> 是在编译时就确定值了。</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Dart中的函数有三种<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明返回值类型 int</span></span><br><span class="line"><span class="built_in">int</span> add1(<span class="built_in">int</span> a, <span class="built_in">int</span> b)&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不声明返回值类型</span></span><br><span class="line">add2(<span class="built_in">int</span> a, <span class="built_in">int</span> b)&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line">add3(a, b) =&gt; a + b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">print</span>(add1(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">print</span>(add2(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">print</span>(add3(<span class="string">'hello '</span>, <span class="string">' world'</span>)); <span class="comment">// hello  world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，Dart中函数中参数的类型需要有一定的限制，同时<code>num</code>与<code>String</code>是不可相加的<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>+<span class="string">'a'</span>); <span class="comment">// Error: The argument type 'String' can't be assigned to the parameter type 'num'. print(1+'a');</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>命名参数是有两种方式 <code>type key</code> 或者是 <code>key: type</code> 的形式，<strong>但是都必须使用 {} 括起来</strong>，例如<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">person(&#123;<span class="built_in">String</span> name, <span class="built_in">int</span> age&#125;) =&gt; <span class="built_in">print</span>(<span class="string">'Hello, my name is <span class="subst">$name</span>, i am <span class="subst">$age</span>.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  person(name: <span class="string">'踏浪'</span>, age: <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传递参数的时候使用 <code>key: value</code> 的形式即可。</p>
<h3 id="可选位置参数"><a href="#可选位置参数" class="headerlink" title="可选位置参数"></a>可选位置参数</h3><p>把一些方法的参数放到 <code>[]</code> 中就变成可选 位置参数了<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> says <span class="subst">$msg</span>'</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'<span class="subst">$result</span> with a <span class="subst">$device</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不使用可选参数<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>)) <span class="comment">// 'Bob says Howdy'</span></span><br></pre></td></tr></table></figure></p>
<p>使用可选参数<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>, <span class="string">'smoke signal'</span>)) <span class="comment">// 'Bob says Howdy with a smoke signal'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>你可以给参数指定默认值，如果传递了参数，那么取代默认值，否则使用默认值<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">person(<span class="built_in">String</span> name = <span class="string">'踏浪'</span>) =&gt; <span class="string">'My name is <span class="subst">$name</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">print</span>(person()); <span class="comment">// My name is 踏浪</span></span><br><span class="line">  <span class="built_in">print</span>(person(<span class="string">'Anthony'</span>)); <span class="comment">// My name is Anthony</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><p>每一个<code>.dart</code>文件都应该有一个入口函数，即：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以有一个可选参数，参数类型是 List</span></span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arguments)&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="一等对象方法"><a href="#一等对象方法" class="headerlink" title="一等对象方法"></a>一等对象方法</h2><p>可以把方法当做参数调用另外一个方法。例如：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">printElement(element) &#123;</span><br><span class="line">  <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass printElement as a parameter.</span></span><br><span class="line">list.forEach(printElement);</span><br></pre></td></tr></table></figure></p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>同样是上面的例子<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass printElement as a parameter.</span></span><br><span class="line">list.forEach((element) &#123;</span><br><span class="line">  <span class="built_in">print</span>(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>forEach方法中的参数函数就是一个匿名函数</p>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>所有的函数都有返回值，如果没有指定return语句，那么该函数的返回值为null。</p>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>Dart中的操作符在大部分语言中都是有的，可以看看下面的表格<br>|描述|操作符|<br>|—|—|<br>|unary postfix|    expr++    expr–    ()    []    .    ?.|<br>|unary prefix|    -expr    !expr    ~expr    ++expr    –expr   |<br>|multiplicative|    <em>    /    %  ~/|<br>|additive|    +    -|<br>|shift|    &lt;&lt;    &gt;&gt;|<br>|bitwise AND|    &amp;|<br>|bitwise XOR|    ^|<br>|bitwise OR    ||<br>|relational and type test|    &gt;=    &gt;    &lt;=    &lt;    as    is    is!|<br>|equality|    ==    !=   |<br>|logical AND|    &amp;&amp;|<br>|logical OR|    || |<br>|if null|    ??|<br>|conditional|    expr1 ? expr2 : expr3|<br>|cascade|    ..|<br>|assignment|    =    </em>=    /=    ~/=    %=    +=    -=    &lt;&lt;=    &gt;&gt;=    &amp;=    ^=    |=    ??=|</p>
<p>常见的就可以不用说了，主要说一下在JS中不怎么常见的。</p>
<h2 id="type-tset-类型判断"><a href="#type-tset-类型判断" class="headerlink" title="type tset(类型判断)"></a>type tset(类型判断)</h2><ul>
<li>as：类型转换</li>
<li>is：类型判断，如果对象是指定的类型怎返回 <code>true</code><br>= is!：类型转换，与<code>is</code>相反</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123; <span class="comment">// 类型检测</span></span><br><span class="line">  emp.firstName = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用以下代码简化上面的代码</span></span><br><span class="line">(emp <span class="keyword">as</span> Person).firstName = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure>
<p><code>注意： 上面这两个代码效果是有区别的。如果 emp 是 null 或者不是 Person 类型， 则第一个示例使用 is 则不会执行条件里面的代码，而第二个情况使用 as 则会抛出一个异常。</code></p>
<h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><p>常用的赋值操作符都是<code>=</code>，dart中有一个<code>??=</code><br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">a = value;   <span class="comment">// 给 a 变量赋值</span></span><br><span class="line">b ??= value; <span class="comment">// 如果 b 是 null，则赋值给 b；</span></span><br><span class="line">             <span class="comment">// 如果不是 null，则 b 的值保持不变</span></span><br></pre></td></tr></table></figure></p>
<h2 id="级联操作符（cascade）"><a href="#级联操作符（cascade）" class="headerlink" title="级联操作符（cascade） (..)"></a>级联操作符（cascade） (..)</h2><p>级联操作有点像JQ中的链式调用，不同点是JQ的链式调用需要上一个方法返回这个对象自身，而级联操作是不需要的，使用级联操作后，自动返回自身</p>
<p>如果是在web前端中，我们要获取一个元素，修改他的一些属性<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>)</span><br><span class="line">img.alt = <span class="string">'图片'</span></span><br><span class="line">img.src = <span class="string">'XXX'</span></span><br><span class="line">img.width = <span class="string">'100'</span></span><br><span class="line">img.height = <span class="string">'100'</span></span><br></pre></td></tr></table></figure></p>
<p>如果是使用Dart中的<code>..</code>操作符，可以这样写（这里只是以此为例，不一定存在前端中的document等）<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">'img'</span>)</span><br><span class="line">  ..alt = <span class="string">'图片'</span></span><br><span class="line">  ..src = <span class="string">'XXX'</span></span><br><span class="line">  ..width = <span class="string">'100'</span></span><br><span class="line">  ..height = <span class="string">'100'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>Dart中的流程控制与前端中的流程控制是一样的，也就以下几种</p>
<ul>
<li><code>if</code> and <code>if...else</code></li>
<li><code>for</code> loops</li>
<li><code>while</code> and <code>do-while</code></li>
<li><code>break</code> and <code>continue</code></li>
<li><code>switch</code> and <code>case</code></li>
<li><code>try...catch</code> and <code>try...finally</code></li>
<li><code>assert</code></li>
</ul>
<p>还是有一些不同点的，需要注意</p>
<ol>
<li>在 <code>switch...case</code> 语句中，case语句中的数据类型必须是跟switch中的类型一致</li>
</ol>
<p>Dart中还有一个<strong>assert（断言）</strong>，作用是：如果条件表达式结果不满足需要，则可以使用 assert 语句俩打断代码的执行。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保 text 不是nunll</span></span><br><span class="line"><span class="keyword">assert</span>(text != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保 number 的值 小于100</span></span><br><span class="line"><span class="keyword">assert</span>(number &lt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p><code>但是：断言只在开发环境有效，如果是生产环境，则无效</code>。</p>
<h1 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h1><p>前端在ES6中才引入了类的概念，即使用<code>class</code>关键字创建一个类<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Point(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"> 	<span class="built_in">print</span>(p.x); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">print</span>(p.y);  <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">print</span>(p.z); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在使用<code>class</code>构建一个类的同时，<strong>在定义一个与类名字相同的方法就定义了一个构造函数</strong>，如上面的<code>Point</code>类中的<code>Point</code>方法。</p>
<p><strong>由于把构造函数参数赋值给实例变量的场景太常见了， Dart 提供了一个语法糖来简化这个操作：</strong></p>
<p>如下面的代码和之前的代码是完全一样的<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认的构造方法</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"> 	<span class="built_in">print</span>(p.x); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">print</span>(p.y);  <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">print</span>(p.z); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>如果你是用过<code>react</code>进行开发前端项目，那么你一定对<code>class ... extends ...</code>非常的属性，不错，Dart中也是使用<code>extends</code>继承的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  Human.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Human's fromJson constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  Man.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Man's fromJson constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Human类没有默认构造方法，只有一个命名构造方法 <code>fromJson</code> ，所以在Man类继承Human类时，需要调用父类的fromJson方法做初始化，而且必须使用<code>Man.fromJson(Map data) : super.fromJson(data)</code>这种写法</p>
<h2 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h2><p>有时候一个构造函数会调动类中的其他构造函数。 一个重定向构造函数是没有代码的，在构造函数声明后，使用 <code>冒号</code> 调用其他构造函数。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The main constructor for this class.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delegates to the main constructor.</span></span><br><span class="line">  Point.alongXAxis(<span class="built_in">num</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="getters-and-setters"><a href="#getters-and-setters" class="headerlink" title="getters and setters"></a>getters and setters</h2><p><code>getters</code> 和 <code>setters</code> 是用来设置和访问对象属性的特殊 函数。每个实例变量都隐含的具有一个 <code>getter，</code> 如果变量不是 <code>final</code> 的则还有一个 <code>setter。</code> 你可以通过实行 <code>getter</code> 和 <code>setter</code> 来创建新的属性， 使用 <code>get</code> 和 <code>set</code> 关键字定义 <code>getter</code> 和 <code>setter</code>:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left;</span><br><span class="line">  <span class="built_in">num</span> top;</span><br><span class="line">  <span class="built_in">num</span> width;</span><br><span class="line">  <span class="built_in">num</span> height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define two calculated properties: right and bottom.</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right             =&gt; left + width;</span><br><span class="line">      <span class="keyword">set</span> right(<span class="built_in">num</span> value)  =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom            =&gt; top + height;</span><br><span class="line">      <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象函数-抽象类"><a href="#抽象函数-抽象类" class="headerlink" title="抽象函数(抽象类)"></a>抽象函数(抽象类)</h2><p>定义一个抽象类需要使用 <code>abstract</code> 关键字，然后在定义一个方法，类型是 <code>void</code> ，具体是实现，由子类实现<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...Define instance variables and methods...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> doSomething(); <span class="comment">// Define an abstract method.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDoer</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="comment">// ...Provide an implementation, so the method is not abstract here...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>调用一个没实现的抽象函数会导致运行时异常。</strong></p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>如果你定义了一个 <code>Vector</code> 类， 你可以定义一个 <code>+</code> 函数来实现两个向量相加。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line">  <span class="keyword">const</span> Vector(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment"><span class="markdown">/// Overrides + (</span>a<span class="markdown"> + b).</span></span></span><br><span class="line">  Vector <span class="keyword">operator</span> +(Vector v) =&gt; <span class="keyword">new</span> Vector(x + v.x, y + v.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment"><span class="markdown">/// Overrides - (</span>a<span class="markdown"> - b).</span></span></span><br><span class="line">  Vector <span class="keyword">operator</span> -(Vector v) =&gt; <span class="keyword">new</span> Vector(x - v.x, y - v.y);</span><br><span class="line"></span><br><span class="line">  printRes()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'X: <span class="subst">$x</span> , Y: <span class="subst">$y</span> '</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">final</span> v = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">final</span> w = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  (v + w).printRes(); <span class="comment">// X: 4 (2+2) , Y: 5(3+2)</span></span><br><span class="line">  (v - w).printRes(); <span class="comment">// X: 0 (2-2) , Y: 1(3-2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>枚举类型通常称之为 enumerations 或者 enums， 是一种特殊的类，用来表现一个<code>固定数目</code>的常量。使用<code>enum</code>关键字定义</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型中的每个值都有一个 <code>index getter</code> 函数， 该函数返回该值在枚举类型定义中的位置（从 0 开始）,有点像数组的索引。</p>
<p>枚举类型具有如下的限制：</p>
<ul>
<li>无法继承枚举类型、无法使用 <code>mixin</code> 、无法实现一个枚举类型</li>
<li>无法显示的初始化一个枚举类型</li>
</ul>
<h2 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h2><p><code>Mixins</code> 是一种在多类继承中重用 一个类代码的方法。</p>
<p>使用 <code>with</code> 关键字后面为一个或者多个 mixin 名字来使用 mixin。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  a() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"A's a()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  b() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"B's b()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with关键字，表示类C是由类A和类B混合而构成</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> = <span class="title">A</span> <span class="title">with</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">main</span>() </span>&#123;</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  c.a(); <span class="comment">// A's a()</span></span><br><span class="line">  c.b(); <span class="comment">// B's b()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态函数与变量"><a href="#静态函数与变量" class="headerlink" title="静态函数与变量"></a>静态函数与变量</h2><p>使用 <code>static</code> 关键字来实现类级别的变量和函数。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> name = <span class="string">'踏浪'</span>;</span><br><span class="line">  <span class="keyword">static</span> sayName() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'我的名字是<span class="subst">$name</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">print</span>(Person.name);</span><br><span class="line">  Person.sayName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，静态函数与变量我们可以直接调用，而不需要通过 <code>new</code> 实现实例后在进行处理。</p>
<h1 id="Generics（泛型）"><a href="#Generics（泛型）" class="headerlink" title="Generics（泛型）"></a>Generics（泛型）</h1><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>&lt;...&gt;</code>表示的就是这个List中每一项的类型，上面的代码中是<code>String</code>，表示的就是这个List中的每一项都要是String类型，而不能是其他的类型。</p>
<p>泛型是什么呢？泛型就是这一个对象中的内容可以使任何的类型，通常情况下，在<code>&lt;&gt;</code>中使用一个字母来代表类型参数， 例如 E, T, S, K, 和 V 等。例如<code>&lt;E&gt;</code></p>
<p>使用泛型的好处：</p>
<ul>
<li>正确指定泛型类型会产生更好的生成代码。</li>
<li>泛型可以减小代码的复杂度</li>
</ul>
<p>更多的泛型知识可以<a href="http://dart.goodev.org/guides/language/language-tour#generics%E6%B3%9B%E5%9E%8B" target="_blank" rel="noopener">点击这里</a>查看</p>
<h1 id="Dart库"><a href="#Dart库" class="headerlink" title="Dart库"></a>Dart库</h1><p>使用 <code>import</code> 来指定一个库如何使用另外 一个库。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>; <span class="comment">// 导入 web 组件库</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>; <span class="comment">// 导入 数学计算库</span></span><br></pre></td></tr></table></figure></p>
<p>更多官方库可以<a href="https://api.dartlang.org/stable/2.3.0/index.html" target="_blank" rel="noopener">点击查看</a></p>
<p>我们也可以引用自己的<code>.dart</code>文件，类似于 ES6 中的 <code>import</code><br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.dart</span></span><br><span class="line">add(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a + b;</span><br></pre></td></tr></table></figure></p>
<p>在另一个文件引入<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./add.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="built_in">print</span>(add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>as</code> 创建别名<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">Element</span> element1 = <span class="keyword">new</span> <span class="built_in">Element</span>();           <span class="comment">// Uses Element from lib1.</span></span><br><span class="line">lib2.<span class="built_in">Element</span> element2 = <span class="keyword">new</span> lib2.<span class="built_in">Element</span>(); <span class="comment">// Uses Element from lib2.</span></span><br></pre></td></tr></table></figure></p>
<p>使用 <code>show</code> and <code>hide</code> 过滤引入内容<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Import only foo.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Import all names EXCEPT foo.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>deferred as</code> 来延时载入库<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:deferred/hello.dart'</span> deferred <span class="keyword">as</span> hello;</span><br></pre></td></tr></table></figure></p>
<h1 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h1><p>Dart支持ES7的 <code>async await</code> 方法</p>
<p>下面的代码使用Dart从网络获取数据并打印出来<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:http/http.dart'</span> <span class="keyword">as</span> http;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; getNetData() <span class="keyword">async</span>&#123;</span><br><span class="line">  http.Response res = <span class="keyword">await</span> http.<span class="keyword">get</span>(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">  <span class="keyword">return</span> res.body;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  getNetData().then((str) &#123;</span><br><span class="line">    <span class="built_in">print</span>(str);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就是关于<code>Dart</code>语法的简单介绍，想要了解更多，可以参阅<a href="https://dart.dev/guides" target="_blank" rel="noopener">Dart官网</a></p>
<p>注：参考文献</p>
<ol>
<li><a href="https://www.jianshu.com/p/06aebcad0543" target="_blank" rel="noopener">https://www.jianshu.com/p/06aebcad0543</a></li>
<li><a href="http://dart.goodev.org/" target="_blank" rel="noopener">Dart中文</a></li>
<li><a href="https://dart.dev/guides" target="_blank" rel="noopener">Dart官网</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter Lesson 1：Flutter之环境搭建</title>
    <url>/%E6%8A%80%E6%9C%AF/Flutter-Lesson-1%EF%BC%9AFlutter%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    <content><![CDATA[<p>就在几天前(2019年05月08日)，Google发布了新一版本的<a href="https://flutter.dev/" target="_blank" rel="noopener">Flutter</a>，同时伴随着巨大的更新。之前的Flutter顶多就是跨Android与IOS平台，现在版本的Flutter就牛逼了，还支持了web，桌面以及嵌入式</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/082127_5lag_2720166.png" alt="Flutter"></p>
<p><a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰老师</a>也说未来跨平台开发语言框架不再是<a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener">React Native</a>，而是Flutter，所以Flutter受到更多人的青睐，同时由于Dart语言会的人很少，所以对于大多数程序员来说，我们都是在同一起跑线上面，我也不例外。写教程的目的，一是为了能够熟悉熟悉一下Flutter，同时记录下自己的观点，二是可以为后来成提供一些用得到的东西。</p>
<p>废话不多说，我们先来看看Flutter的开发环境搭建。</p>
<h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>首先来说说使用Windows搭建怎么搭建。</p>
<p>FLutter的环境搭建其实还是挺简单的，相比于React Native来说简直是不要不要的。</p>
<h2 id="下载包"><a href="#下载包" class="headerlink" title="下载包"></a>下载包</h2><p>首先我们需要下载Flutter的运行包，直接去google的<a href="https://flutter.dev/docs/get-started/install/windows" target="_blank" rel="noopener">Flutter官网</a>下载就可以了。当然，你过你不能够访问google，可以去<a href="https://flutterchina.club/get-started/install/" target="_blank" rel="noopener">Flutter中文网</a>中下载。不过我建议，作为程序员，还是可以弄一个VPN。打个广告，<a href="https://www.bshl.life/auth/register?code=SKSKEFbQeuLSbmPSEYBfVEyR8NpSubu9" target="_blank" rel="noopener">冰山互联</a>还不错，5元一个月30G流量已就够了。</p>
<p>下载完成后，建议解压解压放在C盘根目录下面，方便查找，当然你也可以放在其他目录下面，只要不是在<code>Program File(s)</code>下面就行。</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190512125510.png" alt="放在C盘根目录">。</p>
<p>打开<code>flutter</code>目录，找到<strong>flutter_console.bat</strong></p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190512125653.png" alt="flutter_console.bat"></p>
<p>双击运行。</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190512130027.png" alt="运行成功"></p>
<p>这会安装一系列的依赖，如果你是国内用户而没有开VPN，那么你需要设置一下国内镜像</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PUB_HOSTED_URL</span>=https://pub.flutter-io.cn</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">FLUTTER_STORAGE_BASE_URL</span>=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>安装好Flutter之后，你需要设置一下环境变量。以win10为例，在Cortana中搜索环境变量，进入到环境变量，找到<code>path</code>，添加Flutter目录+<code>\flutter\bin</code></p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190512130312.png" alt="配置环境变量">。</p>
<p>需要注意的是，配置完成以后，Flutter只能在Cmd以及pwoershell中生效，其他的第三方Shell例如GitBash以及Cmder等中是无效的。</p>
<h2 id="运行检测"><a href="#运行检测" class="headerlink" title="运行检测"></a>运行检测</h2><p>打开一个新的Cmd或者powershell，运行以下命令<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flutter doctor</span></span><br></pre></td></tr></table></figure></p>
<p>这会检测我们的工具是否安装完成。</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190512130722.png" alt="检查结果"></p>
<p>上面图片中，我们只需要注意两点，一个是安卓SDK，一个是连接设备。至于Android Studio中的 <code>Flutter</code> 以及 <code>Dart</code> Plugin可以暂时不用管。</p>
<p>我这里是安装成功的截图，如果你是第一次安装，那么可能会提示你安装Android SDK，所以我们需要下载安装Android Studio。</p>
<p>下载完成后一步一步安装就行了，这将安装最新的Android SDK，Android SDK平台工具和Android SDK构建工具，这是Flutter为Android开发时所必需的。</p>
<p>之后我们还需要安装一个模拟器设备。</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190512131345.png" alt="安装模拟器"></p>
<p>点击<code>create</code>后选择这个手机设备就可以了。</p>
<p>上上述安装完成后可以再次执行<code>flutter doctor</code>看看安装情况。</p>
<h1 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h1><p>其实mac的相对来说更简单一点，总的步骤与Windows上面基本一致</p>
<ol>
<li>下载Flutter运行包并解压到适当目录。</li>
<li><p>配置Flutter的环境变量</p>
<p> 当前窗口配置: <em>export PATH=<code>pwd</code>/flutter/bin:$PATH</em> </p>
<p> 打开： <code>$HOME/.bash_profile</code></p>
</li>
<li><p>运行检测 <code>flutter doctor</code></p>
</li>
<li>安装XCode以及IOS模拟器，安装Android Studio以及模拟器</li>
</ol>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/MAC%E5%AE%89%E8%A3%85%E6%8F%90%E7%A4%BA.png" alt="MAC 需要安卓的依赖"></p>
<p>按照上图所示，直接运行命令行即可</p>
<h1 id="配置编辑器"><a href="#配置编辑器" class="headerlink" title="配置编辑器"></a>配置编辑器</h1><p>作为前端工程师，我一直使用的是<code>VS Code</code>，<code>VS Code</code>的配置相对简单，只需要在插件市场下载<code>Flutter</code>插件以及<code>Dart</code>插件就行。</p>
<p>如果你是使用的 <code>Android Studio</code> 进行开发的，那么你需要在他的插件市场下载 Flutter 以及 Dart 插件，然后启动项目即可。</p>
<p>安装<code>Flutter</code>完成后在VSCode中 <code>Ctrl+Shift+P</code> 搜索Flutter，就会出现一系列的Flutter命名</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190512131835.png" alt="Ctrl+Shift+P 搜索Flutter结果"></p>
<p>我们可以选择<code>Flutter：New Project</code>新建一个项目</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190512132256.png" alt="项目结构"></p>
<p>还有我们可以看到VSCode右下角有一个<code>No Devices</code>的标识，你可以点击</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190512132354.png" alt="No Device"></p>
<p>如果你成功的安装了安卓模拟器或者连接了真机，那么就会出俩设备供你选择。当然，你也可以选择<code>Create New</code>。</p>
<h1 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h1><p>在VSCode中，点击左侧菜单栏的调试，在点击调试就可以开始运行项目。但首先要保证有模拟器或者真机连接。</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190512132845.png" alt="运行项目"></p>
<p>温馨提示：第一次运行有点缓慢，请耐心等待。</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190512133802.png" alt="运行结果"></p>
<p>至此，项目环境已经搭建完成，后续知识请在后续章节中查看，谢谢。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>关于网站左右布局适配</title>
    <url>/%E6%8A%80%E6%9C%AF/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%B7%A6%E5%8F%B3%E5%B8%83%E5%B1%80%E9%80%82%E9%85%8D.html</url>
    <content><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>新的一年加入新的公司，新的公司做新的项目。公司涉及到的项目基本都是海外的，没有国内的。做过国际化项目的同学应该知道，世界上每个国家的风俗习惯都不同。对于前端开发来说，就网页布局这方面就有正常的<code>ltr</code>布局，即：从左往右布局。但是在一些国家，比如阿拉伯，希伯来等国家，却有着和我们不一样的习惯，遵从了我们老祖先从右往左的阅读习惯，文字也是从右往左书写的习惯，当然是看不懂的。站在前端的角度就是<code>rtl</code>布局。</p>
<p><a href="https://www.dm.gov.ae/ar/pages/default.aspx" target="_blank" rel="noopener">阿拉伯网站</a> 需要番羽土啬</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190510110549.png" alt="网站截图"></p>
<p>不难看出来，阿拉伯语的网站的布局样式了，箭头，文字与我们的都是相反的。</p>
<p>公司在做双语app，因为我不知道阿拉伯语是从右往左的阅读，在分析需求的时候也没有人讲明这一点，也是之后才知道，可是那个时候英语的页面布局已近差不多了（这也算是一个坑吧）。所以就要为后面阿语的布局采取解决方案。重写是不可能了，因为已经做了10多个页面了。</p>
<p>下面说一下我的处理方式。</p>
<h2 id="采坑，填坑"><a href="#采坑，填坑" class="headerlink" title="采坑，填坑"></a>采坑，填坑</h2><p>在网上找了一些资料</p>
<ul>
<li><a href="https://github.com/zhaotoday/arabic-styles" target="_blank" rel="noopener">阿拉伯语网站 CSS 布局方案</a></li>
<li><a href="https://blog.brain1981.com/453.html" target="_blank" rel="noopener">阿拉伯语网站的CSS要点总结</a></li>
<li><a href="http://blog.baiwand.com/?post=212" target="_blank" rel="noopener">【解决】阿拉伯语等右向左排版文字CSS解决方案</a></li>
</ul>
<p>上面的网站其实都是阐明了一个宗旨，我们如果要进行CSS从右往左的布局，那么还需要使用到中国网站基本用不到的一个属性<code>direction</code>，值是<code>ltr</code>或者<code>rtl</code>。</p>
<p>经过自己的摸爬打滚，最终采取了一种方案：<code>direction + 左右对称 + flex</code>布局。</p>
<p>怎么说呢？意思就是我们的方向主要是由<code>direction</code>进行控制，比如我们要<code>ltr</code>布局，我们在只需要对HTML标签进行设置<code>&lt;html dir=&#39;lrt&#39;/&gt;</code>。这样就可以使html的布局成为从左往右布局，当然，html的默认的布局方式就是从左往右布局的。如果是从右往左布局的话，那么<code>dir=&#39;rtl&#39;</code>就可以了。</p>
<p>上面是的html进行属性设置，当然，还可以从CSS入手。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">direction</span>: ltr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* or */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">direction</span>: rtl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我建议还是直接写在标签上面，作为一个属性，我们更好获取与动态修改。</p>
<p>这就完了么？其实并没有。</p>
<p>我们来举个🌰：</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190510140521.png" alt></p>
<p>这样的一个盒子，我们给了他左边距以及上边距各100px，html的布局是<code>ltr</code></p>
<p>现在我们把html的dir属性改成<code>rtl</code>看看。</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190510140721.png" alt></p>
<p>结果我们是大失所望。外边距的值仍然是左上两个方向，改变了dir属性以后，还是左上。而我们理想的应该是右上的。</p>
<p>所以我们得出：direction属性虽然可以改变文档的布局方式，但是，这并不能解决我们使用了<code>left，right</code>等位置控制的属性（比如：margin-left,padding-left,定位中的left，还有就是transform中的偏移等等）。</p>
<p>因为这个问题，前人已经为我们提供了一个框架<a href="https://rtlcss.com/" target="_blank" rel="noopener">rtlcss</a>。这个框架可以帮我们吧CSS中设置的left和right等控制左右方向的属性互换。或者是使用webpack的<a href="https://github.com/romainberger/webpack-rtl-plugin" target="_blank" rel="noopener">rtl插件</a>等也可以。</p>
<p>但是这样也有问题：</p>
<ol>
<li>一是这样会创建两个CSS包，我们需要根据HTML的语言方向引入不同的CSS包模块。</li>
<li>二是这个插件无法控制js代码中动态生成的left以及right属性，如果是使用js我们也需要进行判断。</li>
</ol>
<h2 id="direction-左右对称-flex布局来看看"><a href="#direction-左右对称-flex布局来看看" class="headerlink" title="direction+左右对称+flex布局来看看"></a>direction+左右对称+flex布局来看看</h2><p>如果我们采用<code>direction+左右对称+flex布局来看看</code></p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190510143302.png" alt></p>
<p>同样是这个盒子，外层套了一个父容器，以供处理弹性盒模型，再给父容器一个内边距，使用<br><code>flex-direction</code>设置位置。这样在html的dir属性变成<code>rtl</code>后，我们无需改动任何的css样式，仍可以实现从右往左的布局方式。</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190510143535.png" alt></p>
<p><code>flex</code>属性的兼容性来看看</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190510143804.png" alt></p>
<p>在2019这个年代了，大部分的浏览器都支持flex布局了，如果是老版本的浏览器，我们也可以考虑不兼容了，直接放弃这一部分的人，就不能惯着。所以这个模式还是可行的，更适合那些左右对称的布局方式。不过这个方式也有缺点，就是js控制的仍然无法得到合理的处理，如果是js，可以考虑flex。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>网上还有一些大牛说可以使用css属性的<code>transform</code>，<code>scale</code>和<code>rotate</code>。</p>
<p>这种方式我试过，镜像翻转，这个方式有一个很大的弊端，又或许是我没有找到合适的解决方案。就是如果使用定位，层级高的镜像翻转后会在最下面，控制层级为负数也不一定可以，尤其是使用一些第三方的UI框架的时候。所以我认为目前这种方案可能不合适。</p>
<p>以上就是我关于网站<code>ltr</code>和<code>rtl</code>布局的一些理解和建议，每个方法都可行但是都有弊端，选取合适的方案来高效的开发自己的网站吧。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>布局，CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于转行IT的一些感想</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%85%B3%E4%BA%8E%E8%BD%AC%E8%A1%8CIT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3.html</url>
    <content><![CDATA[<p>现在是北京时间 <code>2019年4月23日 22:33:34</code>，刚刚解答了一个正在转行Java的年轻人的疑惑。其实他并不是我第一次解疑答惑关于转行IT的人，之前还有3个。而距离我转行IT已经有三年了，所以想要趁着这个机会写一写我的感悟，我怕过了明天我就忘记了。</p>
<h1 id="我的介绍"><a href="#我的介绍" class="headerlink" title="我的介绍"></a>我的介绍</h1><p>其实我的自我介绍在<a href="https://tal007.github.io/about/" target="_blank" rel="noopener">博客个人中心</a>其实已经有简单的介绍了，这里我还是自我介绍一下把。</p>
<p>我是踏浪，或许有人听过我的名号。我毕业于<a href="http://www.scatc.net/" target="_blank" rel="noopener">四川建筑职业技术学院</a>，一个普普通通的大专院校毕业生，和大多数普通人一样，大学的时候没有认真学习的混到了大三，参加了学习的校园招聘，加入公司，进入社会。毕业的时候我进的是<code>中国建筑第六工程局有限公司地铁分公司</code>（以下简称六局），在亲戚朋友的羡慕中进入了国企，央企。</p>
<p>在六局工作了一年多以后我毅然的离职了，此时的亲戚朋友对我又是另一种眼神了，包括我的父母也曾多次劝说我不要离职，在国企带着多好。可是每个人都有梦想，都要想做的事情，所以最终还是在父母亲友的不满与责备中离职，此时的自己犹如重获新生，折断的翅膀再次衔接上，让我振翅高飞，自由翱翔。因为毕竟是自己的第一份工作，离职的时候还是多多少少有些不舍的。</p>
<p>离职后休息了一段时间，就开始了前端之旅。</p>
<h1 id="我的前端学习之路"><a href="#我的前端学习之路" class="headerlink" title="我的前端学习之路"></a>我的前端学习之路</h1><p>其实在我们离职之后很多人（包括我）都会选择一段旅途让自己放松放松，时间短还可以，但是当你半个月一个月以后，体会到这种一直没有收入，看着自己的储蓄一点点减少甚至是到了拥有负债（不管是父母的钱还是信用卡或者其他机构借的钱）的地步，那么你的内心就会焦躁起来，这时候是多么的渴望拥有一份工种，哪怕工资低的和你一个月的正常消费齐平。</p>
<p>我最开始学习前端是自学的，因为在大学的时候就想要自己写一个淘宝客网站，在六局的时候还在当当上买了一本书：<a href="http://e.dangdang.com/products/1900722550.html" target="_blank" rel="noopener">网页设计与前端开发从入门到精通</a>，当时这本书被我看了一遍之后还是有很多的不明白，又反复的看，现在这本书已经被我翻烂了，是真的翻烂的，放在我家的书架上。当时我就觉得我需要有人指点，所以当时选择的一个在线教育的培训机构。为什么是在线教育呢？因为当时工作一年多，自己储蓄不多，而且六局一年转正，作为大专生的我拿了一年的实习工资，扣除了五险一金每个月到手的就只有2000多一点，所以没什么积蓄，也不愿意想父母借钱，只有考虑线上了。</p>
<p>不过当时我看直播可的时候看了不下10节课我就再也没有看过了，因为我个人感觉上课太拖拉，所以就去看以前的视频去了。专心的在家里学习，每天除了吃喝拉撒就是看视频敲代码，每天早上8点到晚上12点，中途累了玩一两把英雄联盟给自己提提神然后继续，有时候一个问题困扰我很久，可能晚上两点过才想明白，然后才瑟瑟发抖（那时候是冬天，而且家里没有空调，门也是漏风的）的钻进被窝，期待着明天造成的阳光。就这样，我坚持了四个月把从0基础都JQ的视频全部看完，并且课堂中的案例也都全部做了一遍，然后就出去找工作了。当然，所说是看视频，但是又不懂的问题还是会主动的去问老师的。</p>
<p>我觉得我的这一段经历我会终身难忘，因为这是我人生的第一个转折点，因为我的决定，我的努力，我的坚持，才有了现在的我。同时也很感谢在我刚刚培训完成能够收留我，并且培养我的<a href="http://www.tanzhouedu.com/" target="_blank" rel="noopener">潭州教育</a>。</p>
<p>就像我之前写的<a href="https://tal007.github.io/%E5%BD%B1%E8%A7%86/%E7%94%B5%E8%A7%86%E5%89%A7%E3%80%8A%E9%83%BD%E6%8C%BA%E5%A5%BD%E3%80%8B.html" target="_blank" rel="noopener">《都挺好》</a>的感悟一样，我们在对的时间遇到了对的人，并且自己足够努力，那么你终将会不一样。</p>
<p>当然，我写的可能很简单，几分钟的时间就能够读完，但是其中的心酸自有当事人才知道，或许你将来也会知道。</p>
<h1 id="关于目前的IT行业"><a href="#关于目前的IT行业" class="headerlink" title="关于目前的IT行业"></a>关于目前的IT行业</h1><p>文章开头就说了最近有人直接或者间接的问我关于目前的IT行业，因为他们认为我是一个转行比较成功的人。那么我就来说说吧。</p>
<p>目前的IT行业其实人才挺缺的，尤其是针对于大数据以及人工智能两方面，因为现在社会需要这方面的人才，前端与java方面都是缺乏中级以上的工程师，其他的语言相对来说较好。为什么呢？因为现在的社会与人。</p>
<p>目前市场上的培训机构很多，如果你是打算转行IT的人，全国型机构相信你们多多少少都听说过，还有很多我们都没有听过的地方型机构，比如今天这位朋友说的（聊天记录没找到这个机构的名字），还有我大学同学培训测试的那个机构。太多太多了。同时，因为社会IT行业的发展，工资待遇高，福利好的问题导致大多数的年轻人转行学习IT，甚至有的40岁的人还在转行，尤其是学习java和前端的人居多。因为java用的公司多，前端入门简单。所以目前的行情就是基础的工程师处于饱和甚至溢出的状态，而高级的工程师一直处于稀缺的状态。所以很多刚培训出来的人找不到工作，从而面临再次转行。</p>
<p>所以，如果你有幸的看到我的文章，同时你也打算转行IT行业的话，请你在打算转行或者有转行念头的时候仔细的想一想以下几个问题：</p>
<ol>
<li>我为什么要转行IT，因为工资高待遇好还是因为我喜欢这个行业。如果只是因为工资待遇的问题，那么我相信我在六局也会有一番成就。</li>
<li>我转行后我还能一直保持积极向上，不断学习的状态么？如果不能，几年之后那么你就会被淘汰。</li>
<li>我能承受住这个行业带来的压力么？比如加班多，现在网上很火的996工作制等等。</li>
<li>我现在的年龄做转行做这个还有必要吗？时间还够吗？</li>
</ol>
<p>针对于第四点我想多说说。如果你现在的年纪已经过了30岁了，我建议你不要转行IT了，除非你是特别有自律力，时间规划特别充分，逻辑思维特别好的人，那么你可以。因为如果你此时转行，面临的不仅仅是和20多岁年轻小伙<strong>抢</strong>工作机会的事件，还有未来的发展，自己的身体种种原因。</p>
<p>所以，如果你要转行，还请郑重的考虑，不仅仅是对自己负责，更是对家人负责。</p>
<h1 id="关于我们的自我提升"><a href="#关于我们的自我提升" class="headerlink" title="关于我们的自我提升"></a>关于我们的自我提升</h1><p>《羊皮卷》的第一卷就是投资自我，所以，不管你是投资公司还是投资实业，都没有投资自我更有价值。或许你看过很多的理财书籍，受歧视股票，他们都会说到一点，买股票就是投资公司，如果要想选得一家好公司，那么你就需要对公司的经营状况，企业年报，公司盈利情况，负债率等等有一定的了解，虽说不是想专业的证券工作人员那样了解，但是也需要比普通的股民了解的多。但是作为一个外行，我们如果要能够看得懂这些数据，信息，那我们还是得投资自我，看看相关的书籍。</p>
<p>不光光是这些，我们还需要在学习中找到乐趣。</p>
<p>还记得去年8月份的时候在英语流利说App上面购买了499元半年的口语课程，让后按照每周5天的计划进行口语练习，我还真就坚持了半年，拿到了全额返现。期间有的课程我需要两个小时才能够完成，就是那仅仅的一小节。我一直想练习自己的口语，但是一直不知道从何说起，看到有一位朋友购买了流利说课程便咨询了他，他说还不错，我就果断的买入了。起初仅仅是为了能够拿到那500元的返额，但是后来确实越说越有兴趣，到目前为止虽不能听懂所有的英语语句，但是基本的OVA常速以及部分OVA快速都能够听懂，当然，除了不认识的单词。所以课程到期后，我就开始着力于单词的记忆，到目前记单词已经有40多天了。</p>
<p>所以，不管是学什么，做什么，从中找到乐趣，你才有做下去的动力。在使用流利说的期间不仅仅是让我提升了口语能力，更多的是让我养成了一个良好的习惯，每天都有目标，而且今日是今日毕。</p>
<p>还有就是平时有时间多看看有利的书籍，不管是技术方面的还是为人处世方面的，或者说是悬疑小说等等，重要的是我们需要从中学习到一些对自己有用的东西。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>第一次写这么正式的文章，没有这么写过，大都是这几年来我工作中的自我总结以及感悟吧。如果其中有一些东西对你有帮助，那我很高兴能换帮助到你，如果没有帮助到你，也很感谢你能够抽出时间阅读我的文章。文章中你可能会看到一下机构公司的名字，请不要以为我是在打广告，因为我没有收一分钱，因为他们确实对我有帮助。再次感谢我以前的公司，同事，以及现在公司同事对我职业生涯做出的帮助。</p>
<p>像李开复的《做最好的自己》说的一样，要做最好的自己。每个行业都要人能有成功，因为他们处在了自己所喜爱擅长的领域，发挥了自己的价值，做出了最好的自己，所以，他们成功了。或许未来我也不会在混迹在IT行业，但是我至少现在还在，所以我还有说一句：<strong>把握住最好的现在</strong>。</p>
<p>最后送上两句话：</p>
<p>第一句是今天记单词打卡的英语语句：<code>You will never know what you can do till you try.</code> – 你永远不知道你可以做，直到你做了。</p>
<p>第二句是我无意中看到的一句话，现在在我的微信个人签名里面：<code>所谓天才，不过是每一天的积累成才</code>。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>转行</tag>
      </tags>
  </entry>
  <entry>
    <title>电视剧《都挺好》</title>
    <url>/%E5%BD%B1%E8%A7%86/%E7%94%B5%E8%A7%86%E5%89%A7%E3%80%8A%E9%83%BD%E6%8C%BA%E5%A5%BD%E3%80%8B.html</url>
    <content><![CDATA[<p>前段时间把火的一塌糊涂的以家庭矛盾为线索的电视剧《都挺好》看完了</p>
<p>故事简介：</p>
<blockquote>
<p>表面上无限风光的苏家，随着苏母的突然离世，瞬间分崩离析。意想不到的隐患层层显露，对毫无主见却又自私、小气的苏父的安置和后续生活问题，打破了远在国外的大哥与本城的二哥、小妹三家的平静生活。父亲苏大强终于摆脱了妻子的铁腕，对几个孩子变本加厉，不断提出过分要求。在美国工作的老大苏明哲回到国内，一心要挑起家庭重担，却力不能及不堪重负，致使妻子孩子与其不断疏远。一直啃老的老二苏明成毫无悔改之心，贪慕虚荣一心发财，从而导致事业和家庭的双重惨败。最不受父母待见，十八岁起就和家里断绝经济往来的老小苏明玉，曾发誓与这个家庭划清界限，却因亲情牵绊，再次搅进了苏家的泥潭之中，在苏家的一次次危机中出手相助。最终，苏家人明白到，虽然有血脉相连，但是一家人彼此间的沟通也不能忽视，终于实现了亲情的回归<br>– 来自<a href="https://baike.baidu.com/item/%E9%83%BD%E6%8C%BA%E5%A5%BD/12006937?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p>
</blockquote>
<p>看完之后还是用一定的感悟的，归为一下几点：</p>
<h2 id="真爱生命"><a href="#真爱生命" class="headerlink" title="真爱生命"></a>真爱生命</h2><p>古话说得好，家家都有一本难念的经，每个家庭的状况都不一样，不管怎么样，我们都要坚强的活着，珍爱生命。苏明玉在18岁之前一直受气，自己的心愿得不到满足，而且母亲连教育经费的不愿意出，重男轻女，还经常被二哥欺负，但是仍然活的好好的。</p>
<h2 id="人生有目标"><a href="#人生有目标" class="headerlink" title="人生有目标"></a>人生有目标</h2><p>随着故事的发展，苏明玉到了18岁，受到一定的打击之后决心不再用家里一分钱，开始自己打工赚钱，努力学习，甚至有出国的梦想，并且为了这个目标不断的努力奋斗</p>
<h2 id="人生需要导师（我认为这是非常重要的）"><a href="#人生需要导师（我认为这是非常重要的）" class="headerlink" title="人生需要导师（我认为这是非常重要的）"></a>人生需要导师（我认为这是非常重要的）</h2><p>苏明玉在遇到师傅以前一直都是攒够30W出国的梦想，可是从来没有想过合适才能够攒够这30W，直到遇到师傅，听了师傅的一番话以后改变自己的目标。</p>
<p>我们一生中可能一直都在为着自己的目标不断的奋斗，梦想就是挣很多很多的钱，但是我们却不知道为什么要这样做，如何做，怎么才能实现，直到听到某个人的一句话或者一些分享，我们后有所感悟。可能让我们之前所做的都付诸东流，又或者是如虎添翼，但是他们在我们的人生中起到了非常重要的作用。这个人可能是你的父母，你的老师，你的朋友，也可能是一个陌生人，所以，如果你遇到了这样的一个人，好好珍惜。</p>
<h2 id="敢于推销自己，胆大，果断，有主见，要把握机会"><a href="#敢于推销自己，胆大，果断，有主见，要把握机会" class="headerlink" title="敢于推销自己，胆大，果断，有主见，要把握机会"></a>敢于推销自己，胆大，果断，有主见，要把握机会</h2><p>苏明玉在听了师傅的一番分析之后，立刻决定把自己给推销给自己的师傅（当时还只是陌生人），所以立刻把自己推销给了这位将来的师傅，所以才有了之后的苏明玉。</p>
<p>所以，现实中我们也需要敢于推销自己，敢于上台，同时也要把握每一个机会。一生中你可能会有很多的机遇，但是我们往往都是在不经意之间就与机会错过。所以我们需要留意生活，争取抓住每一个机会，或许其中一两个，就能给你带来不一样的生活</p>
<h2 id="生活需要奋斗"><a href="#生活需要奋斗" class="headerlink" title="生活需要奋斗"></a>生活需要奋斗</h2><p>详细苏明玉在遇到师傅之后不会是一帆风顺的，虽然电视剧里面是直接跳过了，但是我们可以回到现实，自己思考一下，如果不是她一直不断努力，不得奋斗，怎么会有现在。包括后来二哥“洗白”，为了事业远去非洲也是一样的。</p>
<h2 id="不要愚孝"><a href="#不要愚孝" class="headerlink" title="不要愚孝"></a>不要愚孝</h2><p>很简单，不要像大哥一样愚孝，什么无理的要求都答应了父亲。</p>
<h2 id="珍惜眼前人"><a href="#珍惜眼前人" class="headerlink" title="珍惜眼前人"></a>珍惜眼前人</h2><p>一家人终归是一家人，就算是有不满，不和，但是总会有同甘共苦的时候，总会有美好的回忆。人的一生都不长，在的时候就要好好珍惜，不要以后追悔莫及。</p>
<p>注：以上纯属个人观点与感悟，如果有与你不和的观点，还请口下留情</p>
]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>影视</tag>
        <tag>电视剧</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL+cmder+oh-my-zsh美化win10命令工具（terminal）</title>
    <url>/%E5%85%B6%E4%BB%96/WSL-cmder-oh-my-zsh%E7%BE%8E%E5%8C%96win10%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%EF%BC%88terminal%EF%BC%89.html</url>
    <content><![CDATA[<p>最近在win10下面搭建了一个 <a href="https://baike.baidu.com/item/wsl/20359185?fr=aladdin" target="_blank" rel="noopener">WSL</a>+<a href="https://cmder.net/" target="_blank" rel="noopener">cmder</a>+<a href="https://ohmyz.sh/" target="_blank" rel="noopener">oh-my-zsh</a> 的程序员命令行环境，为什么呢？还不是买不起mac，加上自己的黑苹果瘫了，所有又回到了win10上面。不过上面不管是Cmd还是PowerShell都是难看的要死要死的，而且很多命令不支持，所以有了这一次的实践。</p>
<h1 id="更新于2019年9月28日"><a href="#更新于2019年9月28日" class="headerlink" title="更新于2019年9月28日"></a>更新于2019年9月28日</h1><p>之前我们使用的是 <code>cmder</code> 这个工具。</p>
<p>在 windows 1903 以及以后的版本中，可以直接使用windows自带的 <code>windows terminal</code> ，可以直接从windwos 10 的应用商店里面下载。这个比 cmder 用起来更加的便捷。</p>
<p>检查window版本： windows + R 后 输入 winver</p>
<p>安装 windows terminal 以后我们可以自己去配置 terminal 的样式。<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190928012442.png" alt="CMD"><br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190928012451.png" alt="powershell"><br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190928012530.png" alt="ubuntu"></p>
<p>修改配置如下，其中 <code>#XXX</code> 为注释<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"$schema"</span>: <span class="string">"https://aka.ms/terminal-profiles-schema"</span>,</span><br><span class="line">    <span class="attr">"globals"</span> : </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"alwaysShowTabs"</span> : <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"copyOnSelect"</span> : <span class="literal">true</span>,</span><br><span class="line">        "defaultProfile" : "&#123;c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40&#125;", #默认的终端，点击+号</span><br><span class="line">        "initialCols" : 120,</span><br><span class="line">        "initialRows" : 30,</span><br><span class="line">        "keybindings" : </span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"closePane"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+w"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"copy"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+c"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"duplicateTab"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+d"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"newTab"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+t"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"newTabProfile0"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+1"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"newTabProfile1"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+2"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"newTabProfile2"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+3"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"newTabProfile3"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+4"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"newTabProfile4"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+5"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"newTabProfile5"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+6"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"newTabProfile6"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+7"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"newTabProfile7"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+8"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"newTabProfile8"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+9"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"nextTab"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+tab"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"openNewTabDropdown"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+space"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"openSettings"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+,"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"paste"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+v"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"prevTab"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+tab"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"scrollDown"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+down"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"scrollDownPage"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+pgdn"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"scrollUp"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+up"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"scrollUpPage"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+shift+pgup"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"switchToTab0"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+alt+1"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"switchToTab1"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+alt+2"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"switchToTab2"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+alt+3"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"switchToTab3"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+alt+4"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"switchToTab4"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+alt+5"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"switchToTab5"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+alt+6"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"switchToTab6"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+alt+7"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"switchToTab7"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+alt+8"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"command"</span> : <span class="string">"switchToTab8"</span>,</span><br><span class="line">                <span class="attr">"keys"</span> : </span><br><span class="line">                [</span><br><span class="line">                    <span class="string">"ctrl+alt+9"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        "requestedTheme" : "system",</span><br><span class="line">        "showTabsInTitlebar" : true,</span><br><span class="line">        "showTerminalTitleInTitlebar" : true,</span><br><span class="line">        "wordDelimiters" : " ./\\()\"'-:,.;&lt;&gt;~!@#$%^&amp;*|+=[]&#123;&#125;~?\u2502"</span><br><span class="line">    &#125;,</span><br><span class="line">    "profiles" : </span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"acrylicOpacity"</span> : <span class="number">0.5</span>,</span><br><span class="line">            "backgroundImage": "C://Users//Administrator//Pictures//Saved Pictures//2.jpg", #背景图片</span><br><span class="line">            "backgroundImageOpacity" : 0.6, #背景透明度</span><br><span class="line">            "background" : "#012456",</span><br><span class="line">            "closeOnExit" : true,</span><br><span class="line">            "colorScheme" : "Campbell",</span><br><span class="line">            "commandline" : "powershell.exe",</span><br><span class="line">            "cursorColor" : "#FFFFFF",</span><br><span class="line">            "cursorShape" : "bar",</span><br><span class="line">            "fontFace" : "Cascadia Code", #字体</span><br><span class="line">            "fontSize" : 12,</span><br><span class="line">            "guid" : "&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;", #终端唯一编号</span><br><span class="line">            "historySize" : 9001,</span><br><span class="line">            "icon" : "ms-appx:///ProfileIcons/&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;.png",</span><br><span class="line">            "name" : "Windows PowerShell", #启动的终端</span><br><span class="line">            "padding" : "0, 0, 0, 0",</span><br><span class="line">            "snapOnInput" : true,</span><br><span class="line">            "startingDirectory" : "%USERPROFILE%",</span><br><span class="line">            "useAcrylic" : false,</span><br><span class="line">            "tabTitle" : "Powershell"</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"acrylicOpacity"</span> : <span class="number">0.75</span>,</span><br><span class="line">            <span class="attr">"backgroundImage"</span>: <span class="string">"C://Users//Administrator//Pictures//Saved Pictures//1.jpg"</span>,</span><br><span class="line">            <span class="attr">"backgroundImageOpacity"</span> : <span class="number">0.6</span>,</span><br><span class="line">            <span class="attr">"closeOnExit"</span> : <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"colorScheme"</span> : <span class="string">"Campbell"</span>,</span><br><span class="line">            <span class="attr">"commandline"</span> : <span class="string">"cmd.exe"</span>,</span><br><span class="line">            <span class="attr">"cursorColor"</span> : <span class="string">"#FFFFFF"</span>,</span><br><span class="line">            <span class="attr">"cursorShape"</span> : <span class="string">"bar"</span>,</span><br><span class="line">            <span class="attr">"fontFace"</span> : <span class="string">"Cascadia Code"</span>,</span><br><span class="line">            <span class="attr">"fontSize"</span> : <span class="number">12</span>,</span><br><span class="line">            <span class="attr">"guid"</span> : <span class="string">"&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;"</span>,</span><br><span class="line">            <span class="attr">"historySize"</span> : <span class="number">9001</span>,</span><br><span class="line">            <span class="attr">"icon"</span> : <span class="string">"ms-appx:///ProfileIcons/&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;.png"</span>,</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"cmd"</span>,</span><br><span class="line">            <span class="attr">"padding"</span> : <span class="string">"0, 0, 0, 0"</span>,</span><br><span class="line">            <span class="attr">"snapOnInput"</span> : <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"startingDirectory"</span> : <span class="string">"%USERPROFILE%"</span>,</span><br><span class="line">            <span class="attr">"useAcrylic"</span> : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"acrylicOpacity"</span> : <span class="number">0.59999999999999998</span>,</span><br><span class="line">            <span class="attr">"closeOnExit"</span> : <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"colorScheme"</span> : <span class="string">"Vintage"</span>,</span><br><span class="line">            <span class="attr">"commandline"</span> : <span class="string">"Azure"</span>,</span><br><span class="line">            <span class="attr">"connectionType"</span> : <span class="string">"&#123;d9fcfdfa-a479-412c-83b7-c5640e61cd62&#125;"</span>,</span><br><span class="line">            <span class="attr">"cursorColor"</span> : <span class="string">"#FFFFFF"</span>,</span><br><span class="line">            <span class="attr">"cursorShape"</span> : <span class="string">"bar"</span>,</span><br><span class="line">            <span class="attr">"fontFace"</span> : <span class="string">"Cascadia Code"</span>,</span><br><span class="line">            <span class="attr">"fontSize"</span> : <span class="number">12</span>,</span><br><span class="line">            <span class="attr">"guid"</span> : <span class="string">"&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;"</span>,</span><br><span class="line">            <span class="attr">"historySize"</span> : <span class="number">9001</span>,</span><br><span class="line">            <span class="attr">"icon"</span> : <span class="string">"ms-appx:///ProfileIcons/&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;.png"</span>,</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"Azure Cloud Shell"</span>,</span><br><span class="line">            <span class="attr">"padding"</span> : <span class="string">"0, 0, 0, 0"</span>,</span><br><span class="line">            <span class="attr">"snapOnInput"</span> : <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"startingDirectory"</span> : <span class="string">"%USERPROFILE%"</span>,</span><br><span class="line">            <span class="attr">"useAcrylic"</span> : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"acrylicOpacity"</span> : <span class="number">0.5</span>,</span><br><span class="line">            <span class="attr">"backgroundImage"</span>: <span class="string">"C://Users//Administrator//Pictures//Saved Pictures//3.jpg"</span>,</span><br><span class="line">            <span class="attr">"backgroundImageOpacity"</span> : <span class="number">0.4</span>,</span><br><span class="line">            <span class="attr">"guid"</span>: <span class="string">"&#123;c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40&#125;"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Ubuntu-18.04"</span>,</span><br><span class="line">            <span class="attr">"closeOnExit"</span> : <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"colorScheme"</span> : <span class="string">"Campbell"</span>,</span><br><span class="line">            <span class="attr">"cursorColor"</span> : <span class="string">"#FFFFFF"</span>,</span><br><span class="line">            <span class="attr">"cursorShape"</span> : <span class="string">"bar"</span>,</span><br><span class="line">            <span class="attr">"fontFace"</span> : <span class="string">"Cascadia Code"</span>,</span><br><span class="line">            <span class="attr">"fontSize"</span> : <span class="number">12</span>,</span><br><span class="line">            <span class="attr">"source"</span>: <span class="string">"Windows.Terminal.Wsl"</span>,</span><br><span class="line">            <span class="attr">"padding"</span> : <span class="string">"0, 0, 0, 0"</span>,</span><br><span class="line">            <span class="attr">"snapOnInput"</span> : <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"historySize"</span> : <span class="number">9001</span>,</span><br><span class="line">            <span class="attr">"tabTitle"</span> : <span class="string">"Ubuntu (WSL)"</span>,</span><br><span class="line">            <span class="attr">"useAcrylic"</span> : <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "schemes" : </span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"background"</span> : <span class="string">"#0C0C0C"</span>,</span><br><span class="line">            <span class="attr">"black"</span> : <span class="string">"#0C0C0C"</span>,</span><br><span class="line">            <span class="attr">"blue"</span> : <span class="string">"#0037DA"</span>,</span><br><span class="line">            <span class="attr">"brightBlack"</span> : <span class="string">"#767676"</span>,</span><br><span class="line">            <span class="attr">"brightBlue"</span> : <span class="string">"#3B78FF"</span>,</span><br><span class="line">            <span class="attr">"brightCyan"</span> : <span class="string">"#61D6D6"</span>,</span><br><span class="line">            <span class="attr">"brightGreen"</span> : <span class="string">"#16C60C"</span>,</span><br><span class="line">            <span class="attr">"brightPurple"</span> : <span class="string">"#B4009E"</span>,</span><br><span class="line">            <span class="attr">"brightRed"</span> : <span class="string">"#E74856"</span>,</span><br><span class="line">            <span class="attr">"brightWhite"</span> : <span class="string">"#F2F2F2"</span>,</span><br><span class="line">            <span class="attr">"brightYellow"</span> : <span class="string">"#F9F1A5"</span>,</span><br><span class="line">            <span class="attr">"cyan"</span> : <span class="string">"#3A96DD"</span>,</span><br><span class="line">            <span class="attr">"foreground"</span> : <span class="string">"#CCCCCC"</span>,</span><br><span class="line">            <span class="attr">"green"</span> : <span class="string">"#13A10E"</span>,</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"Campbell"</span>,</span><br><span class="line">            <span class="attr">"purple"</span> : <span class="string">"#881798"</span>,</span><br><span class="line">            <span class="attr">"red"</span> : <span class="string">"#C50F1F"</span>,</span><br><span class="line">            <span class="attr">"white"</span> : <span class="string">"#CCCCCC"</span>,</span><br><span class="line">            <span class="attr">"yellow"</span> : <span class="string">"#C19C00"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"background"</span> : <span class="string">"#000000"</span>,</span><br><span class="line">            <span class="attr">"black"</span> : <span class="string">"#000000"</span>,</span><br><span class="line">            <span class="attr">"blue"</span> : <span class="string">"#000080"</span>,</span><br><span class="line">            <span class="attr">"brightBlack"</span> : <span class="string">"#808080"</span>,</span><br><span class="line">            <span class="attr">"brightBlue"</span> : <span class="string">"#0000FF"</span>,</span><br><span class="line">            <span class="attr">"brightCyan"</span> : <span class="string">"#00FFFF"</span>,</span><br><span class="line">            <span class="attr">"brightGreen"</span> : <span class="string">"#00FF00"</span>,</span><br><span class="line">            <span class="attr">"brightPurple"</span> : <span class="string">"#FF00FF"</span>,</span><br><span class="line">            <span class="attr">"brightRed"</span> : <span class="string">"#FF0000"</span>,</span><br><span class="line">            <span class="attr">"brightWhite"</span> : <span class="string">"#FFFFFF"</span>,</span><br><span class="line">            <span class="attr">"brightYellow"</span> : <span class="string">"#FFFF00"</span>,</span><br><span class="line">            <span class="attr">"cyan"</span> : <span class="string">"#008080"</span>,</span><br><span class="line">            <span class="attr">"foreground"</span> : <span class="string">"#C0C0C0"</span>,</span><br><span class="line">            <span class="attr">"green"</span> : <span class="string">"#008000"</span>,</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"Vintage"</span>,</span><br><span class="line">            <span class="attr">"purple"</span> : <span class="string">"#800080"</span>,</span><br><span class="line">            <span class="attr">"red"</span> : <span class="string">"#800000"</span>,</span><br><span class="line">            <span class="attr">"white"</span> : <span class="string">"#C0C0C0"</span>,</span><br><span class="line">            <span class="attr">"yellow"</span> : <span class="string">"#808000"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"background"</span> : <span class="string">"#282C34"</span>,</span><br><span class="line">            <span class="attr">"black"</span> : <span class="string">"#282C34"</span>,</span><br><span class="line">            <span class="attr">"blue"</span> : <span class="string">"#61AFEF"</span>,</span><br><span class="line">            <span class="attr">"brightBlack"</span> : <span class="string">"#5A6374"</span>,</span><br><span class="line">            <span class="attr">"brightBlue"</span> : <span class="string">"#61AFEF"</span>,</span><br><span class="line">            <span class="attr">"brightCyan"</span> : <span class="string">"#56B6C2"</span>,</span><br><span class="line">            <span class="attr">"brightGreen"</span> : <span class="string">"#98C379"</span>,</span><br><span class="line">            <span class="attr">"brightPurple"</span> : <span class="string">"#C678DD"</span>,</span><br><span class="line">            <span class="attr">"brightRed"</span> : <span class="string">"#E06C75"</span>,</span><br><span class="line">            <span class="attr">"brightWhite"</span> : <span class="string">"#DCDFE4"</span>,</span><br><span class="line">            <span class="attr">"brightYellow"</span> : <span class="string">"#E5C07B"</span>,</span><br><span class="line">            <span class="attr">"cyan"</span> : <span class="string">"#56B6C2"</span>,</span><br><span class="line">            <span class="attr">"foreground"</span> : <span class="string">"#DCDFE4"</span>,</span><br><span class="line">            <span class="attr">"green"</span> : <span class="string">"#98C379"</span>,</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"One Half Dark"</span>,</span><br><span class="line">            <span class="attr">"purple"</span> : <span class="string">"#C678DD"</span>,</span><br><span class="line">            <span class="attr">"red"</span> : <span class="string">"#E06C75"</span>,</span><br><span class="line">            <span class="attr">"white"</span> : <span class="string">"#DCDFE4"</span>,</span><br><span class="line">            <span class="attr">"yellow"</span> : <span class="string">"#E5C07B"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"background"</span> : <span class="string">"#FAFAFA"</span>,</span><br><span class="line">            <span class="attr">"black"</span> : <span class="string">"#383A42"</span>,</span><br><span class="line">            <span class="attr">"blue"</span> : <span class="string">"#0184BC"</span>,</span><br><span class="line">            <span class="attr">"brightBlack"</span> : <span class="string">"#4F525D"</span>,</span><br><span class="line">            <span class="attr">"brightBlue"</span> : <span class="string">"#61AFEF"</span>,</span><br><span class="line">            <span class="attr">"brightCyan"</span> : <span class="string">"#56B5C1"</span>,</span><br><span class="line">            <span class="attr">"brightGreen"</span> : <span class="string">"#98C379"</span>,</span><br><span class="line">            <span class="attr">"brightPurple"</span> : <span class="string">"#C577DD"</span>,</span><br><span class="line">            <span class="attr">"brightRed"</span> : <span class="string">"#DF6C75"</span>,</span><br><span class="line">            <span class="attr">"brightWhite"</span> : <span class="string">"#FFFFFF"</span>,</span><br><span class="line">            <span class="attr">"brightYellow"</span> : <span class="string">"#E4C07A"</span>,</span><br><span class="line">            <span class="attr">"cyan"</span> : <span class="string">"#0997B3"</span>,</span><br><span class="line">            <span class="attr">"foreground"</span> : <span class="string">"#383A42"</span>,</span><br><span class="line">            <span class="attr">"green"</span> : <span class="string">"#50A14F"</span>,</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"One Half Light"</span>,</span><br><span class="line">            <span class="attr">"purple"</span> : <span class="string">"#A626A4"</span>,</span><br><span class="line">            <span class="attr">"red"</span> : <span class="string">"#E45649"</span>,</span><br><span class="line">            <span class="attr">"white"</span> : <span class="string">"#FAFAFA"</span>,</span><br><span class="line">            <span class="attr">"yellow"</span> : <span class="string">"#C18301"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"background"</span> : <span class="string">"#002B36"</span>,</span><br><span class="line">            <span class="attr">"black"</span> : <span class="string">"#073642"</span>,</span><br><span class="line">            <span class="attr">"blue"</span> : <span class="string">"#268BD2"</span>,</span><br><span class="line">            <span class="attr">"brightBlack"</span> : <span class="string">"#002B36"</span>,</span><br><span class="line">            <span class="attr">"brightBlue"</span> : <span class="string">"#839496"</span>,</span><br><span class="line">            <span class="attr">"brightCyan"</span> : <span class="string">"#93A1A1"</span>,</span><br><span class="line">            <span class="attr">"brightGreen"</span> : <span class="string">"#586E75"</span>,</span><br><span class="line">            <span class="attr">"brightPurple"</span> : <span class="string">"#6C71C4"</span>,</span><br><span class="line">            <span class="attr">"brightRed"</span> : <span class="string">"#CB4B16"</span>,</span><br><span class="line">            <span class="attr">"brightWhite"</span> : <span class="string">"#FDF6E3"</span>,</span><br><span class="line">            <span class="attr">"brightYellow"</span> : <span class="string">"#657B83"</span>,</span><br><span class="line">            <span class="attr">"cyan"</span> : <span class="string">"#2AA198"</span>,</span><br><span class="line">            <span class="attr">"foreground"</span> : <span class="string">"#839496"</span>,</span><br><span class="line">            <span class="attr">"green"</span> : <span class="string">"#859900"</span>,</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"Solarized Dark"</span>,</span><br><span class="line">            <span class="attr">"purple"</span> : <span class="string">"#D33682"</span>,</span><br><span class="line">            <span class="attr">"red"</span> : <span class="string">"#DC322F"</span>,</span><br><span class="line">            <span class="attr">"white"</span> : <span class="string">"#EEE8D5"</span>,</span><br><span class="line">            <span class="attr">"yellow"</span> : <span class="string">"#B58900"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"background"</span> : <span class="string">"#FDF6E3"</span>,</span><br><span class="line">            <span class="attr">"black"</span> : <span class="string">"#073642"</span>,</span><br><span class="line">            <span class="attr">"blue"</span> : <span class="string">"#268BD2"</span>,</span><br><span class="line">            <span class="attr">"brightBlack"</span> : <span class="string">"#002B36"</span>,</span><br><span class="line">            <span class="attr">"brightBlue"</span> : <span class="string">"#839496"</span>,</span><br><span class="line">            <span class="attr">"brightCyan"</span> : <span class="string">"#93A1A1"</span>,</span><br><span class="line">            <span class="attr">"brightGreen"</span> : <span class="string">"#586E75"</span>,</span><br><span class="line">            <span class="attr">"brightPurple"</span> : <span class="string">"#6C71C4"</span>,</span><br><span class="line">            <span class="attr">"brightRed"</span> : <span class="string">"#CB4B16"</span>,</span><br><span class="line">            <span class="attr">"brightWhite"</span> : <span class="string">"#FDF6E3"</span>,</span><br><span class="line">            <span class="attr">"brightYellow"</span> : <span class="string">"#657B83"</span>,</span><br><span class="line">            <span class="attr">"cyan"</span> : <span class="string">"#2AA198"</span>,</span><br><span class="line">            <span class="attr">"foreground"</span> : <span class="string">"#657B83"</span>,</span><br><span class="line">            <span class="attr">"green"</span> : <span class="string">"#859900"</span>,</span><br><span class="line">            <span class="attr">"name"</span> : <span class="string">"Solarized Light"</span>,</span><br><span class="line">            <span class="attr">"purple"</span> : <span class="string">"#D33682"</span>,</span><br><span class="line">            <span class="attr">"red"</span> : <span class="string">"#DC322F"</span>,</span><br><span class="line">            <span class="attr">"white"</span> : <span class="string">"#EEE8D5"</span>,</span><br><span class="line">            <span class="attr">"yellow"</span> : <span class="string">"#B58900"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面我们用到了 <code>Cascadia Code</code> 字体。这里在推荐一下这个字体，这个月微软为编程人员出的一款字体，用起来简直舒服。<br><a href="https://github.com/microsoft/cascadia-code/releases" target="_blank" rel="noopener">下载地址</a></p>
<h2 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h2><p>win10系统需要更新到1067及其以后的版本，并且是64位的系统才可以安装。相信做开发的都是64位系统吧。</p>
<p>win10打开程序和功能<br><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190329125336.png" alt><br>勾选适用于系统的Linux的子系统，然后重启系统。<br><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190329125419.png" alt><br>重启以后，此时我们已经可以使用Linux系统，但是我们还差一个系统，所以需要安装一个</p>
<p>我们在win10应用商店里面搜索linux，安装Ubuntu。<br><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190329125827.png" alt></p>
<p>安装完成后在开始菜单里面找到程序，启动。</p>
<p>刚开始的时候需要等一下，在配置环境。完成后需要设置用户名以及密码。</p>
<h2 id="安装cmder"><a href="#安装cmder" class="headerlink" title="安装cmder"></a>安装cmder</h2><p><a href="https://cmder.net/" target="_blank" rel="noopener">cmder</a>有两个版本，Mini版与完整版（包含了git以及一些其他的命令）。推荐安装完整版。<br>安装完成后打开，我们需要进行配置一下<br><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190329131207.png" alt><br>如上图，在tasks中添加一个task</p>
<ul>
<li>名字为Ubuntu，这个名字随便你</li>
<li>下面的大框里面<code>set &quot;PATH=%ConEmuBaseDirShort%\wsl;%PATH%&quot; &amp; %ConEmuBaseDirShort%\conemu-cyg-64.exe --wsl --distro-guid={9df562ee-848c-4af4-ab4e-aedad54ceba9} -cur_console:pm:/mnt</code>。这里面的<code>9df562ee-848c-4af4-ab4e-aedad54ceba9</code>指的是Ubuntu的唯一标识符，如果重装了子系统，那么这个标识符实惠变得。可以在在注册表(regedit)中查找<br><code>计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Lxss</code>。<code>win+R搜索regedit</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190329131803.png" alt><br>在常规里面设置刚刚的名字为默认的启动项。如果你要打开其他的，比如cmd，可以点窗口右下角的<code>+</code>，里面有所有的配置。</p>
<h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><p>在Ubuntu系统中使用命令行而不是win中</p>
<p>安装任何包之前一定要先更新！<br><code>sudo apt-get update</code></p>
<p>安装zsh<br><code>sudo apt-get install zsh</code></p>
<p>安装oh-my-zsh<br><code>sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</code></p>
<p>安装成功<br><img src="https://raw.githubusercontent.com/tal007/PicGo/master/%E5%AE%89%E8%A3%85oh-my-zsh.png" alt></p>
<p>如果 遇到证书类似问题<br>apt-get install ca-certificates</p>
<p>自动启动zsh<br><code>vim ~/.bashrc</code>或者<code>nano ~/.bashrc</code>（推荐使用）打开编辑<code>.bashrc</code>文件，添加以下内容：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -t 1; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> zsh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190329132226.png" alt></p>
<p>如果你使用的是<code>vim ~/.bashrc</code>，编辑后使用<code>:wq</code>退出。</p>
<p>如果你使用的是<code>nano ~/.bashrc</code>，使用<code>Ctrl+Shift+X</code>保存并退出。</p>
<p>修改主题：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">nano ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主题名字ys，你可以搜索其他的主题使用，ys挺好的</span></span><br><span class="line">ZSH_THEME=<span class="string">"ys"</span></span><br></pre></td></tr></table></figure></p>
<p>修改以后保存。</p>
<p>终端字体补全<br><code>sudo apt-get install fonts-powerline</code></p>
<p>客户端字体补全<br>注意： 有些字符在windows 上无法显示，所以需要安装字体<br><a href="nerdfonts.com">nerdfonts.com</a>，选择 Hack</p>
<p>修改<strong>cmder</strong>字体为<br><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190329154316.png" alt><br>当然，你也可以设置为其他你认为好看的字体。</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190329154424.png" alt><br>这个是我的配置的最后的效果，还设置了透明度以及背景什么的，你们也可以自己进行配置。</p>
<h2 id="在VSCode上使用WSL"><a href="#在VSCode上使用WSL" class="headerlink" title="在VSCode上使用WSL"></a>在VSCode上使用WSL</h2><p>由于博主是做前端开发的，用的是VSCode所以这里说一下，怎么在VSCode上面使用。</p>
<p>在VSCode的设置文件中添加这一句<br><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">"terminal.integrated.shell.windows": "C:<span class="symbol">\\</span><span class="symbol">\\</span>Windows<span class="symbol">\\</span><span class="symbol">\\</span>System32<span class="symbol">\\</span><span class="symbol">\\</span>wsl.exe",</span><br></pre></td></tr></table></figure></p>
<p>如果需要使用node，npm等工具，WSL里面是不能够直接使用windows自带的这些环境变量的，我们需要在WSL中安装，具体的安装方法可以google–<code>Ubuntu安装软件</code></p>
<h2 id="说在结尾"><a href="#说在结尾" class="headerlink" title="说在结尾"></a>说在结尾</h2><p>之前说的字体<code>fonts-powerline</code>，<code>Hack Nerd Font Mono</code>这个字体，其实还是挺好看的，大家可以使用，包括在PC上面也可以。这个字体可以使用Git下载<code>https://github.com/powerline/fonts</code>，不过这个实在是有点慢，这里我已经下载下来放在了<a href="https://www.lanzous.com/i3ldpcj" target="_blank" rel="noopener">这里</a>。</p>
<p>下载下来以后使用<code>PowerShell</code>，到字体目录下，运行以下命令<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">.\<span class="keyword">install</span>.ps1</span><br></pre></td></tr></table></figure></p>
<p>可能会遇到报错，此时先执行<code>set-Executionpolicy Remotesigned</code><br><img src="http://upload-images.jianshu.io/upload_images/8678448-30cc7593c1e27cec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><strong>关于启动时候报错</strong><br>有时候我们启动子系统的时候会报错，错误代码：<strong><code>0x800703fa</code></strong></p>
<p>具体错误内容：<strong>WslRegisterDistribution failed with error: 0x800703fa</strong></p>
<p>此时<code>win+R</code>在运行窗口中执行“services.msc”指令，在本地服务中重启 LxssManager 服务即可</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]. <a href="https://segmentfault.com/a/1190000016827068" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016827068</a><br>[2]. <a href="https://blog.joaograssi.com/windows-subsystem-for-linux-with-oh-my-zsh-conemu/" target="_blank" rel="noopener">https://blog.joaograssi.com/windows-subsystem-for-linux-with-oh-my-zsh-conemu/</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>terminal</tag>
        <tag>win10</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>细说前端基础安全知识</title>
    <url>/%E5%85%B6%E4%BB%96/%E7%BB%86%E8%AF%B4%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<p>我们先列出常见的几种前端的安全问题，在逐一的解释每一个并谈谈简单的解决思路</p>
<ul>
<li>XSS（Cross Site Script，跨站脚本攻击）</li>
<li>SQL（Structured Query Language，结构化查询语言）注入</li>
<li>CSRF（Cross-site Request Forgery，跨站请求伪造）</li>
</ul>
<h2 id="XSS（Cross-Site-Script，跨站脚本攻击）"><a href="#XSS（Cross-Site-Script，跨站脚本攻击）" class="headerlink" title="XSS（Cross Site Script，跨站脚本攻击）"></a>XSS（Cross Site Script，跨站脚本攻击）</h2><p>XSS通常是<code>由带有页面解析内容的数据未经处理直接插入页面上解析</code>导致的。而XSS根据攻击脚本的引入位置又可以分为以下三种：</p>
<ol>
<li>存储型XSS</li>
<li>反射性XSS</li>
<li>MXSS（DOM XSS）</li>
</ol>
<h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>常常是由前端提交的数据未经处理直接存储到数据库然后从数据库中读取出来后直接插入到页面中导致</p>
<p>例如<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 前端模版，content为后台得到的数据 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实际上content的内容为&lt;script&gt;alert("")&lt;/script&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 经过解析后，页面上展现的是 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">""</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码如果没有对<code>&lt;</code>，<code>&gt;</code>，<code>/</code>进行处理，那么就会直接的运行这一点script代码，这就是一个简单的存储型XSS。</p>
<h3 id="反射性XSS"><a href="#反射性XSS" class="headerlink" title="反射性XSS"></a>反射性XSS</h3><p>一般产生的原因是在网页URL参数中注入了可解析内容的数据而导致的，如果直接获取URL中不合法的并插入页面中则可能出现页面上的XSS攻击。</p>
<h3 id="MXSS"><a href="#MXSS" class="headerlink" title="MXSS"></a>MXSS</h3><p>一般是在渲染DOM属性是将攻击脚本插入DOM属性中被解析而导致的。</p>
<p>其实这三种的实质是一样的，都是页面中出现了我们本不想让其执行但是可执行的脚本，<code>主要的防范与解决方法就是验证也，输入到页面上所有内容来源数据是否安全，如果有可能含有脚本标签等内容则需要进行转义。</code></p>
<h3 id="HTML常见字符的转义"><a href="#HTML常见字符的转义" class="headerlink" title="HTML常见字符的转义"></a>HTML常见字符的转义</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML字符转义编码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEncode</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span> ( str.length === <span class="number">0</span> ) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  s = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/ /g</span>, <span class="string">'&amp;nbsp;'</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/\'/g</span>, <span class="string">'&amp;#39;'</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/\"/g</span>, <span class="string">'&amp;quot;'</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/\n/g</span>, <span class="string">'&lt;br&gt;'</span>);</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML字符转移解码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlDecode</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span> ( str.length === <span class="number">0</span> ) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  s = str.replace(<span class="regexp">/&amp;amp;/g</span>, <span class="string">'&amp;'</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/&amp;lt;/g</span>, <span class="string">'&lt;'</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/&amp;gt;/g</span>, <span class="string">'&gt;'</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/&amp;nbsp;/g</span>, <span class="string">' '</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/&amp;#39;/g</span>, <span class="string">"\'"</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/&amp;quot;/g</span>, <span class="string">'\"'</span>);</span><br><span class="line">  s = str.replace(<span class="regexp">/&lt;br&gt;/g</span>, <span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SQL（Structured-Query-Language，结构化查询语言）注入"><a href="#SQL（Structured-Query-Language，结构化查询语言）注入" class="headerlink" title="SQL（Structured Query Language，结构化查询语言）注入"></a>SQL（Structured Query Language，结构化查询语言）注入</h2><p>SQL注入攻击主要是<code>因为页面提交数据到服务器后端，在服务器端未进行数据验证就将数据直接拼接到SQL语句中执行，因此产生执行与预期不同的现象。</code></p>
<p>主要的防范措施就是对前端网页提交的数据内容进行严格的检查校验。</p>
<p>例如<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sql = <span class="string">`select * from user_table where id=<span class="subst">$&#123;id&#125;</span>`</span></span><br></pre></td></tr></table></figure></p>
<p>上面的一段查询语句接收一个参数id，如果前端页面所传递的id的值是<strong>100 or name=%user%</strong>，那么查询的结果就不只是<code>id=100</code>的用户了，所有需要对前端传递的数据进行校验，这一步一般由后台人员处理，不过前端人员也可以做一个简单的验证提示，更重要的还是在后台方面。</p>
<h2 id="CSRF（Cross-site-Request-Forgery，跨站请求伪造）"><a href="#CSRF（Cross-site-Request-Forgery，跨站请求伪造）" class="headerlink" title="CSRF（Cross-site Request Forgery，跨站请求伪造）"></a>CSRF（Cross-site Request Forgery，跨站请求伪造）</h2><p>CSRF指<code>非源站点按照源站点的数据请求格式提交非法数据给源站点服务器的一种攻击方法</code>。通俗的讲就是用户进入一个页面，这个页面不是真正的官方页面，而是模仿度非常高的一个页面，用户认为他就是官网了，此时就是访问了伪站点页面（非源站点），用户提交的数据进过这个页面提交而不是官方提交就是非法提交，而非源站点页面还可以获取用户姓名等重要信息（常见的银行卡密码盗取，支付密码盗取等）。</p>
<p>这种问题常见的解决方法就是<code>通过页面Token提交验证的方式来验证请求是否为源站点页面提交的，来阻止跨站伪请求的发生。</code>Token也是需要进行加密解密的。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后说一点，任何所谓的安全都是相对的，只是理论的破解时间变长了，而不容易被攻击。很多时候需要使用多种方法相结合的方式来一起增加网站的安全性，可以结合验证码等手段大大减少盗刷网站用户信息的频率等。进一步增强网站内容的安全性。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
        <tag>前端攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用hexo与github搭建自己的博客（2）</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%882%EF%BC%89.html</url>
    <content><![CDATA[<p>接着<a href="https://blog.lyt007.cn/%E5%85%B6%E4%BB%96/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%881%EF%BC%89.html#more">上一篇</a>的讲，我们把该有的事情都已经准备好了，接下了就是怎么配置我们的博客了</p>
<p><code>hexo</code>的配置文件是<code>_config.yml</code>，整个hexo项目里面有两个这样的文件，一个是在根目录下面，另一个是在文件夹<strong>theme</strong>里面，根目录的主要是对整个项目的配置，而<strong>theme</strong>里面的则主要是对你当前所应用的主题的一个设置。</p>
<p>例如：下面的代码就是我的根目录的配置项，写法如此，一个大的属性，大属性下面的小属性前面需要有空格（最后的效果和JSON一样，只不过这样写起来比JSON更直观）</p>
<p>我们说一下其中的一些属性</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">踏浪个人博客</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">用代码震撼世界</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">踏浪个人博客</span> <span class="bullet">--</span> <span class="string">用代码震撼世界</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">踏浪，IT技术，前端，html，css，js，react，vue，框架</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">踏浪</span></span><br><span class="line"><span class="attr">language:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">zh-cn</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">https://github.com/tal007</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:category/:title.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">  order_by:</span> <span class="bullet">-date</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">技术</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line">  <span class="string">技术:</span> <span class="string">tech-notes</span></span><br><span class="line">  <span class="string">金融:</span> <span class="string">finance</span></span><br><span class="line">  <span class="string">其他:</span> <span class="string">others</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">jsimple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/tal007/tal007.github.io</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">backup:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  message:</span> <span class="string">backup</span> <span class="string">my</span> <span class="string">blog</span> <span class="attr">https://github.com/tal007</span></span><br><span class="line"><span class="attr">  repository:</span></span><br><span class="line"><span class="attr">    github:</span> <span class="attr">https://github.com/tal007/blog.git,master</span></span><br></pre></td></tr></table></figure>
<p>首先是前面的<code>Site</code>，主要是对整个网站属性的的一些设置，包含网站的标题，【副标题】，描述，关键字等。这一部分很简单</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Category &amp; Tag</span></span><br><span class="line"><span class="symbol">default_category:</span> 技术</span><br><span class="line"><span class="symbol">category_map:</span></span><br><span class="line">  技术: tech-notes</span><br><span class="line">  金融: finance</span><br><span class="line">  其他: others</span><br></pre></td></tr></table></figure>
<p><code># Category &amp; Tag</code>就是我们的导航，前面的中文是网页上面显示的，后面的是你的关键字，供程序读取识别</p>
<p>最后就是<code>Deployment</code><br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> https:<span class="comment">//github.com/tal007/tal007.github.io</span></span><br><span class="line"><span class="symbol">  branch:</span> master</span><br><span class="line"></span><br><span class="line"><span class="symbol">backup:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  message:</span> backup my blog https:<span class="comment">//github.com/tal007</span></span><br><span class="line"><span class="symbol">  repository:</span></span><br><span class="line"><span class="symbol">    github:</span> https:<span class="comment">//github.com/tal007/blog.git,master</span></span><br></pre></td></tr></table></figure></p>
<p>主要包含<code>deploy</code>和<code>backup</code>。前一个是我们发布的一个地址，这个地址就是用我们上一节生成的那个带有<code>.github.io</code>的地址。后一个呢是我们备份的一个地址，需要注意的是后面的<code>，master</code>。</p>
<p>其他的配置就不多说，在hexo官网上面都是有具体的说明，需要的话可以自己看看。</p>
<p>至于主题下面的配置文件，每个主题可能不同，这个需要对照着自己的主题进行修改。</p>
<h2 id="下面说说怎么创建发布"><a href="#下面说说怎么创建发布" class="headerlink" title="下面说说怎么创建发布"></a>下面说说怎么创建发布</h2><p>在我们的根目录面下有一个文件夹<code>scaffolds</code>。这里面可能自带有一些<code>md</code>文件。其实这些都是我们默认的一些模版。<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&#123;&#123;</span> <span class="string">title</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">&#123;&#123;</span> <span class="string">date</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">踏浪</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/images/favicon.png</span></span><br><span class="line"><span class="attr">authorLink:</span> <span class="attr">https://github.com/tal007</span></span><br><span class="line"><span class="attr">authorAbout:</span> <span class="attr">https://github.com/tal007</span></span><br><span class="line"><span class="attr">authorDesc:</span> <span class="string">转行IT，用代码震撼世界</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">技术</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">description:</span> </span><br><span class="line"><span class="attr">photos:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p>
<p>我们一般使用的都是<code>page.md</code>和<code>post.md</code>，这两个我设置的都是一样的，上面的<code>title</code>就是我们通过<code>hexo n 你的心新的文档的名字</code>(hexo n 是 hexo new 的简写)命令所输入的title，例如我们本篇文章<br><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">hexo <span class="built_in">n</span> 如何使用hexo与github搭建自己的博客（<span class="number">2</span>）</span><br></pre></td></tr></table></figure></p>
<p><code>data</code>就是发布时间，这个在配置文件里面可以设置时间格式。其余的属性根据不同的主题需求也是不同的。有一点需要说明，就是<code>categories</code>表示这篇文章所述的分类。</p>
<p>使用<code>hexo new</code>命令生成的是一个<code>md</code>格式的文件，接下来我们就是在这个文件里面写我们需要发布的内容</p>
<p>最后通过命令<code>hexo g</code>进行生成静态的文件，执行后可以看见我们的根目录下面多了一个<code>public</code>文件夹，我们所需要的html文件都在里面了。</p>
<p>你可以使用<code>hexo s</code>进行本地浏览测试，调试，带到没有问题以后则可以进行发布了。</p>
<p>使用<code>hexo d</code>进行发布，发布的地址就是我们在<code>_config.yml</code>中配置的<code>deploy</code>里面的<code>repo</code>的地址。</p>
<p>待github上面的代码同步了，我们就可以通过访问<code>XXX.github.io</code>进行访问自己的博客了。</p>
<h2 id="最后还有一些关于博客的插件"><a href="#最后还有一些关于博客的插件" class="headerlink" title="最后还有一些关于博客的插件"></a>最后还有一些关于博客的插件</h2><p>自己的博客的插件可以去<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">hexo插件</a>中去看看，包括评论，时间线等插件，这里就不一一介绍了。</p>
<p><strong>最后说明一下，这里所介绍的知识一些简单的基础，更多的命令以及配置属性都可以上<a href="https://hexo.io" target="_blank" rel="noopener">hexo</a>上面看到，希望你有时间还是能够看一看，主要就是看看Docs这一部分</strong></p>
<p>关于怎么使用<strong>hexo+github</strong>搭建自己的博客就先说到这里，如果有需要，以后可能会更新，还请随时关注，谢谢。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用hexo与github搭建自己的博客（1）</title>
    <url>/%E5%85%B6%E4%BB%96/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%881%EF%BC%89.html</url>
    <content><![CDATA[<p>最近有一批人问我怎么使用hexo搭建博客，因为我的博客就是使用hexo搭建的。这里呢我就简单的说一下因该准备一些什么样的工作</p>
<p>这是我我们的第一节课吧，<strong>我们需要做一些什么样的准备</strong></p>
<h2 id="创建一个自己的github主页项目"><a href="#创建一个自己的github主页项目" class="headerlink" title="创建一个自己的github主页项目"></a>创建一个自己的github主页项目</h2><p>打开<a href="https://github.com/" target="_blank" rel="noopener">github官网</a>，登录自己的账号，并创建一个小的项目（这一步怎么走到这里不进行说明）</p>
<p>接着就是按照下面的步骤来，注意红色字的提醒</p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20190301221029.png" alt></p>
<p>需要的信息填写完成以后就可以确定提交了</p>
<h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>接下来我们需要在电脑本地创建一个项目，这里我们是做博客，那么就创建一个名字为<em>myBlog</em>的文件夹吧</p>
<p>在我们的github上面也需要创建一个项目，项目的名字也是<em>myBlog</em>，然后把这个项目拉去到自己的本地，这样我们的github上面的项目就在自己的本地了</p>
<p>接下来就是实际的操作了</p>
<p>因为我们使用的是<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>搭建博客，所以命令我们也需要使用hexo命令，这些命令可以去hexo官网查看</p>
<p>先来安装hexo，我在在全局安装<code>hexo-cli</code>库，保证我们可以在全局使用<code>hexo</code>命令。<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 这里就不在说明安装git，node等需要的东西</span></span><br><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure></p>
<p>安装完成后我们就需要在我们的<strong>myBlog</strong>文件夹下面执行以下命令，初始化我们的项目<br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># floder文件夹名字（English）</span></span><br><span class="line">hexo init <span class="params">&lt;floder&gt;</span></span><br><span class="line">cd <span class="params">&lt;floder&gt;</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p>
<p>安装完成后，我们可以看见初始的目录如下<br><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="variable">_config</span>.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── <span class="variable">_drafts</span></span><br><span class="line">|   └── <span class="variable">_posts</span></span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p>
<h2 id="最后我们需要做的就是配置我们的项目，这一节我们在下面的章节里面说明"><a href="#最后我们需要做的就是配置我们的项目，这一节我们在下面的章节里面说明" class="headerlink" title="最后我们需要做的就是配置我们的项目，这一节我们在下面的章节里面说明"></a>最后我们需要做的就是配置我们的项目，这一节我们在下面的章节里面说明</h2>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>redux_todoList案例</title>
    <url>/%E6%8A%80%E6%9C%AF/redux-todoList%E6%A1%88%E4%BE%8B.html</url>
    <content><![CDATA[<p>上一节我们说到了redux的基础以及如何理解redux。这一节我们用经典的案例redux-todoList来具体的说一下每一个部分作何解释。</p>
<h2 id="todoList是什么"><a href="#todoList是什么" class="headerlink" title="todoList是什么"></a>todoList是什么</h2><p>todolist是一个经典的案例，代办项的意思。一般我们初学一门语言的时候基本都是会做一个todoList来验证自己所学的知识。我们这里用来理解redux也是一个不错的方法。</p>
<p>具体的功能可以查看<a href="http://www.todolist.cn/" target="_blank" rel="noopener">http://www.todolist.cn/</a>。一个输入框，输入代办事件，刚添加的归类到正在进行，我们可以点击具体的莫一项是他变成已完成。</p>
<p>我自己的代码以及托管到了<a href="https://github.com/tal007/react-webpack/tree/react-redux-todos" target="_blank" rel="noopener">github</a>上面，之后的代码将会以我自己的代码为例，如果需要，可以去想clone。</p>
<h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><p>我们回顾一下之前说redux的三要素：action，reducer，store。我们要完成todolist需要做一下什么呢？接下来看看具体的步骤。</p>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>入口，即整个项目的入口文件。我们需要把我们需要的代码render（渲染到具体的某一个文件中）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./src/index'</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./src/reducers'</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./src/css/style.scss'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure></p>
<p>首先是<code>Provider</code>组件，由<code>react-reudx</code>提供，作用就是作为整个项目的跟标签，我们把属性<code>store</code>传递到整个项目中去，供子组件使用。<code>store</code>就是由<code>redux</code>提供的<code>createStore</code>方法创建的。</p>
<p>我们说<code>createStore</code>方法接收一个参数，所有的reducer，那么reducer在哪里呢？接下来就是reducer。</p>
<h2 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h2><p>我们说reducer是一个函数，给定一个确定的输入必定有一个确定的输出。他的作用就是操作我们需要的state（状态）。</p>
<p>那么在todolist里面有那几个状态呢？</p>
<ul>
<li>所有的代办项，我们用一个数组表示，即todos</li>
<li>todos的过滤，即我们当前所处一个状态，用<code>visibilityFilter</code>表示。</li>
</ul>
<p>所以就有了以下的代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">let</span> initState = &#123;</span><br><span class="line">  todos: [],</span><br><span class="line">  visibilityFilter: <span class="string">"SHOW_ACTIVE"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos = <span class="function">(<span class="params">state=initState.todos, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"ADD_TODO"</span>:</span><br><span class="line">      <span class="comment">// 千万不要使用push，返回的是数组的长度</span></span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">          ...state,</span><br><span class="line">          &#123;</span><br><span class="line">            text: action.text,</span><br><span class="line">            complete: <span class="literal">false</span>,</span><br><span class="line">            index: action.index</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"TOGGLE_TODO"</span>:</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( action.index == index ) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, item, &#123;</span><br><span class="line">            complete: !item.complete</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filterCompleteOrNot = <span class="function">(<span class="params">state=initState.visibilityFilter, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FILTER_COMPLETE_OR_NOT"</span>:</span><br><span class="line">      <span class="keyword">return</span> action.filter</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoApp = combineReducers(&#123;</span><br><span class="line">  todos,</span><br><span class="line">  filterCompleteOrNot</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todoApp</span><br></pre></td></tr></table></figure></p>
<p>我们给定一个初始的状态initState，里面就有两个属性，todos与visibilityFilter，接下来就是编写纯函数了。</p>
<p>我们根据我们的状态来编写，todos会发生改变，什么情况下面会发生改变呢？</p>
<ul>
<li>添加todo</li>
<li>修改todo的状态</li>
</ul>
<p>所以我们的纯函数是这样写的<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todos = <span class="function">(<span class="params">state=initState.todos, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"ADD_TODO"</span>:</span><br><span class="line">      <span class="comment">// 千万不要使用push，返回的是数组的长度</span></span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">          ...state,</span><br><span class="line">          &#123;</span><br><span class="line">            text: action.text,</span><br><span class="line">            complete: <span class="literal">false</span>,</span><br><span class="line">            index: action.index</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"TOGGLE_TODO"</span>:</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( action.index == index ) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, item, &#123;</span><br><span class="line">            complete: !item.complete</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更具我们操作的动作进行switch判断</p>
<p>接下来就是过滤todos，todos里面要显示那些东西呢<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> filterCompleteOrNot = <span class="function">(<span class="params">state=initState.visibilityFilter, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"FILTER_COMPLETE_OR_NOT"</span>:</span><br><span class="line">      <span class="keyword">return</span> action.filter</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是我们的reducer。因为我们写了两个纯函数，但是在我们创建store的时候，<strong>createStore方法只接受一个参数</strong>，即所有纯函数的集合。所以我们需要使用<code>redux</code>提供的<code>combineReducers</code>方法把所有的reducer集合起来。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todoApp = combineReducers(&#123;</span><br><span class="line">  todos,</span><br><span class="line">  filterCompleteOrNot</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>再来看看action，和上面的关联起来了<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> initNumber = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> addTodo = <span class="function">(<span class="params">text</span>) =&gt;</span> (&#123;</span><br><span class="line">  text,</span><br><span class="line">  type: <span class="string">"ADD_TODO"</span>,</span><br><span class="line">  index: initNumber++</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toggleTodo = <span class="function">(<span class="params">index</span>) =&gt;</span> (&#123;</span><br><span class="line">  index,</span><br><span class="line">  type: <span class="string">'TOGGLE_TODO'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filterCompleteOrNot = <span class="function">(<span class="params">filter</span>) =&gt;</span> (&#123;</span><br><span class="line">  filter,</span><br><span class="line">  type: <span class="string">'FILTER_COMPLETE_OR_NOT'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TODOS_TYPE = &#123;</span><br><span class="line">  SHOW_ALL: <span class="string">"SHOW_ALL"</span>,</span><br><span class="line">  SHOW_COMPLETE: <span class="string">"SHOW_COMPLETE"</span>,</span><br><span class="line">  SHOW_ACTIVE: <span class="string">"SHOW_ACTIVE"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  addTodo,</span><br><span class="line">  toggleTodo,</span><br><span class="line">  filterCompleteOrNot,</span><br><span class="line">  TODOS_TYPE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们知道action就是我们集体的操作，有哪一些呢？</p>
<ul>
<li>添加todo</li>
<li>修改单个todo的state</li>
<li>过滤todos</li>
</ul>
<p>所以我们定义了三个<strong>action creater</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addTodo = <span class="function">(<span class="params">text</span>) =&gt;</span> (&#123;</span><br><span class="line">  text,</span><br><span class="line">  type: <span class="string">"ADD_TODO"</span>,</span><br><span class="line">  index: initNumber++</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toggleTodo = <span class="function">(<span class="params">index</span>) =&gt;</span> (&#123;</span><br><span class="line">  index,</span><br><span class="line">  type: <span class="string">'TOGGLE_TODO'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filterCompleteOrNot = <span class="function">(<span class="params">filter</span>) =&gt;</span> (&#123;</span><br><span class="line">  filter,</span><br><span class="line">  type: <span class="string">'FILTER_COMPLETE_OR_NOT'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="最后就是我们具体的展示层了"><a href="#最后就是我们具体的展示层了" class="headerlink" title="最后就是我们具体的展示层了"></a>最后就是我们具体的展示层了</h2><p>因为我们使用的是redux，而redux又提倡数据域结构分离，所以在文件目录下面有<code>components</code>与<code>containers</code>两个文件夹。但是普通的component与container没有什么关系，普通的组件里面没有store的dispatch等方法。所以我们在其中的几个文件代码中可以看到<code>mapStateToProps</code>与<code>mapDispatchToProps</code>两个方法。字面意思就是遍历state（dispatch）到props。意思就是把redux中的state与dispatch方法传递到props中（即组件component）。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (&#123;</span><br><span class="line">    todos: getVisibleTodos(state.todos, state.filterCompleteOrNot)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">  toggleTodo: <span class="function"><span class="params">index</span> =&gt;</span> dispatch(toggleTodo(index))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>但是怎么传递呢？</p>
<p>在react-redux中，我们使用<code>react-redux</code>提供的<code>connect</code>方法。他的作用就是把component与container链接起来。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br></pre></td></tr></table></figure></p>
<p><code>connect</code>是一个二阶函数，第一次运行后返回一个函数再次运行。第一个运行的参数就是我们需要传递的两个props，第二次运行的参数就是我们需要传递到的组件。所以在<code>TodoList</code>文件中<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ListGroup</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-bootstrap'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TodoList = <span class="function">(<span class="params">&#123;todos, toggleTodo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ListGroup&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        todos.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &lt;ListGroup.Item</span><br><span class="line">          key=&#123;index&#125;</span><br><span class="line">          onClick=&#123;() =&gt; toggleTodo(item.index)&#125;</span><br><span class="line">          variant=&#123;item.complete ? <span class="string">'success'</span> : <span class="string">'danger'</span>&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;span className=<span class="string">'name'</span>&gt;&#123;item.text&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">          &lt;span className='state'&gt;&#123;item.complete ? '已完成' : '未完成'&#125;&lt;/</span>span&gt;</span><br><span class="line">        &lt;<span class="regexp">/ListGroup.Item&gt;)</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ListGroup&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TodoList</span><br></pre></td></tr></table></figure></p>
<p>我们才可以使用<strong>todos与toggleTodo</strong>，因为这两个参数都是我们使用<code>mapStateToProps</code>与<code>mapDispatchToProps</code>得到的。</p>
<p>其他的地方理解是一样的。</p>
<p>至于代码中用到的<code>react-bootstrap</code>，就是bootstrap封装的UI插件，集体可以看<a href="http://react.tgwoo.com/" target="_blank" rel="noopener">react-bootstrap</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title>redux基础</title>
    <url>/%E6%8A%80%E6%9C%AF/redux%E5%9F%BA%E7%A1%80.html</url>
    <content><![CDATA[<h2 id="redux概念简介"><a href="#redux概念简介" class="headerlink" title="redux概念简介"></a>redux概念简介</h2><p>redux是一个<code>专门用于</code>处理数据的第三方库（插件）,作用是使MVM，MVVM等框架使用起来视图与控制层更加明显。很多人听到redux都是因为<code>react-redux</code>这一个插件。其实react-redux只是redux的一部分而已。</p>
<p>redux就像<code>Jquery</code>一样，可以在任何的地方使用，只要你用得到他，就像最开始说的，他就是一个插件而已。</p>
<h2 id="redux的三大要素"><a href="#redux的三大要素" class="headerlink" title="redux的三大要素"></a>redux的三大要素</h2><p>redux用来处理数据，存在三大要素<br><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=779109256,4038797986&amp;fm=26&amp;gp=0.jpg" alt="redux"></p>
<p>如上面图上所示，redux存在三个重要的概念</p>
<ul>
<li>action</li>
<li>reducer</li>
<li>store</li>
</ul>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p><code>store</code>的英文的意思是有：<code>贮存, 贮备, 储藏, 存放</code>。所以，我们这里的store也是如此，我们可以把吧他比作是一个<strong>仓库</strong>。这个仓库的作用就是把所有的我们需要的数据存在起来。拿react举例（这里假如你已经了解过react了），react中的所有的数据都是存放在这个仓库里面。<code>一个项目只有唯一的一个store。</code></p>
<p>同样是以react为例，那么store里面究竟存放的是什么呢？</p>
<p>我们知道，在react中，我们控制一个组件是通过这个组件内部的<code>state</code>状态来实现的，如果我们需要修改一个组件的状态，那么我们就需要通过react的<code>setState</code>方法来实现，修改组件的状态。那么在redux的store中，这个仓库中存在的就是整个项目的state。当然，这里的整个项目的state可以是一个，也可以是无数个（即每一个组件单独的状态），仓库中的数据取决于你的项目。</p>
<h2 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h2><p>reducer的英文的意思是：减速器，减压器，还原剂的意思。那么在这里，他表示的是什么呢？其实这里我们也可以把它看做是<code>还原(剂)</code>的意思。即：还原。</p>
<p>那么他是还原的是什么呢？在react里面，还原的就是state。</p>
<p>在redux里面，reducer其实就是一个函数，一个纯函数（给定一个输入，必有有且只有一个唯一的输出）拿函数来，输入就是函数的参数，输出就是函数的返回值。</p>
<p>在redux里面，每一个reducer的输入都有：状态参数（action）以及目前的state。返回值是一个新的state状态值。这就把react中的state单独剥离出来了。</p>
<p>上面说到的<strong>store</strong>，里面就同时也存放了这些reducer。</p>
<p>那么store是怎么来的呢。我们使用redux提供的createStore方法来创建store。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">let store = crateStore(<span class="name">reducers</span>)</span><br></pre></td></tr></table></figure>
<p>所有的reducer我们都需要绑定在一起，使用redux提供的<code>combineReducers</code>把每一个reducer合并成一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> reducders = combineReducers(&#123;</span><br><span class="line">  reducer1,</span><br><span class="line">  reducer2,</span><br><span class="line">  ......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>action的意思是：动作，操作。这里也是一样，就是一个动作。</p>
<p>我们在说reducer的时候提到了action，action非常简单，我们就把他理解为一个信号表示。为了让程序读懂我们究竟是需要做什么样的动作，我们需要给action提供一个属性，表示他是整个项目中为一个那一个。这个属性就是：<code>type</code>。我们还可能给这个action添加一个其他的属性，那么这个action就成了一个对象了。比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">type</span>: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  text: <span class="string">'添加一个新的todo代办项'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样写的话用起来可能会很麻烦，而且text属性无法进行扩展，所以，在使用action的时候，我们通常还是把它写成一个函数。即：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 使用ES6的写法</span><br><span class="line"><span class="keyword">const</span> addTodo = <span class="function"><span class="params">text</span> =&gt;</span> &#123;<span class="keyword">type</span>: <span class="string">'ADD_TODO'</span>, text&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个action。</p>
<h2 id="简单的梳理"><a href="#简单的梳理" class="headerlink" title="简单的梳理"></a>简单的梳理</h2><p>我们用这样一个例子来简单的梳理一下原理。</p>
<blockquote>
<p>在一个图书馆里面，有许多的书，他们有的被借阅了，有的仍然在书架上面放着，这些书的状态都在图书馆的电子屏幕上面显示着。这里的图书的是否被借阅的状态我们可以看做是一个state。有三个人甲，乙，丙，甲需要去借书A，借完书以后我们需要让乙和丙都知道图书被借阅了。电子屏幕上面的图上A的状态就会发生变化，即state的值发生了变化。这时候甲乙丙三个人都知道了图书A的状态了。这里的甲乙丙三个人可以看做是react中的组件。</p>
</blockquote>
<p>但是上面的存在一个问题，甲去借书，不可能借完书就走了，或者直接就去拿书了。这时候我们需要有一个管理者，即reducer。他来判断甲是否可以借书，即他来控制图书A的状态而不是甲乙丙（组件）控制图书A的状态。</p>
<p>其次就是甲怎么让管理者知道我要借的书是A而不是其他的呢？这时候就需要一个为一个标识（action）。{type: ‘A’, name: ‘图书A’}。怎么让管理员知道呢？redux提供了<code>createStore</code>方法，这个方法返回了一个方法<code>dispatch</code>，分发的意思。接收一个action，即<code>store.dispatch(action)</code>，执行之后，管理员修改了图书A的状态。</p>
<p>最后，乙和丙怎么知道图书A的状态发生了变化呢？同样，edux提供了<code>createStore</code>方法，这个方法返回了一个方法<code>subscribe</code>，订阅的意思。乙和丙需要订阅图书A的信息才可以接收到图书A的状态变化，即<code>store.subscribe(reducer)</code>。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react-native修改APP的名字与图标</title>
    <url>/%E6%8A%80%E6%9C%AF/react-native%E4%BF%AE%E6%94%B9APP%E7%9A%84%E5%90%8D%E5%AD%97%E4%B8%8E%E5%9B%BE%E6%A0%87.html</url>
    <content><![CDATA[<h1 id="修改APP名称-Android"><a href="#修改APP名称-Android" class="headerlink" title="修改APP名称-Android"></a>修改APP名称-Android</h1><p>1、找到读取app_name的地方</p>
<p>进入：android/app/src/main/AndroidManifest.xml, </p>
<p>找到 android:label=”@string/app_name”。这个对应的就是APP的名称。</p>
<p>@string类似于定义好的变量，直接调取即可。</p>
<p>2、进入：android/app/src/main/res/valuse/strings.xml目录下，修改即可<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"app_name"</span>&gt;</span>你的APP名称<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="修改APP图标-Android"><a href="#修改APP图标-Android" class="headerlink" title="修改APP图标-Android"></a>修改APP图标-Android</h1><p>1、找到读取APP图标的地方</p>
<p>进入目录：：android/app/src/main/AndroidManifest.xml</p>
<p>找到： android:icon=”@mipmap/ic_launcher” </p>
<p>这里的ic_launcher就是我的图标。这里也是从其他地方引用的，因此需要在被引用的地方修改。</p>
<p>2、修改图标<br>进入目录：android/app/src/main/res/mipmap–xxx, </p>
<p>（PS：这里需要注意，可能是mipmap,也可能是drawable）,我这里是mipmap。这里只需要保持一致即可。</p>
<p>如果是：是mipmap，则android:icon=”@mipmap/ic_launcher”<br>如果是：是drawable，则android:icon=”@drawable/ic_launcher”。</p>
<p>这里面的图标大小都不一样，但是名字是一样的。图标分为<br><code>48x48</code>,<code>72x72</code>,<code>96x96</code>,<code>144x144</code>.适配安卓不同机型</p>
<h1 id="修改App的名字与图标-IOS"><a href="#修改App的名字与图标-IOS" class="headerlink" title="修改App的名字与图标-IOS"></a>修改App的名字与图标-IOS</h1><p>IOS的修改与配置到需要使用到XCode，当然也可以不用。不过既然都涉及到了IOS，那么你因该会有XCode吧。<br><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20181229141008.png" alt="IOS修改APP名字"></p>
<p><img src="https://raw.githubusercontent.com/tal007/PicGo/master/20181229141138.png" alt="IOS修改APP图标"><br>点击图上面的右边的箭头进入修改。</p>
<p>或者是在<code>~.../项目名字/ios/项目名字/Images.xcassets</code>文件目录下添加。如果是需要添加IOS APP启动图，也是需要放在这里面，IOS可以使用一款名为<a href="https://www.jianshu.com/p/2a108f16c4fe" target="_blank" rel="noopener">App Icon Gear</a>的软件生成。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript正则表达式</title>
    <url>/%E6%8A%80%E6%9C%AF/javascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content><![CDATA[<p>正则表达式一直是一个令人头疼但却又是十分重要的一个东西。熟练的使用正则表达式可以让你的工作事半功倍。接下来，一起来看看正则表达式是什么吧！</p>
<h2 id="正则表达式概念"><a href="#正则表达式概念" class="headerlink" title="正则表达式概念"></a>正则表达式概念</h2><p><strong>正则表达式，又称规则表达式。</strong>（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。</p>
<h2 id="正则表达式的基本语法"><a href="#正则表达式的基本语法" class="headerlink" title="正则表达式的基本语法"></a>正则表达式的基本语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/ pattern /</span> flags;</span><br></pre></td></tr></table></figure>
<p>就像上面的，正则表达式是由两个<code>/</code>符号包裹起来的，两个<code>/</code>里面的（上面的pattern）就是需要的任何简单或者是复杂的正则表达式。而在第二个<code>/</code>后面是一个或者是多个标志（flags），用来标明正则表达式的行为。<br><strong>flags</strong>有以下五种行为：</p>
<ul>
<li>g：表示全局（global）模式，即在匹配到第一个后继续匹配</li>
<li>i：忽略（ignore）大小写</li>
<li>m：便是多行（multiline）模式，即到达一行时继续查找下一行</li>
<li>y：(ES6新增的粘连修饰符)</li>
<li><p>u：(ES6新增)</p>
<h2 id="正则的规则分类"><a href="#正则的规则分类" class="headerlink" title="正则的规则分类"></a>正则的规则分类</h2><p>下面根据<a href="https://www.debuggex.com/cheatsheet/regex/javascript" title="JavaScript正则表达式的速查表" target="_blank" rel="noopener">JavaScript正则表达式的速查表</a>中的分类来对每一下进行一个说明。</p>
<h4 id="正则表达式基础"><a href="#正则表达式基础" class="headerlink" title="正则表达式基础"></a>正则表达式基础</h4><p>基础里面呢主要有<code>6</code>需要记忆的东西，分别是：</p>
</li>
<li><p><code>.</code>：匹配除了换行以外其他所有字符</p>
</li>
<li><code>a</code>：匹配字符<code>a</code>，衍生为匹配单个字母</li>
<li><code>ab</code>：匹配字符串<code>ab</code>，衍生为匹配字符串</li>
<li><code>a|b</code>：匹配<code>a或者b</code>，就是或者的意思</li>
<li><code>a*</code>：匹配0次或者是多次<code>a</code></li>
<li><code>\</code>：转义符号，转义一个特殊的字符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `.`的使用</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/./g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (7) ["a", "b", "c", "d", "e", "f", "g"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `a`的使用</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/A/gi</span>; <span class="comment">// 全局匹配。忽略大小写</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (7) ["a"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `ab`的使用</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/AbCdef/gi</span>; <span class="comment">// 全局匹配。忽略大小写</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (7) ["abcdef"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `a|b`的使用 一</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a|b|c|d/</span>; <span class="comment">// 非全局匹配。</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["a", index: 0, input: "abcdefg"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `a|b`的使用 二</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a|b|c|d/g</span>; <span class="comment">// 全局匹配。</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (4) ["a", "b", "c", "d"]。使用全局匹配。会在匹配对后继续匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `a*`的使用</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a*/</span>; </span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcdcba"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["a", index: 0, input: "abcdcba"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `a*`的使用</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a*/g</span>; <span class="comment">// 全局匹配。</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcdcba"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (8) ["a", "", "", "", "", "", "a", ""]。使用全局匹配会把之后没有匹配到的转化为空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `\`的使用  回到第一个 . 的使用那里。如果我把 . 前面加一个 \ 符号，那么这个点就是一个普通的点了</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\./g</span>; <span class="comment">// 全局匹配。</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>JavaScript中需要使用 <code>\</code> 的特殊符号有：<code>(</code>   <code>)</code>   <code>[</code>   <code>]</code>   <code>{</code>   <code>}</code>   <code>.</code>   <code>|</code>   <code>+</code>  <code>*</code>  <code>?</code>   <code>\</code>  <code>^</code>   <code>$</code>     以及 <code>空白</code> 。</p>
<h4 id="正则表达式字符类"><a href="#正则表达式字符类" class="headerlink" title="正则表达式字符类"></a>正则表达式字符类</h4><ul>
<li><code>[ab-d]</code>：a，b，c，d四个字符中的一个，衍生为使用<code>[]</code>，那就是匹配其中的一个</li>
<li><code>[^ab-d]</code>：除了a，b，c，d四个字符其他的任意字符，衍生为使用<code>[^]</code>可以排除[]里面的东西</li>
<li><code>[\b]</code>：退格字符，了解</li>
<li><code>\d</code>：一个0-9的数字</li>
<li><code>\D</code>：一个非数字</li>
<li><code>\s</code>：一个空白字符</li>
<li><code>\S</code>：一个非空白字符</li>
<li><code>\w</code>：匹配一个字母，数字或者是下划线</li>
<li><code>\W</code>：匹配一个除字母,数字,下划线之外的任意字符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `[a-z]`的使用</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]/g</span>; <span class="comment">// 全局匹配。匹配 a-z 的任意一个，因为是全局匹配。所以会一直找。但是不会有 1234</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (4) ["a", "b", "c", "d"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `[a-z]`的使用</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[^a-z]/g</span>; <span class="comment">// 全局匹配。匹配 除了 a-z 的任意一个。所以是 1 2 3 4。因为是全局匹配。所以会一直找</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (4) ["1", "2", "3", "4"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `[\b]`的使用</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[\b]/g</span>; <span class="comment">// 全局匹配。匹配 \b，当然也可以匹配其他的特殊转义字符，见 正则表达式特殊字符</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd\b1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (4) ["1", "2", "3", "4"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `\d`,`\D`,`\s`,`\S`,`\w`,`\W`的使用</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\D\d/g</span>; <span class="comment">// 全局匹配。匹配一个非数字与一个数字。两者紧靠在一起  注意顺序</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["d1"]</span></span><br><span class="line"><span class="comment">// 如果是下面的一个，则匹配 null</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\D\d/g</span>; <span class="comment">// 全局匹配。匹配一个数字与一个非数字。两者紧靠在一起  注意顺序</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 匹配一个</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\D\s\w\d/g</span>; <span class="comment">// 全局匹配。注意顺序  注意大小写</span></span><br><span class="line"><span class="keyword">var</span> text1 = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> text2 = <span class="string">"abcd _1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res1 = text1.match(reg);</span><br><span class="line"><span class="keyword">var</span> res2 = text2.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// ["d _1"]</span></span><br></pre></td></tr></table></figure>
<h4 id="正则表达式量词"><a href="#正则表达式量词" class="headerlink" title="正则表达式量词"></a>正则表达式量词</h4><ul>
<li><code>*</code>：匹配<code>0次</code>或者<code>多次</code>。等价于<code>{0,}</code></li>
<li><code>+</code>：匹配<code>一次</code>或者<code>多次</code>。等价于<code>{1,}</code></li>
<li><code>?</code>：匹配<code>0次</code>或者<code>一次</code>。等价于<code>{0,1}</code></li>
<li><code>{2}</code>：只匹配<code>2</code>次</li>
<li><code>{2, 5}</code>：匹配<code>2-5</code>次</li>
<li><code>{2,}</code>：匹配<code>2次</code>或者<code>多次</code></li>
</ul>
<p>这里涉及到一个<code>贪婪匹配</code>与<code>非贪婪匹配</code>。<br><code>贪婪匹配</code>指的是使用以上量词的时候会按照最大次数进行匹配。<br><code>非贪婪匹配</code>则是按最小次数进行匹配。</p>
<p>使用非贪婪匹配只需在两次后面加上一个<code>?</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `*`的使用</span></span><br><span class="line"><span class="comment">// 非全局匹配。</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]*/</span>; <span class="comment">// 匹配 a-z 的0个或者多个</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["abcd", index: 0, input: "abcd1234"]</span></span><br><span class="line"><span class="comment">// 全局匹配。</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]*/g</span>; <span class="comment">// 匹配 a-z 的0个或者多个</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (6) ["abcd", "", "", "", "", ""]。当匹配为 0 个的时候，会变成空字符串。对比 + 号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `+`的使用</span></span><br><span class="line"><span class="comment">// 非全局匹配。</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]+/</span>; <span class="comment">// 匹配 a-z 的0个或者多个</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["abcd", index: 0, input: "abcd1234"]</span></span><br><span class="line"><span class="comment">// 全局匹配。</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]+/g</span>; <span class="comment">// 匹配 a-z 的0个或者多</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["abcd"]。因为至少匹配一个，所以不会有空字符串。对比 * 号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `?`的使用</span></span><br><span class="line"><span class="comment">// 非全局匹配。</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]?/</span>; <span class="comment">// 匹配 a-z 的0个或者一个</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["a", index: 0, input: "abcd1234"]。匹配到一个就停下来</span></span><br><span class="line"><span class="comment">// 全局匹配。</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]?/g</span>; <span class="comment">// 匹配 a-z 的0个或者一个</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["a", "b", "c", "d", "", "", "", "", ""]。abcd匹配到了。1234则是空字符串。</span></span><br></pre></td></tr></table></figure>
<p>以上说的都属于<code>贪婪匹配</code>。都是按最多个匹配的。如果是<code>非贪婪匹配</code>。则是按照最少的次数匹配。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `*`的使用</span></span><br><span class="line"><span class="comment">// 非全局匹配。贪婪匹配</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]*/</span>; <span class="comment">// 匹配 a-z 的0个或者多个</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["abcd", index: 0, input: "abcd1234"]</span></span><br><span class="line"><span class="comment">// 全局匹配。贪婪匹配</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]*/g</span>; <span class="comment">// 匹配 a-z 的0个或者多个</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (6) ["abcd", "", "", "", "", ""]。当匹配为 0 个的时候，会变成空字符串。对比 + 号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非全局匹配。非贪婪匹配</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]*?/</span>; <span class="comment">// 匹配 a-z 的0个或者多个</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["", index: 0, input: "abcd1234"]</span></span><br><span class="line"><span class="comment">// 全局匹配。非贪婪匹配</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]*?/g</span>; <span class="comment">// 匹配 a-z 的0个或者多个</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (9) ["", "", "", "", "", "", "", "", ""]</span></span><br></pre></td></tr></table></figure>
<p>以上就是<code>贪婪匹配</code>与<code>非贪婪匹配</code>的区别。不过不管是如何。在匹配是<code>0</code>次的时候。空字符串的<code>个数</code>总是匹配不成功部分的字符串的<code>长度+1</code></p>
<h4 id="正则表达式捕获组与非捕获组"><a href="#正则表达式捕获组与非捕获组" class="headerlink" title="正则表达式捕获组与非捕获组"></a>正则表达式捕获组与非捕获组</h4><ul>
<li><code>(...)</code>：捕获组</li>
<li><code>(?...)</code>：非捕获组</li>
<li><code>\Y</code>：匹配第Y个被捕获的组（也称<code>反向引用</code>）。其中<code>Y</code>是一个数字，这个数组取值范围是<code>*</code>，即<code>{0,}</code>。但是建议<code>反向引用</code>不要索引大于9的捕获性分组。<h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/ab(cd(1234))/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (3) ["abcd1234", "cd1234", "1234", index: 0, input: "abcd1234"]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>分析：</p>
<ol>
<li>捕获组就是在匹配 <code>()</code>外面的字符之后在匹配 <code>()</code> 里面的。结果中的 “abcd1234”</li>
<li>捕获组里面还有捕获组会先忽略里面的捕获组匹配在一次匹配里面的捕获组。结果中的<code>&quot;cd1234&quot;</code>与<code>&quot;1234&quot;</code></li>
</ol>
<h5 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/ab(?:cd(1234))/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (3) ["abcd1234", "1234", index: 0, input: "abcd1234"]</span></span><br></pre></td></tr></table></figure>
<p>分析：非捕获组就是不捕获，就行上面的结果中没有了<code>&quot;cd1234&quot;</code></p>
<p><strong>那么捕获与非捕获有什么区别呢？</strong> 记得看宠物小精灵的时候小智看见新的小精灵扔球抓小精灵的时候就属于一个捕获，如果看见不扔球那就是不捕获。那捕获和不捕获有什么区别呢？就行抓小精灵一样，抓住了之后就可以用了嘛！所以被捕获的东西之后是可以使用的。<strong>那么怎么使用呢？</strong> 问得好。这时候就需要使用到<code>\Y</code> 了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/(a)/</span>;</span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/(a)\1/</span>; <span class="comment">// 相当于是 /(a)a/</span></span><br><span class="line"><span class="keyword">var</span> text1 = <span class="string">"aabb1234"</span>;</span><br><span class="line"><span class="keyword">var</span> text2 = <span class="string">"aabb1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res1 = text1.match(reg1);</span><br><span class="line"><span class="keyword">var</span> res2 = text2.match(reg2);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// ["a", "a", index: 0, input: "aabb1234"]</span></span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// ["aa", "a", index: 0, input: "aabb1234"]</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>reg1</code> 与 <code>reg2</code> 仅仅有一点不同。但是匹配后的东西是不同的。简单地说，就是，使用 <code>\Y</code> 后会赋值第Y个捕获的组。以下代码说明通过<code>$Y</code>来接收相应的捕获组。不能从0开始</p>
<h5 id="Y"><a href="#Y" class="headerlink" title="\Y"></a><code>\Y</code></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/ab(cd(1234))/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (3) ["abcd1234", "cd1234", "1234", index: 0, input: "abcd1234"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">0</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">// cd1234</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">// 1234</span></span><br><span class="line"><span class="keyword">var</span> res1 = text.replace(reg,<span class="string">"$1$2"</span>); <span class="comment">// 使用 $1 $2 取出捕获组的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// cd12341234</span></span><br></pre></td></tr></table></figure>
<h4 id="正则表达式断言"><a href="#正则表达式断言" class="headerlink" title="正则表达式断言"></a>正则表达式断言</h4><ul>
<li><code>^</code>：字符串的开始必须是</li>
<li><code>$</code>：字符串的结尾必须是</li>
<li><code>\b</code>：匹配文字（单词）边界</li>
<li><code>\B</code>：非文字（单词）边界</li>
<li><code>(?=...)</code>：积极的前瞻（也叫前瞻或者是顺序肯定环视）</li>
<li><code>(?!...)</code>：消极的前瞻（也加后瞻或者是顺序否定环视）</li>
</ul>
<h5 id="，-的使用"><a href="#，-的使用" class="headerlink" title="^，$的使用"></a><code>^</code>，<code>$</code>的使用</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^b.*\d$/</span>; <span class="comment">// 要求字符 b 开头，中间 * 个任意字符（除换行符），必须以数字结束</span></span><br><span class="line"><span class="keyword">var</span> text1 = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> text2 = <span class="string">"bcd"</span>;</span><br><span class="line"><span class="keyword">var</span> text3 = <span class="string">"bcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res1 = text1.match(reg);</span><br><span class="line"><span class="keyword">var</span> res2 = text2.match(reg);</span><br><span class="line"><span class="keyword">var</span> res3 = text3.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(res3); <span class="comment">// ["bcd1234", index: 0, input: "bcd1234"]</span></span><br></pre></td></tr></table></figure>
<h5 id="b，-B的使用"><a href="#b，-B的使用" class="headerlink" title="\b，\B的使用"></a><code>\b</code>，<code>\B</code>的使用</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\bhi\b/</span>; <span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> text1 = <span class="string">"hi"</span>; </span><br><span class="line"><span class="keyword">var</span> text2 = <span class="string">"him"</span>; </span><br><span class="line"><span class="keyword">var</span> text3 = <span class="string">"history"</span>;</span><br><span class="line"><span class="keyword">var</span> res1 = text1.match(reg);</span><br><span class="line"><span class="keyword">var</span> res2 = text2.match(reg);</span><br><span class="line"><span class="keyword">var</span> res3 = text3.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// ["hi", index: 0, input: "hi"]</span></span><br><span class="line"><span class="built_in">console</span>.log(res2); <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(res3); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h5 id="积极的前瞻-…-积极的前瞻-匹配后面是-…-的位置，不捕获匹配结果"><a href="#积极的前瞻-…-积极的前瞻-匹配后面是-…-的位置，不捕获匹配结果" class="headerlink" title="积极的前瞻 (?=…) 积极的前瞻 匹配后面是 … 的位置，不捕获匹配结果"></a>积极的前瞻 (?=…) 积极的前瞻 匹配后面是 … 的位置，不捕获匹配结果</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abcd(?=1234)/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> text1 = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="keyword">var</span> res1 = text1.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// ["abcd", index: 0, input: "abcd1234"]</span></span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>看上面的例子可以看出积极的前瞻匹配<code>1234</code>前面的<code>abcd</code>，不匹配<code>def</code>前面的<code>abcd</code>；而消极的前瞻恰恰相反，看下面的例子。</p>
<h5 id="消极的前瞻-…-消极的前瞻-匹配后面不是-…-的位置，不捕获匹配结果"><a href="#消极的前瞻-…-消极的前瞻-匹配后面不是-…-的位置，不捕获匹配结果" class="headerlink" title="消极的前瞻 (?!…) 消极的前瞻 匹配后面不是 … 的位置，不捕获匹配结果"></a>消极的前瞻 (?!…) 消极的前瞻 匹配后面不是 … 的位置，不捕获匹配结果</h5><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">reg</span> = /abcd(?!=1234)/;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> text1 = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.<span class="built_in">match</span>(<span class="keyword">reg</span>);</span><br><span class="line"><span class="keyword">var</span> res1 = text1.<span class="built_in">match</span>(<span class="keyword">reg</span>);</span><br><span class="line">console.<span class="built_in">log</span>(res) <span class="comment">// null</span></span><br><span class="line">console.<span class="built_in">log</span>(res1) <span class="comment">// ["abcd", index: 0, input: "abcd1234"]</span></span><br></pre></td></tr></table></figure>
<h4 id="正则表达式特殊字符"><a href="#正则表达式特殊字符" class="headerlink" title="正则表达式特殊字符"></a>正则表达式特殊字符</h4><ul>
<li><code>\n</code>：换行符</li>
<li><code>\r</code>：回车符</li>
<li><code>\t</code>：制表符</li>
<li><code>\0</code>：空字符</li>
<li><code>\YYY</code>：8进制字符</li>
<li><code>\xYY</code>：十六进制字符</li>
<li><code>\uYYYY</code>：十六进制字符</li>
<li><code>\cY</code>：控制符<br>正则的特殊字符在实际中运用的比较少，具体的用法与之前讲到的<code>[\b]</code>类似。上面的两个<code>十六进制字符</code>中，<code>\xYY</code>主要匹配数字字母等。而<code>\uYYYY</code>则是为了匹配汉字以及以下特殊的符号。</li>
</ul>
<h4 id="正则表达式替换"><a href="#正则表达式替换" class="headerlink" title="正则表达式替换"></a>正则表达式替换</h4><p>正则表达式替换主要是替换一些字符。主要以下几个，可是在<code>replace</code>中使用。</p>
<ul>
<li><code>$$</code>：插入<code>$</code></li>
<li><code>$&amp;</code>：插入整个匹配</li>
<li>$`：插入匹配项前面的字符串</li>
<li><code>$&#39;</code>：插入匹配项后面的字符串</li>
<li><code>$Y</code>：插入第Y个捕获的组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/.&#123;2&#125;水(.)/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"君子之交淡如水，小人之交甘若醴"</span>;</span><br><span class="line"><span class="keyword">var</span> res = text.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// (2) ["淡如水，", "，", index: 4, input: "君子之交淡如水，小人之交甘若醴"]</span></span><br></pre></td></tr></table></figure>
<h5 id="：插入"><a href="#：插入" class="headerlink" title="$$：插入$"></a><code>$$</code>：插入<code>$</code></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/.&#123;2&#125;水(.)/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"君子之交淡如水，小人之交甘若醴"</span>;</span><br><span class="line"><span class="keyword">var</span> newStr = text.replace(reg,<span class="string">"$$"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newStr); <span class="comment">// 君子之交$小人之交甘若醴</span></span><br></pre></td></tr></table></figure>
<h5 id="amp-：插入整个匹配"><a href="#amp-：插入整个匹配" class="headerlink" title="$&amp;：插入整个匹配"></a><code>$&amp;</code>：插入整个匹配</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/.&#123;2&#125;水(.)/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"君子之交淡如水，小人之交甘若醴"</span>;</span><br><span class="line"><span class="keyword">var</span> newStr = text.replace(reg,<span class="string">"$&amp;"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newStr); <span class="comment">// 君子之交淡如水，小人之交甘若醴</span></span><br></pre></td></tr></table></figure>
<h5 id="：插入匹配项前面的字符串"><a href="#：插入匹配项前面的字符串" class="headerlink" title="$`：插入匹配项前面的字符串"></a>$`：插入匹配项前面的字符串</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/.&#123;2&#125;水(.)/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"君子之交淡如水，小人之交甘若醴"</span>;</span><br><span class="line"><span class="keyword">var</span> newStr = text.replace(reg,<span class="string">"$`"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newStr); <span class="comment">// 君子之交君子之交小人之交甘若醴</span></span><br></pre></td></tr></table></figure>
<h5 id="39-：插入匹配项后面的字符串"><a href="#39-：插入匹配项后面的字符串" class="headerlink" title="$&#39;：插入匹配项后面的字符串"></a><code>$&#39;</code>：插入匹配项后面的字符串</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/.&#123;2&#125;水(.)/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"君子之交淡如水，小人之交甘若醴"</span>;</span><br><span class="line"><span class="keyword">var</span> newStr = text.replace(reg,<span class="string">"$'"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newStr); <span class="comment">// 君子之交小人之交甘若醴小人之交甘若醴</span></span><br></pre></td></tr></table></figure>
<h5 id="Y：插入第Y个捕获的组"><a href="#Y：插入第Y个捕获的组" class="headerlink" title="$Y：插入第Y个捕获的组"></a><code>$Y</code>：插入第Y个捕获的组</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/.&#123;2&#125;水(.)/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"君子之交淡如水，小人之交甘若醴"</span>;</span><br><span class="line"><span class="keyword">var</span> newStr = text.replace(reg,<span class="string">"$1"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newStr); <span class="comment">// 君子之交，小人之交甘若醴</span></span><br></pre></td></tr></table></figure>
<h2 id="正则表达式实例的方法"><a href="#正则表达式实例的方法" class="headerlink" title="正则表达式实例的方法"></a>正则表达式实例的方法</h2><h4 id="exec-最主要的方法"><a href="#exec-最主要的方法" class="headerlink" title="exec()    最主要的方法"></a>exec()    最主要的方法</h4><p>此方法专门为捕获组设计的。此方法接收一个参数，及需要测试的<code>字符串</code>。返回数组或者是null。但返回的值包含两个额外的属性：<br><code>index</code>：匹配性在字符串中的位置<br><code>input</code>：应用正则的表达式<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/你(我他(与她))/</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"你我他与她"</span>;</span><br><span class="line"><span class="keyword">var</span> res = reg.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">//(3) ["你我他与她", "我他与她", "与她", index: 0, input: "你我他与她"]</span></span><br></pre></td></tr></table></figure></p>
<p><code>[&quot;你我他与她&quot;, &quot;我他与她&quot;, &quot;与她&quot;, index: 0, input: &quot;你我他与她&quot;]</code>的结果。使用<code>res[下标]</code>可以查看具体的匹配下。<code>从第二项开始才是捕获项</code>。使用<code>res.index</code>与<code>res.input</code>查看起始位置与匹配的字符串。</p>
<p>exec()方法始终返回一项，如果设置了全局匹配<code>g</code>，只会从上一次结束的敌法继续查找，而不会返回多项。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"bat, cat, fat"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">var</span> res = reg1.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(res.index);	<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(res[<span class="number">0</span>]);	<span class="comment">// bat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = reg1.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(res.index);	<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(res[<span class="number">0</span>]);	<span class="comment">// bat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/.at/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = reg2.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(res.index);	<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(res[<span class="number">0</span>]);	<span class="comment">// bat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = reg2.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(res.index);	<span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(res[<span class="number">0</span>]);	<span class="comment">// cat</span></span><br></pre></td></tr></table></figure></p>
<h4 id="test-方法"><a href="#test-方法" class="headerlink" title="test()方法"></a>test()方法</h4><p>接收一个字符串作为参数，返回：<br><code>true</code>：匹配<br><code>false</code>：不匹配<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"abcd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/\D/g</span>;</span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/\s/g</span>;</span><br><span class="line"><span class="keyword">var</span> res1 = reg1.test(text);</span><br><span class="line"><span class="built_in">console</span>.log(res1);	<span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> res2 = reg2.test(text);</span><br><span class="line"><span class="built_in">console</span>.log(res2);	<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h2 id="关于使用RegExp构造函数"><a href="#关于使用RegExp构造函数" class="headerlink" title="关于使用RegExp构造函数"></a>关于使用RegExp构造函数</h2><p>语法：<code>var reg = new RegExp(参数1[,参数2])</code>;<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\D"</span>,<span class="string">"gi"</span>);</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"ABd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = reg.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["d", index: 2, input: "ABd1234"]</span></span><br></pre></td></tr></table></figure></p>
<p>看上面的例子。两个参数需要使用<code>字符串</code>。<br>但是，上面的例子有一个问题。没有按照我们所想的出现一个<code>A</code>，而是一个<code>d</code>。同时，我们忽略大小写在看一下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\D"</span>,<span class="string">"g"</span>);</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"ABd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = reg.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
<p>所以，使用构造函数还有一个需要注意的就是<code>所有的元字符都需要双重转义</code>。将上面的代码换为下面的看看<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\D"</span>,<span class="string">"g"</span>);</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"ABd1234"</span>;</span><br><span class="line"><span class="keyword">var</span> res = reg.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ["A", index: 0, input: "ABd1234"]</span></span><br></pre></td></tr></table></figure></p>
<p>注意上面的<code>\\D</code>。这个才表示一个元字符。刚刚的就是一个<code>\</code>一个<code>D</code>。所以。在正则的构造函数中使用<code>元字符</code>需要<code>双重转义</code>。</p>
<h2 id="附上几个常用的正则匹配"><a href="#附上几个常用的正则匹配" class="headerlink" title="附上几个常用的正则匹配"></a>附上几个常用的正则匹配</h2><p>电话号码匹配：<code>/^1[3-8]\d{9}$/</code><br>电子邮件：<code>/[a-zA-z0-9_-]{6,12}@[a-zA-z0-9_-]+\.[a-zA-z0-9]+/</code><br>匹配特定了的邮件：<code>/[a-zA-z0-9_-]{6,12}@(163|qq|gmail)\.com/</code></p>
<p>更多的匹配可查阅：<a href="http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html" target="_blank" rel="noopener">最全的常用正则表达式大全</a></p>
<p>以上就是关于正则的一些使用概念以及使用方法。如果想要熟练的使用正则去匹配或者是修改字符串。还是需要不断的练习才是。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript加载数据简述</title>
    <url>/%E6%8A%80%E6%9C%AF/javascript%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E7%AE%80%E8%BF%B0.html</url>
    <content><![CDATA[<h2 id="加载资源的形式"><a href="#加载资源的形式" class="headerlink" title="加载资源的形式"></a>加载资源的形式</h2><ul>
<li>输入url（或跳转页面）加载html</li>
<li>加载静态资源：图片，js，css，音视频等</li>
</ul>
<h2 id="加载一个资源的过程"><a href="#加载一个资源的过程" class="headerlink" title="加载一个资源的过程"></a>加载一个资源的过程</h2><ul>
<li>浏览器根据DNS服务器得到域名的IP地址</li>
<li>向这个IP的机器发送http请求</li>
<li>服务器收到，处理并返回http请求</li>
<li>浏览器得到返回内容</li>
</ul>
<h2 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a>浏览器渲染页面的过程</h2><ul>
<li>根据HTML结果生成DOM Tree</li>
<li>根据CSS生成CSSOM（CSS Object Model）</li>
<li>将DOM和CSSOM整合形成RenderTree</li>
<li>根据RenderTree开始渲染和展示</li>
<li>遇到<code>&lt;script&gt;</code>标签时，会执行并阻塞渲染<br><a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">渲染页面的过程</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript数组</title>
    <url>/%E6%8A%80%E6%9C%AF/javascript%E6%95%B0%E7%BB%84.html</url>
    <content><![CDATA[<p>数组也是一种数据类型，用于存放数据。在各大语言中都存在数组，但是语法由于大同小异。在JavaScript中数组也是一个非常重要的东西，所以有必要好好的了解一下。</p>
<h1 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h1><p>在JavaScript中数组是一中数据格式，不是一种数据类型。<br>我们可以使用<code>构造函数</code>与<code>字面量</code>两种方式创建一个数组。</p>
<p><code>构造函数：</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p>
<p>我看可以在创建的时候传递参数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (10) [empty × 10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">-10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// Uncaught RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (2) [10, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"10"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ["10"]</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出，参数如果是</p>
<ul>
<li>一个number，数组就是一个长度为number的数组，里面的每一项都为空，不支持负数（取值范围出错）</li>
<li>其他情况，就是数组的每一项，几个参数就是长度为几的数组</li>
</ul>
<p>也可以使用字面量的方式创建一个新数组。<br><code>字面量：</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>,<span class="number">10</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [10, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"10"</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ["10"]</span></span><br></pre></td></tr></table></figure></p>
<p>与使用<code>构造函数</code>不同的是，使用字面量是无法一下创建一个长度为<code>n</code>的数组的，如果是要创建一个长度为10的数组，可以直接修改数组的长度。数组的长度是可读可写的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 0</span></span><br><span class="line">arr.length = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (10) [empty × 10]</span></span><br></pre></td></tr></table></figure></p>
<p>如果修改长度后数组的长度大于原来的长度，那么多出来的这几项为空（empty，一些浏览器显示为undefined）。若果是小于原来数组的长度，那么就是从数组的末尾删除这个差值的项数。</p>
<p>也可以直接使用数组的下标添加或者是修改数组<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"1"</span>;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">"5"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (6) [0, "1", 2, empty × 2, "5"]</span></span><br></pre></td></tr></table></figure></p>
<p>如果数组中原来就存放了这一下那么就是修改，<code>arr[1] = &quot;1&quot;</code>。否则就是添加这一项<code>arr[5] = &quot;5&quot;</code>。中间多出来的显示一个<code>empty</code>。</p>
<h1 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h1><p>数组的方法是非常多的。</p>
<h2 id="添加与删除"><a href="#添加与删除" class="headerlink" title="添加与删除"></a>添加与删除</h2><ul>
<li>push</li>
<li>pop</li>
<li>shift</li>
<li>unshift<h3 id="push与unshift"><a href="#push与unshift" class="headerlink" title="push与unshift"></a>push与unshift</h3><code>push</code>与<code>unshift</code>方法都是添加数组。<code>push</code>是往数组后面添加一项，<code>unshift</code>是往数组前面添加一项。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> res = arr.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (4) [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> res = arr.unshift(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (5) [4, 1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两个方法都接受至少0个参数。<br>两个方法都是<code>返回的新数组的长度</code>。</p>
<h3 id="pop与shift"><a href="#pop与shift" class="headerlink" title="pop与shift"></a>pop与shift</h3><p><code>pop</code>与<code>shift</code>都是删除数组某一项的方法。<code>pop</code>是删除数组的这最后一项，<code>shift</code>是删除数组的第一项。分别与<code>push</code>与<code>unshift</code>方法对应。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> res = arr.pop()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (2) [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> res = arr.shift()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>两个方法都不需要参数<br>两个方法都是<code>返回的删除的这一项</code>。</p>
<h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><ul>
<li>reverse</li>
<li>sort</li>
</ul>
<h3 id="reverse反转数组"><a href="#reverse反转数组" class="headerlink" title="reverse反转数组"></a>reverse反转数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.reverse()) <span class="comment">// (6) [7, 4, 6, 1, 5, 3]</span></span><br></pre></td></tr></table></figure>
<p>很简单，就是把数组倒序了。</p>
<h3 id="sort数组排序"><a href="#sort数组排序" class="headerlink" title="sort数组排序"></a>sort数组排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort()) <span class="comment">// (6) [1, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>
<p>如果只是一位数字没有问题，但是如果是多为数字就有问题。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">22</span>,<span class="number">3</span>,<span class="number">556</span>,<span class="number">1</span>,<span class="number">32</span>,<span class="number">11</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort()) <span class="comment">// (7) [1, 11, 2, 22, 3, 32, 556]</span></span><br></pre></td></tr></table></figure></p>
<p>因为sort()方法会根据测试字符串的结果来改变顺序比较<code>2与11</code>的时候比较的是字符串”2”与”11”。所以出现上面的结果。</p>
<p>sort方法可以接受一个函数作为参数，自己规定排序问题。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">22</span>,<span class="number">3</span>,<span class="number">556</span>,<span class="number">1</span>,<span class="number">32</span>,<span class="number">11</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;)) <span class="comment">// (7) [1, 2, 3, 11, 22, 32, 556]</span></span><br></pre></td></tr></table></figure></p>
<p>参数函数接收两个参数，第一个参数因该位于第二个前面放回负数，位于之后返回正数，否则返回0。</p>
<h2 id="数组拼接concat"><a href="#数组拼接concat" class="headerlink" title="数组拼接concat"></a>数组拼接concat</h2><p>concat 方法及拼接数组。在不改变原数组的情况下把多个数组拼接返回新数组。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.concat([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (2) [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// (4) [1, 2, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="数组切割slice"><a href="#数组切割slice" class="headerlink" title="数组切割slice"></a>数组切割slice</h2><p>slice方法可以把数组切割<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>)) <span class="comment">// (4) [2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">// (4) [2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (5) [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p>
<p>slice接收两个参数，第一个是切割的开始位置。第二个可选，表示切割的结束位置（不包含这个索引对应的值），如果没有第二个参数，表示末尾。</p>
<p>如果slice中存在<code>负数</code>，则是<code>倒数的</code>。如果是slice(-1,3)则相当于是slice(4,3)。那么返回的是一个空数组。</p>
<h2 id="数组的splice方法"><a href="#数组的splice方法" class="headerlink" title="数组的splice方法"></a>数组的splice方法</h2><p>splice是一个非常强大的方法，之前除了排序其他的方法都可以使用splice实现。这个方法自身可以接收<code>&gt;=2</code>个参数。<br><code>两个参数为删除：</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.splice(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure></p>
<p>第一个参数是删除的开始位置，第二个删除的项数。上面的表示第下标为1开始删除两项。<br>返回的是删除的内容。<br><code>三个参数是插入：</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (6) [1, 3, 5, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// (2) []</span></span><br></pre></td></tr></table></figure></p>
<p>第三个及以后参数表示的是需要插入的项。</p>
<p>这样就可以实现替换的效果了。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// (5) [1, 3, 5, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// (2) [2]</span></span><br></pre></td></tr></table></figure></p>
<p>上面表示从第一项开始，删除一项并且替换为后面的东西。</p>
<h2 id="位置判断indexOf与lastIndexOf"><a href="#位置判断indexOf与lastIndexOf" class="headerlink" title="位置判断indexOf与lastIndexOf"></a>位置判断indexOf与lastIndexOf</h2><p>两个方法都是查找，接收一个参数，如果有返回查找的东西在数组中出现的<code>下标（位置）</code>。没有返回<code>-1</code>。<code>indexOf</code>是正向查找，<code>lastIndexOf</code>是反向查找。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">3</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">5</span>)) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">3</span>)) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">5</span>)) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></p>
<h1 id="数组的迭代方法"><a href="#数组的迭代方法" class="headerlink" title="数组的迭代方法"></a>数组的迭代方法</h1><ul>
<li>every</li>
<li>some</li>
<li>filter</li>
<li>forEach</li>
<li>map<br>五个方法都可以接收两个参数。第一个参数是一个函数，第二个是第一个函数中的this的值，即：如果有第二个参数，那么第一个参数中使用了<code>this</code>，这个<code>this</code>就表示第二个参数。</li>
</ul>
<p>第一个参数函数可以接收三个参数：</p>
<ul>
<li>数组每一项的值</li>
<li>这一项在数组中的下标</li>
<li>数组本身</li>
</ul>
<h2 id="every与some"><a href="#every与some" class="headerlink" title="every与some"></a>every与some</h2><p>两个方法是判读数组中每一项满不满足这个条件。<code>every</code>表示每一项都满足返回true，否则返回false。<code>some</code>表示数组中有满足的就返回true，否则false。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> res = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> res = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript-this的指向的问题</title>
    <url>/%E6%8A%80%E6%9C%AF/javascript-this%E7%9A%84%E6%8C%87%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>javasript函数中this的指向一直都是许多编程入门新手的一个问题，老师把这个this的指向弄错误。下面我们可以来看看关于this指向的几种情况。</p>
<p>不过在讲之前，请各位始终记住一句话：<br><span style="color: red;font-weight: 900;font-size: 30px;">JavaScript中的this一直指向触发这个事件（函数）的这个Objoct（对象）。</span></p>
<h4 id="第一种：函数直接添加在行内"><a href="#第一种：函数直接添加在行内" class="headerlink" title="第一种：函数直接添加在行内"></a>第一种：函数直接添加在行内</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert(this.innerHTML);"</span>&gt;</span>this就是指向这个div盒子<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击看看：</p>
<button onclick="alert(this.innerHTML);">this就是指向这个div盒子</button><br>此时的这个<code>alert(this.innerHTML)；</code>事件是直接写在<code>button</code>这个元素行内的。是这个<code>button</code>元素触发的这个事件。<br><br>#### 第二种：通过<span style="color: red;">对象.事件名</span>来实现<br>这是html代码<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span>通过js事件的点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br>下面是js代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box"</span>).onclcik = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.innerHTML);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><button id="box">通过js事件的点击事件</button>

<script type="text/javascript">
document.getElementById("box").onclick = function(){
    alert(this.innerHTML);
}
</script>

<p><strong>以上的两种方式都很好理解，也不做过多的说明。</strong></p>
<h4 id="第三种：函数的调用的形式"><a href="#第三种：函数的调用的形式" class="headerlink" title="第三种：函数的调用的形式"></a>第三种：函数的调用的形式</h4><p>这种方式也是存在许多的变种，先来看看上面例子的一个变种。<br>这是html代码<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"box1"</span>&gt;</span>通过js事件的点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>下面是js代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>).onclick = a;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一种形式的事件与上面的其实是一样的，不过是单独定义了一个函数，然后点击调用这个函数。</p>
<p>在看看下面的例子<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"box1"</span>&gt;</span>通过js事件的点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>下面是js代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box1"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	a();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时的这个与上面的有很相似，不同的就是此时的这个<code>a</code>函数是在一个事件函数里面执行的。此时的逻辑是：我点击这个ID为box1的button,让后触发事件后面的函数<code>function(){a();}</code>。此时呢里面的a函数其实还没有执行。到这个函数执行的时候，执行到里面的函数了，a函数自己调用执行（函数加括号执行），那么问题来了，是谁调用的这个a函数呢？答案是：<code>window</code>。因为不存在上面说的两种以及Object.函数的形式。这个就有点像是定义了一个函数自执行。</p>
<p>像这样<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此时的这个 t 函数是由谁调用的呢（也就是鼠标哪一个对象让他执行的？）</span></span><br><span class="line"><span class="comment"> * 答案是的 null</span></span><br><span class="line"><span class="comment"> * 而在 js 中，如果 this 的指向是null会自动转换为 window</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">t();</span><br></pre></td></tr></table></figure></p>
<p>或者是这样：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">t2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	t2()</span><br><span class="line">&#125;</span><br><span class="line">t();</span><br></pre></td></tr></table></figure></p>
<p>OK！接下来看看这个：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intro</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'名字是'</span>+ <span class="keyword">this</span>.name,<span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = &#123;<span class="attr">name</span>: <span class="string">"狗"</span>&#125;;</span><br><span class="line">dog.intro = intro;</span><br><span class="line">dog.intro(); <span class="comment">// 狗</span></span><br></pre></td></tr></table></figure></p>
<p>分析一下：此时先定义了一个名字是<code>intro</code>的一个函数，在定义一个<code>dog</code>对象并赋值<code>name=狗</code>。下面的代码就是在<code>dog</code>这个对象上添加一个<code>intro</code>对象，赋值为一开始定义的那个函数<code>intro</code>。此时的这个<code>dog</code>对象就多了一个属性<code>intro</code>，值是函数。接着在调用这个<code>dog.intro();</code>。那么是谁调用的呢？很明显是这个<code>dog</code>对象调用的这个函数。所以此时的这个<code>this</code>就是指向<code>dog</code>对象。那<code>this.name</code>就是<code>狗</code>了。</p>
<p>OK！再来：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intro</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'名字是'</span>+ <span class="keyword">this</span>.name,<span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = &#123;<span class="attr">name</span>: <span class="string">"狗"</span>&#125;;</span><br><span class="line">dog.intro = intro;</span><br><span class="line">dog.intro(); <span class="comment">// 狗</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = &#123;<span class="attr">name</span>:<span class="string">"猫"</span>&#125;;</span><br><span class="line">cat.intro = dog.intro;</span><br><span class="line">cat.intro(); <span class="comment">// 猫</span></span><br></pre></td></tr></table></figure></p>
<p>现在多了一个<code>cat</code>,看这句<code>cat.intro = dog.intro;</code>。这个是把<code>dog</code>下面的<code>intro</code>方法赋值给了<code>cat</code>下面新建的一个<code>intro</code>方法。此时涉及到一个内存的问题。<span style="color: red;">js中的对象，函数等都是存放在内存中，给其他对象赋值为这个函数的时候就是让这个对象的这个属性指向内存中的这个函数</span>，所以，不管上面的是怎样赋值，<code>cat</code>与<code>dog</code>的<code>intro</code>的值是指向同一个函数的。不同的是调用他们的对象不同，导致<code>this</code>不同，所以最后的<code>this.name</code>的值不同。</p>
<p>再来看看这个呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intro</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'名字是'</span>+ <span class="keyword">this</span>.name,<span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = &#123;<span class="attr">name</span>: <span class="string">"狗"</span>&#125;;</span><br><span class="line">dog.intro = intro;</span><br><span class="line">dog.intro(); <span class="comment">// 狗</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = &#123;<span class="attr">name</span>:<span class="string">"猫"</span>&#125;;</span><br><span class="line">cat.intro = dog.intro;</span><br><span class="line">cat.intro(); <span class="comment">// 猫</span></span><br><span class="line"></span><br><span class="line">(cat.intro = dog.intro)(); <span class="comment">// 空 this 指向window```javascript</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intro</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'名字是'</span>+ <span class="keyword">this</span>.name,<span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = &#123;<span class="attr">name</span>: <span class="string">"狗"</span>&#125;;</span><br><span class="line">dog.intro = intro;</span><br><span class="line">dog.intro(); <span class="comment">// 狗</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = &#123;<span class="attr">name</span>:<span class="string">"猫"</span>&#125;;</span><br><span class="line">cat.intro = dog.intro;</span><br><span class="line">cat.intro(); <span class="comment">// 猫</span></span><br><span class="line"></span><br><span class="line">(cat.intro = dog.intro)(); <span class="comment">// 空 this 指向window</span></span><br></pre></td></tr></table></figure>
<p>此时的在上面的就是多了一句<code>(cat.intro = dog.intro)();</code>。那为什么就指向window了呢？<br>上面的这个例子，涉及到的是关于计算机里面的计算，cat.intro = dog.intro 这是一个赋值运算，而赋值运算的结果是 = 右侧的值，此时这个值并不属于任何一个对象，而这个值是一个空，也可以说是一个 null ，所以此是为 null 转为指向 window。可以这么做一个比喻：</p>
<blockquote>
<p>一天张三去面馆吃面，给老板说：“老板，一碗牛肉面”，做好面后，此时的这碗牛肉面这个<code>值</code>就有了。相当于上面的<code>intro</code>函数，此时呢他并不属于张三。当老板把这碗面端到张三面前，这是才属于张三。OK。李四也去吃面，进入面馆，看见张三的面。对老板说：“老板，来一碗和他一样的面”。此时老板需要计算，这碗面是什么面？相当于上面的<code>cat.intro = dog.intro</code>计算。老板计算后才知道这碗面是牛肉面。此时让一个<code>值</code>加括号执行，那肯定就不行了。此时的这碗面并不属于李四。赋值的结果是是什么呢？当老板把这碗面端到李四面前，这是才属于李四。这就是结果。</p>
</blockquote>
<p>需要注意的点就是<code>cat.intro = dog.intro</code>只是一个赋值过程，值是<code>=</code>右边的东西。执行<code>cat.intro = dog.intro</code>会导致一个结果就是<code>cat</code>下面多了一个<code>intro</code>属性并且有值。</p>
<p>基本普通的函数中的this存在的问题就是这么多，其他的也就是上面的一些变种。</p>
<p>不过，可以发现，因为this指向window的存在，会导致污染全局，所以多数时候使用构造函数<code>new</code>的方式更可取，这样this才不会指向全局避免污染全局。</p>
<p>上面说了这么多。其实也就是最开始说的那句：<br><span style="color: red;font-weight: 900;font-size: 30px;">JavaScript中的this一直指向触发这个事件（函数）的这个Objoct（对象）。</span></p>
<h2 id="更新于2019年09月11日"><a href="#更新于2019年09月11日" class="headerlink" title="更新于2019年09月11日"></a>更新于2019年09月11日</h2><p>针对于ES6中的箭头函数目前用的非常多。使用箭头函数与普通函数相比，箭头函数有以下几点差异：</p>
<ol>
<li>箭头函数中的this是在定义的时候所在的作用域的this而不再是函数执行时候确定</li>
<li>不可以使用arguments对象，该对象的在函数体内不存在。如果要使用，可以使用rest参数代替</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数</li>
<li>不可以使用new命令，因为（1）：没有自己的this，无法使用call，apply。（2）：没有prototype属性，而new命令在执行时需要将构造函数的prototype赋值给新的对象的proto</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript绑定事件的三种方式</title>
    <url>/%E6%8A%80%E6%9C%AF/JavaScript%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<ul>
<li>使用内联</li>
<li>使用<code>.onclick</code>的方式</li>
<li>使用事件监听<code>addEventListener</code>的方式</li>
</ul>
<h2 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h2><p>形式：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span> <span class="attr">onclick</span>=<span class="string">"alert(1);"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这种方式就是在一个元素上面直接绑定了一个点击<code>onclick</code>事件，此事件为<a href="https://baike.baidu.com/item/DOM/50288?fr=aladdin" target="_blank" rel="noopener">DOM 0级标准</a>。同时，这个事件的优先级是最高的。</p>
<h2 id="使用对象-事件的形式"><a href="#使用对象-事件的形式" class="headerlink" title="使用对象.事件的形式"></a>使用对象.事件的形式</h2><p>形式<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsBytagname(<span class="string">"input"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">	bt.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="undefined">		alert(2)</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用这种形式也是可以给一个DOM元素添加上一个事件。这个也是<a href="https://baike.baidu.com/item/DOM/50288?fr=aladdin" target="_blank" rel="noopener">DOM 0级标准</a>。</p>
<h3 id="以上的弊端"><a href="#以上的弊端" class="headerlink" title="以上的弊端"></a>以上的弊端</h3><p>以上两种方式都是存在一个弊端的，就是一个元素只能添加一个事件。第一种就不用说了，写在行内就一个属性。至于第二种，有的网友可能会说我可以再写一个，比如：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsBytagname(<span class="string">"input"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">	bt.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="undefined">		alert(2)</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined">	</span></span><br><span class="line"><span class="actionscript">	bt.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="undefined">		alert(3)</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>写是可以这么写。那么我们先来看一看这个写法的意思，这种写法的本质就是在一个对象上添加一个属性，就上面的例子，就是在<code>bt</code>这个对象上添加一个<code>onclick</code>属性。那么，如果在之后的代码中也存在<code>bt.onclcik</code>，只会吧前面的给覆盖了。所以这样的写法也只能添加一个事件。</p>
<p>那么，问题来了。我要给一个元素（DOM对象）添加两个甚至是多个事件，使用什么呢？此时，就需要使用<code>addEventListener</code>的方式来添加事件。</p>
<h2 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h2><p>形式：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsBytagname(<span class="string">"input"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">	bt.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="undefined">		alert(1)</span></span><br><span class="line"><span class="undefined">	&#125;)</span></span><br><span class="line"><span class="actionscript">	bt.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="undefined">		alert(2)</span></span><br><span class="line"><span class="undefined">	&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的方式就可以给一个DOM对象绑定一个或者是多个事件。<strong>强烈推荐使用这一种绑定事件的方式</strong>。<br>使用<code>addEventListener</code>的方式还可以拥有第三个参数。<br>以下是<a href="https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-overview" target="_blank" rel="noopener">W3C官网</a>的一个话</p>
<p><img src="http://upload-images.jianshu.io/upload_images/8678448-dfae5dc09dab625a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>三个参数：</p>
<ol>
<li>事件类型，<strong>不需要</strong>添加上<code>on</code></li>
<li>事件函数</li>
<li>是否捕获（布尔值），默认是<code>false</code>，即不捕获，那就是冒泡。</li>
</ol>
<p>那么捕获和冒泡又是什么呢？<br>下面来看一张图：<br>这是三个盒子，相互嵌套的关系<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">	a</span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line">		b</span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"c"</span>&gt;</span>c<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>那么捕获是什么意思呢？<br><img src="http://upload-images.jianshu.io/upload_images/8678448-80d89541972f04aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>弓箭射过来，没穿过一个盒子，就捕获一次，这个过程就是捕获过程。<br>而下面的就是冒泡<br><img src="http://upload-images.jianshu.io/upload_images/8678448-f189afb259e6a23f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>捕获和冒泡会影响到事件的执行顺序<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">"c"</span>);</span><br><span class="line"><span class="comment">// 捕获</span></span><br><span class="line">a.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-a"</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">b.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-b"</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">c.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-c"</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡</span></span><br><span class="line">a.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-a"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">b.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-b"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">c.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-c"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码的执行顺序为：b-a,b-b,b-c,m-c,m-b,m-a。先执行的捕获在是冒泡。<code>得出：同时存在捕获与冒泡时，捕获的优先级是高于冒泡的</code></p>
<p>下面，我们变一下代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">"c"</span>);</span><br><span class="line"><span class="comment">// 捕获</span></span><br><span class="line">a.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-a"</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">b.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-b"</span>)</span><br><span class="line">&#125;) <span class="comment">// 此处不在添加捕获事件，那么就是绑定一个默认的事件</span></span><br><span class="line">c.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-c"</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡</span></span><br><span class="line">a.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-a"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">b.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-b"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">c.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-c"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p>
<p>此时的执行顺序为：b-a,b-c,m-c,b-b,m-b,m-a</p>
<p>再来：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">"c"</span>);</span><br><span class="line"><span class="comment">// 捕获</span></span><br><span class="line">a.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-a"</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-b"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>) <span class="comment">// 把b的冒泡放在这里来了</span></span><br><span class="line">b.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-b"</span>)</span><br><span class="line">&#125;) <span class="comment">// 此处不在添加捕获事件，那么就是绑定一个默认的事件。即冒泡</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-c"</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡</span></span><br><span class="line">a.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-a"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">c.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-c"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p>
<p>此时的执行顺序为：b-a,b-c,m-c,m-b,b-b,m-a<br><code>得出，没有捕获的时候谁在前面先执行谁</code></p>
<p>OK。事件绑定就此结束。下面说说取消事件绑定吧。如果要取消一个使用<code>addEventListener</code>绑定的事件函数，使用<code>removeEventListener</code>可以移除事件。<br><img src="http://upload-images.jianshu.io/upload_images/8678448-df6be084b3f3ed6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>与添加事件一致。不过如果使用这个，最好把这个函数给单离拿出来。</p>
<h2 id="停止传播"><a href="#停止传播" class="headerlink" title="停止传播"></a>停止传播</h2><p>使用<code>stopPropagation</code>可以阻止事件的<strong>传播</strong>。不能使用<code>return false</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">"c"</span>);</span><br><span class="line"><span class="comment">// 捕获</span></span><br><span class="line">a.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-a"</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">b.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-b"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"b-c"</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡</span></span><br><span class="line">a.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-a"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">b.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-b"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻止冒泡</span></span><br><span class="line">c.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"m-c"</span>)</span><br><span class="line">	e.stopPropagation(); <span class="comment">// 此处阻止传播</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p>
<p>此时的顺序：b-a,b-c,m-c。不会传递，后面的不会执行了。阻止捕获也是一样，添加之后就不会在继续往下传递了。</p>
<p>这里有涉及到一个阻止事件的默认<strong>行为</strong>：<code>preventDefault</code>或者是前面提到的<code>return false</code></p>
<h2 id="对于IE下的事件绑定"><a href="#对于IE下的事件绑定" class="headerlink" title="对于IE下的事件绑定"></a>对于IE下的事件绑定</h2><p><strong>适用与IE6，7，8</strong><br>IE的事件与模型与W3C的标准事件相比，主要是以下三点不同：</p>
<ol>
<li>绑定事件的函数不同，IE中使用attachEvent()和detachEvent()</li>
<li>事件必须加上<code>on</code></li>
<li>IE6模型中，不支持捕获，只支持冒泡</li>
<li>IE中还有毛病，先绑定的事件后发生（准确的说是随机发生）</li>
<li>IE中<code>this</code>指向<code>window</code></li>
</ol>
<h4 id="更新与2017年12月2日14-30-05"><a href="#更新与2017年12月2日14-30-05" class="headerlink" title="更新与2017年12月2日14:30:05"></a>更新与2017年12月2日14:30:05</h4><h2 id="关于使用addEventListener"><a href="#关于使用addEventListener" class="headerlink" title="关于使用addEventListener"></a>关于使用<code>addEventListener</code></h2><p>给元素添加事件一般使用<code>addEventListener</code>的方式来添加，这样才可以个一个元素添加多个事件。但是由于<code>addEventListener</code>单词太长，容易写错，并且代码压缩的时候不会压缩，所以一般很少直接使用他，而是使用函数把他封装起来使用，避免出错：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">ele,type,fn</span>)</span>&#123;</span><br><span class="line">	ele.addEventListener(type,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// fn(e)</span></span><br><span class="line">		<span class="comment">// 更新于2019年09月17日，添加call，修改this指向，感谢 小兔子乖乖别开门 指出的错误</span></span><br><span class="line">		fn.call(ele, e)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用以上的方式可以减少出错率以及方便</p>
<h2 id="关于事件代理（委托）"><a href="#关于事件代理（委托）" class="headerlink" title="关于事件代理（委托）"></a>关于事件代理（委托）</h2><p>一般情况下，如果一个元素下存在多个点击事件，代码结构如下：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>list-1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>list-2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>list-3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>list-4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此时，如果你要给每一个<code>li</code>标签添加一个点击事件，弹出每一个<code>li</code>的索引值，初学者可能会使用<code>for</code>循环的方式来添加：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oLis  = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oLis.length; i++) &#123;</span><br><span class="line">	oLis[i].i = i;</span><br><span class="line">	addEvent(oLis[i],<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.i)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者是使用闭包：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oLis  = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oLis.length; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">		addEvent(oLis[i],<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">			alert(i)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是以上两种都不是一个最好的方法，因为你的<code>li</code>的个数可能发生改变，如果是这样的话，可能会出一些问题。那么，此时如果使用事件代理的方式，效果会更好。<br>事件代理代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oBox = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line"></span><br><span class="line">addEvent(oBox,<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> target = e.target;</span><br><span class="line">	<span class="comment">// 判断点击的是li</span></span><br><span class="line">	<span class="keyword">if</span> ( target.nodeName == <span class="string">'LI'</span> ) &#123;</span><br><span class="line">		alert(target.innerHTML)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样也是可以的，不过此时的<code>addEvent</code>函数点击的时候就需要在<code>fn</code>里面判断点击的是哪一个标签。为了更好的使用<code>addEvent</code>，我们可以改进一下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">ele,type,selector,fn</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 如果只有三个参数，那么3,4互换</span></span><br><span class="line">	<span class="keyword">if</span> ( fn == <span class="literal">null</span> ) &#123;</span><br><span class="line">		fn = selector;</span><br><span class="line">		selector = <span class="literal">null</span></span><br><span class="line">	&#125;</span><br><span class="line">	ele.addEventListener(type,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> target;</span><br><span class="line">		<span class="keyword">if</span> ( selector ) &#123;</span><br><span class="line">			<span class="comment">//  代理</span></span><br><span class="line">			target = e.target;</span><br><span class="line">			<span class="keyword">if</span>(target.matches(selector))&#123;</span><br><span class="line">				fn.call(target, e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 不代理</span></span><br><span class="line">			<span class="comment">// 更新于2019年09月17日，添加call，修改this指向，感谢 小兔子乖乖别开门 指出的错误</span></span><br><span class="line">			fn.call(ele, e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时点击<code>li</code>弹出innerHTML就可以这样实现<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addEvent(oBox,<span class="string">'click'</span>,<span class="string">'li'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript错误类型</title>
    <url>/%E6%8A%80%E6%9C%AF/javascript%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B.html</url>
    <content><![CDATA[<p>作为一个程序员，需要的不仅仅是技术，更是需要在遇到错误的时候对错误的处理能力。就前端而言，技术一直在更新，但是JavaScript中的错误也就是那么几个。掌握不同的报错信息会让你的实际开发事半功倍。</p>
<h1 id="JavaScript中的错误类型"><a href="#JavaScript中的错误类型" class="headerlink" title="JavaScript中的错误类型"></a>JavaScript中的错误类型</h1><ul>
<li>Error</li>
<li>EvalError</li>
<li>RangeError</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p><code>Error</code>是最基本的错误类型，其他的错误类型都继承自该类型。因此，<code>所有错误的类型共享了一组相同的属性。</code><br>这个类型的错误很少见。一般使用开发人员自定义抛出的错误。</p>
<h2 id="EvalError"><a href="#EvalError" class="headerlink" title="EvalError"></a>EvalError</h2><p>这个错误会在使用<code>eval()</code>函数发生异常时候抛出。两种情况会出错：</p>
<ol>
<li>new eval();</li>
<li>eval = foo;<br>上面两个的意思结合就是没有直接调用<code>eval</code>函数，而是new或者是重新赋值<br>这个错误基本上不会遇到，因为<code>eval</code>函数本来用的就不多。不过需要注意的是，<code>eval</code>是一个关键字。</li>
</ol>
<h2 id="RangeError"><a href="#RangeError" class="headerlink" title="RangeError"></a>RangeError</h2><p>这个错误会在<code>数值超出相应范围时触发</code>。比如使用<code>new Array()</code>的时候传递一个负数或者是超过数组最大长度（4,294,967,295）的数，比如Number.MAX_VALUE，Number.MIN_VALUE。注意递归爆炸也有这个错误。</p>
<h2 id="ReferenceError"><a href="#ReferenceError" class="headerlink" title="ReferenceError"></a>ReferenceError</h2><p>这个错误一般就是出现在<code>变量找不到的情况</code>，比如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b;</span><br><span class="line">Uncaught <span class="built_in">ReferenceError</span>: b is not defined</span><br></pre></td></tr></table></figure></p>
<p>这时候就需要检查一下一个变量了</p>
<h2 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h2><p>当Javascript语言解析代码时,Javascript引擎发现了不符合语法规范的tokens或token顺序时抛出SyntaxError。</p>
<h2 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h2><p>这个错误在JavaScript中是经常遇到的，不管是初学者还是老手。在变量中保存着以外的类型时，或者在访问不存在的方法时。都会导致这种错误。但是归根结底还是<code>由于在执行特定于类型的操作时，变量的类型并不符合要求所致</code>。比如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="number">10</span>;</span><br><span class="line">a.style.widht = <span class="string">"10px"</span>;</span><br></pre></td></tr></table></figure></p>
<p>关于设置样式这个东西，新手会遇到很多，一般这都是由获取不到元素导致的。</p>
<h2 id="URIError"><a href="#URIError" class="headerlink" title="URIError"></a>URIError</h2><p>在使用<code>encodeURI</code>或者<code>decodeURI</code>因为URL格式不正确时，就会导致URIError错误。这种错误也很少见。</p>
<h1 id="使用try-catch进行错误处理"><a href="#使用try-catch进行错误处理" class="headerlink" title="使用try-catch进行错误处理"></a>使用try-catch进行错误处理</h1><p>try-catch是一个错误处理的方法。使用法法是：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 尝试执行的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">	<span class="comment">// 如果上市执行的代码不成功则执行这段代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>代码中    <code>catch</code>语句的<code>error</code>不能省略。</strong><br>在自己不能把我是否会出错的地方使用<code>try-catch</code>语句能让代码运行的更舒服。<code>try-catch</code>语句其实还有一句<code>finally</code>语句：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 尝试执行的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">	<span class="comment">// 如果上市执行的代码不成功则执行这段代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// finally的语句始终都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为finally语句使用会执行，所以我们一般都不会使用    <code>finally</code>语句。</p>
<h1 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h1><p>在使用<code>try-catch</code>语句时发生错误我们可以执行其他事情或者是抛出这个错误。抛出错误使用<code>throw</code>操作符。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	alert(a)</span><br><span class="line">&#125; <span class="keyword">catch</span>(error)&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"a is not defined"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码就会抛出一个一般的错误：<code>Uncaught Error: a is not defined</code>。具体抛出什么错误根据实际情况确定。类型就是上面的那几种错误类型。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript字符串</title>
    <url>/%E6%8A%80%E6%9C%AF/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content><![CDATA[<p>字符串是JavaScript中7种数据中的一种，用于表示由零个或多个16位的Unicode字符组成的字符序列。创建字符串有两种方式，一种是字面量，另一种是构造函数。</p>
<ol>
<li><p>字面量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"一个字符串"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"一个字符串"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面就是两个字符串，但是字面量对构造函数说：<code>“我们不一样。”</code>那有啥不一样？好。下面来看看具体的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">"一个字符串"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str1);	<span class="comment">// 一个字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str1);	<span class="comment">// string</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"一个字符串"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str2);	<span class="comment">// String &#123;"一个字符串"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str2);	<span class="comment">// object</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出来两个的值与类型都不相同。使用字面量就是返回一个字符串。使用构造函数则是一个字符串对象。如果要将字符串对象转换为字符串。可以使用<code>toString</code>，<code>toLocalSring</code>，<code>valueOf</code>转换为字符串。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"一个字符串"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str2);	<span class="comment">// String &#123;"一个字符串"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str2);	<span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.toString())	<span class="comment">// 一个字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.toLocaleString())	<span class="comment">// 一个字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.valueOf())	<span class="comment">// 一个字符串</span></span><br></pre></td></tr></table></figure></p>
<p>这样要使用一个字符串费劲。所以一般看不到这样的操作，都是使用的字面量定义。下面的关于字符串的一些方法都将使用字面量的形式。</p>
<h2 id="字符串是有长度的"><a href="#字符串是有长度的" class="headerlink" title="字符串是有长度的"></a>字符串是有长度的</h2><p>字符串是有长度这个属性的。从刚刚的构造函数中可以看出来。获取长度使用<code>length</code>属性就不在过多的说明。</p>
<h2 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h2><p>字符串用于两个访问特定字符的方法：<br><code>charAt</code>：一个参数，返回给定位置的字符<br><code>charCodeAt</code>：一个参数，返回给定位置的字符的字符编码<br>以及一个将字符编码转换为字符的方法，这个是<code>String</code>构造函数的<br><code>fromCharCode</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"测试字符方法"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">2</span>));	<span class="comment">// 字</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charCodeAt(<span class="number">2</span>));	<span class="comment">// 23383</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">23383</span>)) <span class="comment">// 字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// charAt()方法获取指定位置的字符还可以直接使用下标获取，因为字符串是有长度的。</span></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="number">2</span>]);	<span class="comment">// 字</span></span><br></pre></td></tr></table></figure>
<p>虽说可以使用下标获取指定位置的字符。但是此方法不兼容<code>IE8以下</code>。所以如果使用需要谨慎。</p>
<h2 id="字符操作方法"><a href="#字符操作方法" class="headerlink" title="字符操作方法"></a>字符操作方法</h2><h3 id="concat-拼接字符串"><a href="#concat-拼接字符串" class="headerlink" title="concat() - 拼接字符串"></a>concat() - 拼接字符串</h3><p><code>concat</code>方法用于讲一个或者多个字符串拼接起来。所以他接收一个或者多个字符创作为参数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"我"</span>;</span><br><span class="line"><span class="keyword">var</span> res = str.concat(<span class="string">"喜"</span>,<span class="string">"欢"</span>,<span class="string">"你"</span>,<span class="string">"！"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);	<span class="comment">// 我</span></span><br><span class="line"><span class="built_in">console</span>.log(res);	<span class="comment">// 我喜欢你！</span></span><br></pre></td></tr></table></figure></p>
<p>经过上面的代码发现，使用<code>concat</code>是不会影响原字符串的。这个方法在数组中也存在，不过那是连接数组了。<br>虽说可以使用<code>concat</code>方法连接两个或者两个以上的字符串，但是基本不使用。开发中还是使用<code>+</code>号拼接的使用更多。</p>
<h3 id="substr-，substring-，slice-切割字符串"><a href="#substr-，substring-，slice-切割字符串" class="headerlink" title="substr()，substring()，slice() - 切割字符串"></a>substr()，substring()，slice() - 切割字符串</h3><p>三个方法都是基于字符串创建新字符的方法，都接收<code>一个或者两个参数</code>，返回一个新字符串，不影响原字符串。第一个参数是切割的开始位置（包括这个位置）。</p>
<p><code>substr</code>：第二个参数指切割的字符串的个数，因为是个数。所以包含最后一个<br><code>substring</code>：第二个参数指切割的字符串的位置，不包含最后一个<br><code>slice</code>：第二个参数指切割的字符串的位置，不包含最后一个<br>三个若都没有第二个参数。默认都字符串末尾<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"我喜欢你一生一世！"</span>;</span><br><span class="line"><span class="comment">// 传递的参数是一个正数</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">2</span>)); <span class="comment">// 欢你一生一世！</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">2</span>)); <span class="comment">// 欢你一生一世！</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">2</span>)); <span class="comment">// 欢你一生一世！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">2</span>,<span class="number">3</span>));	<span class="comment">// 欢你一</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">2</span>,<span class="number">3</span>));	<span class="comment">// 欢</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">2</span>,<span class="number">3</span>));	<span class="comment">// 欢</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递的参数是一个负数</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">-3</span>));	<span class="comment">// 一世！</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">-3</span>));	<span class="comment">// 我喜欢你一生一世！</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-3</span>));	<span class="comment">// 一世！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">3</span>,<span class="number">-4</span>));	<span class="comment">// 空字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">3</span>,<span class="number">-4</span>));	<span class="comment">// 我喜欢</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">3</span>,<span class="number">-4</span>));	<span class="comment">// 你一</span></span><br></pre></td></tr></table></figure></p>
<p>对比上面的代码。当两个参数都是正数的时候很简单。但是当两个都是负数的时候，问题就来了。<code>substr</code>会将<code>负的</code>第一个参数<code>从后往前数</code>第几位作为开始位置。<code>负的</code>第二个参数转化为0。<code>slice</code>会将负数全部从后往前数。但是<code>substring</code>像是没事人一样。把负数忽略了。转化为0，同时以较小数作为开始位置。</p>
<h3 id="字符串位置方法-查找字符串"><a href="#字符串位置方法-查找字符串" class="headerlink" title="字符串位置方法 - 查找字符串"></a>字符串位置方法 - 查找字符串</h3><p><code>indexOf</code>：从头到尾的找<br><code>lastIndexOf</code>：从尾到头的找<br>两个方法都接收<code>一个或者两个参数</code>，第一个是需要查找的字符，第二个是从哪个位置开始查找（下标，默认是0）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"我是真的真的喜欢你！"</span>;</span><br><span class="line"><span class="comment">// 		   0 1 23 4 56 7 8</span></span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"真"</span>));	<span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(str.lastIndexOf(<span class="string">"真"</span>));	<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"真"</span>,<span class="number">3</span>));	<span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(str.lastIndexOf(<span class="string">"真"</span>,<span class="number">3</span>));	<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"他"</span>));	<span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(str.lastIndexOf(<span class="string">"他"</span>));	<span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>可以看的，不管是<code>indexOf</code>还是<code>lastIndexOf</code>找到字符串后都会返回这个字符的下标。不过一个是正着数一个是倒着数。但是当去寻找小三<code>他</code>的时候没有发现小三旧放回一个<code>-1</code>。</p>
<p>所以，两个方法都是找到返回<code>下标(注意从哪头开始的)</code>。未找到返回 <code>-1</code>。</p>
<h2 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h2><p><code>trim()</code>方法很简单，就是取出字符串的收尾的空格。但是此方法不兼容<code>IE8</code>及以下。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"   我喜欢你！   "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);	<span class="comment">//    我喜欢你！   </span></span><br><span class="line"><span class="built_in">console</span>.log(str.trim()); <span class="comment">// 我喜欢你！</span></span><br></pre></td></tr></table></figure></p>
<p>如果是要兼容<code>IE8</code>及以下，可是使用正则去替换。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"   我喜欢你！   "</span>;</span><br><span class="line"><span class="keyword">var</span> res = str.replace(<span class="regexp">/^\s*|\s*$/g</span>,<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 我喜欢你！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"   我喜  欢你！   "</span>;</span><br><span class="line"><span class="keyword">var</span> res = str.replace(<span class="regexp">/^\s*|\s*$/g</span>,<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);	<span class="comment">// 我喜  欢你！</span></span><br></pre></td></tr></table></figure></p>
<h2 id="大小写转化方法"><a href="#大小写转化方法" class="headerlink" title="大小写转化方法"></a>大小写转化方法</h2><p>四个方法：<br><code>toLowerCase</code>：转换为小写<br><code>toLocaleLowerCase</code>：转换为当地时区小写，一些地方专用<br><code>toUpperCase</code>：转换为大写<br><code>toLocaleUpperCase</code>：转换为当地时区大写，一些地方专用<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"I Love You!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.toLowerCase());	<span class="comment">// i love you!</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toLocaleLowerCase());	<span class="comment">// i love you!</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase());	<span class="comment">// I LOVE YOU!</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toLocaleUpperCase());	<span class="comment">// I LOVE YOU!</span></span><br></pre></td></tr></table></figure></p>
<p>为了保险起见，使用带Locale的更好。</p>
<h2 id="字符串匹配方法"><a href="#字符串匹配方法" class="headerlink" title="字符串匹配方法"></a>字符串匹配方法</h2><h3 id="match-匹配"><a href="#match-匹配" class="headerlink" title="match() - 匹配"></a>match() - 匹配</h3><p><code>match</code>本质上与RegExp的exec()方法是一样的。接收一个参数，正则表达式或者是RegExp对象。返回一个数组。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"bat,cat,fat,hat"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">var</span> res = str.match(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res)	<span class="comment">// (4) ["bat", "cat", "fat", "hat"]</span></span><br></pre></td></tr></table></figure></p>
<p><code>var res = str.match(reg);</code>与<code>var res = reg.exec(str);</code>本质上相同。但是后面的无论是不是全局都是返回长度为1的数组。如果不是全局匹配，两者没有区别。</p>
<h3 id="search-搜索"><a href="#search-搜索" class="headerlink" title="search() - 搜索"></a>search() - 搜索</h3><p><code>search</code>的参数与<code>match</code>一样。<code>search</code>方法返回字符串中第一个匹配项的索引。没有则返回<code>-1</code>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"bat,cat,fat,hat"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/at/</span>;</span><br><span class="line"><span class="keyword">var</span> res = str.search(reg);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 1。因为第一个 a 的下标为 1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="replace-替换"><a href="#replace-替换" class="headerlink" title="replace() - 替换"></a>replace() - 替换</h3><p><code>replace</code>方法是字符串中<code>十分重要</code>的一个方法，必须掌握。接收<code>两个参数</code>。</p>
<p>第一个参数：可以是一个字符串或者是一个正则<br>第二个参数：可以是一个字符串或者是一个函数</p>
<p>第二个参数是<code>字符串</code>：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abcdcba"</span>;</span><br><span class="line"><span class="keyword">var</span> res1 = str.replace(<span class="string">"b"</span>,<span class="string">"逼"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1);	<span class="comment">// a逼cdcba</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res2 = str.replace(<span class="regexp">/b/g</span>,<span class="string">"逼"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2);	<span class="comment">// a逼cdc逼a</span></span><br></pre></td></tr></table></figure></p>
<p>第一个参数为<code>字符串</code>基本不用，因为他只能匹配第一个，且只能匹配一个</p>
<p><code>第二个参数是函数</code>：<br>如果是函数<br>第一个参数：匹配项<br><code>中间的参数：捕获组1，捕获组2，捕获组3······</code><br>倒数第二个：位置<br>最后一个：原始字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"fathermatherbrothersister"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/father(mather(brother(sister)))/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = str.replace(reg,<span class="function"><span class="keyword">function</span>(<span class="params">match,capture1,capture2,capture3,pos,originalText</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(match); <span class="comment">// fathermatherbrothersister</span></span><br><span class="line">	<span class="built_in">console</span>.log(capture1); <span class="comment">// matherbrothersister</span></span><br><span class="line">	<span class="built_in">console</span>.log(capture2); <span class="comment">// brothersister</span></span><br><span class="line">	<span class="built_in">console</span>.log(capture3); <span class="comment">// sister</span></span><br><span class="line">	<span class="built_in">console</span>.log(pos); <span class="comment">// 0</span></span><br><span class="line">	<span class="built_in">console</span>.log(originalText); <span class="comment">// fathermatherbrothersister</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// undefined 。因为第二个参数无返回值</span></span><br></pre></td></tr></table></figure>
<p>第二个参数既然可以拿到这些东西。那我们就可以做任何事情。</p>
<h3 id="split-分割"><a href="#split-分割" class="headerlink" title="split() - 分割"></a>split() - 分割</h3><p><code>split</code>方法可以将字符串按指定的符号进行分割，返回一个数组。<br>第一个参数：分隔符。字符串或者正则<br>第二个参数：可选。返回数字的长度，不能大于可切割的长度<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"yellow,red,green,blue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(color.split(<span class="string">","</span>));	<span class="comment">// (4) ["yellow", "red", "green", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(color.split(<span class="string">","</span>,<span class="number">2</span>));	<span class="comment">//(2) ["yellow", "red"]</span></span><br><span class="line"><span class="built_in">console</span>.log(color.split(<span class="regexp">/[^,]+/</span>));	(<span class="number">5</span>) [<span class="string">""</span>, <span class="string">","</span>, <span class="string">","</span>, <span class="string">","</span>, <span class="string">""</span>] 。[^,]除了 , 以外</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript函数</title>
    <url>/%E6%8A%80%E6%9C%AF/javascript%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<h2 id="函数的分类与定义函数的方式"><a href="#函数的分类与定义函数的方式" class="headerlink" title="函数的分类与定义函数的方式"></a>函数的分类与定义函数的方式</h2><p>JavaScript中的函数可以分为两类：<code>有名函数</code>与<code>匿名函数</code>。而定义函数的方式有两种：<code>函数声明</code>与<code>函数表达式</code>。</p>
<p><strong>目标：定义一个函数 fn ==&gt; 有名函数</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 函数执行体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用函数表达式</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 函数执行体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用函数声明的重要特征就是<code>函数声明提升</code>，即在读取代码前会先读取函数声明。<code>函数名()</code>表示执行函数<br>看看下面的代码没有任何问题。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个有名函数 fn1 使用函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"fn1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数 fn1</span></span><br><span class="line">fn1();  <span class="comment">// fn1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个有名函数 fn2 使用函数表达式</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"fn2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数 fn2</span></span><br><span class="line">fn2(); <span class="comment">// fn2</span></span><br></pre></td></tr></table></figure></p>
<p>但是如果是把调用放在定义函数前面，使用<code>函数表达式</code>的就会报错（Uncaught ReferenceError: fn1 is not defined）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用函数 fn1</span></span><br><span class="line">fn1(); <span class="comment">// fn1</span></span><br><span class="line"><span class="comment">// 定义一个有名函数 fn1 使用函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"fn1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数 fn2</span></span><br><span class="line">fn2(); <span class="comment">// Uncaught ReferenceError: fn1 is not defined</span></span><br><span class="line"><span class="comment">// 定义一个有名函数 fn2 使用函数表达式</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"fn2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是使用两种的区别。</p>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>每一个函数在调用的时候都会默认返回一个<code>undefined</code>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fn); <span class="comment">// console出一个函数 即 fn</span></span><br><span class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的地方就是关于<code>函数执行过程</code>与<code>函数执行结果</code>。</p>
<p><code>fn()</code>表示调用函数。那就会执行函数体。并默认返回一个<code>undefined</code>。只不过这个值<code>undefined</code>没有变量接收或者说是我们没有用这个值。</p>
<p><code>console.log(fn)</code>就只是console出一个变量<code>fn</code>的值。只不过这个值是一个函数。</p>
<p><code>console.log(fn())</code>与第一个的区别就是函数执行了并返回了一个结果。这个结果呢与上面不同的就是现在这个结果我们用上了（放在了console）里面。再由于值是<code>undefined</code>，所以console了一个<code>undefined</code>。</p>
<p>既然函数是可以有返回值的，并且这个值默认是一个<code>undefined</code>。那我们可以可以修改呢？答案是可以的。<br>我们使用<code>return</code>语句可以让函数返回一个值<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"哈哈"</span></span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fn); <span class="comment">// 函数 fn</span></span><br><span class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">// 哈哈</span></span><br></pre></td></tr></table></figure></p>
<p>可以看一下第一个与第二个的结果与之前的是相同的。但是第三个的结果就不同了，他是<code>字符串哈哈</code>。因为我们修改了函数的默认返回值。</p>
<p>所以，可以把默认函数理解成这样的<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而我们修改返回值就是吧这个undefined给变成其他的值了。<br><code>注意：</code>函数的返回值可以是任意的数据类型。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数是可以接收参数的，在定义函数的时候放的参数叫<code>形式参数</code>，简称<code>形参</code>。在调用函数的时候传递的参数叫<code>实际参数</code>，简称<code>实参</code>。一个函数可以拥有任意个参数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="built_in">console</span>.log(b)</span><br><span class="line">	<span class="built_in">console</span>.log(a+b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数并传递参数</span></span><br><span class="line">fn(<span class="number">3</span>,<span class="number">5</span>);  <span class="comment">// 3,5,8</span></span><br><span class="line"></span><br><span class="line">fn(<span class="number">3</span>); <span class="comment">// 3,undefined,NaN</span></span><br><span class="line"></span><br><span class="line">fn(<span class="number">3</span>,<span class="number">5</span>,<span class="number">10</span>) <span class="comment">// 3,5,8</span></span><br></pre></td></tr></table></figure></p>
<p>可以看看上面的例子。定义函数的时候有两个形参。调用的时候分为了三种情况。</p>
<p>第一种，传递两个参数，在console时候<code>a=3,b=5,a+b=8</code>。老铁，没问题。</p>
<p>第二种，传递一个参数，在console的时候<code>a=3,b=undefined,a+b=NaN</code>。哈哈，你不行。</p>
<p>第三种，传递3个。在console的时候<code>a=3,b=5,a+b=8</code>。握草，你牛逼。对第三个参数视而不见了。</p>
<p>以上就是三种情况。一句话：<code>参数一一对应，实参少了，那么没有对应的就是undefined，实参多了，多出来的就是没有用的</code></p>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>在不确定参数（或者定义函数的时候没有形参）的时候，调用函数你传递参数了，但是你没有使用新参去接收，就无法使用。把此时就有一个<code>arguments</code>对象可以获取到实参的个数以及具体的值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>) <span class="comment">// Arguments(7) [1, 2, 3, 4, 5, 6, 7, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure></p>
<p><code>arguments</code>在严格模式下无法使用。</p>
<h2 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h2><p><strong>递归</strong>：就是函数自己调用自己。比如下面经典的阶层递归函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stratum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n * stratum(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">stratum(<span class="number">5</span>) <span class="comment">// 120 = 5 * (4 * (3 * (2 * 1) ) )</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出实现的阶层的功能。<br>不过需要注意一下每一个的执行顺序。不是<code>5 * 4 * 3 * 2 * 1</code>。而是<code>5 * (4 * (3 * (2 * 1) ) )</code>的顺序。为了证明这一点。可以将<code>*</code>换为<code>-</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n - fn(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">5</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>如果是按照不带括号的<code>5-4-3-2-1 = -5</code>。但是结果却是<code>3</code>。那<code>3</code>是怎么来的呢？<code>5 - (4 - (3 - (2 - 1) ) ) = 5 - (4 - (3 - 1)) = 5 - (4 - 2) = 5 - 2 = 3</code></p>
<p>还可以使用<code>arguments.callee</code>方法调用自身。这个方法就指向当前运行的函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stratum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n * <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">stratum(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure></p>
<p><strong>递归虽然可以让代码更简洁，但是能不使用递归的时候就不要使用，递归会影响性能（因为过多的调用自己会一直保存每一次的返回值与变量，导致内存占用过多甚至内存泄露）</strong>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stratum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n * <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(stratum(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="number">1</span>) <span class="comment">// 1: 4.470947265625ms</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">	a *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="number">2</span>)  <span class="comment">// 2: 0.2373046875ms</span></span><br></pre></td></tr></table></figure></p>
<p>两个阶层，一看。for循环快太多了。具体的性能问题可以看看<a href="https://www.jianshu.com/p/6bdc8e3637f2" target="“_blank”">爱情小傻蛋</a>关于递归的算法改进。</p>
<h2 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h2><p><strong>闭包</strong>是指有权访问另一个函数作用域中的变量的函数。<br>两个条件：</p>
<ol>
<li>函数嵌套函数</li>
<li>内部函数使用包含函数的变量或者是参数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(a);</span><br><span class="line">		a++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()(); <span class="comment">// 1</span></span><br><span class="line">fn()(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = fn();</span><br><span class="line">a(); <span class="comment">// 1</span></span><br><span class="line">a(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中的函数就是一个闭包。注意上面的直接调用返回值与先保存返回值在调用的区别。</p>
<p><strong>闭包只能取得包含函数中任何变量的最后一个值</strong>。<code>this</code>是无法在闭包函数中调用的。因为每一个函数都有一个<code>this</code>。</p>
<p>闭包函数中使用的变量是<strong>不会进行销毁</strong>的，像上面的<code>var a = fn()</code>，这个函数a中使用了函数fn中的变量，且<code>a</code>是一直存在的，所以<code>函数fn</code>里面的变量<code>a</code>是不会销毁的。如果是直接调用函数<code>fn()()</code>只是相当于调用一次<code>fn</code>函数的返回值。调用完函数返回值就销毁了。所以变量<code>a</code>不会一直保存。</p>
<p>因为闭包函数的变量会一直保存不会</p>
<h3 id="call，apply与bind"><a href="#call，apply与bind" class="headerlink" title="call，apply与bind"></a>call，apply与bind</h3><p>三个方法都是改变this指向</p>
<h4 id="call-apply"><a href="#call-apply" class="headerlink" title="call    apply"></a>call    apply</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="built_in">console</span>.log(b)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"嘻嘻"</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="string">"name"</span>: <span class="string">"哈哈"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行函数fn</span></span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 1,2,嘻嘻</span></span><br></pre></td></tr></table></figure>
<p>直接调用函数<code>fn(1,2)</code>，<code>this.name</code>的值是<code>嘻嘻</code></p>
<p>如果使用call：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 1,2,哈哈</span></span><br></pre></td></tr></table></figure></p>
<p><code>call</code>方法的第一个参数是改变<code>this</code>指向的东西，可以是任何的数据类型。只不过如果是<code>null</code>或者是<code>undefined</code>就会指向<code>window</code>。<span style="color: red;font-weight: 900;">其他的参数</span>依次对应函数的每一个形参。</p>
<p>如果使用<code>apply</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.apply(obj,[<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure></p>
<p><code>apply</code>的使用与call的使用的唯一的区别就是它对应函数每一项形参<span style="color: red;font-weight: 900;">是一个数组</span>而不是单独的每一个。</p>
<p><code>call与applu都是在函数调用的时候去使用</code></p>
<p><code>bind</code>则是在函数定义的时候使用<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="built_in">console</span>.log(b)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"嘻嘻"</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="string">"name"</span>: <span class="string">"哈哈"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行函数fn</span></span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 1,2,嘻嘻</span></span><br></pre></td></tr></table></figure></p>
<p>如果使用<code>bind</code>可以是一下几种方式<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用函数表达式 + 匿名函数</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="built_in">console</span>.log(b)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;.bind(obj)</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用有名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="built_in">console</span>.log(b)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">fn.bind(obj)(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数在自执行</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="built_in">console</span>.log(b)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)	</span><br><span class="line">&#125;.bind(obj)(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="built_in">console</span>.log(b)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;.bind(obj))(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="built_in">console</span>.log(b)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;).bind(obj)(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>使用<code>bind</code>的时候也是可以传递参数的，但是不要这样使用，因为使用<code>bind</code>后你不调用函数那么参数还是没有作用。既然还是要调用函数，我们一般就把函数的实参传递到调用的括号里面。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5多线程与离线存储</title>
    <url>/%E6%8A%80%E6%9C%AF/HTML5%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8.html</url>
    <content><![CDATA[<h2 id="多线程-Worker"><a href="#多线程-Worker" class="headerlink" title="多线程 Worker"></a>多线程 Worker</h2><ol>
<li>前端页面<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Worker(<span class="string">"work.js"</span>);</span><br><span class="line">w.postmessage(<span class="string">"发送的数据"</span>);</span><br><span class="line">w.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.多线程处理页面<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 前端页面传过来的数据</span></span><br><span class="line">	<span class="built_in">console</span>.log(e.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h2><p>使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。<br>HTML5引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。 应用程序缓存为应用带来三个优势：</p>
<ul>
<li>离线浏览 – 用户可在应用离线时使用它们</li>
<li>速度 – 已缓存资源加载得更快</li>
<li>减少服务器负载 – 浏览器将只从服务器下载更新过或更改过的资源。</li>
</ul>
<hr>
<ol>
<li>新建一个 <code>.appcache</code> 文件，html文件的html标签中引入这个文件</li>
<li>在<code>apache</code>的<strong>httpd.conf</strong>文件下添加 <code>AddType text/cache-manifest .appcache</code></li>
<li>在<code>.appcache</code>文件下进行设置：</li>
</ol>
<blockquote>
<p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。manifest 文件可分为三个部分：</p>
<ol>
<li>CACHE MANIFEST - 在此标题下列出的文件将在首次加载后进行缓存</li>
<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li>
<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li>
</ol>
</blockquote>
<blockquote>
<p>在线的情况下,用户代理每次访问页面，都会去读一次manifest.如果发现其改变, 则重新加载全部清单中的资源</p>
</blockquote>
<h3 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h3><p>一旦应用被缓存，它就会保持缓存直到发生下列情况：<br>用户清空浏览器缓存<br>manifest 文件被修改（包括注释）<br>由程序来更新应用缓存</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>站点离线存储的容量限制是5M</li>
<li>如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存</li>
<li>引用manifest的html必须与manifest文件同源，在同一个域下</li>
<li>在manifest中使用的相对路径，相对参照物为manifest文件</li>
<li>CACHE MANIFEST字符串应在第一行，且必不可少</li>
<li>系统会自动缓存引用清单文件的 HTML 文件</li>
<li>manifest文件中CACHE则与NETWORK，FALLBACK的位置顺序没有关系，如果是隐式声明需要在最前面</li>
<li>FALLBACK中的资源必须和manifest文件同源</li>
<li>当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</li>
<li>站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问</li>
<li>当manifest文件发生改变时，资源请求本身也会触发更新</li>
</ul>
<h2 id="同域跨文档操作（服务器下运行）"><a href="#同域跨文档操作（服务器下运行）" class="headerlink" title="同域跨文档操作（服务器下运行）"></a>同域跨文档操作（服务器下运行）</h2><p>iframe内页：<br>    父页面操作子页面：contentWindow<br>    子页面操作父页面：window.top(找到最顶级的父页面)/parent(第一父页面)</p>
<p>新窗口页：<br>    父页面操作子页面：window.open<br>    子页面操作父页面：window.opener</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5拖拽</title>
    <url>/%E6%8A%80%E6%9C%AF/HTML5%E6%8B%96%E6%8B%BD.html</url>
    <content><![CDATA[<p>@(HTML5)[HTML 5拖拽]</p>
<h2 id="HTML-5-拖拽事件"><a href="#HTML-5-拖拽事件" class="headerlink" title="HTML 5 拖拽事件"></a>HTML 5 拖拽事件</h2><p>图片自带拖拽功能<br>其他元素可设置draggable属性：draggable ：true<br>拖拽元素(被拖拽的元素)事件 :  </p>
<ul>
<li>ondragstart :     拖拽的一瞬间触发 </li>
<li>ondrag :    拖拽前、拖拽结束之间，连续触发</li>
<li>ondragend :    拖拽结束触发</li>
</ul>
<p>目标元素(拖拽元素被拖到的地方)事件 :  </p>
<ul>
<li>ondragenter :    进入目标元素触发</li>
<li>ondragover :    进入目标、离开目标之间，连续触发</li>
<li>ondragleave :    离开目标元素触发</li>
<li>ondrop :在目标元素上释放鼠标触发<br><code>默认状态下，一个元素不能放另一元素的上面，需要在ondragover事件里面阻止默认事件</code><br><code>IE没效果</code></li>
</ul>
<p>生命周期：<br>dragstart -&gt; drag -&gt; dragenter -&gt; dragover -&gt;  dragleave  -&gt; drop -&gt; dragend </p>
<h2 id="火狐下的兼容"><a href="#火狐下的兼容" class="headerlink" title="火狐下的兼容"></a>火狐下的兼容</h2><p>火狐浏览器下需设置dataTransfer对象才可以拖拽除图片外的其他标签</p>
<ul>
<li>dataTransfer对象</li>
<li>setData() :     设置数据 key和value(必须是字符串)</li>
<li>getData() :     获取数据，根据key值，获取对应的value</li>
<li>effectAllowed :     设置光标样式(none, copy, copyLink, copyMove, link, linkMove, move, all 和 uninitialized)</li>
<li>setDragImage ：  三个参数（指定的元素，坐标X，坐标Y）</li>
<li>files：         获取外部拖拽的文件，返回一个filesList列表</li>
<li>filesList下有个type属性，返回文件的类型</li>
</ul>
<h2 id="FileReader-读取文件信息"><a href="#FileReader-读取文件信息" class="headerlink" title="FileReader(读取文件信息)"></a>FileReader(读取文件信息)</h2><p>readAsDataURL</p>
<ul>
<li>参数为要读取的文件对象</li>
<li>onload当读取文件成功完成的时候触发此事件</li>
<li>this. result 获取读取的文件数据</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5视频与音频</title>
    <url>/%E6%8A%80%E6%9C%AF/HTML5%E8%A7%86%E9%A2%91%E4%B8%8E%E9%9F%B3%E9%A2%91.html</url>
    <content><![CDATA[<p>简单介绍<br>HTML5 对视频和音频特性规范文档的制定是被讨论最多的。除浏览器自带支持的明显好处外，评论点集中在浏览器提供商对音频/视频格式 的不同选择。如果你准备使用HTML5的</p>
<p><strong>音频:</strong> ogg (ogg, oga), mp3, wav, AAC<br><strong>视频:</strong> ogg (ogv), H.264 (mp4)</p>
<p>另外你还需要留意一下 Google 的 VP8 视频解码，这个将被作为一个开源格式来结束（格式选择的）纷争。HTML5 提供的一个解决方案是 ，让你可以指定多个不同格式的源文件，以便于用户浏览器选择它认识的文件。对于 &lt; IE9 和旧浏览器，你将需要一个折衷的解决方案。</p>
<p>当你第一次尝试 HTML5 的音频/视频，你可能会想知道这些可能对你有帮助的东东：</p>
<p>你的服务器必须支持你打算提供的音频/视频的 MIME 格式。你将需要检查一下其在本地服务器上是否被支持。</p>
<p>如果你使用 Safari 来检测 HTML5 的音频/视频支持，需要安装 QuickTime Player，没有QuickTime Player 的 Safari 什么都不能播放。</p>
<h2 id="音频-audio"><a href="#音频-audio" class="headerlink" title="音频    -    audio"></a>音频    -    audio</h2><h3 id="关于音频的格式"><a href="#关于音频的格式" class="headerlink" title="关于音频的格式"></a>关于音频的格式</h3><h4 id="ogg"><a href="#ogg" class="headerlink" title="ogg"></a>ogg</h4><p>Ogg全称应该是OGGVobis(oggVorbis)是一种新的音频压缩格式，类似于MP3等的音乐格式。Ogg是完全免费、开放和没 有专利限制的。OggVorbis文件的扩展名是.OGG。Ogg文件格式可以不断地进行大小和音质的改良，而不影响旧有的编码器或播放器。</p>
<h4 id="mp3"><a href="#mp3" class="headerlink" title="mp3"></a>mp3</h4><p>MP3是一种音频压缩技术，其全称是 动态影像专家压缩标准音频层面3（Moving Picture Experts Group Audio Layer III），简称为MP3。 它被设计用来大幅度地降低音频数据量。利用 MPEG Audio Layer 3 的技术，将音乐以1:10 甚至 1:12 的压缩率，压缩成容量较小的文件，而 对于大多数用户来说重放的音质与最初的不压缩音频相比没有明显的下降。它是在1991年由位于德国埃尔朗根的研究组织Fraunhofer-Gesellschaft 的一组工程师发明和标准化的。用MP3形式存储的音乐就叫作MP3音乐，能播放MP3音乐的机器就叫作MP3播放器。</p>
<h4 id="wav"><a href="#wav" class="headerlink" title="wav"></a>wav</h4><p>WAV为微软公司(Microsoft)开发的一种声音文件格式，它符合RIFF(Resource Interchange File Format)文件规范，用于保存Windows平台的音 频信息资源，被Windows平台及其应用程序所广泛支持，该格式也支持MSADPCM，CCITT A LAW等多种压缩运算法，支持多种音频数字，取样频率和 声道，标准格式化的WAV文件和CD格式一样，也是44.1K的取样频率，16位量化数字，因此在声音文件质量和CD相差无几！ WAV打开工具是WINDOWS 的媒体播放器。</p>
<h4 id="acc"><a href="#acc" class="headerlink" title="acc"></a>acc</h4><p>AAC（Advanced Audio Coding），中文称为“高级音频编码”，出现于1997年，基于 MPEG-2的音频编码技术。由Fraunhofer IIS、杜比实验室 、AT&amp;T、Sony（索尼）等公司共同开发，目的是取代MP3格式。2000年，MPEG-4标准出现后，AAC 重新集成了其特性，加入了SBR技术和PS技术， 为了区别于传统的 MPEG-2 AAC 又称为 MPEG-4 AAC。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span> <span class="attr">src</span>=<span class="string">"audio/after the afterparty.mp3"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;source src="audio/after the afterparty.mp3" type=""&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="HTML5-Audio-Video-方法"><a href="#HTML5-Audio-Video-方法" class="headerlink" title="HTML5 Audio/Video 方法"></a>HTML5 Audio/Video 方法</h4><p>addTextTrack()：向音频/视频添加新的文本轨道</p>
<p>canPlayType()：检测浏览器是否能播放指定的音频/视频类型</p>
<p>load()：重新加载音频/视频元素</p>
<p>play()：开始播放音频/视频</p>
<p>pause()：暂停当前播放的音频/视频</p>
<h4 id="HTML5-Audio-Video-属性"><a href="#HTML5-Audio-Video-属性" class="headerlink" title="HTML5 Audio/Video 属性"></a>HTML5 Audio/Video 属性</h4><p>audioTracks：返回表示可用音轨的 AudioTrackList 对象</p>
<p><code>autoplay：设置或返回是否在加载完成后随即播放音频/视频</code></p>
<p>buffered：返回表示音频/视频已缓冲部分的 TimeRanges 对象</p>
<p>`controller：返回表示音频/视频当前媒体控制器的 MediaController 对象</p>
<p><code>controls：设置或返回音频/视频是否显示控件（比如播放/暂停等）</code><br>crossOrigin：设置或返回音频/视频的 CORS 设置</p>
<p>currentSrc：返回当前音频/视频的 URL</p>
<p><code>currentTime：设置或返回音频/视频中的当前播放位置（以秒计）</code></p>
<p>defaultMuted：设置或返回音频/视频默认是否静音</p>
<p>defaultPlaybackRate：设置或返回音频/视频的默认播放速度</p>
<p><code>duration：返回当前音频/视频的长度（以秒计）</code></p>
<p>ended：返回音频/视频的播放是否已结束</p>
<p>error：返回表示音频/视频错误状态的 MediaError 对象</p>
<p><code>loop：设置或返回音频/视频是否应在结束时重新播放</code></p>
<p>mediaGroup：设置或返回音频/视频所属的组合（用于连接多个音频/视频元素）</p>
<p><code>muted：设置或返回音频/视频是否静音</code></p>
<p>networkState：返回音频/视频的当前网络状态</p>
<p><code>paused：设置或返回音频/视频是否暂停</code></p>
<p><code>playbackRate：设置或返回音频/视频播放的速度</code></p>
<p>played：返回表示音频/视频已播放部分的 TimeRanges 对象</p>
<p>preload：设置或返回音频/视频是否应该在页面加载后进行加载</p>
<p>readyState：返回音频/视频当前的就绪状态</p>
<p>seekable：返回表示音频/视频可寻址部分的 TimeRanges 对象</p>
<p>seeking：返回用户是否正在音频/视频中进行查找</p>
<p><code>src：设置或返回音频/视频元素的当前来源</code></p>
<p>startDate：返回表示当前时间偏移的 Date 对象</p>
<p>textTracks：返回表示可用文本轨道的 TextTrackList 对象</p>
<p>videoTracks：返回表示可用视频轨道的 VideoTrackList 对象</p>
<p><code>volume：设置或返回音频/视频的音量</code></p>
<h4 id="HTML5-Audio-Video-事件"><a href="#HTML5-Audio-Video-事件" class="headerlink" title="HTML5 Audio/Video 事件"></a>HTML5 Audio/Video 事件</h4><p>abort：当音频/视频的加载已放弃时</p>
<p>canplay：当浏览器可以播放音频/视频时</p>
<p>canplaythrough：当浏览器可在不因缓冲而停顿的情况下进行播放时</p>
<p>durationchange：当音频/视频的时长已更改时</p>
<p>emptied：当目前的播放列表为空时</p>
<p>ended：当目前的播放列表已结束时</p>
<p>error：当在音频/视频加载期间发生错误时</p>
<p>loadeddata：当浏览器已加载音频/视频的当前帧时</p>
<p>loadedmetadata：当浏览器已加载音频/视频的元数据时</p>
<p>loadstart：当浏览器开始查找音频/视频时</p>
<p>pause：当音频/视频已暂停时</p>
<p>play：当音频/视频已开始或不再暂停时</p>
<p>playing：当音频/视频在已因缓冲而暂停或停止后已就绪时</p>
<p>progress：当浏览器正在下载音频/视频时</p>
<p>ratechange：当音频/视频的播放速度已更改时</p>
<p>seeked：当用户已移动/跳跃到音频/视频中的新位置时</p>
<p>seeking：当用户开始移动/跳跃到音频/视频中的新位置时</p>
<p>stalled：当浏览器尝试获取媒体数据，但数据不可用时</p>
<p>suspend：当浏览器刻意不获取媒体数据时</p>
<p>timeupdate：当目前的播放位置已更改时</p>
<p>volumechange：当音量已更改时</p>
<p>waiting：当视频由于需要缓冲下一帧而停止</p>
<p><code>注意：</code>为了兼容性。一般使用source标签加载多个音频</p>
<h3 id="利用AudioContext绘制"><a href="#利用AudioContext绘制" class="headerlink" title="利用AudioContext绘制"></a>利用AudioContext绘制</h3>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>SVG</title>
    <url>/%E6%8A%80%E6%9C%AF/SVG.html</url>
    <content><![CDATA[<p>HTML体系中，最常用的绘制矢量图的技术是SVG和HTML5新增加的canvas元素。这两种技术都支持绘制矢量图和光栅图。不过canvas更偏重于动画的制作。所以，<code>绘制矢量图</code>的大任落到了SVG身上。</p>
<h2 id="SVG简介"><a href="#SVG简介" class="headerlink" title="SVG简介"></a>SVG简介</h2><p>可缩放矢量图形(Scalable Vector Graphics，简称SVG)是一种使用XML来描述二维图形的语言(SVG严格遵从XML语法)。 SVG允许三种类型的图形对象：矢量图形形状（例如由直线和曲线组成的路径）、图像和文本。 可以将图形对象（包括文本）分组、样式化、转换和组合到以前呈现的对象中。 SVG 功能集包括嵌套转换、剪切路径、alpha 蒙板和模板对象。</p>
<p><code>SVG既可以说是一种协议，也可以说是一门语言；既是HTML的一个标准元素，也是一种图片格式。</code></p>
<h2 id="SVG与其他的图片格式对比"><a href="#SVG与其他的图片格式对比" class="headerlink" title="SVG与其他的图片格式对比"></a>SVG与其他的图片格式对比</h2><p>SVG与其它的图片格式相比，有很多优点(很多优点来源于矢量图的优点)：</p>
<ul>
<li>SVG文件是纯粹的XML， 可被非常多的工具读取和修改(比如记事本)。</li>
<li>SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同）</li>
<li>SVG里的属性值必须用引号引起来，就算是数值也必须这样做。</li>
<li>SVG 与JPEG 和GIF图像比起来，尺寸更小，且可压缩性更强。</li>
<li>SVG 是可伸缩的，可在图像质量不下降的情况下被放大，可在任何的分辨率下被高质量地打印。</li>
<li>SVG 图像中的文本是可选的，同时也是可搜索的(很适合制作地图)。</li>
<li>SVG 可以与 Java 技术一起运行。</li>
<li>SVG 是开放的标准。</li>
</ul>
<p><code>注意事项：
SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同）
SVG里的属性值必须用引号引起来，就算是数值也必须这样做。</code></p>
<h3 id="SVG使用"><a href="#SVG使用" class="headerlink" title="SVG使用"></a>SVG使用</h3><ol>
<li>可以直接使用svg</li>
<li>可以使用img标签引用svg</li>
<li>可以在HTML中使用svg</li>
<li>可以作为背景图片</li>
</ol>
<h2 id="使用SVG画图"><a href="#使用SVG画图" class="headerlink" title="使用SVG画图"></a>使用SVG画图</h2><h3 id="矩形-rect元素"><a href="#矩形-rect元素" class="headerlink" title="矩形 - rect元素"></a>矩形 - rect元素</h3><pre><code>&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot;/&gt;
&lt;rect x=&quot;60&quot; y=&quot;10&quot; rx=&quot;10&quot; ry=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot;/&gt;
</code></pre><p>这个元素有6个控制位置和形状的属性，分别是：</p>
<p>x：矩形左上角的坐标(用户坐标系)的x值。</p>
<p>y：矩形左上角的坐标(用户坐标系)的y值。</p>
<p>width：矩形宽度。</p>
<p>height：矩形高度。</p>
<p>rx：实现圆角效果时，圆角沿x轴的半径。</p>
<p>ry：实现圆角效果时，圆角沿y轴的半径。</p>
<p><code>注意：rx与ry只设置了一个，另一个值等于设置了的这个值</code></p>
<h3 id="圆-circle元素"><a href="#圆-circle元素" class="headerlink" title="圆 - circle元素"></a>圆 - circle元素</h3><pre><code>&lt;circle cx=&quot;25&quot; cy=&quot;75&quot; r=&quot;20&quot;/&gt;
</code></pre><p>这个元素的属性很简单，主要是定义圆心和半径：</p>
<p>r：圆的半径。</p>
<p>cx：圆心坐标x值。</p>
<p>cy：圆心坐标y值。</p>
<h3 id="椭圆-ellipse元素"><a href="#椭圆-ellipse元素" class="headerlink" title="椭圆 - ellipse元素"></a>椭圆 - ellipse元素</h3><pre><code>&lt;ellipse cx=&quot;75&quot; cy=&quot;75&quot; rx=&quot;20&quot; ry=&quot;5&quot;/&gt;
</code></pre><p>这个是更加通用的圆形元素，你可以分别控制半长轴和半短轴的长度，来实现不同的椭圆，很容易想到，当两个半轴相等时，就是正圆形了。</p>
<p>rx：半长轴(x半径)。</p>
<p>ry：半短轴(y半径)。</p>
<p>cx：圆心坐标x值。</p>
<p>cy：圆心坐标y值。</p>
<h3 id="直线-line元素"><a href="#直线-line元素" class="headerlink" title="直线 - line元素"></a>直线 - line元素</h3><pre><code>&lt;line x1=&quot;10&quot; x2=&quot;50&quot; y1=&quot;110&quot; y2=&quot;150&quot;/&gt;
</code></pre><p>直线需要定义起点与终点即可：</p>
<p>x1：起点x坐标。</p>
<p>y1：起点y坐标。</p>
<p>x2：终点x坐标。</p>
<p>y2：终点y坐标。</p>
<h3 id="折线-polyline元素"><a href="#折线-polyline元素" class="headerlink" title="折线 - polyline元素"></a>折线 - polyline元素</h3><pre><code>&lt;polyline points=&quot;60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145&quot;/&gt;
</code></pre><p>折线主要是要定义每条线段的端点即可，所以只需要一个点的集合作为参数：</p>
<p>points：一系列的用空格，逗号，换行符等分隔开的点。每个点必须有2个数字：x值和y值。所以下面3个点 (0,0), (1,1)和(2,2)可以写成：”0 0, 1 1, 2 2”。</p>
<h3 id="多边形-polygon元素"><a href="#多边形-polygon元素" class="headerlink" title="多边形- polygon元素"></a>多边形- polygon元素</h3><pre><code>&lt;polygon points=&quot;50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180&quot;/&gt;
</code></pre><p>这个元素就是比polyline元素多做一步，把最后一个点和第一个点连起来，形成闭合图形。参数是一样的。</p>
<p>points：一系列的用空格，逗号，换行符等分隔开的点。每个点必须有2个数字：x值和y值。所以下面3个点 (0,0), (1,1)和(2,2)可以写成：”0 0, 1 1, 2 2”。<code>路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。</code></p>
<h3 id="路径-path元素"><a href="#路径-path元素" class="headerlink" title="路径 - path元素"></a>路径 - path元素</h3><pre><code>&lt;path d=&quot;M 20 230 Q 40 205, 50 230 T 90230&quot;/&gt;
</code></pre><p>这个是<code>最通用，最强力</code>的元素了；使用这个元素你可以实现<code>任何其他的图形</code>，不仅包括上面这些基本形状，也可以实现像贝塞尔曲线那样的复杂形状；此外，使用path可以实现平滑的过渡线段，虽然也可以使用polyline来实现这种效果，但是需要提供的点很多，而且放大了效果也不好。这个元素控制位置和形状的只有一个参数：</p>
<p>d：一系列绘制指令和绘制参数(点)组合成。</p>
<p>中间的字母的意思：</p>
<ul>
<li>M：moveTo <code>M10 10</code></li>
<li>L：lineTo <code>L10 10</code></li>
<li>H：H draws a horizontal line <code>H 90</code></li>
<li>V：V draws a vertical line <code>V 90</code></li>
<li>Z：ClosePath <code>Z</code></li>
<li>C：三次贝赛尔曲线 <code>C x1 y1, x2 y2, x y</code></li>
<li>S：<code>三次贝赛尔曲线</code>补充命令。S命令可以用来创建与之前那些曲线一样的贝塞尔曲线但是，如果S命令跟在一个C命令或者另一个S命令的后面，它的第一个控制点，就会被假设成前一个控制点的对称点。如果S命令单独使用，前面没有C命令或者另一个S命令，那么它的两个控制点就会被假设为同一个点。<code>S x2 y2, x y</code></li>
<li>Q：二次贝塞尔曲线 <code>Q x1 y1, x y</code></li>
<li>T：<code>三次贝赛尔曲线</code>补充命令。与<code>S</code>有异曲同工之妙。T命令前面必须是一个Q命令，或者是另一个T命令，才能达到这种效果。需要注意的是，如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。 <code>T x y</code></li>
<li>A：弧形命令 <code>A rx ry x-axis-rotation large-arc-flag sweep-flag x y</code> 前两个参数分别是x轴半径和y轴半径，第三个参数表示弧形的旋转情况。large-arc-flag（角度大小） 和sweep-flag（弧线方向），large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。最后两个参数是指定弧形的终点</li>
</ul>
<p><code>L,H,V为小写的时候便表示的是长度，为大写的表示的是坐标</code></p>
<p><strong>绘制指令分为绝对坐标指令和相对坐标指令两种，这两种指令使用的字母是一样的，就是大小写不一样，绝对指令使用大写字母，坐标也是绝对坐标；相对指令使用对应的小写字母，点的坐标表示的都是偏移量。</strong></p>
<h3 id="绝对坐标绘制指令"><a href="#绝对坐标绘制指令" class="headerlink" title="绝对坐标绘制指令"></a>绝对坐标绘制指令</h3><p>这组指令的参数代表的是绝对坐标。假设当前画笔所在的位置为(x0,y0)，则下面的绝对坐标指令代表的含义如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/8678448-34dca01adedda6a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="SVG画笔与填充"><a href="#SVG画笔与填充" class="headerlink" title="SVG画笔与填充"></a>SVG画笔与填充</h2><h3 id="边框色-stroke属性"><a href="#边框色-stroke属性" class="headerlink" title="边框色 - stroke属性"></a>边框色 - stroke属性</h3><p>这个属性使用设置的值画图形的边框，使用起来也很直接，把颜色值赋给它就可以了。<code>注意：</code></p>
<ol>
<li>如果不提供stroke属性，则默认不绘制图形边框。</li>
<li>可以设置边的透明度，就是<code>stroke-opacity</code>，值的范围是0到1。</li>
<li>使用stroke-width定义描边的宽度</li>
</ol>
<p>实际上，边的情况比图形内部稍微复杂一点，因为边除了颜色，还有”形状”需要定义。</p>
<p><strong>线的端点 - stroke-linecap属性</strong><br>这个属性定义了线段端点的风格，这个属性可以使用<code>butt,square,round</code>三个值。<br><img src="http://upload-images.jianshu.io/upload_images/8678448-a564c2c9197cf95e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enter image description here"></p>
<p><strong>线的连接 - stroke-linejoin属性</strong><br>这个属性定义了线段连接处的风格，这个属性可以使用miter,round,bevel三个值。</p>
<p><strong>线的虚实 - stroke-dasharray属性</strong><br>这个属性可以设置线段采用何种虚实线。这个属性是设置一些列数字，不过这些数字必须是逗号隔开的。属性中当然可以包含空格，但是空格不作为分隔符。每个数字定义了实线段的长度，分别是按照绘制、不绘制这个顺序循环下去。<code>需要注意两个只与三个值的情况</code></p>
<p><strong>stroke-miterlimit</strong><br>这个和canvas中的一样，它处理什么时候画和不画线连接处的miter效果。</p>
<p><strong>stroke-dashoffset</strong><br>这个属性设置开始画虚线的位置</p>
<h3 id="填充色-fill属性"><a href="#填充色-fill属性" class="headerlink" title="填充色 - fill属性"></a>填充色 - fill属性</h3><p>这个属性使用设置的颜色填充图形内部，使用很简单，直接把颜色值赋给这个属性就可以了。<br>注意事项：</p>
<ol>
<li>如果不提供fill属性，则默认会使用黑色填充,如果要取消填充，需要设置成none。</li>
<li>可以设置填充的透明度，就是<code>fill-opacity</code>，值的范围是0到1。</li>
<li>稍微复杂一点的是fill-rule属性。这个属性定义了判断点是不是属于填充范围的算法；除了inherit这个值外，还有两个取值： <ul>
<li><strong>nonzero</strong>：这个值采用的算法是：从需要判定的点向任意方向发射线，然后计算图形与线段交点的处的走向；计算结果从0开始，每有一个交点处的线段是从左到右的，就加1；每有一个交点处的线段是从右到左的，就减1；这样计算完所有交点后，如果这个计算的结果不等于0，则该点在图形内，需要填充；如果该值等于0，则在图形外，不需要填充。</li>
<li><strong>evenodd</strong>：这个值采用的算法是：从需要判定的点向任意方向发射线，然后计算图形与线段交点的个数，个数为奇数则改点在图形内，需要填充；个数为偶数则点在图形外，不需要填充。</li>
</ul>
</li>
</ol>
<h3 id="使用CSS展示数据"><a href="#使用CSS展示数据" class="headerlink" title="使用CSS展示数据"></a>使用CSS展示数据</h3><p>当然，你也可以直接使用css来修改这些样式</p>
<h2 id="SVG颜色的表示"><a href="#SVG颜色的表示" class="headerlink" title="SVG颜色的表示"></a>SVG颜色的表示</h2><p>SVG和canvas中是一样的，都是使用标准的HTML/CSS中的颜色表示方法，这些颜色都可以用于fill和stroke属性。</p>
<p>基本有下面这些定义颜色的方式：</p>
<ol>
<li>颜色名字： 直接使用颜色名字red, blue, black…</li>
<li>rgba/rgb值： 这个也很好理解，例如#ff0000,rgba(255,100,100,0.5)。</li>
<li>十六进制值： 用十六进制定义的颜色，例如#ffffff。</li>
<li>渐变值：这个也与canvas中一样，支持两种渐变色：线性渐变，环形渐变。</li>
<li>图案填充：使用自定义的图案作为填充色。</li>
</ol>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>使用linearGradient元素即可定义线性渐变，每一个渐变色成分使用<code>stop</code>元素定义。<br><img src="http://upload-images.jianshu.io/upload_images/8678448-1f20273cc74862ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><code>注意：</code></p>
<ul>
<li>使用stop定义</li>
<li>渐变代码需要放在<code>&lt;defs&gt;</code>标签中</li>
<li>必须使用id命名</li>
<li>使用url(#id)赋值</li>
</ul>
<h4 id="线性：linearGradient"><a href="#线性：linearGradient" class="headerlink" title="线性：linearGradient"></a>线性：linearGradient</h4><p><strong>offset属性</strong>：这个和线性渐变的值是一样，但是含义不一样。在环形渐变中，0%代表圆心处，这个很好理解。</p>
<p><strong>x1=”0” x2=”0” y1=”0” y2=”1”</strong>：四个属性决定渐变的方向</p>
<h4 id="径向：radialGradient"><a href="#径向：radialGradient" class="headerlink" title="径向：radialGradient"></a>径向：radialGradient</h4><p><strong>cx,cy,r属性</strong>：其实也很好理解，环形渐变，当然要定义环的圆心和半径了，体会一下上面例子中圆的大小和位置就能理解了。</p>
<p><strong>fx,fy属性</strong>：定义颜色中心(焦点)处的位置，也就是渐变色最浓处的坐标</p>
<p>不过这里需要注意一下上面cx,cy,r,fx,fy的值，你会发现它们都是小数，那么单位是什么呢？</p>
<p>这个需要先了解另外一个相关的属性：<strong>gradientUnits</strong>，它定义了定义渐变色使用的坐标单位。这个属性有2个可用值：<strong>userSpaceOnUse</strong>和<strong>objectBoundingBox</strong>。</p>
<p><strong>objectBoundingBox</strong>是默认值，它使用的坐标都是相对于对象包围盒的(方形包围盒，不是方形包围盒的情况比较复杂，略过)，取值范围是0到1。例如上例中的cx,cy的坐标值(0.25,0.25)。意味着这个圆心是在包围盒的左上角1/4处，半径0.25意味着半径长是对象方形包围盒长的1/4，就像你们图中看到的那样。</p>
<p><strong>userSpaceOnUse</strong>表示使用的是绝对坐标，使用这个设置的时候，你必须要保证渐变色和填充的对象要保持在一个位置。</p>
<p><strong>spreadMethod属性</strong>：这个属性定义了渐变色到达它的终点时应该采取的行为。该属性有3个可选值：<code>pad(默认值),reflect,repeat</code>。pad不用说了，属于自然过渡，渐变色结束以后，使用最后一个成员色直接渲染对象剩下的部分。refect会让渐变色继续，只不过渐变色会反向继续渲染，从最后一个颜色开始到第一个颜色这个顺序渲染；等到再次到达渐变色终点时，再反序，如此这般指导对象填充完毕。repeat也会让渐变色继续渲染，但是不会反序，还是一遍一遍从第一种颜色到最后一种颜色渲染</p>
<h3 id="纹理填充"><a href="#纹理填充" class="headerlink" title="纹理填充"></a>纹理填充</h3><p>例子看起来很简单，<code>由渐变色创建pattern</code>，然后使用pattern<br>填充矩形。这里需要注意：</p>
<ol>
<li>不同的浏览器填充这个pattern的时候效果不一样。</li>
<li>pattern也需要定义id。</li>
<li>pattern也必须要定义在defs中。</li>
<li>pattern的使用也是把url(#id)直接赋值给fill或stroke。</li>
</ol>
<h2 id="SVG文本与图像"><a href="#SVG文本与图像" class="headerlink" title="SVG文本与图像"></a>SVG文本与图像</h2><h3 id="SVG中渲染文本"><a href="#SVG中渲染文本" class="headerlink" title="SVG中渲染文本"></a>SVG中渲染文本</h3><p><strong>直接显示在图片中文本  -text元素</strong><br>直接显示文本可以使用text元素<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&lt;svg&gt;</span><br><span class="line">	&lt;<span class="built_in">rect</span> <span class="built_in">width</span>=<span class="string">"300"</span> <span class="built_in">height</span>=<span class="string">"200"</span> <span class="built_in">fill</span>=<span class="string">"red"</span> /&gt;</span><br><span class="line">	&lt;<span class="built_in">circle</span> r=<span class="string">"80"</span> cx=<span class="string">"150"</span> cy=<span class="string">"100"</span> <span class="built_in">fill</span>=<span class="string">"green"</span> /&gt;</span><br><span class="line">	&lt;<span class="built_in">text</span> x=<span class="string">"150"</span> y=<span class="string">"125"</span> font-<span class="built_in">size</span>=<span class="string">"60"</span> <span class="built_in">text</span>-anchor=<span class="string">"middle"</span> <span class="built_in">fill</span>=<span class="string">"white"</span>&gt;SVG&lt;/<span class="built_in">text</span>&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></p>
<p>如上面的例子中所示，text元素可以设置下列的属性：</p>
<ul>
<li>x,y是文本位置坐标。</li>
<li>text-anchor是文本显示的方向，其实也就是位置(x,y)处于文本的位置。这个属性有<code>start,middle,end和inherit</code>三种值。</li>
<li>start表示文本位置坐标(x,y)位于文本的开始处，文本从这点开始向右挨个显示。</li>
<li>middle表示(x,y)位于文本中间处，文本向左右两个方向显示，其实就是居中显示。</li>
<li>end表示(x,y)点位于文本结尾，文本向左挨个显示。</li>
</ul>
<p>除了这些属性，下面的这些属性都既可以在CSS中指定，也可以直接在属性中指定:</p>
<ul>
<li>fill,stroke：填充和描边颜色，具体使用在后面总结。</li>
<li>font的相关属性：font-family, font-style, font-weight, font-variant, font-stretch, font-size, font-size-adjust, kerning, letter-spacing, word-spacing 和 text-decoration。</li>
</ul>
<p><strong>文本区间 - tspan元素 </strong><br>这个元素是text元素的强力补充；它用于渲染一个区间内的文本；它只能出现在text元素或者tspan元素的子元素中。典型的用法就是强调显示部分文本。例如：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tspan</span> <span class="attr">font-weight</span>=<span class="string">"bold"</span> <span class="attr">fill</span>=<span class="string">"red"</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">tspan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>tspan元素可以设置一下的属性：</p>
<ul>
<li>x,y：设置包含的文本的绝对坐标值，这个值会覆盖默认的文本位置</li>
<li>dx,dy：设置包含的文本相对于默认的文本位置的偏移量</li>
<li>rotate：设置字体的旋转角度</li>
<li>textLength：给出字符串的计算长度</li>
</ul>
<p><strong>文本引用 - tref元素</strong><br>这个元素允许引用定义过的文本，并高效的拷贝到当前位置，通常配合<code>xlink:href</code>指定目的元素。因为是拷贝过来的，所以使用css修改当前文本的时候，不会修改原来的文本。</p>
<p><strong>文本路径 - textPatch元素</strong><br>这个比较有意思，效果也很酷，能做出很多的艺术效果；这个元素从它的xlink:href属性获取指定的路径并把文本对齐到这个路径上</p>
<h2 id="SVG坐标与变换"><a href="#SVG坐标与变换" class="headerlink" title="SVG坐标与变换"></a>SVG坐标与变换</h2><h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p>SVG存在两套坐标系统：视窗坐标系与用户坐标系。默认情况下，用户坐标系与视窗坐标系的点是一一对应的，都为原点在视窗的左上角，x轴水平向右，y轴竖直向下；<br>SVG的视窗位置一般是由CSS指定，尺寸由SVG元素的属性width和height设置</p>
<p><strong>视窗</strong>：指的是网页上面可视的矩形局域，长度和宽度都是有限的，这个区域一般与外围对象的尺寸有关。</p>
<p><strong>视窗坐标系</strong>：本质是一个坐标系，有原点，x轴与y轴；而且在两个方向上是无限延伸的。默认情况下，原点在视窗的左上角，x轴水平向右，y轴竖直向下。<strong>可以对这个坐标系的点进行变换。</strong></p>
<p><strong>用户坐标系</strong>：本质是一个坐标系，有原点，x轴与y轴；而且在两个方向上是无限延伸的。默认情况下，原点在视窗的左上角，x轴水平向右，y轴竖直向下。<strong>可以对这个坐标系的点进行变换。</strong></p>
<h3 id="坐标空间变换"><a href="#坐标空间变换" class="headerlink" title="坐标空间变换"></a>坐标空间变换</h3><p>视窗空间变换由相关元素(这些元素创建了新的视窗)的属性<strong><code>viewBox</code></strong>控制；用户空间变换由图形元素的<strong><code>transform</code></strong>属性控制。视窗空间变换应用于对应的整个视窗，用户空间变换应用于当前元素及其子元素。</p>
<h3 id="视窗变换-viewBox属性"><a href="#视窗变换-viewBox属性" class="headerlink" title="视窗变换 - viewBox属性"></a>视窗变换 - viewBox属性</h3><p>viewBox属性值的格式为(x0,y0,u_width,u_height)，每个值之间用逗号或者空格隔开，它们共同确定了视窗显示的区域：视窗左上角坐标设为(x0,y0)、视窗的宽设为u_width，高为u_height；这个变换对整个视窗都起作用。</p>
<h3 id="用户坐标系的变换-transform属性"><a href="#用户坐标系的变换-transform属性" class="headerlink" title="用户坐标系的变换 - transform属性"></a>用户坐标系的变换 - transform属性</h3><p>这个与css中的translate，rotate，skew，scale一样。同样可以一起使用</p>
<h2 id="SVG的重用与引用"><a href="#SVG的重用与引用" class="headerlink" title="SVG的重用与引用"></a>SVG的重用与引用</h2><h3 id="组合-g元素"><a href="#组合-g元素" class="headerlink" title="组合- g元素"></a>组合- g元素</h3><p>g元素是一种容器，它组合一组相关的图形元素成为一个整体；这样，我们就可以对这个整体进行操作。这个元素通常可以和desc和title元素配合使用，提供文档的结构信息。结构良好的文档通常可读性和渲染效率都不错。</p>
<p><code>注意几点：</code></p>
<ol>
<li><p>xmlns=”<a href="http://www.w3.org/2000/svg&quot;表明了整个svg元素默认的命名空间是svg。这个在无歧义的时候可以省略。这里由于svg文档是一个XML文档，XML命名空间的相关规则这里都是适用的。例如可以给svg显示的指定命名空间，给命名空间提供别名等。" target="_blank" rel="noopener">http://www.w3.org/2000/svg&quot;表明了整个svg元素默认的命名空间是svg。这个在无歧义的时候可以省略。这里由于svg文档是一个XML文档，XML命名空间的相关规则这里都是适用的。例如可以给svg显示的指定命名空间，给命名空间提供别名等。</a></p>
</li>
<li><p>g元素是可以嵌套的。</p>
</li>
<li><p>组合起来的图形元素就和单个的元素一样，可以给id值，这样，需要的时候(例如动画和重用一组元素)只用引用这个id值就可以了。</p>
</li>
<li><p>组合一组图形元素可以统一设置这组元素的相关属性(fill,stroke,transform等)，这也是使用组合的一种场景。</p>
</li>
</ol>
<h3 id="基础变形"><a href="#基础变形" class="headerlink" title="基础变形"></a>基础变形</h3><h4 id="平移：translate-x-y"><a href="#平移：translate-x-y" class="headerlink" title="平移：translate(x,y)"></a>平移：translate(x,y)</h4><p>两个参数，如果没有第二个参数，则默认赋值为0。</p>
<h4 id="旋转：rotate-angle"><a href="#旋转：rotate-angle" class="headerlink" title="旋转：rotate(angle)"></a>旋转：rotate(angle)</h4><p>一个参数，参数指旋转的度数</p>
<h4 id="斜切：skewX-与skewY"><a href="#斜切：skewX-与skewY" class="headerlink" title="斜切：skewX()与skewY()"></a>斜切：skewX()与skewY()</h4><p>每个需要一角度以确定元素斜切到多远。</p>
<h4 id="scale"><a href="#scale" class="headerlink" title="scale()"></a>scale()</h4><p>它需要两个数字，作为比率计算如何缩放。0.5表示收缩到50%。如果第二个数字被忽略了，它默认等于第一个值。</p>
<p>利用刚刚介绍的<code>&lt;g&gt;</code>元素，把这些东西变成一个整体。可以对整体进行操作</p>
<p><code>如果使用了变形，你会在元素内部建立了一个新的坐标系统，应用了这些变形，你为该元素和它的子元素指定的单位可能不是1:1像素映射。但是依然会根据这个变形进行歪曲、斜切、转换、缩放操作。</code></p>
<p><code>SVG可以嵌套SVG</code></p>
<h3 id="剪切与遮罩"><a href="#剪切与遮罩" class="headerlink" title="剪切与遮罩"></a>剪切与遮罩</h3><p><strong>clipPath</strong>：剪切。<code>clipPath的这一部分区域才会被显示</code><br><strong>mask</strong>：遮罩</p>
<h3 id="用opacity定义透明度"><a href="#用opacity定义透明度" class="headerlink" title="用opacity定义透明度"></a>用opacity定义透明度</h3><p>opacity：<br>fill-opacity：<br>stroke-opacity：<br><code>当然，你可以使用CSS样式来修饰</code></p>
<h3 id="SVG中渲染图片-image元素"><a href="#SVG中渲染图片-image元素" class="headerlink" title="SVG中渲染图片 - image元素"></a>SVG中渲染图片 - image元素</h3><p>使用<code>xlink:href</code>插入图片路径<br><code>注意</code>：<br>如果你没有设置x属性或y属性，它们自动被设置为0。</p>
<p>如果你没有设置height属性或width属性，它们自动被设置为0。</p>
<p>如果width属性或height等于0，将不会呈现这个图像。</p>
<h3 id="模板-symbol元素"><a href="#模板-symbol元素" class="headerlink" title="模板 - symbol元素"></a>模板 - symbol元素</h3><p>symbol元素用于定义图形模板(模板可以包含很多图形)，<strong>这个模板可以被use元素实例化</strong>。模板的功能与g元素很相似，都是提供一组图形对象，但是也有一些区别。与g元素不同的地方是：</p>
<p>1.symbol元素本身是不会被渲染的，只有symbol模板的实例会被渲染。</p>
<p>2.symbol元素可以拥有属性viewBox和preserveAspectRatio，这些允许symbol缩放图形元素。</p>
<p>从渲染角度来说，与symbol元素相似的元素是marker(定义箭头和标号)和pattern(定义颜色)元素；这些元素不会直接被渲染；他们的使用方式基本都是由use元素去实例化。正是这个原因，<strong>对于symbol来说，’display’属性是没有意义的。</strong></p>
<h3 id="定义-defs元素"><a href="#定义-defs元素" class="headerlink" title="定义 - defs元素"></a>定义 - defs元素</h3><p>SVG允许定义一组对象，然后重用这组对象(注意，不仅仅是图形对象)。最常见的例子如定义渐变色，然后再其他的图形对象中赋给fill属性。渐变色定义的时候是不会渲染的，所以这类型的对象可以放到任何地方。重用对于图形对象中也是经常存在的，而且我们也不希望定义的时候直接渲染，而是想在引用的地方渲染，这个可以用defs元素实现。</p>
<p>两种使用：一种是使用fill填充。另一个是使用use元素连接</p>
<h3 id="引用-use元素"><a href="#引用-use元素" class="headerlink" title="引用 - use元素"></a>引用 - use元素</h3><p>任何svg, symbol, g, 单个的图形元素和use元素本质上都可以作为模板对象被use元素引用(例如初始化)。use引用的图形内容会在指定的位置渲染。与image元素不同，use元素不能引用整个文档。<br>use元素也有x, y, width和height属性，这些属性可以省略，如果不省略的话，会将被引用的图形内容坐标或长度映射到当前的用户坐标空间来。</p>
<h3 id="基本操作API"><a href="#基本操作API" class="headerlink" title="基本操作API"></a>基本操作API</h3><ul>
<li>创建图形：<ul>
<li>document.createElementNS(ns,tagName)  <code>ns是什么呢？就是 这个  &quot;http://www.w3.org/2000/svg&quot;   tagName值 svg rect，circle等</code></li>
</ul>
</li>
<li>添加图形：<ul>
<li>appendChild</li>
</ul>
</li>
<li>设置/获取属性：<ul>
<li>setAttribute</li>
<li>getAttribute</li>
</ul>
</li>
</ul>
<h3 id="SVG-SMIL-animation"><a href="#SVG-SMIL-animation" class="headerlink" title="SVG SMIL animation"></a>SVG <a href="https://www.w3.org/TR/REC-smil/" target="_blank" rel="noopener">SMIL</a> animation</h3><p>SMIL是Synchronized Multimedia Integration Language（同步多媒体集成语言）的首字母缩写简称</p>
<p>SMIL允许你做下面这些事情：</p>
<ul>
<li>动画元素的数值属性（X, Y, …）</li>
<li>动画属性变换（平移或旋转）</li>
<li>动画颜色属性</li>
<li><code>沿着运动路径运动</code></li>
</ul>
<h4 id="五大元素"><a href="#五大元素" class="headerlink" title="五大元素"></a>五大元素</h4><ol>
<li>set</li>
<li>animate</li>
<li>animateColor ：以废弃，使用animate实现</li>
<li>animateTransform</li>
<li>animateMotion</li>
</ol>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><code>set</code>意思设置，此元素没有动画效果。你可能会疑问了，既然这个元素没有动画效果，怎么会是animation五大成员之一呢？</p>
<p>OK, 这样的，虽然set虽然不能触发连续的动画，但是，其还是可以实现基本的延迟功能。就是指：可以在特定时间之后修改某个属性值（也可以是CSS属性值）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"320"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">g</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">font-family</span>=<span class="string">"microsoft yahei"</span> <span class="attr">font-size</span>=<span class="string">"120"</span> <span class="attr">y</span>=<span class="string">"160"</span> <span class="attr">x</span>=<span class="string">"160"</span>&gt;</span></span><br><span class="line">      马</span><br><span class="line">      <span class="tag">&lt;<span class="name">set</span> <span class="attr">attributeName</span>=<span class="string">"x"</span> <span class="attr">attributeType</span>=<span class="string">"XML"</span> <span class="attr">to</span>=<span class="string">"60"</span> <span class="attr">begin</span>=<span class="string">"3s"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="animate"><a href="#animate" class="headerlink" title="animate"></a>animate</h4><p>基础动画元素。实现单属性的动画过渡效果。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"320"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">g</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">font-family</span>=<span class="string">"microsoft yahei"</span> <span class="attr">font-size</span>=<span class="string">"120"</span> <span class="attr">y</span>=<span class="string">"160"</span> <span class="attr">x</span>=<span class="string">"160"</span>&gt;</span></span><br><span class="line">    马</span><br><span class="line">      <span class="tag">&lt;<span class="name">animate</span> <span class="attr">attributeName</span>=<span class="string">"x"</span> <span class="attr">from</span>=<span class="string">"160"</span> <span class="attr">to</span>=<span class="string">"60"</span> <span class="attr">begin</span>=<span class="string">"0s"</span> <span class="attr">dur</span>=<span class="string">"3s"</span> <span class="attr">repeatCount</span>=<span class="string">"indefinite"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="animateTransform"><a href="#animateTransform" class="headerlink" title="animateTransform"></a>animateTransform</h4><p>一看就知道实现transform变换动画效果的。知识是一脉相承的，这里的transform变换与CSS3的transform变换</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"320"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">g</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">font-family</span>=<span class="string">"microsoft yahei"</span> <span class="attr">font-size</span>=<span class="string">"80"</span> <span class="attr">y</span>=<span class="string">"100"</span> <span class="attr">x</span>=<span class="string">"100"</span>&gt;</span>马<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">animateTransform</span> <span class="attr">attributeName</span>=<span class="string">"transform"</span> <span class="attr">begin</span>=<span class="string">"0s"</span> <span class="attr">dur</span>=<span class="string">"3s"</span>  <span class="attr">type</span>=<span class="string">"scale"</span> <span class="attr">from</span>=<span class="string">"1"</span> <span class="attr">to</span>=<span class="string">"1.5"</span> <span class="attr">repeatCount</span>=<span class="string">"indefinite"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="animateMotion"><a href="#animateMotion" class="headerlink" title="animateMotion"></a>animateMotion</h4><p>animateMotion元素可以让SVG各种图形沿着特定的path路径运动</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&lt;svg <span class="built_in">width</span>=<span class="string">"360"</span> <span class="built_in">height</span>=<span class="string">"200"</span> xmlns=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span><br><span class="line">  &lt;<span class="built_in">text</span> font-family=<span class="string">"microsoft yahei"</span> font-<span class="built_in">size</span>=<span class="string">"40"</span> x=<span class="string">"0"</span> y=<span class="string">"0"</span> <span class="built_in">fill</span>=<span class="string">"#cd0000"</span>&gt;马</span><br><span class="line">    &lt;animateMotion path=<span class="string">"M10,80 q100,120 120,20 q140,-50 160,0"</span> <span class="built_in">begin</span>=<span class="string">"0s"</span> dur=<span class="string">"3s"</span> repeatCount=<span class="string">"indefinite"</span>/&gt;</span><br><span class="line">  &lt;/<span class="built_in">text</span>&gt;</span><br><span class="line">  &lt;path d=<span class="string">"M10,80 q100,120 120,20 q140,-50 160,0"</span> <span class="built_in">stroke</span>=<span class="string">"#cd0000"</span> <span class="built_in">stroke</span>-<span class="built_in">width</span>=<span class="string">"2"</span> <span class="built_in">fill</span>=<span class="string">"none"</span> /&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<h4 id="自由组合"><a href="#自由组合" class="headerlink" title="自由组合"></a>自由组合</h4><h4 id="SVG-animation-参数"><a href="#SVG-animation-参数" class="headerlink" title="SVG animation 参数"></a>SVG animation 参数</h4><ol>
<li>attributeName = “attributeName”<br>要变化的元素属性名称，① 可以是元素直接暴露的属性，例如，对于本文反复出现的「马」对应的text元素上的x, y或者font-size; ② 可以是CSS属性。例如，透明度opacity</li>
<li>attributeType = “CSS | XML | auto”<br>attributeType支持三个固定参数，CSS/XML/auto. 用来表明attributeName属性值的列表。x, y以及transform就属于XML, opacity就属于CSS. auto为默认值，自动判别的意思（实际上是先当成CSS处理，如果发现不认识，直接XML类别处理）。因此，如果你不确信某属性是XML类别还是CSS类别的时候，我的建议是不设置attributeType值，直接让浏览器自己去判断，几乎无差错。<code>那么疑问来了：“既然浏览器酱可以自己判断属性类别，那这个属性还有什么意义吗？”我琢磨着，可能某些属性，XML能其作用，CSS也能其作用，例如font-size, 此时就需要明确下归属。</code></li>
<li>from, to, by, values<br>上面4个属性是一个家族的，是最具哲理的一个家族。他们解决的是非常有哲理的问题：你从哪里来？要到哪里去？</li>
</ol>
<ul>
<li>from = “value“：动画的起始值。</li>
<li>to = “value“：指定动画的结束值。</li>
<li>by = “value“：动画的相对变化值。</li>
<li>values = “list”：用分号分隔的一个或多个值，可以看出是动画的多个关键值点。</li>
</ul>
<p><code>四个之间的约束</code>：<br><strong>a.</strong> 如果动画的起始值与元素的默认值是一样的，from参数可以省略。<br><strong>b.</strong> （不考虑values）to,by两个参数至少需要有一个出现。否则动画效果没有。to表示绝对值，by表示相对值。拿位移距离，如果from是100, to值为160则表示移动到160这个位置，但是，如果by值是160，则表示移动到100+160=260这个位置。<br><strong>c.</strong> 如果to,by同时出现，则by打酱油，只识别to.<br><strong>d.</strong> 如果to,by,values都没设置，自然没动画效果。如果任意（包括from）一个属性的值不合法，规范上说是没有动画效果。但是，经测试，FireFox浏览器确实如此，但是Chrome特意做了写容错处理。例如，本来是数值的属性，写了个诸如a这个不合法的值，其会当作0来处理，动画效果依然存在。<br><strong>e.</strong> values可以是一个值或多值。根据在Chrome浏览器下的测试，是一个值的时候是没有动画效果。多值时候有动画效果。<code>当values值设置并能识别时候，from, to, by的值都会被忽略。</code>那values属性是干什么的呢？别看名字挺大众的，其还是有些功力的。我们实现动画，不可能就是单纯的从a位置到b位置，有时候，需要去c位置过渡下。此时，实际上有3个动画关键点。而from, to/by只能驾驭两个，此时就是values大显身手的时候了！<br><code>总结下，也就是from-to动画、from-by动画、to动画、by动画以及values动画。</code></p>
<ol start="4">
<li>begin, end<br><code>begin</code>的定义是分号分隔的一组值。看到没？是一组值，单值只是其中的情况之一。例如，beigin=”3s;5s”表示的是3s之后动画走一下，6s时候动画再走一下（如果之前动画没走完，会立即停止从头开始）</li>
<li>dur<br>dur属性值比begin简单了好几层楼，就后面两种：常规时间值 | “indefinite”.</li>
</ol>
<p>“常规时间值”就是3s之类的正常值；”indefinite”指事件无限。试想下，动画时间无限，实际上就是动画压根不执行的意思。因此，设置为”indefinite”跟没有dur是一个意思，与dur解析异常一个意思。</p>
<ol start="6">
<li>calcMode, keyTimes, keySplines<br>这几个参数是控制动画先快还是先慢类似这样作用的。</li>
</ol>
<p>calcMode属性支持4个值：discrete | linear | paced | spline. 中文意思分别是：“离散”|“线性”|“踏步”|“样条”。</p>
<p>discrete<br>from值直接跳到to值。</p>
<p>linear<br>animateMotion元素以外元素的calcMode默认值。动画从头到尾的速率都是一致的。</p>
<p>paced<br>通过插值让动画的变化步调平稳均匀。仅支持线性数值区域内的值，这样点之间“距离”的概念才能被计算（如position, width, height等）。如果”paced“指定，任何keyTimes或keySplines值都会打酱油。</p>
<p>spline <code>谷歌不兼容</code><br>插值定义贝塞尔曲线。spline点的定义在keyTimes属性中，每个时间间隔控制点由keySplines定义。</p>
<p>keyTimes = “list”<br>跟上面提到的list类似，都是分号分隔一组值。keyTimes总名字上看是关键时间点的意思，大致就是这个意思。前面提到过values也是多值，这里有一些约定的规则：首先，keyTimes值的数目要和values一致，如果是from/to/by动画，keyTimes就必须有两个值。然后对于linear和spline动画，第一个数字要是0, 最后一个是1。 最后，每个连续的时间值必须比它前面的值大或者相等。</p>
<p>paced模式下，keyTimes会被忽略；keyTimes定义错误，也会被忽略；dur为indefinite也会被忽略。</p>
<p>keySplines = “list”<br>keySplines表示的是与keyTimes相关联的一组贝塞尔控制点（默认0 0 1 1）。每个控制点使用4个浮点值表示：x1 y1 x2 y2. 只有模式是spline时候这个参数才有用，也是分号分隔，值范围0~1，总是比keyTimes少一个值。</p>
<p>如果keySplines值不合法或个数不对，是没有动画效果的。</p>
<ol start="7">
<li>repeatCount, repeatDur<br>repeatCount表示动画执行次数，可以是合法数值或者”indefinite“（动画循环到电脑死机）。</li>
</ol>
<p>repeatDur定义重复动画的总时间。可以是普通时间值或者”indefinite（”动画循环到电脑死机）。</p>
<ol start="8">
<li><p>fill<br>fill表示动画间隙的填充方式。支持参数有：freeze | remove. 其中remove是默认值，表示动画结束直接回到开始的地方。freeze“冻结”表示动画结束后像是被冻住了，元素保持了动画结束之后的状态。</p>
</li>
<li><p>accumulate, additive<br>accumulate是累积的意思。支持参数有：none | sum. 默认值是none. 如果值是sum表示动画结束时候的位置作为下次动画的起始位置。</p>
</li>
</ol>
<p>additive控制动画是否附加。支持参数有：replace | sum. 默认值是replace. 如果值是sum表示动画的基础知识会附加到其他低优先级的动画上，</p>
<ol start="10">
<li>restart<br>restart这个属性诞生的背景如下：很多动画呢，其触发可能与事件相关，例如，点击某圆圈，马儿就跑。而且，似乎没点一次，马儿就跑一下。现在，存在这种情况，希望马儿只跑一次，之后在点击就没有反应。这种需求的出现迫使restart参数的出现。支持的参数有：always | whenNotActive | never.</li>
</ol>
<p>always是默认值，表示总是，也就是点一次圈圈，马儿跑一下。whenNotActive表示动画正在进行的时候，是不能重启动画的。never表示动画是一波流。</p>
<ol start="11">
<li>min, max<br>min/max表示动画执行最短和最长时间。支持参数为时间值和”media”（媒介元素有效）, max还支持indefinite.</li>
</ol>
<h4 id="动画的暂停与播放"><a href="#动画的暂停与播放" class="headerlink" title="动画的暂停与播放"></a>动画的暂停与播放</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// svg指当前svg DOM元素</span></span><br><span class="line"><span class="comment">// 暂停</span></span><br><span class="line">svg.pauseAnimations();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重启动</span></span><br><span class="line">svg.unpauseAnimations()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5响应式布局</title>
    <url>/%E6%8A%80%E6%9C%AF/HTML5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80.html</url>
    <content><![CDATA[<h2 id="什么是响应式网页设计（布局）"><a href="#什么是响应式网页设计（布局）" class="headerlink" title="什么是响应式网页设计（布局）"></a>什么是响应式网页设计（布局）</h2><p><strong><code>响应式网页设计</code></strong>(Responsive Web design，通常缩写为RWD)是指：页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整。可以说是一种网页设计的技术做法，该设计可使网站在多种浏览设备（从桌面电脑显示器到移动电话或其他移动产品设备）上阅读和导航，同时减少缩放、平移和滚动。<br><code>响应式网页设计就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。</code></p>
<h2 id="响应式布局的实现"><a href="#响应式布局的实现" class="headerlink" title="响应式布局的实现"></a>响应式布局的实现</h2><h3 id="1-Meta标签定义"><a href="#1-Meta标签定义" class="headerlink" title="1. Meta标签定义"></a>1. Meta标签定义</h3><p>使用<code>viewport meta</code>标签在手机上控制布局</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1&quot; /&gt;
</code></pre><p>隐藏状态栏</p>
<pre><code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;blank&quot; /&gt;
</code></pre><p>iPhone会将看起来像是电话号码的数字添加链接，需要关闭</p>
<pre><code>&lt;meta name=&quot;format-detection content=&quot;telephone=no&quot; /&gt;
</code></pre><h3 id="2-使用Media-Queries适配对应样式"><a href="#2-使用Media-Queries适配对应样式" class="headerlink" title="2.使用Media Queries适配对应样式"></a>2.使用Media Queries适配对应样式</h3><p>常用于布局的CSS Media Queries</p>
<h4 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h4><ul>
<li>all 所有设备；</li>
<li>screen 电脑显示器；</li>
<li>int 打印用纸或打印预览视图；</li>
<li>ndheld 便携设备；</li>
<li>电视机类型的设备；</li>
<li>eech 语意和音频盒成器；</li>
<li>aille 盲人用点字法触觉回馈设备； </li>
<li>bossed 盲文打印机；</li>
<li>ojection 各种投影设备；</li>
<li>tty 使用固定密度字母栅格的媒介，比如电传打字机和终端。<h4 id="设备特性"><a href="#设备特性" class="headerlink" title="设备特性"></a>设备特性</h4></li>
<li>width 浏览器宽度；</li>
<li>height 浏览器高度；</li>
<li>device-width 设备屏幕分辨率的宽度值；</li>
<li>device-height 设备屏幕分辨率的高度值；</li>
<li>orientation 浏览器窗口的方向纵向还是横向，当窗口的高度值大于等于宽度时该特性值为portrait，否则为landscape；</li>
<li>aspect-ratio 比例值，浏览器的纵横比；</li>
<li>device-aspect-ratio 比例值，屏幕的纵横比。</li>
</ul>
<h3 id="实现响应式布局"><a href="#实现响应式布局" class="headerlink" title="实现响应式布局"></a>实现响应式布局</h3><p>通过媒体查询<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@media screen <span class="keyword">and</span> (<span class="built_in">max</span>-<span class="built_in">width</span>:<span class="number">320</span>px) &#123; &#125; </span><br><span class="line">@media screen <span class="keyword">and</span> (<span class="built_in">min</span>-<span class="built_in">width</span>:<span class="number">320</span>px) <span class="keyword">and</span> (<span class="built_in">max</span>-<span class="built_in">width</span>:<span class="number">640</span>px) &#123; &#125;</span><br><span class="line">样式表也可以引入外部的</span><br><span class="line">@<span class="keyword">import</span> url(<span class="string">"css/demo.css"</span>) screen <span class="keyword">and</span> (<span class="built_in">min</span>-<span class="built_in">width</span>:<span class="number">320</span>px) <span class="keyword">and</span> (<span class="built_in">max</span>-<span class="built_in">width</span>:<span class="number">640</span>px);</span><br><span class="line">@media screen <span class="keyword">and</span> (<span class="built_in">min</span>-<span class="built_in">width</span>:<span class="number">640</span>px) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，工作中是使用的外部样式表<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">"stylesheet"</span> <span class="attribute">type</span>=<span class="string">"text/css"</span> <span class="attribute">href</span>=<span class="string">"a.css"</span>  <span class="attribute">media</span>=<span class="string">"screen and (min-width: 1000px)"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">"stylesheet"</span> <span class="attribute">type</span>=<span class="string">"text/css"</span> <span class="attribute">href</span>=<span class="string">"b.css"</span>  <span class="attribute">media</span>=<span class="string">"screen and (min-width: 600px) and (max-width: 1000px)"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">"stylesheet"</span> <span class="attribute">type</span>=<span class="string">"text/css"</span> <span class="attribute">href</span>=<span class="string">"c.css"</span>   <span class="attribute">media</span>=<span class="string">"screen and (max-width: 600px)"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>也许，你需要让手机的屏幕横着，比如你在玩<code>王者荣耀</code><br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">竖屏- 屏幕宽度小于高度</span><br><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">"stylesheet"</span> <span class="attribute">media</span>=<span class="string">"all and (orientation:portrait)"</span> <span class="attribute">href</span>=<span class="string">"portrait.css"</span>&gt;</span><br><span class="line"></span><br><span class="line">横屏-屏幕宽度大于高度</span><br><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">"stylesheet"</span> <span class="attribute">media</span>=<span class="string">"all and (orientation:landscape)"</span> <span class="attribute">href</span>=<span class="string">"portrait.css"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="响应式布局缺点和优点"><a href="#响应式布局缺点和优点" class="headerlink" title="响应式布局缺点和优点"></a>响应式布局缺点和优点</h3><ul>
<li><p>优点：面对不同分辨率设备，灵活性强，能够快捷地解决设备显示适应问题。</p>
</li>
<li><p>缺点：兼容各种设备时所需工作量大、效率低下、代码累赘，会隐藏无用的元素，加载时间延长，其实这是一种折中性质的设计解决方案，由于多方面元素影响而达不到最佳效果，在一定程度上改变了网站原有的布局结构，会出现用户混淆的情况。</p>
</li>
</ul>
<h3 id="这里有一个很严重的缺点"><a href="#这里有一个很严重的缺点" class="headerlink" title="这里有一个很严重的缺点"></a>这里有一个很严重的缺点</h3><p>由于PC端和移动终端访问的是同一个网站，PC端可以不计较流量限制，但是移动端不可能不计较。 </p>
<p>这里主要是针对于<code>图片</code>的使用，为适配不同终端机型的屏幕宽度和像素密度，我们一般会使用如下方法设置图片的CSS样式：</p>
<pre><code>&lt;style&gt;
    img{
        max-width:100%;
        height:auto;
    }
&lt;/style&gt;
</code></pre><p>将图片的最大宽度设置为100%，以确保图像不会超出其父级元素的宽度，如果父级元素的宽度发生改变，图片的宽度也随之改变，height：auto 可以确保图片的宽度发生改变时，图片的高度会依据自身的宽高比例进行缩放。<br>这样当我们在移动设备上访问响应式网页里的图片时，只是把图片的分辨率做了缩放，下载的还是PC端的那张大图，这样不仅浪费流量，而且浪费带宽，而且会拖慢网页的打开速度，严重影响用户的使用体验。</p>
<h3 id="解决方案：-lt-picture-gt"><a href="#解决方案：-lt-picture-gt" class="headerlink" title="解决方案：&lt;picture&gt;"></a>解决方案：<code>&lt;picture&gt;</code></h3><p>如下栗子中针对不同屏幕宽度加载不同的图片；当页面宽度 在320px到640px之间时加载minpic.png；当页面宽度大于640px时加载middle.png</p>
<pre><code>&lt;picture&gt;
    &lt;source media=&quot;(min-width: 320px) and (max-width: 640px)&quot; srcset=&quot;img/minpic.png&quot;&gt;
    &lt;source media=&quot;(min-width: 640px)&quot; srcset=&quot;img/middle.png&quot;&gt;
    &lt;img src=&quot;img/picture.png&quot; alt=&quot;this is a picture&quot;&gt;
&lt;/picture&gt;
</code></pre><p>如下例子中添加了屏幕的方向作为条件；当屏幕方向为横屏方向时加载_landscape.png结尾的图片；当屏幕方向为竖屏方向时加载 _portrait.png结尾的图片；</p>
<pre><code>&lt;picture&gt;
    &lt;source media=&quot;(min-width: 320px) and (max-width: 640px) and (orientation: landscape)&quot; srcset=&quot;img/minpic_landscape.png&quot;&gt;
    &lt;source media=&quot;(min-width: 320px) and (max-width: 640px) and (orientation: portrait)&quot; srcset=&quot;img/minpic_portrait.png&quot;&gt;
    &lt;source media=&quot;(min-width: 640px) and (orientation: landscape)&quot; srcset=&quot;img/middlepic_landscape.png&quot;&gt;
    &lt;source media=&quot;(min-width: 640px) and (orientation: portrait)&quot; srcset=&quot;img/middlepic_portrait.png&quot;&gt;
    &lt;img src=&quot;img/picture.png&quot; alt=&quot;this is a picture&quot;&gt;
&lt;/picture&gt;
</code></pre>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>css-transform</title>
    <url>/%E6%8A%80%E6%9C%AF/css-transform.html</url>
    <content><![CDATA[<h2 id="transform-2D变换"><a href="#transform-2D变换" class="headerlink" title="transform 2D变换"></a>transform 2D变换</h2><h3 id="rotate旋转，只有一个参数"><a href="#rotate旋转，只有一个参数" class="headerlink" title="rotate旋转，只有一个参数"></a>rotate旋转，只有一个参数</h3><pre><code>单位角度：deg
</code></pre><h3 id="scale缩放"><a href="#scale缩放" class="headerlink" title="scale缩放"></a>scale缩放</h3><ul>
<li>一个参数：水平和垂直同时缩放<br>  transform:scale(1.1)</li>
<li>两个参数：第一个参数指定水平方向的缩放倍率，第二个参数指定垂直方向的缩放倍率。<br>可以是负数，如果是负数则会图片翻转<h3 id="translate位移"><a href="#translate位移" class="headerlink" title="translate位移"></a>translate位移</h3></li>
<li>一个值表示X轴的位移，两个值表示X轴Y轴<h3 id="skew倾斜"><a href="#skew倾斜" class="headerlink" title="skew倾斜"></a>skew倾斜</h3></li>
<li>一个参数时：表示水平方向的倾斜角度；</li>
<li>两个参数时：第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度。<br>水平方向对应垂直方向的角，垂直方向对应方向的角<br><code>skew的默认原点transform-origin是这个物件的中心点</code></li>
</ul>
<h2 id="变换基点"><a href="#变换基点" class="headerlink" title="变换基点"></a>变换基点</h2><h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><ul>
<li>默认基点为中心点，可以通过关键词设置坐标值或关键词改变基点</li>
</ul>
<h3 id="perspective-origin景深基点-在什么方位去看"><a href="#perspective-origin景深基点-在什么方位去看" class="headerlink" title="perspective-origin景深基点 在什么方位去看"></a>perspective-origin景深基点 在什么方位去看</h3><h3 id="多方法组合变形"><a href="#多方法组合变形" class="headerlink" title="多方法组合变形"></a>多方法组合变形</h3><p>上面我们介绍了使用transform对元素进行旋转、缩放、倾斜、移动的方法，这里讲介绍综合使用这几个方法来对一个元素进行多重变形。</p>
<blockquote>
<p>用法：transform: rotate(45deg) scale(0.5) skew(30deg, 30deg) translate(100px, 100px);</p>
</blockquote>
<p>这四种变形方法顺序可以随意，但<strong><code>不同的顺序导致变形结果不同</code></strong>，原因是变形的顺序是从左到右依次进行，这个用法中的执行顺序为1.rotate  2.scalse  3.skew  4.translate<br>并且，每个变形之间<strong><code>用“空格”分隔符，而不是“，”</code></strong>。</p>
<h2 id="transform-3D变换"><a href="#transform-3D变换" class="headerlink" title="transform 3D变换"></a>transform 3D变换</h2><h3 id="变换风格transform-style"><a href="#变换风格transform-style" class="headerlink" title="变换风格transform-style"></a>变换风格transform-style</h3><ul>
<li>flat：没有3D效果。不是默认值。这个值<code>js</code>改变值的时候用</li>
<li>preserve-3d：子元素将有3D的效果<h3 id="perspective景深，近大远小"><a href="#perspective景深，近大远小" class="headerlink" title="perspective景深，近大远小"></a>perspective景深，近大远小</h3></li>
</ul>
<p>景深给爷爷，风格给父亲</p>
<h3 id="3D-属性"><a href="#3D-属性" class="headerlink" title="3D 属性"></a>3D 属性</h3><h4 id="3D位移：CSS3中的3D位移主要包括translateZ-和translate3d-两个功能函数；"><a href="#3D位移：CSS3中的3D位移主要包括translateZ-和translate3d-两个功能函数；" class="headerlink" title="3D位移：CSS3中的3D位移主要包括translateZ()和translate3d()两个功能函数；"></a>3D位移：CSS3中的3D位移主要包括translateZ()和translate3d()两个功能函数；</h4><blockquote>
<p>translate3d(tx,ty,tz)</p>
</blockquote>
<p>其属性值取值说明如下：</p>
<p>tx：代表横向坐标位移向量的长度；<br>ty：代表纵向坐标位移向量的长度；<br>tz：代表Z轴位移向量的长度。此值不能是一个百分比值，如果取值为百分比值，将会认为无效值。</p>
<h4 id="3D旋转：CSS3中的3D旋转主要包括rotateX-、rotateY-、rotateZ-和rotate3d-四个功能函数；"><a href="#3D旋转：CSS3中的3D旋转主要包括rotateX-、rotateY-、rotateZ-和rotate3d-四个功能函数；" class="headerlink" title="3D旋转：CSS3中的3D旋转主要包括rotateX()、rotateY()、rotateZ()和rotate3d()四个功能函数；"></a>3D旋转：CSS3中的3D旋转主要包括rotateX()、rotateY()、rotateZ()和rotate3d()四个功能函数；</h4><blockquote>
<p>scale3d(sx,sy,sz)</p>
</blockquote>
<p>sx：横向缩放比例；<br>sy：纵向缩放比例；<br>sz：Z轴缩放比例；</p>
<h4 id="3D缩放：CSS3中的3D缩放主要包括scaleZ-和scale3d-两个功能函数；"><a href="#3D缩放：CSS3中的3D缩放主要包括scaleZ-和scale3d-两个功能函数；" class="headerlink" title="3D缩放：CSS3中的3D缩放主要包括scaleZ()和scale3d()两个功能函数；"></a>3D缩放：CSS3中的3D缩放主要包括scaleZ()和scale3d()两个功能函数；</h4><blockquote>
<p>rotate3d(x,y,z,a)</p>
</blockquote>
<p>x：是一个0到１之间的数值，主要用来描述元素围绕X轴旋转的矢量值；<br>y：是一个０到１之间的数值，主要用来描述元素围绕Y轴旋转的矢量值；<br>z：是一个０到１之间的数值，主要用来描述元素围绕Z轴旋转的矢量值；<br>a：是一个角度值，主要用来指定元素在3D空间旋转的角度，如果其值为正值，元素顺时针旋转，反之元素逆时针旋转。</p>
<p><code>下面介绍的三个旋转函数功能等同：</code></p>
<p>rotateX(a)函数功能等同于rotate3d(1,0,0,a)<br>rotateY(a)函数功能等同于rotate3d(0,1,0,a)<br>rotateZ(a)函数功能等同于rotate3d(0,0,1,a)</p>
<h4 id="3D矩阵：CSS3中3D变形中和2D变形一样也有一个3D矩阵功能函数matrix3d-。"><a href="#3D矩阵：CSS3中3D变形中和2D变形一样也有一个3D矩阵功能函数matrix3d-。" class="headerlink" title="3D矩阵：CSS3中3D变形中和2D变形一样也有一个3D矩阵功能函数matrix3d()。"></a>3D矩阵：CSS3中3D变形中和2D变形一样也有一个3D矩阵功能函数matrix3d()。</h4>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3盒子模型</title>
    <url>/%E6%8A%80%E6%9C%AF/CSS3%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<h2 id="盒子阴影-box-shadow"><a href="#盒子阴影-box-shadow" class="headerlink" title="盒子阴影 box-shadow"></a>盒子阴影 box-shadow</h2><ul>
<li>h-shadow    必需。水平阴影的位置。允许负值。</li>
<li>v-shadow    必需。垂直阴影的位置。允许负值。</li>
<li>blur        可选。模糊距离。</li>
<li>spread    可选。阴影的尺寸。</li>
<li>color    可选。阴影的颜色。请参阅 CSS 颜色值。</li>
<li>inset    可选。将外部阴影 (outset) 改为内部阴影。</li>
</ul>
<h2 id="弹性盒子模型"><a href="#弹性盒子模型" class="headerlink" title="弹性盒子模型"></a>弹性盒子模型</h2><h3 id="display-flex"><a href="#display-flex" class="headerlink" title="display:flex"></a>display:flex</h3><p>给父级设置一个display:flex属性，子元素设置flex相关属性才可以自动分配宽高。</p>
<h3 id="flex-–-给需要设置弹性布局的子元素设置该属性"><a href="#flex-–-给需要设置弹性布局的子元素设置该属性" class="headerlink" title="flex  –  给需要设置弹性布局的子元素设置该属性"></a>flex  –  给需要设置弹性布局的子元素设置该属性</h3><ul>
<li><p>flex-grow：占父元素的剩余空间的多少<br>比如这个例子：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">ul</span> class=<span class="string">"flex"</span>&gt;</span><br><span class="line">    &lt;li&gt;a&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;b&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;c&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">.<span class="attribute">flex</span>&#123;display:flex;<span class="attribute">width</span>:<span class="number">600px</span>;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">list-style</span>:none;&#125;</span><br><span class="line"><span class="selector-class">.flex</span> <span class="selector-tag">li</span>:nth-child(<span class="number">1</span>)&#123;<span class="attribute">width</span>:<span class="number">200px</span>;&#125;</span><br><span class="line"><span class="selector-class">.flex</span> <span class="selector-tag">li</span>:nth-child(<span class="number">2</span>)&#123;<span class="attribute">flex-grow</span>:<span class="number">1</span>;<span class="attribute">width</span>:<span class="number">50px</span>;&#125;</span><br><span class="line"><span class="selector-class">.flex</span> <span class="selector-tag">li</span>:nth-child(<span class="number">3</span>)&#123;<span class="attribute">flex-grow</span>:<span class="number">3</span>;<span class="attribute">width</span>:<span class="number">50px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>  flex-grow的默认值为0，如果没有显示定义该属性，是不会拥有分配剩余空间权利的。<br>  本例中b,c两项都设置的定义了flex-grow，flex容器的剩余空间分成了4份，其中b占1份，c占3分，即1:3<br>  flex容器的剩余空间长度为：600-200-50-50=300px，所以最终a,b,c的长度分别为：<br>  a: 50+(300/4)=200px<br>  b: 50+(300/4<em>1)=125px<br>  a: 50+(300/4</em>3)=275px</p>
</li>
<li><p>flex-shrink： 默认值是1。占据超出父级容器的宽度的百分比。如果所有的子元素的宽度相加没有超过父级的在宽度，则次属性无效。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">ul</span> class=<span class="string">"flex"</span>&gt;</span><br><span class="line">    &lt;li&gt;a&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;b&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;c&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">.<span class="attribute">flex</span>&#123;display:flex;<span class="attribute">width</span>:<span class="number">400px</span>;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">list-style</span>:none;&#125;</span><br><span class="line"><span class="selector-class">.flex</span> li&#123;<span class="attribute">width</span>:<span class="number">200px</span>;&#125;</span><br><span class="line"><span class="selector-class">.flex</span> <span class="selector-tag">li</span>:nth-child(<span class="number">3</span>)&#123;<span class="attribute">flex-shrink</span>:<span class="number">3</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>  flex-shrink的默认值为1，如果没有显示定义该属性，将会自动按照默认值1在所有因子相加之后计算比率来进行空间收缩。<br>  本例中c显式的定义了flex-shrink，a,b没有显式定义，但将根据默认值1来计算，可以看到总共将剩余空间分成了5份，其中a占1份，b占1份，c占3分，即1:1:3<br>  我们可以看到父容器定义为400px，子项被定义为200px，相加之后即为600px，超出父容器200px。那么这么超出的200px需要被a,b,c消化<br>  通过收缩因子，所以加权综合可得200<em>1+200</em>1+200<em>3=1000px；<br>  于是我们可以计算a,b,c将被移除的溢出量是多少：<br>  a被移除溢出量：(200</em>1/1000)<em>200，即约等于40px<br>  b被移除溢出量：(200</em>1/1000)<em>200，即约等于40px<br>  c被移除溢出量：(200</em>3/1000)*200，即约等于120px<br>  最后a,b,c的实际宽度分别为：200-40=160px, 200-40=160px, 200-120=80px</p>
</li>
<li>flex-basis：和width一样，他的默认值为auto，把上面几个例子换成flex-basis也是一样的。工作中最好用flex-basis，更符合规范。</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>如果父级的空间足够：flex-grow有效，flex-shrink无效。</p>
<p>如果父级的空间不够：flex-shrink 有效，flex-grow无效。</p>
<p>flex属性是以上三者的集合，一般设置为flex：1</p>
<h3 id="其他属性，设置给父级元素"><a href="#其他属性，设置给父级元素" class="headerlink" title="其他属性，设置给父级元素"></a>其他属性，设置给父级元素</h3><ul>
<li>flex-wrap：wrap;子元素在必要的时候换行显示。默认值是<code>nowrap</code>，还有一个值是<code>wrap-reverse</code></li>
<li><p>flex-direction：规定主轴的方向（水平与垂直）</p>
<pre><code>row：主轴与行内轴方向作为默认的书写模式。即横向从左到右排列（左对齐）。
row-reverse：对齐方式与row相反。
column：主轴与块轴方向作为默认的书写模式。即纵向从上往下排列（顶对齐）。
column-reverse：对齐方式与column相反。
</code></pre></li>
</ul>
<hr>
<ul>
<li>flex-flow：<code>flex-wrap</code> <code>flex-direction</code>;</li>
</ul>
<hr>
<ul>
<li>align-content：设置子元素的整体对齐方式</li>
<li><p>此值必须子元素占据多行</p>
<pre><code>flex-start：各行向弹性盒容器的起始位置堆叠。弹性盒容器中第一行的侧轴起始边界紧靠住该弹性盒容器的侧轴起始边界，之后的每一行都紧靠住前面一行。
flex-end：各行向弹性盒容器的结束位置堆叠。弹性盒容器中最后一行的侧轴起结束界紧靠住该弹性盒容器的侧轴结束边界，之后的每一行都紧靠住前面一行。
center：各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一行之间的距离相等。（如果剩下的空间是负数，则各行会向两个方向溢出的相等距离。）
space-between：各行在弹性盒容器中平均分布。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于&apos;flex-start&apos;。在其它情况下，第一行的侧轴起始边界紧靠住弹性盒容器的侧轴起始内容边界，最后一行的侧轴结束边界紧靠住弹性盒容器的侧轴结束内容边界，剩余的行则按一定方式在弹性盒窗口中排列，以保持两两之间的空间相等。
space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于&apos;center&apos;。在其它情况下，各行会按一定方式在弹性盒容器中排列，以保持两两之间的空间相等，同时第一行前面及最后一行后面的空间是其他空间的一半。
stretch：各行将会伸展以占用剩余的空间。如果剩余的空间是负数，该值等效于&apos;flex-start&apos;。在其它情况下，剩余空间被所有行平分，以扩大它们的侧轴尺寸。    （默认值）
</code></pre></li>
</ul>
<hr>
<ul>
<li><p>align-items: 定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。</p>
<pre><code>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。
flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。
center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。
baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与&apos;flex-start&apos;等效。其它情况下，该值将参与基线对齐。
stretch：如果指定侧轴大小的属性值为&apos;auto&apos;，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照&apos;min/max-width/height&apos;属性的限制。
</code></pre></li>
</ul>
<hr>
<ul>
<li><p>justify-content：设置盒子在主轴方向上的对齐方式</p>
<pre><code>flex-start：弹性盒子元素将向行起始位置对齐。该行的第一个子元素的主起始位置的边界将与该行的主起始位置的边界对齐，同时所有后续的伸缩盒项目与其前一个项目对齐。
flex-end：弹性盒子元素将向行结束位置对齐。该行的第一个子元素的主结束位置的边界将与该行的主结束位置的边界对齐，同时所有后续的伸缩盒项目与其前一个项目对齐。
center：弹性盒子元素将向行中间位置对齐。该行的子元素将相互对齐并在行中居中对齐，同时第一个元素与行的主起始位置的边距等同与最后一个元素与行的主结束位置的边距（如果剩余空间是负数，则保持两端相等长度的溢出）。
space-between：弹性盒子元素会平均地分布在行里。如果最左边的剩余空间是负数，或该行只有一个子元素，则该值等效于&apos;flex-start&apos;。在其它情况下，第一个元素的边界与行的主起始位置的边界对齐，同时最后一个元素的边界与行的主结束位置的边距对齐，而剩余的伸缩盒项目则平均分布，并确保两两之间的空白空间相等。
space-around：弹性盒子元素会平均地分布在行里，两端保留子元素与子元素之间间距大小的一半。如果最左边的剩余空间是负数，或该行只有一个伸缩盒项目，则该值等效于&apos;center&apos;。在其它情况下，伸缩盒项目则平均分布，并确保两两之间的空白空间相等，同时第一个元素前的空间以及最后一个元素后的空间为其他空白空间的一半。
</code></pre></li>
</ul>
<h3 id="其他属性，设置给子元素"><a href="#其他属性，设置给子元素" class="headerlink" title="其他属性，设置给子元素"></a>其他属性，设置给子元素</h3><ul>
<li><p>align-self: 定义flex子项单独在侧轴（纵轴）方向上的对齐方式。取值与<code>align-items</code>一样。不过多了一个auto值：</p>
<pre><code>auto：如果&apos;align-self&apos;的值为&apos;auto&apos;，则其计算值为元素的父元素的&apos;align-items&apos;值，如果其没有父元素，则计算为&apos;stretch&apos;。
</code></pre></li>
</ul>
<hr>
<ul>
<li>order：设置弹性盒子的顺序</li>
</ul>
<h2 id="允许调整大小"><a href="#允许调整大小" class="headerlink" title="允许调整大小"></a>允许调整大小</h2><p>reisze：</p>
<pre><code>both
none
horizontal
vertical
</code></pre><h2 id="倒影"><a href="#倒影" class="headerlink" title="倒影"></a>倒影</h2><p>box-reflect：a b c；</p>
<pre><code>a:left/right/above/below
b:距离本体多远
c:遮盖层
</code></pre><h2 id="怪异盒子模型"><a href="#怪异盒子模型" class="headerlink" title="怪异盒子模型"></a>怪异盒子模型</h2><p>box-sizing</p>
<pre><code>content-box : 默认值 盒子总宽=内(width)+padding+border
border-box : 怪异盒模型 盒子的总宽=width，会对应得缩小内容部分
如果border+padding &gt; width，盒子总宽=border+padding，内容部分为0
</code></pre><h2 id="多列布局（加上兼容性前缀）"><a href="#多列布局（加上兼容性前缀）" class="headerlink" title="多列布局（加上兼容性前缀）"></a>多列布局（加上兼容性前缀）</h2><p>column-width：每列的最小宽度<br>column-count：列数<br>columns：<code>column-width</code> <code>column-count</code>；规定列的宽度和列数。<br>column-gap：列之间间隙的大小<br>column-rule：列之间的边框。值与border一样的<br>column-span：none/all    设置给子元素，规定这个元素跨不夸列</p>
<pre><code>// 下面两个只兼容谷歌
-webkit-column-break-before: 设置或检索对象之前是否断行。设定给子元素，子元素之前是否另起一列 auto/always/avoid
auto：既不强迫也不禁止在元素之前断行并产生新列
always：总是在元素之前断行并产生新列
avoid：避免在元素之前断行并产生新列
-webkit-column-break-after: 设定给子元素，子元素之后
</code></pre><h2 id="禁止文字选中"><a href="#禁止文字选中" class="headerlink" title="禁止文字选中"></a>禁止文字选中</h2><p>user-select：none；<br>-moz-user-select:none;<br>-ms-user-select:none;</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5表单</title>
    <url>/%E6%8A%80%E6%9C%AF/HTML5%E8%A1%A8%E5%8D%95.html</url>
    <content><![CDATA[<h2 id="新的输入型控件"><a href="#新的输入型控件" class="headerlink" title="新的输入型控件"></a>新的输入型控件</h2><ul>
<li>email：电子邮件</li>
<li>tel：电话号码</li>
<li>url：网页的url（需要带上http(s)://）</li>
<li>search：搜索引擎</li>
<li>range：数值控件，特定范围内的数值选择器<ul>
<li>min</li>
<li>max</li>
<li>step（步数）</li>
<li>value</li>
</ul>
</li>
</ul>
<h2 id="新的输入控件"><a href="#新的输入控件" class="headerlink" title="新的输入控件"></a>新的输入控件</h2><p>number  :  只能包含数字的输入框<br>color  :  颜色选择器<br>datetime  :  显示完整日期（chrome）<br>datetime-local  :  显示完整日期，不含时区<br>time  :  显示时间，不含时区<br>date  :    显示日期<br>week  :  显示周<br>month  :  显示月</p>
<h2 id="新的表单特性"><a href="#新的表单特性" class="headerlink" title="新的表单特性"></a>新的表单特性</h2><p>placeholder  :  输入框提示信息<br>autocomplete  :  是否保存用户输入值。默认为on，关闭提示选择off<br>autofocus  :  指定表单获取输入焦点 true<br>required  :  此项必填，不能为空<br>Pattern : 正则验证  pattern=”\d{1,5}“<br>Formaction 在submit里定义提交地址</p>
<h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p>validity对象，通过下面的valid可以查看验证是否通过，如果八种验证都通过返回true，一种验证失败返回false<br>oText.addEventListener(“invalid”,fn1,false);<br>ev.preventDefault()<br>valueMissing  :  输入值为空时     返回的是true<br>typeMismatch :  控件值与预期类型不匹配     返回的是true<br>patternMismatch  :  输入值不满足pattern正则     返回的是true<br>tooLong  :  超过maxLength最大限制     超出的返回的是true<br>rangeUnderflow : 验证的range最小值<br>rangeOverflow：验证的range最大值<br>stepMismatch: 验证range 的当前值 是否符合min、max及step的规则<br>customError 不符合自定义验证   是不是匹配 true<br>setCustomValidity(); 自定义验证<br>Invalid事件  :  验证反馈 input.addEventListener(‘invalid’,fn,false)<br>阻止默认验证：ev.preventDefault()<br>formnovalidate属性  :  关闭验证</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>过渡与动画</title>
    <url>/%E6%8A%80%E6%9C%AF/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html</url>
    <content><![CDATA[<h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><pre><code>transition：property duration delay timing-function
</code></pre><blockquote>
<p>transition-property：过渡属性的名称</p>
<blockquote>
<p>none：没有过渡属性<br>all：所有的属性都过渡(默认值)<br>property：具体的属性名称</p>
</blockquote>
</blockquote>
<blockquote>
<p>transition-duration：过渡属性花费的时间  s/ms<br>transition-delay：过渡效果延时时间  s/ms<br>transition-timing-function：过渡效果速度曲线</p>
<blockquote>
<p>linear / ease / ease-in / ease-out / ease-in-out</p>
</blockquote>
</blockquote>
<pre><code>过渡完成事件：
Webkit内核： obj.addEventListener(&apos;webkitTransitionEnd&apos;,function(){});
标准:  obj.addEventListener(&apos;transitionend&apos;,function(){});
</code></pre><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><pre><code>animation: name duration delay timing-function iteration-count direction;
</code></pre><blockquote>
<p>animation-name: 动画名称</p>
<blockquote>
<p>keyframename  自定义的名字<br>            none  无动画效果</p>
</blockquote>
</blockquote>
<blockquote>
<p>animation-duration: 动画执行时间<br>    animation-delay:动画效果延迟时间<br>    animation-timing-function: 动画速度曲线</p>
<blockquote>
<p>linear / ease / ease-in / ease-out / ease-in-out</p>
</blockquote>
</blockquote>
<blockquote>
<p>animation-iteration-count: 动画执行次数</p>
<blockquote>
<p>次数数值 / infinite无限重复</p>
</blockquote>
</blockquote>
<blockquote>
<p>animation-direction:动画执行方向</p>
<blockquote>
<p>normal正常/alternate  动画轮流反向播放</p>
</blockquote>
</blockquote>
<blockquote>
<p>animation-play-state:动画执行状态</p>
<blockquote>
<p>paused  暂停动画 / running  运行动画</p>
</blockquote>
</blockquote>
<blockquote>
<p>animation-fill-mode:动画执行过程效果是否可见</p>
<blockquote>
<p>none 不改变（默认）<br>        forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）<br>        backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）<br>    both 向前和向后填充模式都被应用，forwards 与backwards 的</p>
</blockquote>
</blockquote>
<pre><code>@keyframes:规定动画
@keyframes animationname {keyframes-selector {css-styles;}}
</code></pre><blockquote>
<p>animationname 定义动画的名称。<br>keyframes-selector 动画时长的百分比。</p>
<blockquote>
<p>0-100%<br>            from（与 0% 相同）<br>            to（与 100% 相同）<br>            可以只有to</p>
</blockquote>
</blockquote>
<blockquote>
<p>css-styles  一个或多个合法的 CSS 样式属性。</p>
</blockquote>
<pre><code>动画事件：

动画开始触发：obj.addEventListener(&quot;webkitAnimationStart&quot;, fn);
obj.addEventListener(&quot;animationstart&quot;, fn);
动画执行过程中触发：    obj.addEventListener(&quot;webkitAnimationIteration&quot;, fn);
obj.addEventListener(&quot;animationiteration&quot;, fn);
动画结束触发:obj.addEventListener(&apos;webkitAnimationEnd&apos;,fn);
obj.addEventListener(&apos;animationend&apos;,fn);
</code></pre><p>HTML5中的<code>requestAnimationFrame</code>动画优化</p>
<pre><code>window.requestAnimFrame = (function () {
    return window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    function (callback) {
        window.setTimeout(callback, 1000 / 60);
    };
})();
</code></pre>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>圆角与文本</title>
    <url>/%E6%8A%80%E6%9C%AF/%E5%9C%86%E8%A7%92%E4%B8%8E%E6%96%87%E6%9C%AC.html</url>
    <content><![CDATA[<h2 id="圆角-border-radius"><a href="#圆角-border-radius" class="headerlink" title="圆角 border-radius"></a>圆角 border-radius</h2><ul>
<li>如果是一个值，那么 top-left、top-right、bottom-right、bottom-left 四个值相等。 </li>
<li>如果是两个值，那么 top-left和bottom-right相等，为第一个值，top-right和bottom-left值相等，为第二个值。 </li>
<li>如果是三个值，那么第一个值是设置top-left，而第二个值是 top-right 和 bottom-left 并且他们会相等,第三个值是设置 bottom-right。 </li>
<li>如果是四个值，那么第一个值是设置 top-left， 而第二个值是 top-right 第三个值 bottom-right 第四个值是设置 bottom-left<br><code>border-radius可以单独指定水平和垂直半径，只需要用一个斜杠(水平/垂直)分割即可。</code><br><strong>除了上述的简写外，还可以和border一样，分别写四个角，如下：</strong><br>border-top-left-radius: //左上角<br>border-top-right-radius: //右上角<br>border-bottom-right-radius: //右下角<br>border-bottom-left-radius: //左下角<br>分别是水平方向和竖直方向半径，第二值省略的情况下，水平方向和竖直方向的半径相等</li>
</ul>
<h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><h3 id="white-space：空格、缩进、换行的处理方式"><a href="#white-space：空格、缩进、换行的处理方式" class="headerlink" title="white-space：空格、缩进、换行的处理方式"></a>white-space：空格、缩进、换行的处理方式</h3><pre><code>normal 默认 忽略多个空格/缩进/换行只留一个
nowrap 控制文本不换行
pre 空白/缩进/换行 会被浏览器保留
pre-line 合并空白/缩进  保留换行符
pre-wrap 保留空白/缩进  正常换行
</code></pre><h3 id="2-Word-wrap-break-word-与-word-break-break-all"><a href="#2-Word-wrap-break-word-与-word-break-break-all" class="headerlink" title="2.    Word-wrap:break-word 与 word-break:break-all"></a>2.    Word-wrap:break-word 与 word-break:break-all</h3><p>两者究竟有什么样的区别呢。我们看看官方的解释：</p>
<p><strong><code>word-wrap</code></strong><br><img src="https://user-gold-cdn.xitu.io/2018/11/22/1673953c8cde8d5f?w=887&amp;h=63&amp;f=jpeg&amp;s=10592" alt="word-wrap"></p>
<p><strong><code>word-break</code></strong><br><img src="https://user-gold-cdn.xitu.io/2018/11/22/1673953c8ceaa0da?w=647&amp;h=43&amp;f=jpeg&amp;s=6909" alt="word-break"></p>
<p>看看翻译后的：</p>
<blockquote>
<p>word-wrap:<br>css的 word-wrap 属性用来标明是否允许浏览器在单词内进行断句，这是为了防止当一个字符串太长而找不到它的自然断句点时产生溢出现象。<code>从上一个单词换行开始</code></p>
</blockquote>
<hr>
<blockquote>
<p>word-break:<br>css的 word-break 属性用来标明怎么样进行单词内的断句。<code>可以从上一个的结尾开始</code></p>
</blockquote>
<p><code>两者对中文无效</code></p>
<h3 id="文本书写模式"><a href="#文本书写模式" class="headerlink" title="文本书写模式"></a>文本书写模式</h3><p><code>direction</code>：规定文本的方向<br><code>unicode-bidi</code>：设置文本的方向</p>
<pre><code>direction: rtl =&gt; right to left
direction: ltr =&gt; left to rigth
unicode-bidi：bidi-override
</code></pre><hr>
<p><code>writing-mode</code>:设置或检索对象的内容块固有的书写方向</p>
<pre><code>horizontal-tb：水平方向自上而下的书写方式。即 left-right-top-bottom（类似IE私有值lr-tb）
vertical-rl：垂直方向自右而左的书写方式。即 top-bottom-right-left（类似IE私有值tb-rl）
vertical-lr：垂直方向自左而右的书写方式。即 top-bottom-left-right
lr-tb：左-右，上-下。对象中的内容在水平方向上从左向右流入，后一行在前一行的下面。 所有的字形都是竖直向上的。这种布局是罗马语系使用的（IE）
tb-rl：上-下，右-左。对象中的内容在垂直方向上从上向下流入，自右向左。后一竖行在前一竖行的左面。全角字符是竖直向上的，半角字符如拉丁字母或片假名顺时针旋转90度。这种布局是东亚语系通常使用的（IE）
</code></pre><h3 id="文本超出：text-overflow"><a href="#文本超出：text-overflow" class="headerlink" title="文本超出：text-overflow"></a>文本超出：text-overflow</h3><p>主要用于文本超出后显示省略号，结合white-space与overflow使用</p>
<pre><code>white-space:nowrap; /*文本不换行*/
overflow:hidden; /*超出隐藏*/
text-overflow:ellipsis; /*显示省略号*/
</code></pre><p>上面的是单行的显示，多行的显示省略号怎么弄呢？结合以下的几个属性</p>
<pre><code>display:-webkit-box;
-webkit-box-orient:vertical;
-webkit-line-clamp:5; /*设置文本显示的行数*/
</code></pre><p>当然，你也可以使用js实现</p>
<h3 id="文字阴影：text-shadow"><a href="#文字阴影：text-shadow" class="headerlink" title="文字阴影：text-shadow"></a>文字阴影：text-shadow</h3><p>参数：x轴偏移量 y轴偏移量 模糊度 颜色<br>例子：<br>浮雕例子：</p>
<pre><code>color:#fff;text-shadow:2px 2px 4px #000;
</code></pre><p>立体字：</p>
<pre><code>color:#fff;
text-shadow:0 1px 0 #ccc,0 2px 0 #9c9c9c,0 3px 0 #bbb,0 4px 0 #9b9b9b,0 5px 0 #aaa;
</code></pre><p>模糊字：</p>
<pre><code>color:rgba(0,0,0,0); text-shadow:0 0 20px blue;
</code></pre><p>霓虹灯：</p>
<pre><code>text-shadow:0px 0px 10px #f3c,0px 0px 20px #f39,0px 0px 40px #f33,0px 0px 60px #f30;
</code></pre><h3 id="文字描边、文字填充"><a href="#文字描边、文字填充" class="headerlink" title="文字描边、文字填充"></a>文字描边、文字填充</h3><p>text-stroke：宽度  颜色；   描边，加上兼容性前缀<br>text-stroke-width： 宽度<br>text-stroke-color： 颜色</p>
<p>text-fill-color: 颜色   </p>
<h3 id="文字大小写-text-transform"><a href="#文字大小写-text-transform" class="headerlink" title="文字大小写  text-transform"></a>文字大小写  text-transform</h3><p>四个值：</p>
<pre><code>none：默认值
capitaize：将每个单词的第一个字母转换为大写
uppercase：转换为大写
lowercase：转换为小写
</code></pre>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3背景</title>
    <url>/%E6%8A%80%E6%9C%AF/CSSS3%E8%83%8C%E6%99%AF.html</url>
    <content><![CDATA[<h2 id="CSS背景属性回顾"><a href="#CSS背景属性回顾" class="headerlink" title="CSS背景属性回顾"></a>CSS背景属性回顾</h2><p><strong><code>背景单个属性</code></strong></p>
<ul>
<li>background-image</li>
<li>background-color</li>
<li>background-repeat</li>
<li>background-position</li>
<li>background-attachment<br><strong><code>背景符合属性</code></strong></li>
<li>background<br><strong><code>注意：复合属性会覆盖前面的单个属性，反之则不会</code></strong></li>
</ul>
<h3 id="背景定位的扩展"><a href="#背景定位的扩展" class="headerlink" title="背景定位的扩展"></a>背景定位的扩展</h3><p>在CSS3中，背景定位得到了扩展，它允许我们指定背景图片在<strong>距离任意角的偏移量</strong>，只需要<strong>在偏移量前面指定关键字</strong></p>
<blockquote>
<p>background-position：right 20px bottom 10px;使用时单独设置。也可以使用background-origin：content-box实现</p>
</blockquote>
<h2 id="CSS3新增背景属性"><a href="#CSS3新增背景属性" class="headerlink" title="CSS3新增背景属性"></a>CSS3新增背景属性</h2><h3 id="背景尺寸：background-size"><a href="#背景尺寸：background-size" class="headerlink" title="背景尺寸：background-size"></a>背景尺寸：background-size</h3><ol>
<li><p>设置背景尺寸  <code>background-size</code><br>background-size:x y;        //水平 垂直；值可以为像素、百分比、auto等<br>background-size:cover;    //保持宽高比不变，保证占满盒子，但是不一定能看到全部图<br>backgroundsize:contain;        //保持宽高比不变，保证看清全图，但是不一定占满盒子</p>
</li>
<li><p>多背景 <code>background-image</code><br>background-image:url(1.jpg),url(2.jpg);    多个背景以逗号隔开，无限个数</p>
</li>
<li><p>背景起始区域  <code>background-origin</code><br>background-origin:border-box;    //从border区域起始<br>background-origin:padding-box;    //默认值，从padding区域起始<br>background-origin:content-box;    //从内容部分起始</p>
</li>
<li><p>背景显示区域 <code>background-clip</code>        //从什么地方看到图片<br> background-clip:border-box;    //默认值，从border区域开始显示背景<br> background-clip:padding-box;    //从padding区域开始显示背景<br> background-clip:content-box;    //从内部区域开始显示背景</p>
</li>
</ol>
<h2 id="新增颜色与背景渐变"><a href="#新增颜色与背景渐变" class="headerlink" title="新增颜色与背景渐变"></a>新增颜色与背景渐变</h2><h3 id="新增背景色"><a href="#新增背景色" class="headerlink" title="新增背景色"></a>新增背景色</h3><ol>
<li><code>rgb</code>：rgb为三原色，取值范围为0~255</li>
<li><code>hsl</code>：<code>H</code>：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 – 360，<code>S</code>：Saturation(饱和度)。取值为：0.0% - 100.0%，<code>L</code>：Lightness(亮度)。取值为：0.0% - 100.0%。 100%纯白色</li>
<li><code>rgba，hsla</code>：在上面的基础上多了一个a透明度数值，取值范围0~1，0为完全透明，1为完全不透明</li>
</ol>
<h3 id="渐变色"><a href="#渐变色" class="headerlink" title="渐变色"></a>渐变色</h3><ol>
<li>线性渐变：linear-gradient()</li>
<li>径向渐变：radial-gradient()</li>
</ol>
<p>线性渐变很简单，这里说一下经向渐变。<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标准写法</span></span><br><span class="line">radial-gradient([<span class="meta">[&lt;shape&gt;||&lt;size&gt;]</span>?[at &lt;position&gt;,]?&lt;color-stop&gt;[,&lt;color-stop&gt;]+)</span><br><span class="line"><span class="comment">//-webkit-老版本径向渐变的写法</span></span><br><span class="line">-webkit-radial-gradient(<span class="meta">[&lt;position&gt;||&lt;angle&gt;,]? [&lt;shape&gt;||&lt;size&gt;,]&gt;?&lt;color-stop&gt;[,&lt;color-stop&gt;]</span>+)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>径向渐变方式主要由position、shape、size这三个参数影响，分别控制椭圆的圆心、形状和大小</li>
<li>position：定义渐变的圆心。默认是center（X轴），center（Y轴），可以是left，right，center关键词，也可以是具体的数值，还可以是百分比。最后可以是单个值，另一个就默认是center</li>
<li>shape：定义渐变的形状是圆（circle）或者是椭圆（ellipse   默认）</li>
<li>size：定义渐变的大小、默认是farthest-corner。有四个值。<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">closest-<span class="string">side:</span>半径为从圆心到最近边</span><br><span class="line">closest-<span class="string">corner:</span>半径为从圆心到最近角</span><br><span class="line">farthest-<span class="string">side:</span>半径为从圆心到最远边</span><br><span class="line">farthest-<span class="string">side:</span>半径为从圆心到最远角</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>注意：在使用时需要加上 –webkit-兼容前缀
IE低版本兼容filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#39;#ffffff&#39;,endColorstr=&#39;#ff0000&#39;,GradientType=&#39;1&#39;)</code>.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5选择器</title>
    <url>/%E6%8A%80%E6%9C%AF/HTML5%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content><![CDATA[<h2 id="CSS选择器回顾"><a href="#CSS选择器回顾" class="headerlink" title="CSS选择器回顾"></a>CSS选择器回顾</h2><ul>
<li>ID选择器</li>
<li>类名选择器：多类（.class1.class2）不被<code>ie6</code>支持</li>
<li>标签（元素）选择器</li>
<li>组合（后代）选择器</li>
<li>通配符选择器</li>
<li>直接子元素选择器 <code>&gt;</code>：<code>ie6</code>不支持</li>
<li>相邻兄弟选择器 <code>+</code>：<code>ie6</code>不支持</li>
<li>属性选择器</li>
<li>伪元素选择器<br><img src="https://user-gold-cdn.xitu.io/2018/11/22/1673950ee03ea697?w=401&amp;h=136&amp;f=jpeg&amp;s=12837" alt="enter image description here"></li>
<li>伪类选择器<br><img src="https://user-gold-cdn.xitu.io/2018/11/22/1673950ee15ac671?w=431&amp;h=214&amp;f=jpeg&amp;s=22986" alt="enter image description here"></li>
</ul>
<h2 id="CSS新增选择器"><a href="#CSS新增选择器" class="headerlink" title="CSS新增选择器"></a>CSS新增选择器</h2><ol>
<li>通用兄弟（关联）选择器：<code>~</code>，选择后面的所有的子元素</li>
<li>属性选择器（新增的）：<ul>
<li><strong><code>E[attr~=&quot;value&quot;]</code></strong>：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写；</li>
<li><strong><code>E[attr^=&quot;value&quot;]</code></strong>：指定了属性名，并且有属性值，属性值是以value开头的；</li>
<li><strong><code>E[attr$=&quot;value&quot;]</code></strong>：指定了属性名，并且有属性值，而且属性值是以value结束的；</li>
<li><strong><code>E[attr*=&quot;value&quot;]</code></strong>：指定了属性名，并且有属性值，而且属值中包含了value；</li>
<li><strong><code>E[attr|=&quot;value&quot;]</code></strong>：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn）;</li>
<li><code>注意：IE6不支持所有的属性选择器</code></li>
</ul>
</li>
<li><p><code>:nth</code>选择器</p>
<ul>
<li><strong>:first-child</strong> 选择某个元素的第一个子元素；</li>
<li><strong>:last-child</strong> 选择某个元素的最后一个子元素；</li>
<li><p><strong>:nth-child()</strong> 选择某个元素的一个或多个特定的子元素；</p>
<pre><code> :nth-child(length);/*参数是具体数字*/
:nth-child(n);/*参数是n,n从0开始计算*/
:nth-child(n*length)/*n的倍数选择，n从0开始算*/
:nth-child(n+length);/*选择大于length后面的元素*/
:nth-child(-n+length)/*选择小于length前面的元素*/
:nth-child(n*length+1);/*表示隔几选一*/
//上面length为整数
</code></pre></li>
<li><p><strong>:nth-last-child()</strong> 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算；</p>
<pre><code>其实这种使用和:nth-child使用是一样的，也可以使用:nth-child的那些表达式和使用方法，唯一不同的是这种指定了元素的类型而以。
</code></pre></li>
<li><p><strong>:nth-of-type()</strong> 选择指定的元素；</p>
</li>
<li><strong>:nth-last-of-type()</strong> 选择指定的元素，从元素的最后一个开始计算；</li>
<li><strong>:first-of-type</strong> 选择一个上级元素下的第一个同类子元素；</li>
<li><strong>:last-of-type</strong> 选择一个上级元素的最后一个同类子元素；</li>
<li><strong>:only-child</strong> 选择的元素是它的父元素的唯一一个了元素；</li>
<li><strong>:only-of-type</strong> 选择一个元素是它的上级元素的唯一一个相同类型的子元素</li>
<li><strong>:empty</strong> 选择的元素里面没有任何内容</li>
<li><strong>:not</strong> 否定选择器</li>
</ul>
</li>
<li><p>UI元素状态伪类<br>我们把<code>&quot;:enabled&quot;,&quot;:disabled&quot;,&quot;:checked&quot;</code>伪类称为UI元素状态伪类，这些主要是针对于HTML中的Form元素操作，最常见的比如我们<strong>“type=”text”</strong>有enable和disabled两种状态，前者为可写状态后者为不可状态；另外<strong>“type=”radio”</strong>和<strong>“type=”checkbox”</strong>有”checked”和”unchecked”两种状态。来看两个实例，比如说你想将”disabled”的文本框与别的文本框区别出来，你就可以这样应用</p>
<pre><code>input[type=&quot;text&quot;]:disabled {border:1px solid #999;background-color: #fefefe;}
</code></pre></li>
</ol>
<p><strong><code>注意：IE6-8不支持&quot;:checked&quot;,&quot;:enabled&quot;,&quot;:disabled&quot;这三种选择器。著作权归作者所有。</code></strong></p>
<ol start="5">
<li>伪元素新增</li>
</ol>
<ul>
<li><code>::selection</code> 选择被用户选中的input：注意是选中，不是获得焦点</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5语法,标签,属性</title>
    <url>/%E6%8A%80%E6%9C%AF/HTML5%E8%AF%AD%E6%B3%95-%E6%A0%87%E7%AD%BE-%E5%B1%9E%E6%80%A7.html</url>
    <content><![CDATA[<h2 id="HTML-5的语法"><a href="#HTML-5的语法" class="headerlink" title="HTML 5的语法"></a>HTML 5的语法</h2><p>html5相对于以前的html（html4，xhtml等）更加简洁更加的人性化。主要体现在一下几个方面：</p>
<ol>
<li>文档申明：DOCTYPE</li>
<li>字符编码：charset</li>
<li>不区分大小写了：DIV标签与div标签一样</li>
<li>布尔值：主要是关于input等的checked=”checked”属性</li>
<li>可以省略引号：属性的引号可以省略</li>
<li>可以进行标签的省略：大多数标签可以省略，不过不建议</li>
</ol>
<h2 id="HTML-5新增-删除标签"><a href="#HTML-5新增-删除标签" class="headerlink" title="HTML 5新增/删除标签"></a>HTML 5新增/删除标签</h2><h3 id="新增的标签"><a href="#新增的标签" class="headerlink" title="新增的标签"></a>新增的标签</h3><p>主要分为以下几个方面：</p>
<ul>
<li>结构标签</li>
<li>表单标签</li>
<li>媒体标签</li>
<li>其他功能标签 </li>
</ul>
<h4 id="结构标签"><a href="#结构标签" class="headerlink" title="结构标签"></a>结构标签</h4><ol>
<li>header：定义整个文档的头部区域或者是一篇文章的头部区域</li>
<li>section：表示页面中的一个内容区块，比如页眉、页脚或页面的其他部分</li>
<li>article：定义页面独立（与上下文不相关）的文章内容</li>
<li>aside：表示article标签内容之外，与article标签内容相关的辅助信息</li>
<li>hgroup：对整个页面或者是页面中的一个区块的标题进行组合使用</li>
<li>nav：表示页面中的导航链接的部分</li>
<li>figure：表示一段独立的内容，一般表示一个独立的单元，使用figcaption为figure添加标题，写出来有点像定义列表</li>
<li>footer：定义整个文档的尾部区域或者是一篇文章的尾部区域</li>
</ol>
<h4 id="媒体标签"><a href="#媒体标签" class="headerlink" title="媒体标签"></a>媒体标签</h4><p>大致包含：</p>
<ol>
<li>video：视频</li>
<li>audio：音频</li>
<li>embed：嵌入内容（包括各种媒体），Midi、Wav、AU、MP3、Flash、AIFF等。<br><code>这里不做过多的说明</code></li>
</ol>
<h4 id="表单控件标签"><a href="#表单控件标签" class="headerlink" title="表单控件标签"></a>表单控件标签</h4><ol>
<li>email：必须输入邮件；</li>
<li>url：必须输入url地址；</li>
<li>number：必须输入数值；</li>
<li>range：必须输入一定范围内的数值；</li>
<li>Date Pickers：日期选择器；<ul>
<li>date：选取日、月、年</li>
<li>month：选取月、年</li>
<li>week：选取周和年</li>
<li>time：选取时间（小时和分钟）</li>
<li>datetime：选取时间、日、月、年（UTC时间）</li>
<li>datetime-local：选取时间、日、月、年（本地时间）</li>
</ul>
</li>
<li>search：搜索常规的文本域；</li>
<li>color：颜色<br><code>这里不做过多的说明</code></li>
</ol>
<h4 id="其他功能标签"><a href="#其他功能标签" class="headerlink" title="其他功能标签"></a>其他功能标签</h4><ol>
<li>mark：凸显文字</li>
<li>meter： 标签定义度量衡。仅用于已知最大和最小值的度量。</li>
<li>progress：定义运行中的进度（进程）。</li>
<li>ruby：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">ruby</span>&gt;</span>月明<span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>つきあ<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span>かり昇る頃<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>灯る <span class="tag">&lt;<span class="name">ruby</span>&gt;</span>赤提灯 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>あかちょうちん<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p></p><p><ruby>月明<rp>(</rp><rt>つきあ</rt><rp>)</rp></ruby>かり昇る頃</p><p></p>
<p></p><p>灯る <ruby>赤提灯 <rp>(</rp><rt>あかちょうちん</rt><rp>)</rp></ruby></p><p></p>
<ol start="5">
<li><p>details：显示详情</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">summary</span>&gt;</span>选择详细的信息<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>datalist：下拉选框，有点像select，不过还是有区别</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">list</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"宝马"</span>&gt;</span>宝马<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"奔驰"</span>&gt;</span>奔驰<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"劳斯莱斯"</span>&gt;</span>劳斯莱斯<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="删除的标签"><a href="#删除的标签" class="headerlink" title="删除的标签"></a>删除的标签</h3><p>1、能用css代替的元素<br>basefont、big、center、font、s、strike、tt、u。这些元素纯粹是为画面展示服务的，HTML5中提倡把画面展示性功能放在css中统一编辑。</p>
<p>2、不再使用frame框架。</p>
<p>frameset、frame、noframes。HTML5中不支持frame框架，只支持iframe框架，或者用服务器方创建的由多个页面组成的符合页面的形式，删除以上这三个标签。</p>
<p>3、只有部分浏览器支持的元素</p>
<p>applet、bgsound、blink、marquee等标签。</p>
<p>4、其他被废除的元素</p>
<p>废除rb，使用ruby替代。</p>
<p>废除acronym使用abbr替代。</p>
<p>废除dir使用ul替代。</p>
<p>废除isindex使用form与input相结合的方式替代</p>
<p>废除listing使用pre替代</p>
<p>废除xmp使用code替代</p>
<p>废除nextid使用guids</p>
<p>废除plaintex使用“text/plian”（无格式正文）MIME类型替代。</p>
<h3 id="新增的属性"><a href="#新增的属性" class="headerlink" title="新增的属性"></a>新增的属性</h3><h4 id="对于js进行添加的属性。"><a href="#对于js进行添加的属性。" class="headerlink" title="对于js进行添加的属性。"></a>对于js进行添加的属性。</h4><p>`<script defer src=".....js" onload="alert('a')"></script></p>
<p><script async src=".....js" onload="alert('b')"></script>`</p>
<p>如果没有以上两个属性的话，执行顺序为先加载（下载）第一个src，然后在执行其onload，然后在向下依次同步执行defer属性在h5之前就已经有了，输入延迟加载（推迟执行），它会先加载（下载）src中文件内容，然后等页面全部加载完成后，再加载onload中js.async属性属于异步加载，它会在加载src后，立即执行onload,同时还会继续加载页面以上执行顺序，alert显示会先显示b然后再显示a</p>
<h4 id="网页中标签中加入小图标的样式代码"><a href="#网页中标签中加入小图标的样式代码" class="headerlink" title="网页中标签中加入小图标的样式代码"></a>网页中标签中加入小图标的样式代码</h4><p><code>&lt;link rel=&quot;icon&quot; href=&quot;url...&quot; type=&quot;图片名称&quot; sizes=&quot;16*16&quot;&gt;</code><br>有序列表ol:新增start（列表起始值），reversed（是否倒置）menu菜单type属性（3个菜单类型）内嵌css样式：在标签内部来定义一个样式区块（scoped）,只对样式标签内部才有效内嵌框架：iframe元素，新增了seamless无边距无边框，srcdoc定义了内嵌框架的内容</p>
<h4 id="iframe新增属性："><a href="#iframe新增属性：" class="headerlink" title="iframe新增属性："></a>iframe新增属性：</h4><p><code>&lt;!--seamless定义框架无边框 无边距--&gt;
&lt;!--srcdoc的显示级别比sandbox高--&gt;
&lt;!--sandbox用来规定一个内嵌框架的安全级别--&gt;
&lt;!--sandbox=&quot;allow-forms:允许提交表单&quot;--&gt;
&lt;!--sandbox=&quot;allow-origin:允许是相同的源&quot;--&gt;
&lt;!--sandbox=&quot;allow-scripts：允许执行脚本&quot;--&gt;
&lt;!--sandbox=&quot;allow-top-navigation:允许使外面的页面进行跳转&quot;--&gt;</code></p>
<h4 id="charset属性："><a href="#charset属性：" class="headerlink" title="charset属性："></a>charset属性：</h4><p>meta属性之一,定义页面的字符集</p>
<h4 id="sizes属性："><a href="#sizes属性：" class="headerlink" title="sizes属性："></a>sizes属性：</h4><p>link新增属性，当link的rel=”icon”时，用以设置图标大小</p>
<h4 id="base属性"><a href="#base属性" class="headerlink" title="base属性:"></a>base属性:</h4><p><code>&lt;base href=&quot;http://localhost/&quot; target=&quot;_blank&quot;&gt;</code>表示当在新窗口打开一个页面时，会将href中的内容作为前缀添加到地址前</p>
<h4 id="defer属性："><a href="#defer属性：" class="headerlink" title="defer属性："></a>defer属性：</h4><p>script标签属性，表示脚本加载完毕后，只有当页面也加载完毕才执行（推迟执行）</p>
<h4 id="async属性："><a href="#async属性：" class="headerlink" title="async属性："></a>async属性：</h4><p>script标签属性，脚本加载完毕后马上执行（运行过程中浏览器会解析下面的内容），即使页面还没有加载完毕（异步执行）</p>
<h4 id="media属性："><a href="#media属性：" class="headerlink" title="media属性："></a>media属性：</h4><p><code>&lt;a&gt;</code>元素属性：表示对何种设备进行优化</p>
<h4 id="hreflang属性："><a href="#hreflang属性：" class="headerlink" title="hreflang属性："></a>hreflang属性：</h4><p><code>&lt;a&gt;</code>的属性，表示超链接指向的网址使用的语言</p>
<h4 id="ref属性："><a href="#ref属性：" class="headerlink" title="ref属性："></a>ref属性：</h4><p><code>&lt;a&gt;</code>的属性,定义超链接是否是外部链接</p>
<h4 id="reversed属性"><a href="#reversed属性" class="headerlink" title="reversed属性:"></a>reversed属性:</h4><p><code>&lt;ol&gt;</code>的属性，定义序号是否倒叙</p>
<h4 id="start属性："><a href="#start属性：" class="headerlink" title="start属性："></a>start属性：</h4><p><code>&lt;ol&gt;</code>的属性，定义序号的起始值</p>
<h4 id="scoped属性："><a href="#scoped属性：" class="headerlink" title="scoped属性："></a>scoped属性：</h4><p>内嵌CSS样式的属性，定义该样式只局限于拥有该内嵌样式的元素，适用于单页开发</p>
<h3 id="HTML-5全局属性"><a href="#HTML-5全局属性" class="headerlink" title="HTML 5全局属性"></a>HTML 5全局属性</h3><ol>
<li>可直接在标签里插入的：<code>data-自定义属性名字</code>；</li>
<li><code>hidden</code>（直接放上去就是隐藏）；</li>
<li><code>spellcheck</code>=”true”（语法纠错）；</li>
<li><code>tabindex</code>=”1”（Tab跳转顺序）；</li>
<li><code>contenteditable</code>=”true”(可编辑状态，单击内容，可修改)；</li>
<li>在JavaScript里插入的window.document.<code>designMode</code> = ‘on’（JavaScript的全局属性，整个页面的文本都可以编辑了）；</li>
</ol>
<h3 id="HTML-5的兼容性"><a href="#HTML-5的兼容性" class="headerlink" title="HTML 5的兼容性"></a>HTML 5的兼容性</h3><ol>
<li><p>HTML5有部分内容兼容到IE9，IE8及以下对H5完全不兼容后面的内容不再考虑此类浏览器。</p>
</li>
<li><p>部分内容需要加兼容前缀，<br> -webkit-常用于兼容chrome浏览器，<br> -moz-常用于兼容火狐，<br> -o-常用于兼容opera，<br> -ms-常用于兼容IE。</p>
</li>
<li><p>兼容性查询网站：<a href="http://caniuse.com/" target="_blank" rel="noopener">http://caniuse.com/</a></p>
</li>
</ol>
<h2 id="web语义化的定义"><a href="#web语义化的定义" class="headerlink" title="web语义化的定义"></a>web语义化的定义</h2><p>在HTML结构的恰当位置上使用语义恰当的标签，使页面具有良好的结构，是页面标签元素具有含义，能让搜索引擎更容易理解。<br>从一下几点理解：</p>
<ul>
<li>用正确的标签做正确的事</li>
<li>HTML语义化能让页面更具结构化且更加清晰，便于浏览器和搜索引擎进行解析因此<code>在兼容条件下</code>，要尽量使用具有语义化的<code>结构</code>标签。</li>
<li>即使在没有css样式的情况下，网页的内容也应该是有序的文档格式显示，并且是容易阅读的。</li>
<li>使项目维护人员更容易对网站进行分块，便于阅读理解。</li>
<li>不具有语义的标签元素最好不要在里面放文字。比如div与i标签。一般div是作为容器。i标签作为图标（icon）</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
</search>
