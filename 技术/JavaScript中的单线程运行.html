<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript中的单线程运行，JavaScript宏任务与微任务"><meta name="keywords" content="JavaScript"><meta name="author" content="踏浪"><meta name="copyright" content="踏浪"><meta name="google-site-verification" content="9yQKCditbXpx0d4kb3-ZBnz5x88H0Q2b2arCt_rSP4w"><meta name="baidu-site-verification" content="R8n93qV3hH"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-141130158-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-141130158-1'，{ 'optimize_id': 'GTM-MRHV7JS'});</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script><title>JavaScript中的单线程运行，宏任务与微任务，EventLoop | 踏浪 - 前端技术分享</title><link rel="shortcut icon" href="/img/favicon-32x32.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-141130158-1', 'auto');
ga('require', 'GTM-MRHV7JS');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"7E70L82AL9","apiKey":"dafa357aaa50e7d9460158e4eb49cc90","indexName":"gitBlog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是EventLoop"><span class="toc-number">1.</span> <span class="toc-text">什么是EventLoop</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript中的单线程"><span class="toc-number">2.</span> <span class="toc-text">JavaScript中的单线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#宏任务"><span class="toc-number">3.</span> <span class="toc-text">宏任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#微任务"><span class="toc-number">4.</span> <span class="toc-text">微任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浏览器中的EventLoop"><span class="toc-number">5.</span> <span class="toc-text">浏览器中的EventLoop</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NodeJS中的EventLoop"><span class="toc-number">6.</span> <span class="toc-text">NodeJS中的EventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#对比浏览器与NodeJS的不同"><span class="toc-number">6.1.</span> <span class="toc-text">对比浏览器与NodeJS的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NodeJS中的process-nextTick"><span class="toc-number">6.2.</span> <span class="toc-text">NodeJS中的process.nextTick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NodeJS中-setImmediate-与-setTimeout-的区别"><span class="toc-number">6.3.</span> <span class="toc-text">NodeJS中 setImmediate 与 setTimeout 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关于-async-await-函数"><span class="toc-number">7.</span> <span class="toc-text">关于 async/await 函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">踏浪</div><div class="author-info__description text-center">踏浪个人博客 -- 用代码震撼世界</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">66</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">38</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="http://www.dreamwq.com">Mr.W</a><a class="author-info-links__name text-center" href="https://blog.cnbuilder.cn/">猿码优创</a><a class="author-info-links__name text-center" href="https://www.qqdeveloper.com/">浪子编程走四方</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/top-img.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">踏浪 - 前端技术分享</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags/Flutter">Flutter</a></span></div><div id="post-info"><div id="post-title">JavaScript中的单线程运行，宏任务与微任务，EventLoop</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技术/">技术</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>在前端的面试中经常会问到关于代码执行顺序的问题，尤其是下面的一段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">5</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>问题是</strong>：在浏览器上面 1 2 3 4 5 的打印的顺序。</p>
<p>上面这个问题看起来对有的同学可能很简单，到有的同学可能会比较复杂。对你不管是复杂还是简单，这其中涉及到的只是点都是一样的。JavaScript单线程，宏任务与微任务，EventLoop。这些就是这个题目的考点，理解了这些，那么上面的这道题对你来说那就是信手拈来，游刃有余。</p>
<p>我猜你应该知道，JavaScript除了在浏览器环境中运行，还可以在Node环境中运行，虽说都是JavaScript代码，但是在这两种环境下面执行的结果是可能不一样的。所以，我们需要分两种情况来分析他们的EventLoop。</p>
<h1 id="什么是EventLoop"><a href="#什么是EventLoop" class="headerlink" title="什么是EventLoop"></a>什么是EventLoop</h1><p>EventLoop是一个执行模型，在不同的有不同的实现，浏览器和NodeJS基于不同的技术实现了各自的EventLoop。</p>
<ul>
<li>浏览器的EventLoop是在<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" target="_blank" rel="noopener">HTML5规范</a>中明确定义了的</li>
<li>NodeJS的EventLoop是基于<a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a>实现的。可以在<a href="http://docs.libuv.org/en/v1.x/" target="_blank" rel="noopener">libuv官网</a>和<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" target="_blank" rel="noopener">NodeJS官网</a>查看</li>
<li>libuv已经对NodeJS的EventLoop做出了实现，但是浏览器的HTML5规范只是定义了EventLoop的实现模型，具体的实现留给了浏览器厂商。</li>
</ul>
<h1 id="JavaScript中的单线程"><a href="#JavaScript中的单线程" class="headerlink" title="JavaScript中的单线程"></a>JavaScript中的单线程</h1><p>JavaScript是单线程脚本语言。所以，在一行代码的执行过程过，必然不会执行另一行代码的，就行你在使用了<code>alert(1)</code>以后在后面疯狂的<code>console.log()</code>，如果执行到 <code>alert(1)</code>，你没有关闭这个弹窗，后面的<code>console.log()</code>是永远都不会执行的，因为 <code>alert()</code> 这个任务还没有执行完成，下面的代码没法执行。通俗一点就是：如果你去食堂打饭，前面排了很长的队，如果你想要打到饭，那么你需要等前面的小可爱都能够顺利的打完饭才可以，你是不能够插队的。那什么是宏任务，什么又是微任务呢？</p>
<p>同样是打饭的例子，你要打饭这件事请就是宏任务。这是一个大的事件。当轮到你打饭的时候，事件执行到你这里了，这个时候阿姨开始给你打饭，后面的同学还在等待着。但是你去打饭不单单的就是打饭，你会询问每种菜是什么，价格是多少，有没有XXX菜，有没有汤一样，那这些询问可以比作是微任务。当你的宏任务与微任务都执行完成了，相当于你的这一轮时间执行完成，这个时候开始执行下一轮事件，也就是下一个同学开始打饭了。同样的，下面的一轮循环中也可能存在微任务。</p>
<p>通过上面的例子，如果能有大概的明白了什么是宏任务，什么是微任务了。</p>
<h1 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h1><p>macrotask，也叫 tasks，主要的工作如下</p>
<ul>
<li>创建主文档对象,解析HTML,执行主线或者全局的javascript的代码,更改url以及各种事件。</li>
<li>页面加载,输入，网络事件，定时器。从浏览器角度看，宏任务是一个个离散的，独立的工作单元。</li>
<li>运行完成后，浏览器可以继续其他调度，重新渲染页面的UI或者去执行垃圾回收</li>
</ul>
<p>一些异步任务的回调会以此进入 <code>macrotask queue(宏任务队列)</code>，等等后续被调用，这些异步函数包括：</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate (Node)</li>
<li>requestAnimationFrame (浏览器)</li>
<li>I/O</li>
<li>UI rendering (浏览器)</li>
</ul>
<h1 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h1><p>microtask，也叫 jobs，注意的工作如下</p>
<ul>
<li>微任务是更小的任务，微任务更新应用程序的状态，但是必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。</li>
<li>微任务包括Promise的回调函数，DOM发生变化等，微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。</li>
<li>微任务能使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使得应用状态不连续</li>
</ul>
<p>另一些异步回调会进入 <code>microtask queue(微任务队列)</code> ，等待后续被调用，这些异步函数包括：</p>
<ul>
<li>process.nextTick (Node)</li>
<li>Promise.then()</li>
<li>catch</li>
<li>finally</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<blockquote>
<p>这里有一点需要注意的：<code>Promise.then()</code> 与 <code>new Promise(() =&gt; {}).then()</code> 是不同的，前面的是一个微任务，后面的 <code>new Promise()</code> 这一部分是一个构造函数，这是一个同步任务，后面的 <code>.then()</code> 才是一个微任务，这一点是非常重要的。</p>
</blockquote>
<h1 id="浏览器中的EventLoop"><a href="#浏览器中的EventLoop" class="headerlink" title="浏览器中的EventLoop"></a>浏览器中的EventLoop</h1><p>关于宏任务与微任务我们看看下面的执行流程<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190820105509.png" alt="JavaScript EventLoop"></p>
<p>最开始有一个执行栈，当执行到带有异步操作的宏任务的时候，比如 setTimeout 的时候就会将这个异步任务存在背景线程里面，待本次的事件执行完成以后再去执行微任务。即图中 <code>Stack --&gt; Background Thread</code>。但是需要注意到，从 <code>Stack --&gt; Microtask Queue</code> 还有一条路线，意思就是在当前这轮的任务中还有执行微任务的操作。当前轮的微任务优先于宏任务异步操作先执行，执行完成到 <code>loop</code> 中，进入到下一轮。下一轮执行之前的宏任务的异步操作，比如 <code>setTimeout</code> 。此时，如果这个异步任务中还有微任务，那么就会执行完成这个微任务，在执行下一个异步任务。就这样一次的循环。</p>
<p>回到最开始的那道题上面<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">5</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>整个这一串代码我们所在的层级我们看做一个任务，其中我们先执行同步代码。第一行的 <code>setTimeout</code> 是异步代码，跳过，来到了 <code>new Promise(...)</code> 这一段代码。前面提到过，这种方式是一个构造函数，是一个同步代码，所以执行同步代码里面的函数，即 <code>console.log(1)</code>，接下来是一个 <code>then</code> 的异步，跳过。在往下，是一个<code>Promise.then()</code> 的异步，跳过。最后一个是一段同步代码 <code>console.log(2)</code>。所以，这一轮中我们知道打印了<code>1, 2</code>两个值。接下来进入下一步，即之前我们跳过的异步的代码。从上午下，第一个是 <code>setTimeout</code>，还有两个是 <code>Promise.then()</code>。<code>setTimeout</code> 是宏任务的异步，<code>Promise.then()</code>是微任务的异步，微任务是优先于宏任务执行的，所以，此时会先跳过 <code>setTimeout</code> 任务，执行两个 <code>Promise.then()</code> 的微任务。所以此时会执行 <code>console.log(3)</code> 和 <code>console.log(5)</code> 两个函数。最后就只剩下 <code>setTimeout</code> 函数没有执行，所以最后执行 <code>console.log(4)</code>。</p>
<p>综上：最后的执行结果是 <code>1, 2, 3, 5, 4</code>。</p>
<p>这只是我们的推测的结果，我们来看看在浏览器中的实际的打印结果是什么？<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190710152407.png" alt="浏览器中的执行结果"></p>
<p>从图中可以看到，实际的运行结果与我们推测的结果是一一致的。所以，我们上面的分析步骤是正确的。</p>
<p>但是有一个问题，什么呢？可以看到，在浏览器中，会有一个 <code>undefined</code> 的返回值。为什么呢？这是因为浏览器将上面的一整段代码当成一个函数，而这个函数<strong>执行完成</strong>以后返回了 <code>undefined</code>。那么？这就完了吗？没有。我们看看浏览器返回的截图中，<code>3,5</code> 两个数字其实是在 <code>undefined</code> 前面。<code>3,5</code>两个数是两个 <code>Promise.then()</code> 中的 <code>console.log()</code> 的打印值，而 <code>undefined</code> 在这里可以作为一轮任务的结束。这表明的意思就是，<strong>微任务会在下一轮任务开始前执行</strong>。</p>
<p>这一切都是针对于浏览器的EventLoop。在NodeJS的环境中，可能就会有不同的结果。至于结果如何，我们暂时先不讨论，在来看一段代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">6</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">6</span>))</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">5</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>在浏览器中执行结果：<button id="evnetloop-btn">点击查看</button></p>
<p><div id="evnetloop-result"></div></p>
<script>
  var eventloopBtn = document.getElementById("evnetloop-btn");
  var eventloopResult = document.getElementById("evnetloop-result");
  eventloopBtn.addEventListener("click", () => {
    eventloopResult.innerHTML = "1，2，3，5，4，7，8，6，9"
  })
</script>

<p>上面就是关于在浏览器中的EventLoop。附上浏览器上面的<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly" target="_blank" rel="noopener">可视化操作</a></p>
<h1 id="NodeJS中的EventLoop"><a href="#NodeJS中的EventLoop" class="headerlink" title="NodeJS中的EventLoop"></a>NodeJS中的EventLoop</h1><p>虽然NodeJS中的JavaScript运行环境也是V8，也是单线程，但是，还是有一些与浏览器中的表现是不一样的。<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190710160659.png" alt="NodeJS中的EventLoop"></p>
<p>上面的图片的上半部分来自<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" target="_blank" rel="noopener">NodeJS官网</a>。下面的图片来自互联网。</p>
<p>同样的两段代码，我们在node环境中执行一下，看看结果。<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190710155941.png" alt="第一段代码的运行结构"></p>
<p>从上面的图中可以看到，实际的运行结果与浏览器中的运行结果并无二致。</p>
<p>在来看看另一段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">6</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">6</span>))</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">5</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>他的执行结果是：<code>1，2，3，5，4，8，7，6，9</code>。<br>与浏览器的<code>1，2，3，5，4，7，8，6，9</code>不同。</p>
<h2 id="对比浏览器与NodeJS的不同"><a href="#对比浏览器与NodeJS的不同" class="headerlink" title="对比浏览器与NodeJS的不同"></a>对比浏览器与NodeJS的不同</h2><p>在大部分情况下，浏览器与NodeJS的运行没有区别，唯一有区别的是在第二轮事件执行的时候，如果有多个宏任务(<code>setTimeout</code>)，浏览器会依次的执行宏任务，<strong>上一个宏任务执行完成了在执行下一个宏任务</strong>。在NodeJS中，则是相当于并行执行，相当于把所有的宏任务组合到一个宏任务中，再在这个组合后宏任务中，依次执行<code>同步代码 --&gt; 微任务 --&gt; 宏任务</code>。</p>
<h2 id="NodeJS中的process-nextTick"><a href="#NodeJS中的process-nextTick" class="headerlink" title="NodeJS中的process.nextTick"></a>NodeJS中的process.nextTick</h2><p>关于 <code>process.nextTick</code>，就只需要记住一点，那就是 <strong><code>process.nextTick</code> 优先于其他的微任务执行</strong>。</p>
<p>所以，下面的代码中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>分析（以Node作为运行环境，因为process在node中才存在）：</p>
<p>第一轮事件循环流程：</p>
<ul>
<li>整体的script代码作为第一个宏任务进入主线程，执行同步代码，遇到<code>console.log(1)</code>，输出 <code>1</code></li>
<li>遇到setTimeout，其回调函数被分发到宏任务的 Event Queue 中，等待执行。这里标记为<code>setTimeout1</code></li>
<li>遇到<code>process.nextTick</code>，其回调函数被分发到微任务的 Event Queue 中，等待执行。</li>
<li>遇到new Promise，这是一个构造函数，new Promise构造函数直接执行，遇到<code>console.log(7)</code>，输出 <code>7</code>。接着Promise.then()函数被分发到微任务的 Event Queue 中，等待执行。<br>遇到setTimeout，其回调函数被分发到宏任务的 Event Queue 中，等待执行。这里标记为<code>setTimeout2</code></li>
</ul>
<p>将上面的统计一下</p>
<table>
<thead>
<tr>
<th style="text-align:center">宏任务Event Queue</th>
<th style="text-align:center">微任务Event Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">setTimeout1</td>
<td style="text-align:center">process.nextTick</td>
</tr>
<tr>
<td style="text-align:center">setTimeout2</td>
<td style="text-align:center">Promise.then()</td>
</tr>
</tbody>
</table>
<p>第一轮事件循环同步代码执行完成，接下来<code>执行微任务</code>。</p>
<p>微任务有两个，一个是 <code>process.nextTick</code> ，里一个是 <code>Promise.then()</code>。</p>
<p>前面说了，<code>process.nextTick</code>优先于其他的微任务执行，所以</p>
<ul>
<li>执行process.nextTick：输出 <code>6</code></li>
<li>执行Promise.then()：输出 <code>8</code></li>
</ul>
<p>到此，第一轮事件循环结束，最终第一轮事件的输出为 <code>1,7,6,8</code>。开始执行第二轮事件循环（setTimeout）。</p>
<p>第二轮事件循环分析</p>
<ul>
<li>在 <code>setTimeout1</code> 与 <code>setTimeout2</code> 中先找同步代码</li>
<li>setTimeout1 中遇到 console.log(2),输出<code>2</code></li>
<li>setTimeout1 中遇到 process.nextTick，放在第二轮的微任务的Event Queue中，等待执行。这里标记为<code>process_1</code></li>
<li>setTimeout1 中遇到 new Promise ，执行同步代码，输出 <code>4</code>, Promise.then() 放到微任务的Event Queue中，等待执行。这里标记为<code>Promise_1</code></li>
<li>setTimeout2 中遇到 console.log(9),输出<code>9</code></li>
<li>setTimeout2 中遇到 process.nextTick，放在第二轮的微任务的Event Queue中，等待执行。这里标记为<code>process_2</code></li>
<li>setTimeout2 中遇到 new Promise ，执行同步代码，输出 <code>11</code>, Promise.then() 放到微任务的Event Queue中，等待执行。这里标记为<code>Promise_2</code></li>
</ul>
<p>第二轮的统计</p>
<table>
<thead>
<tr>
<th style="text-align:center">第二轮宏任务Event Queue</th>
<th style="text-align:center">第二轮微任务Event Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">process_1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">Promise_1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">process_2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">Promise_2</td>
</tr>
</tbody>
</table>
<p>第二轮没有事件循环中没有宏任务，有四个微任务。</p>
<p>四个微任务中，有两个 <code>process</code> </p>
<ul>
<li>依次执行 <code>process_1</code> 和 <code>process_2</code>。输出：<code>3, 10</code></li>
<li>一次执行 <code>Promise_1</code> 和 <code>Promise_2</code>。输出：<code>5, 12</code></li>
</ul>
<p>所以第二轮输出：<code>2，4，9，11，3，10，5，12</code></p>
<p>最终的输出为：<code>1，7，6，8，2，4，9，11，3，10，5，12</code>。</p>
<p>如果是在浏览器中，排除掉<code>process</code>的输出，结果为：<code>1，7，8，2，4，5，9，11，12</code></p>
<h2 id="NodeJS中-setImmediate-与-setTimeout-的区别"><a href="#NodeJS中-setImmediate-与-setTimeout-的区别" class="headerlink" title="NodeJS中 setImmediate 与 setTimeout 的区别"></a>NodeJS中 setImmediate 与 setTimeout 的区别</h2><p>在官方文档中的定义，<strong>setImmediate 为一次Event Loop执行完毕后调用。setTimeout 则是通过计算一个延迟时间后进行执行。</strong></p>
<p>但是同时还提到了如果在主进程中直接执行这两个操作，很难保证哪个会先触发。因为如果主进程中先注册了两个任务，然后执行的代码耗时超过XXs，而这时定时器已经处于可执行回调的状态了。所以会先执行定时器，而执行完定时器以后才是结束了一次Event Loop，这时才会执行setImmediate。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>))</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>))</span><br></pre></td></tr></table></figure>
<p>node环境下执行上面的代码，可以看到如下结果<br><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190710165932.png" alt="执行结构"></p>
<p>这两个console的结果是随机的。</p>
<p>我们可以通过一些处理，使得我们可以先执行 <code>setTimeout</code> 或者是 <code>setImmediate</code>。</p>
<p>但是如果后续添加一些代码以后，就可以保证setTimeout一定会在setImmediate之前触发了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>))</span><br><span class="line">setImmediate(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> countdown = <span class="number">1e9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(countdonn--) &#123; &#125; <span class="comment">// 我们确保这个循环的执行速度会超过定时器的倒计时，导致这轮循环没有结束时，setTimeout已经可以执行回调了，所以会先执行`setTimeout`再结束这一轮循环，也就是说开始执行`setImmediate`</span></span><br></pre></td></tr></table></figure></p>
<p>如果在另一个宏任务中，必然是setImmediate先执行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'fs'</span>).readFile(__dirname, _ =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'timeout'</span>))</span><br><span class="line">  setImmediate(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'immediate'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用一个设置了延迟的setTimeout也可以实现相同的效果</span></span><br></pre></td></tr></table></figure></p>
<p>上面的为什么有这样的解决方法，从上面的定义中就可以看出来。</p>
<h1 id="关于-async-await-函数"><a href="#关于-async-await-函数" class="headerlink" title="关于 async/await 函数"></a>关于 async/await 函数</h1><p>因为，async/await本质上还是基于Promise的一些封装，而Promise是属于微任务的一种。所以在使用await关键字与Promise.then效果类似</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>输出的结果是：<code>1，2，3，4</code>。</p>
<p>可以理解为，<code>await</code> 以前的代码，相当于与 <code>new Promise</code> 的同构代码，以后的代码相当于 <code>Promise.then</code>。到<code>await</code>的时候就会执行<code>await</code>后面的函数（相当于和前面的代码同步执行）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>之前了解过JavaScript单线程，也了解过JavaScript代码的执行顺序，但是宏任务与微任务也是最近才听说的，这对于一个从事两年前端的开发者真的是，我自己的过失。或需又是因为我是转行的，没有过相关的基础，没有接触到这方面的只是。不过现在我很高兴，因为我对JavaScript的执行有了更多的了解，相比于之前的只是，真的是了解了很多。学习永远都不晚，就怕你从来都不想去了解。在了解EventLoop，宏任务与微任务，JavaScript单线程的时候，参考了一些文档</p>
<ul>
<li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a></li>
<li><a href="https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40" target="_blank" rel="noopener">Understanding JS: The Event Loop</a></li>
<li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" target="_blank" rel="noopener">NodeJS EventLoop</a></li>
<li><a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" target="_blank" rel="noopener">HTML5 EventLoop 标准</a></li>
<li><a href="https://www.cnblogs.com/jiasm/p/9482443.html" target="_blank" rel="noopener">博客园的一位大佬</a>，最后的ES7的 async/await 就是从这里看到的</li>
<li><a href="https://www.bilibili.com/video/av37759434/" target="_blank" rel="noopener">到底什么是时间循环 Event loop in JavaScript</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">踏浪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.lyt007.cn/技术/JavaScript中的单线程运行.html">https://blog.lyt007.cn/技术/JavaScript中的单线程运行.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lyt007.cn">踏浪 - 前端技术分享</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechatpay.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cdd1b7c28eeaa67" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/技术/switch-case与if-else执行能力分析.html"><i class="fa fa-chevron-left">  </i><span>switch...case与if...else执行能力分析</span></a></div><div class="next-post pull-right"><a href="/技术/Flutter-lesson-9-Flutter的网络（HTTP）请求.html"><span>Flutter lesson 9: Flutter的网络（HTTP）请求</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC80MzU5OC8yMDEzNw=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(/img/top-img.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 踏浪</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">蜀ICP备19000202号</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div><script>var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1271259829'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1271259829%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>