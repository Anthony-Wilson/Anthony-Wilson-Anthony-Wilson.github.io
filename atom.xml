<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>踏浪 - 前端技术分享</title>
  
  <subtitle>所谓天才，不过是每一天的积累成才</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.lyt007.cn/"/>
  <updated>2020-05-26T02:18:05.771Z</updated>
  <id>https://blog.lyt007.cn/</id>
  
  <author>
    <name>踏浪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ECMA-262-3深入解析第四章：作用域链</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/ECMA-262-3%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html"/>
    <id>https://blog.lyt007.cn/技术/ECMA-262-3深入解析第四章：作用域链.html</id>
    <published>2020-05-22T02:16:54.000Z</published>
    <updated>2020-05-26T02:18:05.771Z</updated>
    
    <content type="html"><![CDATA[<p>从来没有深入了解ECMA，网上找了一下，发现早在2010年就有大佬 <a href="http://dmitrysoshnikov.com/about/" target="_blank" rel="noopener">Dmitry Soshnikov</a> 总结了ECMA中的核心内容，我这里只是翻译记录，加深自己的印象。文章原文来自<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="noopener">ECMA-262-3 in detail. Chapter 4. Scope chain.</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13" target="_blank" rel="noopener">第二章</a>我们已经了解了<em>变量对象</em>，<a href="https://juejin.im/post/5ebcdda76fb9a0433567b062" target="_blank" rel="noopener">执行上下文</a>中的数据（变量，函数声明，函数形参）作为这个变量对象的属性被存起来了。</p><p>同时，我们也知道，变量对象是在每一次<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13#heading-6" target="_blank" rel="noopener">进入上下文</a>的时候被创建并且赋予初始值的，并且在<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13#heading-7" target="_blank" rel="noopener">代码执行阶段</a>更新。</p><p>本章致力于讨论与执行上下文紧密相关的更多细节；这一次，我们会提到一个<em>作用域链</em>的概念。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果要简短描述并且展现出重点，那么，作用域链主要与内部函数息息相关。</p><p>我们知道，ECMAScript允许在函数内部创建函数，并且，我们甚至可以从父级函数中返回这些函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(x + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>因此，每一个上下文都有他自己的变量对象：对于全局上下文就是全局对象自己，对于函数就是活动对象。</p><p>作用域链正好就是内部上下文所有变量对象的列表。这个链条用域变量查找。在上面的例子中，‘bar’上下文的作用域链中包含了AO（bar），AO（foo）和VO（global）；</p><p>让我们详细讨论这个主题。</p><p>我们从定义开始，然后进一步深入讨论示例。</p><blockquote><p>作用域链与执行上下文息息相关，一连串的变量对象是为了在标识符解析的时候查找变量。</p></blockquote><p>函数上下文的作用域链是在函数调用的时候创建，并且由<em>变量对象</em>和内置的<em>[[Scope]]</em>属性构成。下面我们详细讨论一下函数的 [[Scrope]] 属性。</p><p>在上下文中的示意图：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line">VO: &#123;...&#125;, <span class="comment">// or AO</span></span><br><span class="line"><span class="keyword">this</span>: thisValue,</span><br><span class="line">Scope: [</span><br><span class="line"><span class="comment">// 为了标识符查找的变量对象作用域链列表</span></span><br><span class="line">]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Scope 定义的范围是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = AO + [[Scope]]</span><br></pre></td></tr></table></figure><p>在我我们的例子中，可以使用ECMAScript的普通函数来表示 <em>Scope</em>，和 <em>[[SCope]]</em></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Scope = [VO1, VO2, ..., VOn]; <span class="comment">// scope chain</span></span><br></pre></td></tr></table></figure><p>可以将替代结构视图表示为分层对象链，并在链的每个链接上都引用父作用域（父变量对象）。对于此视图，</p><p>对应某些实现的 <strong>parent</strong> 概念，这个我们在第二章变量对象中有<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13#heading-9" target="_blank" rel="noopener">讨论</a>过。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> VO1 = &#123;<span class="attr">__parent__</span>: <span class="literal">null</span>, ... other data&#125;; --&gt;</span><br><span class="line"><span class="keyword">var</span> VO2 = &#123;<span class="attr">__parent__</span>: VO1, ... other data&#125;; --&gt;</span><br><span class="line"><span class="comment">// etc.</span></span><br></pre></td></tr></table></figure><p>但是使用一个数字来表示一个作用域链更方便，所以我们将使用这种方法。除此之外，规范中声明的“一个作用域链就是一个对象列表”本身就是抽象的。不管可以在实现级别上使用带有<strong>parent</strong>功能的层次链的方法。数组抽象表示法是列表概念的理想选择。</p><p>我们接下来要讨论的AO + [[Scope]]的组合和标识符解析过程都与函数生命周期有关</p><h2 id="函数声明周期"><a href="#函数声明周期" class="headerlink" title="函数声明周期"></a>函数声明周期</h2><p>函数的声明周期分为创建和执行两个阶段。接下来详细看看。</p><h3 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h3><p>我们知道，在进入上下文阶段的时候，函数声明会放入变量/活动对象（VO/AO）。来看看这个例子，在全局上下文（即变量对象就是全局对象自身，还记得吗？）中声明一个变量和一个函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">alert(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>在函数激活时候，我们看到正确的（意料中的）结果 — 30。但是，其中有非常重要的一点。</p><p>在这之前，我们值讨论了当前上下文的变量对象。但是这里我们可以看到， ‘y’ 变量是定义在函数 ‘foo’ 的内部（即是在 ’foo‘ 上下文的 AO 中），而变量 ‘x’ 没有定义在 ‘foo’ 上下文中，因此它没有被添加到 ‘foo’ 的AO中。乍一看，函数 ‘foo’ 中根本不存在变量 ‘x’，但是正如我们看到的那样，仅仅只是“乍一看”。 ‘foo’上下文的活动对象中只有一个属性 — 属性 ‘y’ 。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fooContext.AO = &#123;</span><br><span class="line">y: <span class="literal">undefined</span> <span class="comment">// 进入上下文的时候是 undefined ， 执行的时候才是 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那’foo’函数又是如何访问’x’变量的呢？我们设想函数可以访问更高层上下文的变量对象，那这一切就说得通了。事实上，的确如此，并且实际上，这种机制是通过函数内部的[[Scope]]属性实现的。</p><blockquote><p>[[Scope]]是所有父变量对象的层级链，这些父变量对象位于当前函数上下文之上。这个层次连在（函数）创建时候被保存到函数。</p></blockquote><p>注意重要的一点 — [[Scope]]在函数创建是被保存 — 永久的保存 — 直到函数销毁。函数可以不被调用，但是 [[Scope]] 属性却写入并保存到函数对象中了。</p><p>另一个值得思考的，与作用域（作用域链）相比， [[Scope]] 是函数的属性，而不是上下文。上面的那个例子中， ‘foo’ 函数的 [[Scope]] 可以这样表示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.[[Scope]] = [</span><br><span class="line">globalContext.VO <span class="comment">// === global</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>更远的说，真如我们知道的，函数调用的时候，进入函数上下文并且活动对象（AO）被创建，同时， <code>this</code> 值和 <code>Scope</code> （作用域链）被决定。我们来详解看看这种情况。</p><h3 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h3><p>在定义中以及说过了，在进入上下文和确定AO/VO后，上下文（供变量查找的作用域链）的 <em>Scope</em> 属性被定义为这样：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = AO|VO = [[Scope]]</span><br></pre></td></tr></table></figure><p>这里的重点是，<em>Scope</em>数组的第一个元素是活动对象，我们他把添加到作用域链中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><p>这一点对于标识符解析的过程非常重要。</p><blockquote><p>标识符解析是确定变量（或者是函数声明）属于哪一个变量对象的过程。</p></blockquote><p>这个算法的返回此总是一个引用类型的值，基本组成都是相应的变量对象（如果变量没有找到则为 <code>null</code> ），并且属性名称是由查找（解析）标识符的名称组成。在<a href="https://juejin.im/post/5ec49063e51d457848684711" target="_blank" rel="noopener">第三章</a>中我们详细讨论了引用类型。</p><p>标识符解析过程包括寻找与变量名一致的属性，例如，在作用域链中对变量对象进行了连续检查，从上下文的最底层到作用域链的最顶层。</p><p>因此，在查找上变量的优先级上，上下文中的局部变量比父级上下文中的变量更高，即使是在不同上下文中两个变量名字相同的情况下，第一个找到的也是更深层次上下文中的变量（即更接近局部上下文的那一个）。</p><p>我们来使上述例子复杂一点，并在更里层添加一些其他内容：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="number">30</span>;</span><br><span class="line">    alert(x +  y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">foo(); <span class="comment">// 60</span></span><br></pre></td></tr></table></figure><p>这些上下文中，包含了如下内容：<em>变量对象/活动对象，函数的[[Scope]]属性和作用域链。</em></p><p>全局上下文的变量对象是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">globalContext.VO === Global = &#123;</span><br><span class="line">x: <span class="number">10</span>,</span><br><span class="line">foo: <span class="xml"><span class="tag">&lt;<span class="name">函数引用</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><code>foo</code>创建的时候， <code>foo</code> 的 <code>[[Scope]]</code> 属性是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.[[Scope]] = [</span><br><span class="line">globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>foo</code> 调用的时候， <code>foo</code> 上下文中的活动对象是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fooContext.AO = &#123;</span><br><span class="line">y: <span class="number">20</span>,</span><br><span class="line">bar: <span class="xml"><span class="tag">&lt;<span class="name">函数引用</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><code>foo</code> 上下文的作用域链是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fooContext.Scope = fooContext.AO + foo.[[Scope]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即</span></span><br><span class="line">fooContext.Scope = [</span><br><span class="line">fooContext.AO,</span><br><span class="line">globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>内部 <code>bar</code> 函数创建时，它的 <code>[[Scope]]</code> 是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar.[[Scope]] = [</span><br><span class="line">fooContext.AO,</span><br><span class="line">globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><code>bar</code> 函数调用时候， <code>bar</code> 上下文的活动对象是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">barContext.AO = &#123;</span><br><span class="line">z: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bar</code> 上下文的作用域链是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">barContext.Scope = barContext.AO + bar.[[Scope]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即：</span></span><br><span class="line">barContext.Scope = [</span><br><span class="line">barContext.AO,</span><br><span class="line">fooContext.AO,</span><br><span class="line">globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><code>x</code> ， <code>y</code> ， <code>z</code> 的标识符解析：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x</span></span><br><span class="line">--&gt; barContext.AO <span class="comment">// 没有，进入上一层</span></span><br><span class="line">--&gt; fooContext.AO <span class="comment">// 没有，进入上一层</span></span><br><span class="line">--&gt; globalContext.VO <span class="comment">// 找到了 x = 10</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// y</span></span><br><span class="line">--&gt; barContext.AO <span class="comment">// 没有，进入上一层</span></span><br><span class="line">--&gt; fooContext.AO <span class="comment">// 找到了 y = 20</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// z</span></span><br><span class="line">--&gt; barContext.AO <span class="comment">// 找到了 z = 30</span></span><br></pre></td></tr></table></figure><h2 id="作用域的特性"><a href="#作用域的特性" class="headerlink" title="作用域的特性"></a>作用域的特性</h2><p>我们来看看与作用域链与函数 <code>[[Scope]]</code> 属性更多相关的特性。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>ECMAScript中闭包与函数的 <code>[[Scope]]</code> 属性直接相关。之前说过， <code>[[Scope]]</code> 在函数创建是保存并在函数对象销毁的时候消失。实际上，闭包恰恰就是函数代码与 <code>[[Scope]]</code> 属性的组合。因此，</p><p><code>[[Scope]]</code> 包含了函数创建时的词法环境（即父级变量对象）。在进一步的函数激活中，将在此词汇链（创建时静态保存的）中搜索更高上下文中的变量。</p><p>例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">foo(); <span class="comment">// 10 ，而不是20</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>变量 <code>x</code> 在 <code>foo</code> 函数的 <code>[[Scope]]</code> 属性中找到了，对于变量而言，实在函数创建那一刻的词汇（封闭）链中查找，而不是在函数调用（这时候 <code>x</code> 被赋值为20）时候的动态链。</p><p>另一个闭包的典型案例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert([x, y])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo(); <span class="comment">// 返回匿名函数</span></span><br><span class="line">bar();<span class="comment">// [10, 20];</span></span><br></pre></td></tr></table></figure><p>我们再次看到，对于标识符解析，使用了在函数创建时定义的词法作用域链 — 变量 <code>x</code> 被赋值为 <code>10</code> ，而不是 <code>30</code> 。而且，这个例子还清楚的展示了，即使是在一个函数已经创建完成上下文后，函数的 <code>[[Scope]]</code> （这个例子中， <code>foo</code> 函数番号的匿名函数）依然存在。</p><p>有关闭包理论以及其在ECMAScript中的实现的更多详情，请查阅<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="noopener">第六章：闭包</a>。</p><h3 id="通过Function构造函数创建的函数的-Scope"><a href="#通过Function构造函数创建的函数的-Scope" class="headerlink" title="通过Function构造函数创建的函数的[[Scope]]"></a>通过Function构造函数创建的函数的[[Scope]]</h3><p>在上面的例子中，我们了解到函数在创建的时候获得 <code>[[Scope]]</code> 属性，并且通过此属性可以访问所有父级作用域的变量。然而对于一点有一个例外，这关系到通过Function构造函数创建的函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">barFD</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 函数声明</span></span><br><span class="line">alert(x);</span><br><span class="line">alert(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> barFE = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 函数表达式</span></span><br><span class="line">alert(x);</span><br><span class="line">alert(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> barFn = <span class="built_in">Function</span>(<span class="string">'alert(x); alert(y);'</span>);</span><br><span class="line"></span><br><span class="line">barFD(); <span class="comment">// 10, 20</span></span><br><span class="line">barFE(); <span class="comment">// 10, 20</span></span><br><span class="line">barFn(); <span class="comment">// 20, y is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>可以看到，对于通过 <code>Function</code> 构造函数创建的函数 <code>barFn</code> ，变量 <code>y</code> 是不可访问的。但是这并不意味着函数 <code>barFn</code> 没有内部的 <code>[[Scope]]</code> 属性（即使他没有权限访问变量 <code>x</code> ）。原因是因为用过 <code>Function</code> 构造函数创建的函数的 <code>[[Scope]]</code> 的属性总是<strong>只包含全局对象。</strong>因此，通过这种函数无法创建除了全局以外的（还包含其他）上层上下文的闭包。</p><h3 id="二维作用域链查找"><a href="#二维作用域链查找" class="headerlink" title="二维作用域链查找"></a>二维作用域链查找</h3><p>在作用域链中查找的很重要的一点就是变量对象的原型（如果有）也要被考虑进去 — 由于ECMAScript的原型性质：如果没有直接在对象中找到属性，则其查找将会在原型链中进行。就像是链的某种2D查找：（1）在原型链连接上，（2）在每一个原型链连接上 — 深入到链链接的原型。如果在 <code>Object.prototype</code> 中定义属性，我们可以观察到这种效果：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>活动对象没有原型链，我们可以在下面的例子中看出来：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>如果 <code>bar</code> 函数上下文的活动对象有原型，那么 <code>x</code> 属性应该在 <code>Object.prototype</code> 中解析，而不是直接在AO中解析。但是在上面的第一个例子中，在解析标识符中遍历作用域链，我们到达了全局对象（在某些视线中而不是全部），它继承自 <code>Object.prototype</code> ，因此解析为10。</p><p>类似的情况在某些版本的带有明明函数表达式的SpiderMokey中也有，其中存储函数表达式可选名称的对象是继承自 <code>Object.protoype</code> 的，在某些版本的Balckberry中，活动对象也是继承自 <code>Object.prototype</code>。更多这个特性的详情将在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="noopener">第五章：函数</a>中讨论。</p><h3 id="全局上下文与eval上下文的作用域链"><a href="#全局上下文与eval上下文的作用域链" class="headerlink" title="全局上下文与eval上下文的作用域链"></a>全局上下文与eval上下文的作用域链</h3><p>这或许不太有趣，但是这很重要。全局上下文的作用域链中只包含了全局对象。“eval”类型代码的上下文与调用上下文有相同的作用域链。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext.Scope = [</span><br><span class="line">  Global</span><br><span class="line">];</span><br><span class="line">  </span><br><span class="line">evalContext.Scope === callingContext.Scope;</span><br></pre></td></tr></table></figure><h3 id="代码执行时对作用域链的影响"><a href="#代码执行时对作用域链的影响" class="headerlink" title="代码执行时对作用域链的影响"></a>代码执行时对作用域链的影响</h3><p>在ECMAScript中有两种语句在代码执行时可以修改作用域链。他们是 <code>with</code> 语句和 <code>catch</code> 语句。他们都把出现在这些语句中的查询标识符所需要的对象添加到了作用域链的最前端。如果其中一种情况发生了，那么作用域链就会被修改为如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = withObject|catchObject + AO/VO + [[Scope]]</span><br></pre></td></tr></table></figure><p>下面例子中 <code>with</code> 语句添加一个对象作为他的参数（因此这个对象的属性无需前缀即可访问）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(foo) &#123;</span><br><span class="line">alert(x); <span class="comment">// 10</span></span><br><span class="line">alert(y); <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的作用域：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = foo + AO/VO + [[Scope]]</span><br></pre></td></tr></table></figure><p>让我们再次展示，标识符是在with语句添加到作用域链前面的对象中解析的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>, y = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> (&#123;<span class="attr">x</span>: <span class="number">20</span>&#125;) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">30</span>, y = <span class="number">30</span>;</span><br><span class="line">  </span><br><span class="line">  alert(x); <span class="comment">// 30</span></span><br><span class="line">  alert(y); <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">alert(x); <span class="comment">// 10</span></span><br><span class="line">alert(y); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>发生了什么？在进入上下文阶段，”x”和”y”被添加到变量对象。因此，代码执行阶段，有如下修改：</p><ul><li>x = 10, y = 10；</li><li>对象 <code>{x: 20}</code> 添加到作用域链的顶端；</li><li><code>with</code> 代码块中遇到 <code>var</code> 语句，什么也没有创建，因为所有的变量已经在进入上下文的阶段被解析和添加；</li><li>只有 “x” 的值修改了，确切的说 “x” 是第二步在作用域顶端添加对象的时候被修改的。“x“先是20，然后变成了30；</li><li>”y“也修改了，因为上面的变量对象造成的，因此，先是10，变成了30；</li><li>因此， <code>with</code> 语句完成后，他的特殊对象从作用域链中移除（并且被修改的 ”x“ — 30也随着对象移除被移除），作用域链恢复到 <code>with</code> 语句增强以前的状态；</li><li>最后两个alert：当前变量对象中的“ x”值保持不变，并且“ y”的值现在等于30，并且在 <code>with</code> 语句中被更改。</li></ul><p>另外，为了能够访问parameter-exception的catch子句会创建一个具有唯一属性（异常参数名称）的中间范围对象，并将此对象置于范围链的前面。从示意图上看，它看起来是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  alert(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的作用域：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> catchObject = &#123;</span><br><span class="line">  ex: <span class="xml"><span class="tag">&lt;<span class="name">exception</span> <span class="attr">object</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml">  </span></span><br><span class="line"><span class="xml">Scope = catchObject + AO|VO + [[Scope]]</span></span><br></pre></td></tr></table></figure><p>catch语句执行完成后，作用域链也会恢复到之前的状态。</p><hr><p>所以啊，开发中经常听到老前辈说尽量不要使用 <code>with</code> 和 <code>try...catch</code> 。</p>]]></content>
    
    <summary type="html">
    
      ECMA 262-3 深入解析第二章：变量对象。文章翻译自 ECMA-262-3 in detail. Chapter 4. Scope chain.
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="https://blog.lyt007.cn/tags/JavaScript/"/>
    
      <category term="ECMA" scheme="https://blog.lyt007.cn/tags/ECMA/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3深入解析第三章：This</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/ECMA-262-3%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AThis.html"/>
    <id>https://blog.lyt007.cn/技术/ECMA-262-3深入解析第三章：This.html</id>
    <published>2020-05-20T02:16:03.000Z</published>
    <updated>2020-05-26T02:17:54.325Z</updated>
    
    <content type="html"><![CDATA[<p>从来没有深入了解ECMA，网上找了一下，发现早在2010年就有大佬 <a href="http://dmitrysoshnikov.com/about/" target="_blank" rel="noopener">Dmitry Soshnikov</a> 总结了ECMA中的核心内容，我这里只是翻译记录，加深自己的印象。文章原文来自 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="noopener">ECMA-262-3 in detail. Chapter 3. This.</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在这篇文章里，我们将讨论更多与执行上下文相关的细节。讨论的主题就是 <code>This</code> 关键字。</p><p>实践证明，这个主题很难，并且在不同的执行上下文中经常导致确定 <code>this</code> 的值很难。</p><p>许多程序员认为，在程序语言中， <code>this</code> 关键字与面向对象编程很接近（紧密相关），它完全指向于由构造函数新创建的对象。在ECMAScript中，这个概念也得到了实现，但是，正如我们即将看到的，这里的概念不仅限于所创建对象的定义。</p><p>让我们更详细的了解一下，在ECMAScript中， <code>this</code> 的值到底是什么。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p><code>this</code> 是执行上下文的一个属性。这是一个在代码初始时就存在的一个特殊对象。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line">VO: &#123;...&#125;,</span><br><span class="line"><span class="keyword">this</span>: thisValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 VO 就是<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13" target="_blank" rel="noopener">上一章</a>中我们讨论过的变量对象。</p><p><code>this</code> 与<a href="https://juejin.im/post/5ebcdda76fb9a0433567b062" target="_blank" rel="noopener">上下文中可执行代码类型</a>直接相关。这个值在进入上下文的时候就已经确定了，并且在代码运行的时候不会改变。</p><p>让我们更详细的考虑一下这些情况。</p><h2 id="全局代码中的This的值"><a href="#全局代码中的This的值" class="headerlink" title="全局代码中的This的值"></a>全局代码中的This的值</h2><p>在这里，一切都很简单。在全局代码中， <code>this</code> 的值总是指向 <em>global object（全局对象自身）</em>。因此，可以间接使用它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示的在全局对象上定义属性</span></span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">10</span>; <span class="comment">// global.a = 10;</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过分配不合规的标识符进行隐式定义</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过变量声明的形式隐式定义，因为全局上下文中的变量对象就是全局对象自己</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.c); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><h2 id="函数代码中的This值"><a href="#函数代码中的This值" class="headerlink" title="函数代码中的This值"></a>函数代码中的This值</h2><p>当 <code>this</code> 的值在函数代码中的时候，事情变得更加有趣了。这种情况很难（理解this），并且可能会造成很多问题。</p><p>在这种类型的代码中， <code>this</code> 的第一（或者说，主要）特征就是 <code>this</code> 没有静态的与函数绑定。</p><p>上面已经提到了， <code>this</code> 的值是在进行上下文的时候就已经确定了的，但是在函数代码的这种情况下， <code>this</code> 的值可能在每一次（进入执行上下文）都不同。</p><p>但是，在代码运行的时候， <code>this</code> 的值是不可变的。例如：不能传递一个新的值给他，因为他<em>不是一个变量</em>。相比之下，使用 <code>Python</code> 编程语言及其显示定义的 <code>self</code> 对象，都是可以在运行的时候进行多次更改。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">x: <span class="number">20</span>,</span><br><span class="line">test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === bar); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span> = foo; <span class="comment">// 报错了 Invalid left-hand side in assignment</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// 如果没有报错的话，将会是10而不是20</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当进入上下文的时候，this的值被确定为 ‘bar’ 对象</span></span><br><span class="line"><span class="comment">// 为什么会这样，将会在下面讨论</span></span><br><span class="line">bar.test(); <span class="comment">// true, 20</span></span><br><span class="line">foo.test = bat.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，这里的 this 值没有指向 'foo' -- 即使我们调用了相同的函数 </span></span><br><span class="line">foo.test(); <span class="comment">// false, 10</span></span><br></pre></td></tr></table></figure><p>那么，什么会影响函数代码中 <code>this</code> 的值呢？有几种因素。</p><p>首先，在通常的函数调用中， <code>this</code> 是由激活上下文的调用者提供（就是我们说的谁调用就指向谁），即调用户数的父级上下文。 <code>this</code> 的值取决于调用函数的方式。（换句话说，在语法构成上，函数是以怎样的形式被调用的）</p><p>为了能够在任何上下文中毫无疑问的确定 <code>this</code> 的值，理解并记住这个重点是非常有必要的。调用表达式的确切形式，或者说调用函数的方法影响了调用上下文中的 <code>this</code> 值而不是其他（情况）。</p><p>（我们在一些文章甚至是关于Javascript的书籍中看到，他们指出： <code>this</code> 值取决于函数如何定义：如果是一个全局函数， <code>this</code> 指向全局对象，如果是一个对象的方法， <code>this</code> 总是指向这个对象。 — 这绝对是不正确的）。继续，我们可以看到，即使是普通的全局函数也可以被不同形式的的调用形式激活，这些不同的形式影响了不同的 <code>this</code> 值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// global</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo === foo.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是相同的函数使用另一种形式， this 值就不一样了</span></span><br><span class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype</span></span><br></pre></td></tr></table></figure><p>作为一个对象的方法来调用的时候也可能出现类似的情况， <code>this</code> 的值不会是这个对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === foo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar(); <span class="comment">// foo, true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exampleFunc = foo.bar;</span><br><span class="line"><span class="built_in">console</span>.log(exampleFunc === foo.bar); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再一次，相同函数的不同调用方式，不同的this值</span></span><br><span class="line">exampleFunc(); <span class="comment">// global, false</span></span><br></pre></td></tr></table></figure><p>所以，不同调用形式是怎样影响 <code>this</code> 值的呢？为了充分了解 <code>this</code> 的值，有必要详细分析一种内部类型 — 引用类型（Reference Type）。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>使用伪代码（假设存在这样的代码）的形式可以将 <code>Reference</code> 的值表示为一个含有两个属性的对象：</p><ul><li>base（拥有这个属性的对象）</li><li>base中的propertyName</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> valueOfReferenceType = &#123;</span><br><span class="line">base: <span class="xml"><span class="tag">&lt;<span class="name">base</span> <span class="attr">object</span>&gt;</span>,</span></span><br><span class="line">propertyName: &lt;property name&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：从ES5开始，在使用严格模式（use strict）的代码中，一个引用也包含了一个名为 <code>strict</code> 的属性。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooReference = &#123;</span><br><span class="line">base: global,</span><br><span class="line">propertyName: foo,</span><br><span class="line">strict: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>引用类型的值只有两种情况：</p><ol><li>当我们处理一个标识符（原文：when we deal with an identifier）</li><li>或者一个属性访问器（原文：or with a property accessor）</li></ol><p>标识符的处理过程会在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="noopener">Chapter 4. Scope chain</a>中详细介绍。这里呢，我们只需要注意，从这个算法返回值总是一个引用类型的值（这对 <code>this</code> 的值很重要）。</p><p><strong>标识符是变量名，函数名，函数参数名和全局对象中不合规（没有定义）的属性名</strong>。例如，下面标识符中的值：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>在操作的过度结果中，引用类型对应的值如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">base: global,</span><br><span class="line">propertyName: <span class="string">'foo'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> barReference = &#123;</span><br><span class="line">base: global,</span><br><span class="line">propertyName: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了从引用类型的值中获取一个对象真正的值，在伪代码中可以使用 <code>GetValue</code> 方法，就像下面这样：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Type(value) != Reference) &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> base = GetBase(value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (base === <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> base.[[<span class="keyword">get</span>]](GetPropertyName(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部 <code>[[Get]]</code> 方法返回对象属性的真实值，包括对原型链继承属性的分析：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetValue(fooReference); <span class="comment">// 10</span></span><br><span class="line">GetValue(barReference); <span class="comment">// function object 'bar'</span></span><br></pre></td></tr></table></figure><p>属性访问器因该知道，他的两种变体：点（.）符号（当属性名是正确的标识符且实现知道的时候），和括号（[]）符号。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.bar();</span><br><span class="line">foo[<span class="string">'bar'</span>]();</span><br></pre></td></tr></table></figure><p>在计算中间的返回值中，引用类型对应的值如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fooBarReference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  propertyName: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">GetValue(fooBarReference); <span class="comment">// function object "bar"</span></span><br></pre></td></tr></table></figure><p>那么，引用类型的值又和函数上下文中的 <code>this</code> 的值又是怎样关联起来的呢？<strong>重点来了</strong>，这个关联时机是整篇文章个核心。在一个函数上下文中， 确定<code>this</code> 值的通用规则如下：</p><ul><li>函数上下文中的 <code>this</code> 值由调用者提供，由函数调用的方式决定（语法上怎么写函数就怎么调用）</li><li>如果调用括号()的左侧是一个引用类型的值， <code>this</code> 将被设置成这个引用类型值的 base 对象。</li><li>所有的其他情况中（与引用类型不同的任何其它属性）, <code>this</code> 的值往往都是 <code>null</code> 。但是 <code>this</code> 值为 <code>null</code> 将没有任何意义，所以，他将隐式的被转换成全局对象。</li></ul><p>看一个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;;</span><br><span class="line">foo(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure><p>我们看到在括号调用的左边是一个引用类型值（因为 foo 是一个标识符）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fooFeference = &#123;</span><br><span class="line">base: global,</span><br><span class="line">propertyName: <span class="string">'foo'</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>因此， <code>this</code> 的值被设置成了引用类型值的base对象，即，全局对象。</p><p>相似的情况也出现在属性访问中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure><p>同样，我们拥有一个引用类型的值，其base是foo对象，在bar函数激活的时候将base赋值给this。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fooBarReference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  propertyName: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而，同样的函数，使用另一种方式执行，得到不一样的值：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = foo.bar;</span><br><span class="line">test(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure><p>因为 <code>test</code> 是标识符，生成了其他引用类型值，该值的base（全局对象）被设置为this的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: <span class="string">'test'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：在ES5的严格模式中， <code>this</code>值没有强制指向全局对象，而是<code>undefined</code></p><p>现在，我们可以很明确的说，为什么用不同的形式激活相同的函数会有不一样的 <code>this</code> 值呢？答案是引用类型的不同中间值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// global object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">base: global,</span><br><span class="line">propertyName: <span class="string">'foo'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo === foo.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype, 因为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooPrototypeConstructorReference = &#123;</span><br><span class="line">base: foo.prototype,</span><br><span class="line">propertyName: <span class="string">'constructor'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一个动态确定 <code>this</code> 值的（经典）例子，就是调用表达式的方式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = &#123;<span class="attr">bar</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> y = &#123;<span class="attr">bar</span>: <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">x.test = foo;</span><br><span class="line">y.test = foo;</span><br><span class="line"></span><br><span class="line">x.test(); <span class="comment">// 10</span></span><br><span class="line">y.test(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h2 id="函数调用与非引用类型"><a href="#函数调用与非引用类型" class="headerlink" title="函数调用与非引用类型"></a>函数调用与非引用类型</h2><p>因此，真如我们上面提到的，如果在调用括号的左侧有一个不是引用类型的值，而是其他类型的值，那么 <code>this</code> 的值将自动设置为 <code>null</code> ，最终的结果就是， <code>this</code> 指向了全局对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// null ==&gt; global</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这个例子中，（括号左侧）是一个函数对象而不是一个引用类型的对象（他不是标识符也不是属性访问器），相应的， <code>this</code> 的值最终设置成了全局对象。</p><p>更复杂的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); <span class="comment">// Reference, OK ==&gt; foo</span></span><br><span class="line">(foo.bar)(); <span class="comment">// Reference, OK ==&gt; foo</span></span><br><span class="line"></span><br><span class="line">(foo.bar = foo.bar)(); <span class="comment">// global ?</span></span><br><span class="line">(<span class="literal">false</span> || foo.bar)(); <span class="comment">// global ?</span></span><br><span class="line">(foo.bar, foo.bar)(); <span class="comment">// global ?</span></span><br></pre></td></tr></table></figure><p>那么，为什么有一个属性访问器了，中间值也是一个引用类型的值，在某些调用中，我们得到的 <code>this</code> 值不是base对象而是global。</p><p>问题出现在最后的三个调用中，在调用某些操作后，括号左侧的值将<strong>不再是</strong>引用类型。</p><p>在第二个例子中，分组运算（grouping operator，结合上面的例子，这里指的就是这个<code>()</code>）没有生效，仔细想想上面提到的，从一个引用类型获取真正值的方法，如：<code>GetValue</code> 。因此，分组运算的返回值依旧是一个引用类型的值，这就是为什么 <code>this</code> 值仍然是base对象，即这里的 <code>foo</code> 。</p><p>在第三个例子中，不像分组运算，复制运算调用了 <code>GetValue</code> 方法。结果就是这个运算返回的是一个函数对象（而不是一个引用类型），这就意味着， <code>this</code> 值成了 <code>null</code> ，最终指向了global。</p><p>第四个与第五个也是一样的，逗号运算与逻辑运算（OR）调用了 <code>GetValue</code> 方法，失去了引用类型的值，取而代之的是一个函数类型的值，最终 <code>this</code> 指向了global。</p><p><strong>关于这个问题，其实有点模糊，原文中作者为一个名叫Aprit的提问者做出了这样的回答</strong>：</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d6e05455-3a77-418b-80b9-f1cddce2cc93/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d6e05455-3a77-418b-80b9-f1cddce2cc93/Untitled.png"></p><h2 id="引用类型与this为null"><a href="#引用类型与this为null" class="headerlink" title="引用类型与this为null"></a>引用类型与this为null</h2><p>有一种情况，当括号左侧的表达式（即调用方式）决定了引用类型的值， <code>this</code> 的值无论是以何种方式设置成 <code>null</code> 的，最终都将被设置成 global。当引用类型的base对象是一个活动对象的时候就造成这种情况。</p><p>我们可以从父级调用内部函数的例子中看到这种情况。在<a href="https://juejin.im/post/5ebe64486fb9a0433d763e13" target="_blank" rel="noopener">第二章</a>我我们了解到，局部变量，内部函数和形式参数存储在给定函数的活动对象中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// global</span></span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// 等同于 AO.bar()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>活动对象总是作为 <code>this</code> 的值返回 — null（伪代码 <code>AO.bar()</code> 等同于 <code>null.bar()</code>）。再次回到上面的描述中， <code>this</code> 的值再次被设置为 null。</p><p>有一个例外，在 <code>with</code> 语句中调用一个函数且 <code>with</code> 对象包含函数名称属性（结合下面的例子，值得应该是属性对应的值是一个函数）。 <code>with</code> 语言把他的对象添加到<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="noopener">作用域链</a>的最前端，即在活动对象之前。因此，引用类型有值（通过标识符或者属性访问器），base对象不是活动对象而是 <code>with</code> 语句对象。顺便提一下，这种情况不仅与内部函数有个，也与全局函数有关，因为 <code>with</code> 对象比作用域链的顶层对象（全局对象或者活动对象）还有靠前。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> (&#123;</span><br><span class="line"> </span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">  x: <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">&#125;) &#123;</span><br><span class="line"> </span><br><span class="line">  foo(); <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// because</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span>  fooReference = &#123;</span><br><span class="line">  base: __withObject,</span><br><span class="line">  propertyName: <span class="string">'foo'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>catch</code> 语句中的实际参数的函数调用也存在相同的情况：在这种情况下， <code>catch</code> 对象也是被添加到了作用域链的最前端，在活动对象或者全局对象之前。但是，这种表现在 ECMA-262-3 中被认为是一个bug，并且在 ECMA-262-5 中被修复。修复后，在给定的活动中， <code>this</code> 值指向的是全局对象而不是 <code>catch</code> 对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  e(); <span class="comment">// __catchObject - in ES3, global - fixed in ES5</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// on idea</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> eReference = &#123;</span><br><span class="line">  base: __catchObject,</span><br><span class="line">  propertyName: <span class="string">'e'</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// but, as this is a bug</span></span><br><span class="line"><span class="comment">// then this value is forced to global</span></span><br><span class="line"><span class="comment">// null =&gt; global</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> eReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: <span class="string">'e'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的情况还出现在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#feature-of-named-function-expression-nfe" target="_blank" rel="noopener">命名函数</a>（关于函数的更多细节查看 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="noopener">Chapter 5. Functions</a>）的递归调用中。在函数第一次调用的时候，base对象是父级的活动对象（或者是全局对象），在递归调用中，base对象应该是存储着函数表达式可选名称的特殊对象。但是，在这个例子中， <code>this</code> 总是被设置为 global。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">  !bar &amp;&amp; foo(<span class="number">1</span>); <span class="comment">// "should" be special object, but always (correct) global</span></span><br><span class="line"> </span><br><span class="line">&#125;)(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure><h2 id="构造函数中的-this-值"><a href="#构造函数中的-this-值" class="headerlink" title="构造函数中的 this 值"></a>构造函数中的 this 值</h2><p>还有一个在函数上下文中和 <code>this</code> 值息息相关的例子 — 函数作为构造器调用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// newly created object, below - "a" object</span></span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>在这个例子中，new操作符调用 <code>A</code> 函数内部的 [[Constructor]] 方法，在创建对象以后，接着调用内部的 [[Call]] 方法，所有相同函数 <code>A</code> ，都将 <code>this</code> 值设置为新创建的对象。</p><h2 id="手动设置一个函数调用的this"><a href="#手动设置一个函数调用的this" class="headerlink" title="手动设置一个函数调用的this"></a>手动设置一个函数调用的this</h2><p>在 <code>Function.prototype</code> 中定义了两个方法（因此所有的函数都可以访问），函数调用的时候可以手动的修改 <code>this</code> 值。他们是 <code>call</code> 和 <code>apply</code> 方法。</p><p>这两个函数都可以在函数执行上下文中将 <code>this</code> 值设置为接收的第一个参数。两个方法的区别不大：对于 <code>apply</code> 来说，第二个参数必须是一个数组（或者是一个类数组的对象，比如： <code>arguments</code> ）。相反的， <code>call</code> 方法可以接收人么参数。两个方法都必须有第一个参数 — this。</p><p>例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">a(<span class="number">20</span>); <span class="comment">// this === global, this.b == 10, c == 20</span></span><br><span class="line"> </span><br><span class="line">a.call(&#123;<span class="attr">b</span>: <span class="number">20</span>&#125;, <span class="number">30</span>); <span class="comment">// this === &#123;b: 20&#125;, this.b == 20, c == 30</span></span><br><span class="line">a.apply(&#123;<span class="attr">b</span>: <span class="number">30</span>&#125;, [<span class="number">40</span>]) <span class="comment">// this === &#123;b: 30&#125;, this.b == 30, c == 40</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      ECMA 262-3 深入解析第二章：变量对象。文章翻译自 ECMA-262-3 in detail. Chapter 3. This.
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="https://blog.lyt007.cn/tags/JavaScript/"/>
    
      <category term="ECMA" scheme="https://blog.lyt007.cn/tags/ECMA/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3深入解析第二章：变量对象</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/ECMA-262-3%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html"/>
    <id>https://blog.lyt007.cn/技术/ECMA-262-3深入解析第二章：变量对象.html</id>
    <published>2020-05-16T02:14:06.000Z</published>
    <updated>2020-05-26T02:17:41.730Z</updated>
    
    <content type="html"><![CDATA[<p>从来没有深入了解ECMA，网上找了一下，发现早在2010年就有大佬 <a href="http://dmitrysoshnikov.com/about/" target="_blank" rel="noopener">Dmitry Soshnikov</a> 总结了ECMA中的核心内容，我这里只是翻译记录，加深自己的印象。文章原文来自 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="noopener">ECMA-262-3 in detail. Chapter 2. Variable object.</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在我们创建应用程序的时候，总是避免不了会进行函数和变量的声明。但是，解释器（interpreter）是怎么找到我们的数据（函数和变量）的呢？又是在哪里找到的呢？我们引用我们需要的对象的时候又发生了什么呢？</p><p>大部分程序员都知道变量与<a href="https://juejin.im/post/5ebcdda76fb9a0433567b062" target="_blank" rel="noopener">执行上下文</a>紧密相关。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// variable of global context</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// local variable of the function context</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">alert(a); <span class="comment">// 10</span></span><br><span class="line">alert(b); <span class="comment">// b is not defined</span></span><br></pre></td></tr></table></figure><p>同样，许多程序员也都知道，在当前的版本规范中，只有函数（function）代码的执行上下文才可以创建独立的作用域。与C++等语言相反，在ECMAScript中，for循环 <code>没有</code> 创建一个独立的作用域。这就是为什么，下面的代码， <code>i</code> 始终是5</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">obj[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123; obj[k]() &#125;</span><br></pre></td></tr></table></figure><p>我们来详细了解一下声明数据的时候都发生了什么。</p><h2 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h2><p>如果变量与执行上下文相关，那么，他就知道它的数据存放在哪里以及如何获取。这种机制称为 <code>变量对象(variable object)</code></p><p>一个变量对象（缩写形式 - VO）是包含执行上下文的特殊对象，并且保存着：</p><ul><li>variables( <code>var</code>, 变量声明 )</li><li>function declarations(函数声明，缩写形式为FD)</li><li>函数形参</li></ul><p>以上内容均在上下文中声明。</p><p><strong>Notice：在ES5中，变量对象的概念已经被词汇环境模型所取代。</strong></p><p>举例来说，可以将变量对象表示为普通的ESMAScript对象：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>正如我们所说，变量对象是执行上下文的一个属性，则：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line">VO: &#123;</span><br><span class="line"><span class="comment">// context data(var, FD, function arguments)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有全局上下文中的变量对象可以通过VO的属性名称间接访问、使用（其中全局变量自身就是变量对象）。对于其他的上下文，直接访问VO是不可能的，因为它（VO）纯粹是实现机制（内部的事情）。</p><p>当我们声明变量或者函数的时候，除了使用变量名和值创建VO的新属性外，没有其他的事情了。</p><p>例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line">test(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>对应的变量对象是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的变量对象</span></span><br><span class="line">VO(globalContext) = &#123;</span><br><span class="line">a: <span class="number">10</span>,</span><br><span class="line">test: <span class="xml"><span class="tag">&lt;<span class="name">test</span>&gt;</span> fn</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 函数 test 中的变量对象</span></span><br><span class="line"><span class="xml">VO(test functionContext) = &#123;</span></span><br><span class="line"><span class="xml">x: 30,</span></span><br><span class="line"><span class="xml">b: 20</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>但是在具体的实现层级（和规范中），变量对象只是抽象的事物（实际上是不存在的）。从根本上来说，在不同的具体执行上下文中，VO的名称和初始结构都是不同的。</p><h2 id="不同执行上下文中的变量对象"><a href="#不同执行上下文中的变量对象" class="headerlink" title="不同执行上下文中的变量对象"></a>不同执行上下文中的变量对象</h2><p>变量对象的某些操作（例如：变量实例化）和表现对于所有的执行上下文类型都成很普通的。从这个角度出发，将变量对象当作为一个抽象的基础物质更容易理解。函数上下文还可以定义域变量对象相关的其他详细信息。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AbstractVO (变量实例化过程的一般行为)</span><br><span class="line"> </span><br><span class="line">  ║</span><br><span class="line">  ╠══&gt; GlobalContextVO</span><br><span class="line">  ║        (<span class="attr">VO</span> === <span class="attr">this</span> === global)</span><br><span class="line">  ║</span><br><span class="line">  ╚══&gt; FunctionContextVO</span><br><span class="line">           (<span class="attr">VO</span> === AO, &lt;arguments&gt; object <span class="literal">and</span> &lt;formal parameters&gt; are added)</span><br></pre></td></tr></table></figure><p>我们来详细分析一下：</p><h2 id="全局上下文中的VO"><a href="#全局上下文中的VO" class="headerlink" title="全局上下文中的VO"></a>全局上下文中的VO</h2><p>首先，要给出Global对象的定义：</p><blockquote><p>全局对象是在进入任何执行上下文之前就被创建好的。这个对象只存在一份，他的属性可以在进程的任何地方访问，进程结束，全局对象的声明周期结束。</p></blockquote><p>在创建时候，全局对象通过 <code>Math</code>， <code>String</code>， <code>Date</code> ， <code>parseInt</code> 等属性进行初始化，还可以附加其他对象作为属性，其中也包括引用全局对象自身的对象。例如：在BOM（浏览器对象模型）中，全局对象的 <code>window</code> 属性就是指向全局的（当然，并不是所有的实现都是这样的）。</p><p>请看下面的这个例子： <code>windos</code> 是global的属性，但同时值是global。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">global = &#123;</span><br><span class="line"><span class="built_in">Math</span>: <span class="xml"><span class="tag">&lt;<span class="name">...</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">String: <span class="tag">&lt;<span class="name">...</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">...,</span></span><br><span class="line"><span class="xml">window: global</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>当引用全局对象属性的时候，通常是省略前缀的，因为全局对象不可以直接通过名称访问。但是，可以通过<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/#this-value-in-the-global-code" target="_blank" rel="noopener">全局上下文中的 <code>this</code></a> 访问，也可以通过递归自己调用自己（例如BOM中的window）来访问。所以，代码可简写为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">10</span>); <span class="comment">// 等同于 global.String(10);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有前缀</span></span><br><span class="line"><span class="built_in">window</span>.a = <span class="number">10</span>; <span class="comment">// === global.window.a = 10 === global.a = 10;</span></span><br><span class="line"><span class="keyword">this</span>.b = <span class="number">20</span>; <span class="comment">// global.b = 20;</span></span><br></pre></td></tr></table></figure><p>回到全局上下文中的变量对象，这里的变量对象就是全局变量本身。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO(globalContext) === global;</span><br></pre></td></tr></table></figure><p>准确理解 <em>全局上下文中的变量对象就是全局变量自身</em> 是非常有必要的，基于这个事实，在全局上下文中声明一个变量的时候，我们才可以通过全局对象的属性访问到这个变量（例如：实现未知变量名时）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">alert(a); <span class="comment">// 直接获取到，因为在VO中找到了：'text'</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">window</span>[<span class="string">'a'</span>]); <span class="comment">// 间接获取到，通过 global === VO: 'text'</span></span><br><span class="line">alert(a === <span class="keyword">this</span>.a); <span class="comment">// true this === window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> akey = <span class="string">'a'</span>;</span><br><span class="line">alert(<span class="built_in">window</span>[akey]); <span class="comment">// 间接获取到，通过动态属性名 akey === 'a'</span></span><br></pre></td></tr></table></figure><h2 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h2><p>关于函数的执行上下文，VO是不能直接获取的。此时由活动对象（activation object）扮演VO的角色。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO(functionContext) === AO;</span><br></pre></td></tr></table></figure><p>活动对象在进入函数上下文的时候被创建，并且有一个属性名为 <code>argumants</code> ，属性值为 <code>Argumants Object</code> 的初始值：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line"><span class="built_in">arguments</span>: <span class="xml"><span class="tag">&lt;<span class="name">ArgO</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Arguments Object</code> 是活动对象的属性，他包含以下属性：</p><ul><li>callee：指向当前函数的引用</li><li>length：实际传递的参数的数量</li><li>properties-indexes（属性索引，字符串类型的整数）：属性的值就是函数的参数值（按照参数列表从左往右排列）。属性索引的数量==arguments.length。属性索引对应的值和实际传进来的参数是 <strong>共享的</strong>。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义的函数的参数数量 (x, y, z)</span></span><br><span class="line">  alert(foo.length); <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 实际传递参数的数量 (only x, y)</span></span><br><span class="line">  alert(<span class="built_in">arguments</span>.length); <span class="comment">// 2</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 函数自身的引用</span></span><br><span class="line">  alert(<span class="built_in">arguments</span>.callee === foo); <span class="comment">// true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 参数共享</span></span><br><span class="line"> </span><br><span class="line">  alert(x === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line">  alert(x); <span class="comment">// 10</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">  alert(x); <span class="comment">// 20</span></span><br><span class="line">  <span class="number">11549</span></span><br><span class="line">  x = <span class="number">30</span>;</span><br><span class="line">  alert(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 30</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 但是，对于未传递参数的z，属性索引的值是不共享的</span></span><br><span class="line">  </span><br><span class="line">  z = <span class="number">40</span>;</span><br><span class="line">  alert(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">50</span>;</span><br><span class="line">  alert(z); <span class="comment">// 40</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>关于最后一个例子，在 chrome 的老版本中存在一个bug — 即，没有传递参数z，z 与 arguments[2] 的仍然是共享的。</p><h2 id="处理上下文代码的阶段"><a href="#处理上下文代码的阶段" class="headerlink" title="处理上下文代码的阶段"></a>处理上下文代码的阶段</h2><p>现在，我们终于进入到本文的关键部分，处理上下文代码的过程被分为两个基本阶段：</p><ol><li>进入执行上下文</li><li>代码运行</li></ol><p>变量对象的修改与这两个阶段有着密切的关联。</p><p>注意：这两个阶段的处理是一般行为，与上下文类型无关。（对于全局和函数上下文都是公平的）。</p><h2 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h2><p>当进入执行上下文（但是是在代码运行 <code>之前</code>），VO被下面这些属性填充（在前文已经描述过）（从上往下优先级依次降低）</p><ul><li>函数的每一个形参（如果我们是在函数执行上下文） — 变量对象的一个属性，这个属性由形参的名称与值组成；如果没有传递实际参数，那么这个属性就由形参形式的名称和 <code>undefined</code> 的值组成。</li><li>每一个函数声明（FunctionDeclaration， FD） — 变量对象的一个属性，这个属性的名称是函数名，值是这个函数对象，如果这个变量对象已经拥有了相同名称的属性，那么完全替换这个属性。</li><li>每一个变量声明（var， VariableDecalartion） — 变量对象的一个属性，这个属性的名称是变量名，值是 <code>undefined</code> 。如果这个变量名和已经声明的形参或者是函数名称相同，那么这个变量<strong>不会影响</strong>已经存在的属性。</li></ul><p>来看一个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>当进入到 test 函数的上下文的时候，test函数接收了一个实参 10，AO对象如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AO(test) = &#123;</span><br><span class="line">a: <span class="number">10</span>,</span><br><span class="line">b: <span class="literal">undefined</span>,</span><br><span class="line">c: <span class="literal">undefined</span>,</span><br><span class="line">d: <span class="xml"><span class="tag">&lt;<span class="name">FD</span> <span class="attr">d</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">e: undefined</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>注意，AO中并没有包含函数 x，这是因为 x 并不是一个函数声明而是一个函数表达式（FunctionExpression， 缩写形式：FE），不影响VO（即这里的AO）。</p><p>但是，函数 _e 也是一个函数表达式，就像接下来要看到的，它是被分配给了变量 e，它可以通过变量 e 来访问。关于函数声明( <code>FunctionDeclaration</code> ）和函数表达式( <code>FunctionExpression</code> )的不同将会在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="noopener">Chapter 5. Functions</a>中讲到。</p><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>这个时候，AO/VO已经被各种属性填满了（但是，不是所有的属性都已经由具体的值了，他们中的大部分的初始值都还是 <code>undefined</code> ）。</p><p>所有代码以及环境不变的情况下，上面的代码中，AO/VO在代码解释器间被修改为如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AO[<span class="string">'c'</span>] = <span class="number">10</span>;</span><br><span class="line">AO[<span class="string">'e'</span>] = <span class="xml"><span class="tag">&lt;<span class="name">FE</span> <span class="attr">_e</span>&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>再次注意，因为FE _e 是被保存在变量 e 中，所以，它仍然存在于内存（理解成AO/VO）中。但是FE x 不在了。如果我们在定义之前或者时候调用 x 函数，我们会得到一个错误： <code>x is not defined</code> 。没有保存到一个变量的函数表达式（FE）只能立即执行或者是递归调用。</p><p>另一个经典例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(x); <span class="comment">// function</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">alert(x); <span class="comment">// 10</span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">alert(x); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>为什么第一次 <code>alert x</code> 的是一个函数，而且，还是在声明之前？为什么不是 <code>10</code> 或者 <code>20</code> ？因为，根据规则 — 当进去执行上下文的时候，VO是由函数声明填充的。同时，在相同的阶段，进入执行上下文的时候，有一个 x 的变量声明，但是我们上面已经提到了，如果这个变量名和已经声明的形参或者是函数名称相同，那么这个变量<strong>不会影响</strong>已经存在的属性。因此，当进入执行上下文的时候。VO进行如下填充：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;&#125;;</span><br><span class="line">VO[<span class="string">'x'</span>] = <span class="xml"><span class="tag">&lt;<span class="name">FD</span> <span class="attr">X</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">// 找到x的变量声明，但是x已经存在了，所以变量声明无效</span></span><br><span class="line"><span class="xml">VO['x'] = <span class="tag">&lt;<span class="name">值没有被影响，仍然是</span> <span class="attr">function</span> <span class="attr">x</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>当到了函数执行阶段，VO进行如下填充：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VO[<span class="string">'x'</span>] = <span class="number">10</span>;</span><br><span class="line">VO[<span class="string">'x'</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>这就是我们在第二次 alert 和第三次 alert 看到的内容。</p><p>下面的例子中，我们看到，当进入执行上下文阶段的时候变量都被存放在了 VO 中（虽然 <code>else</code> 语句块没有执行，但是， <code>b</code> 依然存在于 VO中）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(a); <span class="comment">// 1</span></span><br><span class="line">alert(b); <span class="comment">// undefined 不是 b is not defined.</span></span><br></pre></td></tr></table></figure><h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p>通常很多关于JavaScript的文章或者数据中都指出：“不管是使用var关键字（在全局上下文）还是不使用var关键字（在任何地方），都可以声明一个变量”。 <strong>根本就不是这样的</strong>。<strong>请记住：</strong></p><p><strong><em>变量声明只能通过 var 关键字进行声明。</em></strong></p><p>就像这样：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这仅仅只是在全局对象上创建了一个新的属性（而不是一个变量）。“不是变量”不是表示不能被修改，而是指ESMAScript规范中的“不是变量”。（由于 VO(globalContext) === global的原因，也会成为全局对象上的属性，还记得吗？）</p><p>让我们用代码来展示两者的不同</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(a); <span class="comment">// undefined</span></span><br><span class="line">alert(b); <span class="comment">// b is not defined</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>所有这些都取决于VO及其修改的阶段（进入上下文阶段和代码执行阶段）：</p><p>进入上下文：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">a: <span class="literal">undefined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到，这里没有 <code>b</code> ，因为这不是一个变量。 <code>b</code> 只会出现在在代码执行阶段（但是上面的例子中不会出现，因为出错了）。</p><p>来改一下这段代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(a); <span class="comment">// undefined 我们知道为什么</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line">alert(b); <span class="comment">// 10 创建 代码执行阶段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">alert(a); <span class="comment">// 20 代码执行阶段修改</span></span><br></pre></td></tr></table></figure><p>关于变量还有一个很重要的观点。与简单属性相反，变量具有 <code>DontDelete</code> 属性(ES5中为 <code>[[Configurable]]</code>)，意味着我们不能通过 <code>delete</code> 删除变量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="keyword">delete</span> a); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">alert(<span class="built_in">window</span>.b); <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="keyword">delete</span> b); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="built_in">window</span>.b); <span class="comment">// still 20</span></span><br></pre></td></tr></table></figure><p>然而，有一个例外。在 <code>eval</code> 上下文中，声明的变量没有 <code>{DontDelete}</code> 属性：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'var a = 10;'</span>);</span><br><span class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="keyword">delete</span> a); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">alert(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>使用一些调试工具(例如：Firebug)的控制台测试该实例时，请注意，Firebug同样是使用eval来执行控制台里你的代码。因此，变量属性同样没有 <code>{DontDelete}</code>特性，可以被删除。</p><h2 id="特殊实现：parent属性-不重要了"><a href="#特殊实现：parent属性-不重要了" class="headerlink" title="特殊实现：parent属性(不重要了)"></a>特殊实现：<strong>parent</strong>属性(不重要了)</h2><p>前面已经提到过，按照标准规范，活动对象是不能直接访问的。然而，一些具体的实现并没有按照这个标准，例如 <a href="https://zh.wikipedia.org/wiki/SpiderMonkey" target="_blank" rel="noopener"><code>SpiderMonkey</code></a> 和Rhino。在这些视实现中，函数具有特殊的属性 <code>__parent__</code> ，通过这个属性可以访问到已经创建的活动对象（或者是全局变量对象）。</p><p>例如（SpiderMonkey, Rhino）:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">alert(foo.__parent__); <span class="comment">// global</span></span><br><span class="line"><span class="keyword">var</span> VO = foo.__parent__;</span><br><span class="line">alert(VO.a); <span class="comment">// 10</span></span><br><span class="line">alert(VO === global);</span><br></pre></td></tr></table></figure><p>在上面的例子中我们可以看到，函数foo是在全局上下文中创建的，所以属性<strong>parent</strong> 指向全局上下文的变量对象，即全局对象。(译者注：还记得这个吧：VO(globalContext) === global)</p><p>然而，在SpiderMonkey中用同样的方式访问激活对象是不可能的：在不同版本的SpiderMonkey中，内部函数的<strong>parent</strong> 有时指向null ，有时指向全局对象。</p><p>在Rhino中，用同样的方式访问激活对象是完全可以的。</p><p>例如 (Rhino)：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// the activation object of the "foo" context</span></span><br><span class="line">  <span class="keyword">var</span> AO = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).__parent__;</span><br><span class="line"> </span><br><span class="line">  print(AO.y); <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// __parent__ of the current activation</span></span><br><span class="line">  <span class="comment">// object is already the global object,</span></span><br><span class="line">  <span class="comment">// i.e. the special chain of variable objects is formed,</span></span><br><span class="line">  <span class="comment">// so-called, a scope chain</span></span><br><span class="line">  print(AO.__parent__ === global); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">  print(AO.__parent__.x); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      ECMA 262-3 深入解析第二章：变量对象。文章翻译自 ECMA-262-3 in detail. Chapter 2. Variable object.
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="https://blog.lyt007.cn/tags/JavaScript/"/>
    
      <category term="ECMA" scheme="https://blog.lyt007.cn/tags/ECMA/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3深入解析第一章：执行上下文</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/ECMA-262-3%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.html"/>
    <id>https://blog.lyt007.cn/技术/ECMA-262-3深入解析第一章：执行上下文.html</id>
    <published>2020-05-12T08:07:12.000Z</published>
    <updated>2020-05-14T04:14:54.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMA-262-3-详解：1、执行上下文"><a href="#ECMA-262-3-详解：1、执行上下文" class="headerlink" title="ECMA-262-3 详解：1、执行上下文"></a>ECMA-262-3 详解：1、执行上下文</h1><p>转行来的前端，从来没有深入了解ECMA，网上找了一下，发现早在2010年就有大佬 <a href="http://dmitrysoshnikov.com/about/" target="_blank" rel="noopener">Dmitry Soshnikov</a> 总结了ECMA中的核心内容，我这里只是翻译记录，加深自己的印象。文章原文来自 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="noopener">ECMA-262-3 in detail. Chapter 1. Execution Contexts</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这篇文章中将会涉及到ECMAScript的执行上下文和与之相关的可执行代码类型。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>每一次当控件进入ECMA的可执行代码区域，那么控件就进入到了执行上下文。</p><blockquote><p>执行上下文（缩写为-EC）是ECMA-262规范用于可执行代码的典型和区分的抽象概念。</p></blockquote><p>从技术实施的角度来看，这个标准并没有定义EC的准确结构和类型。这是ECMAScript引擎实施标准的问题。</p><p>从逻辑上来说，一组活动的执行上下文形成一个堆栈。栈底始终都是一个全局上下文，栈顶则是当前（活动）执行上下文。在进入和退出各种EC的时候修改（推入/推出）堆栈。</p><h2 id="可执行代码的种类"><a href="#可执行代码的种类" class="headerlink" title="可执行代码的种类"></a>可执行代码的种类</h2><p>对于可执行上下文的抽象概念，可执行代码的类型的概念是与之相关的。说道代码类型，在某些时候，是可以表示执行上下文的。</p><p>例如，我们将执行上下栈定义为一个数组</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [];</span><br></pre></td></tr></table></figure><p>每一次进入一个函数的时候（即使这个函数是一个递归函数或者是一个构造函数），以及内置的 <code>eval</code> 函数工作时，堆栈都会被推入。</p><h2 id="全局代码"><a href="#全局代码" class="headerlink" title="全局代码"></a>全局代码</h2><p>这类代码在程序初始化的时候执行：例如加载外部的js文件或者通过本地的内联js代码（包含在 <code>&lt;script&gt;&lt;/script&gt;</code> 中的代码）。全局代码不包含任何函数体中的代码。</p><p>初始的时候（程序开始运行的时候）， <code>ECStack</code> 看起来是这样：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="函数代码（功能代码）"><a href="#函数代码（功能代码）" class="headerlink" title="函数代码（功能代码）"></a>函数代码（功能代码）</h2><p>当进入函数代码时候（各种函数，构造函数，递归，IIFE，eval等）， <code>ECStack</code> 推入一个新的元素。需要注意的是，具体函数的代码不包括内部函数的代码。</p><p>举个例子，我们运行一个一次递归的函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">flag</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">foo(<span class="literal">true</span>);</span><br><span class="line">&#125;)(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>然后，对 ECStack 进行如下修改：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次运行 foo 函数，即 foo 的立即执行</span></span><br><span class="line">ECStack = [</span><br><span class="line">&lt;foo&gt; functionContext,</span><br><span class="line">globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行 foo 函数的递归</span></span><br><span class="line">ECStack = [</span><br><span class="line">&lt;foo&gt; functionContext - recursively,</span><br><span class="line">&lt;foo&gt; functionContext,</span><br><span class="line">globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>函数的每个返回（可以理解为这段函数执行完成）都会退出当前的执行上下文，并且 <code>ECStack</code> 进行相对应的退出，这是堆栈的客观规律。上面这段代码（包含一次递归）执行完成后， <code>ECStack</code> 将再次只包含 <code>globalContext</code> ，知道程序结束。</p><p>抛出但未捕获的异常也可能会导致一个或者多个执行上下文退出。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">'退出 bar 和 foo 的执行上下文'</span>;</span><br><span class="line">&#125;)();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>虽然上面的代码是推出了栈，但是，程序出错，可能就不执行了。</p><h2 id="Eval代码"><a href="#Eval代码" class="headerlink" title="Eval代码"></a><code>Eval</code>代码</h2><p><code>eval</code> 代码让事情变得更加有趣了。在使用 <code>eval</code> 的情况下，关于 <em>调用上下文</em> 的概念产生了。即，在一个上下文中调用了 <code>eval</code> 函数。</p><p>由 <code>eval</code> 进行的操作，比如定义一个函数或者函数声明的时候会直接影响了调用上下文。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 影响了全局上下文</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'var x = 10'</span>);</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 影响了 foo 函数的局部上下文，b 是函数的局部变量</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'var y = 20'</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">alert(x); <span class="comment">// 10</span></span><br><span class="line">alert(y); <span class="comment">// y is not defined</span></span><br></pre></td></tr></table></figure><p><strong>Note：在 <code>ES5</code> 的严格模式中， <code>eval</code> 不会影响调用上下文，取而代之的是，会对沙箱代码进行评估。</strong></p><p>上面的例子会对 <code>ECStack</code> 进行如下修改：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ESStack = [</span><br><span class="line">globalContext,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval('var x = 10');</span></span><br><span class="line">ECStack.push(&#123;</span><br><span class="line">context: evalContext,</span><br><span class="line">callingContext: globalContext</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval('var x = 10'); 执行完成</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo function 执行</span></span><br><span class="line">ECStack.push(</span><br><span class="line">&lt;foo&gt; functionContext</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// eval('var y = 20');</span></span><br><span class="line">ECStack.push(&#123;</span><br><span class="line">context: evalContext,</span><br><span class="line">callingContext: <span class="xml"><span class="tag">&lt;<span class="name">foo</span>&gt;</span> functionContext</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// eval('var y = 20'); 执行完成</span></span><br><span class="line"><span class="xml">ECStack.pop();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// foo function 执行完成</span></span><br><span class="line"><span class="xml">ECStack.pop();</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      ECMA 262-3 深入解析第一章：执行上下文。文章翻译自 ECMA-262-3 in detail. Chapter 1. Execution Contexts.
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="https://blog.lyt007.cn/tags/JavaScript/"/>
    
      <category term="ECMA" scheme="https://blog.lyt007.cn/tags/ECMA/"/>
    
  </entry>
  
  <entry>
    <title>react+antd+webpack4 构建项目框架</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/react-antd-webpack4%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6.html"/>
    <id>https://blog.lyt007.cn/技术/react-antd-webpack4构建项目框架.html</id>
    <published>2020-04-15T07:02:37.000Z</published>
    <updated>2020-04-23T08:44:12.840Z</updated>
    
    <content type="html"><![CDATA[<p>入职新公司，要求自己搭建一个react的开发模板，而不是使用现有的 <code>create-react-app</code> 。所以自己搭建了一个</p><p>涉及到的功能：</p><ol><li>react, react-dom, react-router</li><li>ESlint + Aribnb</li><li>prettier</li><li>具体使用还是不使用状态管理库（redux or mobx），视情况而定，不复杂使用 React.crateContext() </li><li>使用less不使用scss</li><li>热更新，不是热重载</li></ol><p>其他的功能自己适适当配置</p><p>项目地址：<a href="https://github.com/tal007/react-antd-webpack" target="_blank" rel="noopener">https://github.com/tal007/react-antd-webpack</a></p><h2 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h2><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p>处理js，jsx，ts，tsx语法</p><h3 id="style-loader，css-loader，less-loader，postcss-loader"><a href="#style-loader，css-loader，less-loader，postcss-loader" class="headerlink" title="style-loader，css-loader，less-loader，postcss-loader"></a>style-loader，css-loader，less-loader，postcss-loader</h3><p>处理css</p><p>style-loader：添加到js中，这样修改才会热更新，在开发环境中需要加上，生产环境如果使用<code>mini-css-extract-plugin</code>抽离css，那么不要加上style-loader</p><p>注意loader使用顺序</p><p>使用less-loader需要同时安装less库</p><p>postcss-loader处理css中的一些问题，压缩等，同时可以使用postcss插件，例如<code>postcss-flexbugs-fixes</code>, <code>postcss-cssnext</code>, <code>cssnano</code> 等。</p><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>处理文件（字体，图片，影视频等）并重新命名</p><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>处理图片，设置路径以及base64图片压缩</p><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>设置html模板以及输出路径等</p><h3 id="webpack-ProvidePlugin"><a href="#webpack-ProvidePlugin" class="headerlink" title="webpack.ProvidePlugin"></a>webpack.ProvidePlugin</h3><p>设置webpack全局变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  <span class="comment">// 这样就不用每个文件都引用react了，但是需要在eslintrc中配置eslint语法检测</span></span><br><span class="line">  React: <span class="string">'react'</span>,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>css代码抽离，详见<code>config/webpack.prod.js</code></p><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>清除之前打包的代码</p><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p><code>webpack.HotModuleReplacementPlugin</code> 与 <code>webpack.NamedModulesPlugin()</code>。前者使用热更新，后者在控制台展示热更新名字。</p><p>热更新需要同时使用 <code>react-hot-loader</code>。</p><blockquote><p>npm i –save-dev react-hot-loader</p></blockquote><p>使用详见： <code>src/App.jsx</code>。还需要在 <code>.babelrc</code> 中配置 plugins</p><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>ESlint + Prettier</p><blockquote><p>npm i –save-dev eslint</p></blockquote><h3 id="配合VSCode使用"><a href="#配合VSCode使用" class="headerlink" title="配合VSCode使用"></a>配合VSCode使用</h3><p>VSCode 安装插件</p><ul><li><p><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank" rel="noopener">Prettier - Code formatter</a></p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener">ESLint</a></p></li></ul><p>.eslintrc.js中添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"plugins"</span>: [<span class="string">"prettier"</span>],</span><br><span class="line"><span class="string">"rules"</span>: &#123;</span><br><span class="line">  <span class="string">"prettier/prettier"</span>: <span class="string">"error"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 .ptettierrc.js 配置如下，可自行修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// configs see https://prettier.io/docs/en/options.html</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  trailingComma: <span class="string">'es5'</span>,</span><br><span class="line">  singleQuote: <span class="literal">true</span>,</span><br><span class="line">  tabWidth: <span class="number">2</span>,</span><br><span class="line">  semi: <span class="literal">true</span>,</span><br><span class="line">  bracketSpacing: <span class="literal">true</span>,</span><br><span class="line">  arrowParens: <span class="string">'always'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在settings.json 中添加如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// jsx自动修复有问题，取消js的format</span><br><span class="line">"editor.formatOnSave": false,</span><br><span class="line">// Enable/disable default JavaScript formatter (For Prettier)</span><br><span class="line">"javascript.format.enable": false,</span><br><span class="line">"prettier.singleQuote": true,</span><br><span class="line">// 点击保存时，根据 eslint 规则自定修复，同时集成 prettier 到 eslint 中</span><br><span class="line">"prettier.eslintIntegration": true,</span><br><span class="line">// 保存自动修复</span><br><span class="line">"editor.codeActionsOnSave": &#123;</span><br><span class="line">  "source.fixAll.eslint": true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="使用-BrowserRouter-刷新-404"><a href="#使用-BrowserRouter-刷新-404" class="headerlink" title="使用 BrowserRouter 刷新 404"></a>使用 BrowserRouter 刷新 404</h3><p>在 devServer 中 添加 <code>historyApiFallback: true</code></p><h3 id="使用-webpack-alias-的时候路径提示"><a href="#使用-webpack-alias-的时候路径提示" class="headerlink" title="使用 webpack alias 的时候路径提示"></a>使用 webpack alias 的时候路径提示</h3><p>根目录添加 <code>jsconfig.json</code> 文件，与 alias 中的对应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">      <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"baseUrl"</span>: <span class="string">"./"</span>,</span><br><span class="line">      <span class="attr">"paths"</span>: &#123;</span><br><span class="line">        <span class="attr">"@/*"</span>: [<span class="string">"./src"</span>],</span><br><span class="line">        <span class="attr">"@comp/*"</span>: [<span class="string">"./src/components"</span>],</span><br><span class="line">        <span class="attr">"@img/*"</span>: [<span class="string">"./src/img"</span>],</span><br><span class="line">        <span class="attr">"@styl/*"</span>: [<span class="string">"./src/style"</span>],</span><br><span class="line">        <span class="attr">"@pages/*"</span>: [<span class="string">"./src/pages"</span>],</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>, <span class="string">"dist"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用git-commit-规范"><a href="#使用git-commit-规范" class="headerlink" title="使用git commit 规范"></a>使用git commit 规范</h2><p>git-commit规范可以查看<a href="https://juejin.im/post/5afc5242f265da0b7f44bee4" target="_blank" rel="noopener">优雅的提交你的 Git Commit Message</a></p><p>项目地址：<a href="https://github.com/tal007/react-antd-webpack" target="_blank" rel="noopener">https://github.com/tal007/react-antd-webpack</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;入职新公司，要求自己搭建一个react的开发模板，而不是使用现有的 &lt;code&gt;create-react-app&lt;/code&gt; 。所以自己搭建了一个&lt;/p&gt;
&lt;p&gt;涉及到的功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;react, react-dom, react-router&lt;/li
      
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>使用nextjs进行react项目的服务端渲染</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/%E4%BD%BF%E7%94%A8nextjs%E8%BF%9B%E8%A1%8Creact%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93.html"/>
    <id>https://blog.lyt007.cn/技术/使用nextjs进行react项目的服务端渲染.html</id>
    <published>2020-03-24T01:42:40.000Z</published>
    <updated>2020-04-23T09:05:46.956Z</updated>
    
    <content type="html"><![CDATA[<p>react作为前端三大框架之一，用的人自然是很多的。我也是一直使用react进行项目的开发，不管是移动端还是PC端，不管是大项目还是小项目，大部分都是使用的是react进行开发的。当然，其他的框架（vue等）也是使用的。当然，客户端渲染的弊端也是很明显的，<code>首页加载缓慢</code>，<code>网站SEO问题</code>等等。</p><blockquote><p>如果功能不是太复杂又要SEO，可以尝试预渲染的模式<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/react%E9%A1%B9%E7%9B%AE%E9%A2%84%E6%B8%B2%E6%9F%93%E5%BC%80%E5%8F%91.html">react项目预渲染开发</a></p></blockquote><p>React服务端渲染可以解决这个问题。以前在没有<a href="https://nextjs.org/" target="_blank" rel="noopener">nextjs</a>的时候，我们通常都是使用react提供的<code>renderToString</code>方法在结合express等来实现的服务端渲染。当然也可以实现。但是正所谓专业的人做专业的事。自己搭建一个服务端渲染先不说麻烦，自己要踩得坑也是很多的。所以，如果是要上正式环境，在自己构建不熟悉的情况下，使用服务端渲染框架也是很不错的。</p><p>目前用的比较多的就是<a href="https://nextjs.org/" target="_blank" rel="noopener">nextjs</a>。</p><p>关于nextjs的使用在<a href="https://nextjs.org/" target="_blank" rel="noopener">官网</a>上面说的很明确。可以自己去看看。这里我记录一下实际使用的时候遇到的一些问题。</p><h2 id="1-项目部署。"><a href="#1-项目部署。" class="headerlink" title="1.项目部署。"></a>1.项目部署。</h2><p>构建自己的项目后，并成功添加页面，在本地跑起来都是没有问题的。这时候就需要部署到服务端了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hello-next"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"next"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"next build"</span>,</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"next start"</span>,</span><br><span class="line">    <span class="attr">"export"</span>: <span class="string">"npm run build &amp;&amp; next export"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"axios"</span>: <span class="string">"^0.19.2"</span>,</span><br><span class="line">    <span class="attr">"next"</span>: <span class="string">"^9.2.2"</span>,</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"^16.13.0"</span>,</span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^16.13.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>yarn build</code>以后会生成一个<code>.next</code>目录的文件夹，里面就是我们需要部署的内容。然后使用<code>yarn start</code>就可以跑起来了。可以在本地试试。</p><blockquote><p>执行 <code>yarn start</code> 之前必须先执行 <code>yarn build</code>。因为 start 需要的就是 <code>.next</code> 文件夹里面的东西。</p></blockquote><p>所以，我们在服务器上面只需要上传 <code>.next</code> 和 <code>package.json</code> 就可以了。</p><p>这样操作以后，就可以在服务器3000端口访问了。但是，如果一关闭命令窗口，那么久GG了，无法访问。</p><h2 id="使用pm2托管node项目"><a href="#使用pm2托管node项目" class="headerlink" title="使用pm2托管node项目"></a>使用pm2托管node项目</h2><p>在服务器上面安装pm2 然后使用 <code>pm2 start --name=&#39;nextjs&#39; npm -- start</code> 运行项目。这样就可以解决上面的问题。</p><p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20200324103128.png" alt="pm2启动成功"></p><p>启动成功，这样就可以在对应的端口查看了 <a href="http://118.24.6.33:3000/" target="_blank" rel="noopener">http://118.24.6.33:3000/</a></p><p>关于pm2的一系列操作可以查看<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/PM2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html">PM2常用命令</a></p><h2 id="路由页面与路由需要对应"><a href="#路由页面与路由需要对应" class="headerlink" title="路由页面与路由需要对应"></a>路由页面与路由需要对应</h2><p>开始学习的时候，我创建组件也是按照传统的创建组件（首字母大写）的方式创建的，而路由跳转又是小写的，本地一切正常，但是在部署后，就出问题了。找不到对应的小写的js的文件。这就是问题所在。</p><p>两种解决：</p><ol><li>使用小写，或者说路由与文件名字一样</li><li>使用自定义路由而不是用默认的路由</li></ol><h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><p>一直使用域名 + 端口访问是很愚蠢的。所以我们需要绑定域名。在你的域名里面添加一个二级域名解析，我这里是<code>nextjs.lyt007.cn</code>。</p><p>然后需要配置服务器上的nginx。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 定义了一个名字</span><br><span class="line">upstream nodenext &#123;</span><br><span class="line">    server 127.0.0.1:3000; #next项目 监听端口</span><br><span class="line">    keepalive 64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name nextjs.lyt007.cn;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;  </span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Nginx-Proxy true;</span><br><span class="line">        proxy_cache_bypass $http_upgrade;</span><br><span class="line">        # 这里使用这个名字反向代理</span><br><span class="line">        proxy_pass http://nodenext; #反向代理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用nextjs进行react项目的服务端渲染
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="react" scheme="https://blog.lyt007.cn/tags/react/"/>
    
      <category term="服务端渲染" scheme="https://blog.lyt007.cn/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-从使用new到手写new</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/JavaScript-%E4%BB%8E%E4%BD%BF%E7%94%A8new%E5%88%B0%E6%89%8B%E5%86%99new.html"/>
    <id>https://blog.lyt007.cn/技术/JavaScript-从使用new到手写new.html</id>
    <published>2020-03-21T07:10:16.000Z</published>
    <updated>2020-04-13T03:13:34.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><blockquote><p>new运算符创建一个用户定义的对象类型的实例或者具有构造函数的内置对象类型之一</p></blockquote><p>在手写 <code>new</code> 之前，我们来看看 new 实现了那些功能。</p><p>Demo：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, age</span>) </span>&#123; </span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.habit = <span class="string">"Ball"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.weight = <span class="number">50</span>;</span><br><span class="line">Dog.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I am"</span> + <span class="keyword">this</span>.name + <span class="string">", i am run..."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一条白色的狗</span></span><br><span class="line"><span class="keyword">var</span> whiteDog = <span class="keyword">new</span> Dog(<span class="string">'xiao bai'</span>, <span class="string">'2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(whiteDog.name); <span class="comment">// xiao bai</span></span><br><span class="line"><span class="built_in">console</span>.log(whiteDog.age); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(whiteDog.weight); <span class="comment">// 50</span></span><br><span class="line">whiteDog.run(); <span class="comment">// I am xiao bai, i am run...</span></span><br></pre></td></tr></table></figure><p>从上面的Demo中可以看出来，实例 whiteDog 可以：</p><ol><li>访问到 Dog 构造函数中的属性；</li><li>访问到 Dog.prototype 中的属性；</li></ol><p>所以。我们可以简单的实现一个 new。</p><p><strong>因为new是关键字，我们无法覆盖，所以我们用new2来表示我们的new</strong></p><p>使用的时候呢如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">...</span>)</span>&#123;...&#125;;</span><br><span class="line"><span class="comment">// 使用new</span></span><br><span class="line"><span class="keyword">var</span> whiteDog = <span class="keyword">new</span> Dog(...);</span><br><span class="line"><span class="comment">// 使用new2</span></span><br><span class="line"><span class="keyword">var</span> whiteDog = new2(Dog,...);</span><br></pre></td></tr></table></figure><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>分析：</p><p>因为 new 的结果会返回一个对象，所以在模拟实现它的时候，我们也要建立一个新的对象，假设这个对象叫 obj。因为 obj 会具有构造函数（这里指Dog）里面的属性。我们使用 Dog.allpy(obj, arguments) 来给 obj 添加新的属性。</p><p>补充两点：</p><ol><li><code>__proto__</code> 和 <code>constructor</code> 属性是对象所独有的；</li><li><code>prototype</code> 属性是函数所独有的。</li></ol><p>第一版代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  obj.__proto__ = Constructor.prototype;</span><br><span class="line">  Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面的代码已经可以生效了。不信你可以复制下面的代码运行一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 狗的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, age</span>) </span>&#123; </span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.habit = <span class="string">"Ball"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.weight = <span class="number">50</span>;</span><br><span class="line">Dog.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I am"</span> + <span class="keyword">this</span>.name + <span class="string">", i am run..."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一条白色的狗的实例</span></span><br><span class="line"><span class="keyword">var</span> whiteDog = <span class="keyword">new</span> Dog(<span class="string">'xiao bai'</span>, <span class="string">'2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(whiteDog.name); // xiao bai</span></span><br><span class="line"><span class="comment">// console.log(whiteDog.age); // 2</span></span><br><span class="line"><span class="comment">// console.log(whiteDog.weight); // 50</span></span><br><span class="line"><span class="comment">// whiteDog.run(); // I am xiao bai, i am run...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 这里通过定制传参规则，获取第一个参数，即我们需要继承的对象。</span></span><br><span class="line">  <span class="comment">// 同时因为使用的数组的 shift 方法，最后的 arguments 是少了第一项的</span></span><br><span class="line">  <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  obj.__proto__ = Constructor.prototype;</span><br><span class="line">  Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blackDog = new2(Dog, <span class="string">"xiao hei"</span>, <span class="string">'1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(blackDog.name); <span class="comment">// xiao hei</span></span><br></pre></td></tr></table></figure><p>但是有一个问题。</p><p>什么问题呢？那就是如果我的构造函数不是默认的返回值而是自己添加了一个返回值呢？</p><p>Demo2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.weight = <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    habit: <span class="string">'Games'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'Kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.weight) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.age) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。</p><p>而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个 <code>基本类型</code> 的值呢？</p><p>Demo3:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.weight = <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Kevin"</span> <span class="comment">// 你可以试试其他基本类型，包括ES6中的 Symbol();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'Kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.habit) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.weight) <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.age) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。</p><p>所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。</p><p>所以我们有了第二版的 new2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;,</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> res= Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">'object'</span> ? res: obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      通过手写一个new函数彻底理解JavaScript中的new
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javaScript" scheme="https://blog.lyt007.cn/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>PM2常用命令</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/PM2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>https://blog.lyt007.cn/技术/PM2常用命令.html</id>
    <published>2020-03-11T06:42:09.000Z</published>
    <updated>2020-04-13T03:13:34.973Z</updated>
    
    <content type="html"><![CDATA[<p>pm2常用命令记录</p><p><code>pm2 start app.js</code> # 启动app.js应用程序</p><p><code>pm2 start app.js -i 4</code>        # cluster mode 模式启动4个app.js的应用实例 4个应用程序会自动进行负载均衡</p><p><code>pm2 start app.js --name=&quot;api&quot;</code> # 启动应用程序并命名为 “api”</p><p><code>pm2 start app.js --watch</code>      # 当文件变化时自动重启应用</p><p><code>pm2 start script.sh</code>          # 启动 bash 脚本</p><p><code>pm2 list</code>                      # 列表 PM2 启动的所有的应用程序</p><p><code>pm2 monit</code>                    # 显示每个应用程序的CPU和内存占用情况</p><p><code>pm2 show [app-name]</code>          # 显示应用程序的所有信息</p><p><code>pm2 logs</code>                      # 显示所有应用程序的日志</p><p><code>pm2 logs [app-name]</code>          # 显示指定应用程序的日志</p><p><code>pm2 flush</code>                       # 清空所有日志文件</p><p><code>pm2 stop all</code>                  # 停止所有的应用程序</p><p><code>pm2 stop 0</code>                    # 停止 id为 0的指定应用程序</p><p><code>pm2 restart all</code>              # 重启所有应用</p><p><code>pm2 reload all</code>               # 重启 cluster mode下的所有应用</p><p><code>pm2 gracefulReload all</code>        # Graceful reload all apps in cluster mode</p><p><code>pm2 delete all</code>                # 关闭并删除所有应用</p><p><code>pm2 delete 0</code>                  # 删除指定应用 id 0</p><p><code>pm2 scale api 10</code>              # 把名字叫api的应用扩展到10个实例</p><p><code>pm2 reset [app-name]</code>          # 重置重启数量</p><p><code>pm2 startup</code>                  # 创建开机自启动命令</p><p><code>pm2 save</code>                      # 保存当前应用列表</p><p><code>pm2 resurrect</code>                # 重新加载保存的应用列表</p><p><code>pm2 update</code>                    # Save processes, kill PM2 and restore processes</p><p><code>pm2 generate</code>                  # Generate a sample json configuration file</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><code>pm2 start npm -- start</code>        # pm2 启动 npm 命令。scripts中名字为 start</p><p>pm2文档地址：<a href="https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/</a></p>]]></content>
    
    <summary type="html">
    
      pm2 常用命令
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="pm2" scheme="https://blog.lyt007.cn/tags/pm2/"/>
    
  </entry>
  
  <entry>
    <title>移动端UI框架</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AFUI%E6%A1%86%E6%9E%B6.html"/>
    <id>https://blog.lyt007.cn/技术/移动端UI框架.html</id>
    <published>2020-03-02T01:32:10.000Z</published>
    <updated>2020-04-13T03:13:34.974Z</updated>
    
    <content type="html"><![CDATA[<p>UI框架作为前端一门必须要了解并且熟练掌握的一门技术，关于目前不同的js框架对应的不同的框架还是有必要说说。</p><p>关于PC端的UI框架是在是太多了。</p><ul><li><p>react：目前常用的得数蚂蚁金服出的<a href="https://ant.design/" target="_blank" rel="noopener">Ant Design</a>了。而最新刚刚发布了4.0版本。移除了对IE9/10的支持，同时也支持 React Hook。当然还有其他的</p></li><li><p>vue：目前常用的算得上是饿了么出的ElementUI了。当然还有其他的</p></li></ul><p>移动端的UI框架也挺多。不过这是针对于VUE来说的。</p><ul><li><a href="https://youzan.github.io/vant/#/zh-CN/" target="_blank" rel="noopener">Vant UI</a>。有赞公司出的一套电商类的UI框架，如果是做移动端电商的，想必这款UI框架用的是得心应手了吧</li><li><a href="https://muse-ui.org/#/zh-CN" target="_blank" rel="noopener">Muse UI</a>。社区人员维护的一套UI框架。</li><li><a href="https://didi.github.io/mand-mobile/#/zh-CN/home" target="_blank" rel="noopener">Mand Mobile</a>。也是社区活跃挺高的一款UI。同时还包含了<a href="https://didi.github.io/mand-mobile-rn/?path=/story/mand-mobile-rn--%E5%BF%AB%E9%80%9F%E6%8E%A5%E5%85%A5" target="_blank" rel="noopener">React Native的UI</a>。</li></ul><p>VUE的可以说有很多，但也有很多都不再维护了。比如滴滴公司的Cube UI，京东的Nut UI等等。</p><p>再来看看React，相对来说就很少了。我一直都是在使用react开发网站，不管是PC还是H5的。PC的当然是首选了 Ant Design，但是H5端的ant是真的没有PC的好用。所以最开始在开发移动端的时候都是自己写的样式，交互体验也比较差。后面觉得是在是不行了。就到处找，找了一款国外的UI框架 <a href="https://framework7.io/" target="_blank" rel="noopener">Framework7</a>。</p><p>Framework7其实最开始是专注于 WebApp 开发的，而且在IOS的上面的体验几乎与原生媲美，安卓上性能就差很多了。不多最近我在使用这个框架的时候，其中的大部分功能还是挺不错的，在使用React开发的时候可以选择这款UI框架。不过如果是做H5，那最好就不要使用UI框架自带的路由了，真的太差了。</p><p>如果你有其他的react的UI框架推荐，欢迎留言。</p>]]></content>
    
    <summary type="html">
    
      移动端UI框架推荐
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="移动端" scheme="https://blog.lyt007.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="UI" scheme="https://blog.lyt007.cn/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>不打算在使用BootCND</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/%E4%B8%8D%E6%89%93%E7%AE%97%E5%9C%A8%E4%BD%BF%E7%94%A8BootCND.html"/>
    <id>https://blog.lyt007.cn/技术/不打算在使用BootCND.html</id>
    <published>2020-02-24T02:13:15.000Z</published>
    <updated>2020-04-13T03:13:34.974Z</updated>
    
    <content type="html"><![CDATA[<p>今天（2020年02月24日）上班来到公司，一如既往的开机准备开开心心的敲代码了。结果，日了狗了。网站报错了。</p><p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/E8EF11D3-D0D4-4E6F-8EEF-2D76D59784B2.png" alt></p><p>结果。就是因为使用了 <a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">BootCND</a> 导致的网站无法访问。</p><p>出问题了。可能会亏损几个亿吧。当然，几个亿是不可能的。</p><p>所以。这件事情以后，打算不再使用CDN了。<strong>还是老老实实的放本地吧。</strong></p><p>或者 <a href="cdnjs.com">https://cdnjs.com/</a> 可能也是一个不错的选择。</p><p>记在这里，就当给自己一个教训。</p>]]></content>
    
    <summary type="html">
    
      关于CND那些事
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CDN" scheme="https://blog.lyt007.cn/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>React Hook</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/React-Hook.html"/>
    <id>https://blog.lyt007.cn/技术/React-Hook.html</id>
    <published>2020-01-16T09:25:27.000Z</published>
    <updated>2020-04-22T03:28:52.454Z</updated>
    
    <content type="html"><![CDATA[<p>React Hook 在 <code>react 16.8及以后的版本</code>中才会有</p><h2 id="React-Hook-解决的问题"><a href="#React-Hook-解决的问题" class="headerlink" title="React Hook 解决的问题"></a>React Hook 解决的问题</h2><h3 id="1-组件之间复用状态逻辑"><a href="#1-组件之间复用状态逻辑" class="headerlink" title="1. 组件之间复用状态逻辑"></a>1. 组件之间复用状态逻辑</h3><h3 id="2-减少组件的复杂程度"><a href="#2-减少组件的复杂程度" class="headerlink" title="2. 减少组件的复杂程度"></a>2. 减少组件的复杂程度</h3><p>在传统的 class 中，会使用 componentDidMount 和 componentDidUpdate 获取数据。同时 componentDidMount 中也会处理一些其他的事务，例如事件监听，定时器等等。而后还需要在 componentWillUnmount 中取消。万一忘记其中某一个部分或者处理的时间过多，很可能导致一些可怕的bug。</p><h3 id="3-关于-class-类与函数组件-this-的问题"><a href="#3-关于-class-类与函数组件-this-的问题" class="headerlink" title="3. 关于 class 类与函数组件 this 的问题"></a>3. 关于 class 类与函数组件 this 的问题</h3><p>对于一部分人来说，理解 class 中的 this 会比理解函数组件中的 this 更加困难，而且增加了学习成本。<strong>但是，react 中并不会移除 class 这种方法</strong></p><p><a href="https://www.youtube.com/watch?time_continue=356&amp;v=dpw9EHDh2bM&amp;feature=emb_logo" target="_blank" rel="noopener">YouTube上面的视频</a></p><h2 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h2><p>传统的 React 组件的 state 都是这样的，创建一个 state 与更新（this.setState）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;_</span> =&gt;</span> this.setState(&#123;count: this.state.count++&#125;)&#125;&gt;&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 React Hook 后<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;_</span> =&gt;</span> setCount(count++)&#125;&gt;&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到。使用 Hook 后的代码简洁了很多。但是，使用 <code>useState</code> 不会把新的 state 和旧的 state 进行合并。</p><p>上面，我们只是用了一个 count。但是通常一个组件都不会只有一个 state 的，这时候可以多次使用 <code>useState</code>。</p><p>同时，定义 state 的时候定义在一个数组里面，可以猜到， useState 返回的不是一个不同的数字或者字符串，而是一个对象（数组）。这里这样定义，使用了 ES6 中的<a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">解构赋值</a></p><h2 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h2><p><code>useState</code> 其实不难理解，唯一需要注意的就是 <code>this.setState</code> 是修改后的 state 与之前的 state 对比合并，而采用 <code>useState</code> 则是直接替换。</p><p>作为使用过一段时间的 React Hook 的程序员，个人认为 <code>Effect Hook</code> 才需要更多的理解。</p><p>React官方文档中这样定义的</p><blockquote><p>你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。<br><code>useEffect</code> 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API。</p></blockquote><p>所以，我们使用 Hook 后，数据获取、订阅或者手动修改过 DOM等都需要在 <code>useEffect</code> 中进行了。</p><blockquote><p>不要以为 <code>useEffect</code> 和 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 一样只能使用一次，他与 <code>useState</code> 一样，可以多次使用。</p></blockquote><p>默认情况下，React 会在每次渲染后调用副作用函数(<code>useEffect</code>) —— 包括第一次渲染的时候。所以，在 <code>useEffect</code> 函数中可以直接使用 props 和 state</p><p><code>useEffect</code> 接收两个参数。第一个参数是一个函数，第一个参数相当于 <code>componentDidMount</code> 和 <code>componentDidUpdate</code>，第一个参数可以有一个返回值（一般就是一个函数，我们将之称为<em>清除函数</em>），相当于与 <code>componentWillUnmount</code>。这样一说，你可能就理解了。再来举个例子，更形象的说明一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> doSomething(), <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.timer) clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的是传统的方式，添加以及移除定时器的操作。因为需要在 <code>componentWillUnmount</code> 中进行判断，有时候（大部分时候）可能都会遗忘。</p><p>再来看看使用 <code>useEffect</code> 的代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> doSomething(), <span class="number">1000</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// return 一个函数，将会在组件将要卸载的时候调用 相当于 componentWillUnmount</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(timer)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，使用 <code>useEffect</code> 不单单是代码更简洁，同时使我们的代码逻辑看起来更直观。设置定时器与清除定时器是放在一个API里面的，代码的耦合更高。更能体现这是一个整体，也避免了遗忘。</p><p><strong>为什么要在 effect 中返回一个函数？</strong> 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><p><strong>React 何时清除 effect？</strong> React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</p><p>如果不涉及到异步，订阅等操作，可以不用返回清除函数</p><p>上面只是 <code>useEffect</code> 的一个简单的事例，它的功能不止于此。因为之前还说过，处理数据请求也是在里面处理的。那么怎么使用呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do ajax request</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是上面那样写，会有一个严重的问题。之前说过， <code>useEffect</code> 是会在<strong>DOM初次加载完成以及DOM更新完成的时候调用</strong>，所以上面的请求会在每一次DOM更新的时候再次执行，而如果请求返回的结果会使DOM更新，那么，这就是一个无限循环的过程了。</p><p>那么怎么处理这个副作用呢？这时候就需要 <code>useEffect</code> 的第二个参数了。一般是一个数组</p><p>如果两次需要更新的数据没有变化，只需要在第二个参数（数组）中添加对应的变量，例如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure></p><p>但是如果是上面的处理 <code>ajax request</code> 的 effect 。只需要传递一个空数组即可。这样，这个 effect 只会执行一次。</p><p><em>React 会对数组中的数据进行更新前后数据的对比，如果没有变化，那么则不更新</em></p><p>这个方法对于有清除函数的 effect 同样适用。</p><blockquote><p>React官网中说到：未来版本，可能会在构建时自动添加第二个参数。期待他的到来，这将大大减少可能出现的bug。</p></blockquote><h2 id="其他-Hook"><a href="#其他-Hook" class="headerlink" title="其他 Hook"></a>其他 Hook</h2><p>除了 <code>useState</code> 和 <code>useEffect</code> 两个常用的 Hook， 还有一些其他的 Hook， 这些可能用的不多。</p><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure><p>这个 Hook 用于连接 React 上下文。使用过 <code>React.createContext</code> 的老铁应该知道，这是创建一个 React 上下文</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Context = React.createContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上层组件</span></span><br><span class="line">&lt;Context.Provider&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 消费这个 Context 的组件</span></span><br><span class="line">&lt;Context.Consumer&gt;&lt;/Context.Consumer&gt;</span><br></pre></td></tr></table></figure><p>使用 <code>useContext</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Context = React.createContext;</span><br><span class="line"></span><br><span class="line">useContext(Context)</span><br></pre></td></tr></table></figure></p><p>例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">"#000000"</span>,</span><br><span class="line">    background: <span class="string">"#eeeeee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">"#ffffff"</span>,</span><br><span class="line">    background: <span class="string">"#222222"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br><span class="line">      &lt;Toolbar /&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemedButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ThemedButton() &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 通过 useContext 使用 React.createContext(themes.light) 创建的 Context</span></span><br><span class="line"><span class="regexp">  const theme = useContext(ThemeContext);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      I am styled by theme context!</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><p><code>useState</code> 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>既然作用类似于 Redux， 那么可以用这个取代 Redux 么？答案是可以的，不过需要结合 <code>useContext</code> 来使用。掘金上面有码友给出了一个例子<a href="https://juejin.im/post/5ceb37c851882520724c7504" target="_blank" rel="noopener">用 useContext + useReducer 替代 redux</a>。</p><p>你可以在新项目中或者涉及状态管理不多的项目中尝试使用，现有的大型项目不建议重构，使用 Redux 依然是不错的方案。</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>返回一个 <code>memoized</code> 回调函数。</p><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code> ，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code> ）的子组件时，它将非常有用。</p><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure><p>返回一个 memoized 值。</p><p><code>useCallback</code> 与 <code>useMemo</code> 都可以用于 React 性能优化的手段。</p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure><p><code>useRef</code> 返回一个可变的 <code>ref</code> 对象，其 <code>.current</code> 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</p><p>所以，这个方法就相当于 class 中的 <code>ref</code> 属性，用于获取具体的DOM元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3><p>上面未说明的 Hook 可以查看 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext" target="_blank" rel="noopener">React 官网</a></p><h2 id="Hook-规则"><a href="#Hook-规则" class="headerlink" title="Hook 规则"></a>Hook 规则</h2><p>Hook <strong>永远是在最顶层调用</strong>，不能在条件判断语句或者其他语句中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 正确</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(name === <span class="string">'tal'</span>)&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误</span></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'tal'</span>) &#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你害怕你写错了，但是没有检查出来，可以使用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener">eslint-plugin-react-hooks</a> 这个插件来检测。</p><h2 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h2><p>Hook 我们也是可以自定义的。那么为什么需要自定义。答案是 <strong>逻辑共享</strong>。</p><p>假如有一个 state 需要在多个组件中使用，我们不应该在多个组件中都单独的去创建这个 state， 而是应该<strong>逻辑共享</strong>。把这个 state 以及操作这个 state 的方法定义在我们自己的 Hook 中。那这个 Hook 就是我们自定义的 Hook，其实，他也是一个函数，接收参数，返回你需要的值。唯一需要注意的是：<strong>自定义 Hook 必须以 <code>use</code> 开头</strong>，不管怎么变，使用需要遵循 React Hook 以 <code>use</code> 开头的规则。</p><p>下面是一个获取window视窗的hook</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useCallback, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取窗口大小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWinSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [size, setSize] = useState(&#123;</span><br><span class="line">    width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">    height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onResize = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setSize(&#123;</span><br><span class="line">      width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">      height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, onResize);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, onResize);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useWinSize;</span><br></pre></td></tr></table></figure><p><a href="https://zh-hans.reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">官网介绍</a></p>]]></content>
    
    <summary type="html">
    
      React Hook介绍，React Hook笔记
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="react" scheme="https://blog.lyt007.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react 读书笔记</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/react-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>https://blog.lyt007.cn/技术/react-读书笔记.html</id>
    <published>2020-01-09T02:46:51.000Z</published>
    <updated>2020-04-13T03:13:34.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在-React-组件中，代码重用的主要方式是组合而不是继承。"><a href="#在-React-组件中，代码重用的主要方式是组合而不是继承。" class="headerlink" title="在 React 组件中，代码重用的主要方式是组合而不是继承。"></a>在 React 组件中，代码重用的主要方式是组合而不是继承。</h2><blockquote><p>We strongly recommend against creating your own base component classes. In React components, code reuse is primarily achieved through composition rather than inheritance.</p></blockquote><p>这句话来自于react的<a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">官方网站</a></p><p>为什么要提及这句话呢。因为现在我的项目中也有自己的创建的组件类，然后其余的组件来继承它。</p><p>其实最开始我也是一步一步的使用<code>class App extends React.Component</code>来写我自己的组件，这样确实有点复杂，但是还算过得去。或许是因为初学react或者是对react的了解不深入，所以，一直就这样。去年了解了一下同事的安卓开发，他们都会建一个基础的类来继承于这个类，这个基础的类实现了一些公用的方法，所以继承于这个基础类的组件也会有这些方法，而且不用每一次都引入。这样理念确实很不错。自己用了一段时间，某些地方也确实方便，尤其是在组件数据请求的时候，需要渲染不同的组件（loading，completed，empty，request_error and so on），而且目前还没有发现有什么不一样的地方，因为这些继承于基础类的组件也是可以使用React的生命周期。直到今天，我才知道，原来这是<strong>违背了react的开发理念</strong>。那要怎么实现呢。正如上面所说</p><blockquote><p>code reuse is primarily achieved through composition rather than inheritance.</p></blockquote><p>通过组件的组合来实现，通过<code>props</code>参数来实现，具体查看<a href="https://reactjs.org/docs/composition-vs-inheritance.html" target="_blank" rel="noopener">Composition vs Inheritance</a>。</p><p>虽说这样开发可能会复杂一点（或许是自己的技术能力有限），不过这样也算是符合react的理念。</p><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>react组件的生命周期作为react开发人员面试的必考知识，还是很有必要实时掌握，并且实时更新。</p><p>React生命周期有一份<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">图谱</a>。上面可以查看react的生命周期(新版)。</p><p>react的组件的生命周期在react16.3及以后的版本中已经不一样了。但是总的几个阶段是不变的，不管是新的版本还是老的版本，都分为</p><ul><li>组件挂载</li><li>组件更新</li><li>组件卸载</li></ul><p>这样的几个阶段。</p><h3 id="React16-3以前的生命周期-作为了解"><a href="#React16-3以前的生命周期-作为了解" class="headerlink" title="React16.3以前的生命周期(作为了解)"></a>React16.3以前的生命周期(作为了解)</h3><h4 id="1-组件挂载"><a href="#1-组件挂载" class="headerlink" title="1.组件挂载"></a>1.组件挂载</h4><ol><li>getDefaultProps()：加载的时候调用一次，设置默认的<code>props</code>，也可以使用<code>组件名.defaultProps = {}</code>设置默认属性。</li><li>getInitialState()：加载的时候调用一次，可以初始化<code>state</code>。</li><li>componentWillMount()：只在组件挂载的时候调用，且整个生命周期只调用一次，此时可以修改<code>state</code>。但是一般不使用</li><li>render()：react的最重要的步骤，创建虚拟DOM，进行<code>diff算法</code>,更新DOM树都在此运行</li><li>componentDidMount()：组件渲染之后（执行rendeer后）调用一次</li></ol><h4 id="2-组件更新"><a href="#2-组件更新" class="headerlink" title="2.组件更新"></a>2.组件更新</h4><ol><li>componentWillReceiveProps(nextProps)：组件加载时不使用，组件接收新的<code>props</code>是调用</li><li>shouldComponentUpdate(nextProps, nextState)：组件接收到新的props或state时调用，函数<strong>必须</strong>有一个返回值（true or false），为<code>true</code>的时候组件更新，为 <code>flase</code> 的时候组件不更新。默认返回的是<code>true</code>。这个方法很重要，一个组件的优化都在这里面进行。</li><li>componentWillUpdata(nextProps, nextState)</li><li>render()：react的最重要的步骤，创建虚拟DOM，进行<code>diff算法</code>,更新DOM树都在此运行</li><li>componentDidUpdate()：组件挂载时不调用，组件更新完成调用</li></ol><h3 id="3-卸载阶段"><a href="#3-卸载阶段" class="headerlink" title="3.卸载阶段"></a>3.卸载阶段</h3><ol><li>componentWillUnmount()：组件将要移除时候调用。一般在这个函数里面清除定时器，异步操作等</li></ol><h3 id="React16-3以后的生命周期"><a href="#React16-3以后的生命周期" class="headerlink" title="React16.3以后的生命周期"></a>React16.3以后的生命周期</h3><h3 id="1-挂载阶段"><a href="#1-挂载阶段" class="headerlink" title="1.挂载阶段"></a>1.挂载阶段</h3><ol><li>constructor()：在这个构造函数中一般处理初始化state或者进行方法的绑定，如不需要，则可以不使用此方法</li><li>static getDerivedStateFromProps()：会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</li><li>render()</li><li>componentDidMount()</li></ol><p>*.componentWillMount方法在新的生命周期中已经过期，应该替换成<code>UNSAFE_componentWillMount</code>，不过也将在react17中移除</p><h3 id="2-更新阶段"><a href="#2-更新阶段" class="headerlink" title="2.更新阶段"></a>2.更新阶段</h3><ol><li>static getDerivedStateFromProps()</li><li>shouldComponentUpdate()</li><li>render()</li><li>getSnapshotBeforeUpdate(prevProps, prevState)：此方法并不常使用</li><li>componentDidUpdate()</li></ol><p>*. 老方法的<code>componentWillUpdate</code>以及<code>componentWillReceiveProps</code>即将过期，应该避免使用它们</p><h3 id="3-卸载阶段-1"><a href="#3-卸载阶段-1" class="headerlink" title="3.卸载阶段"></a>3.卸载阶段</h3><ol><li>componentWillUnmount()</li></ol><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol><li>static getDerivedStateFromProps()</li><li>componentDidCatch(error, info)：此生命周期在后代组件抛出错误后被调用</li></ol><p>总的来说新的生命周期移除了一些不必要的函数。具体的可以查看<a href="https://zh-hans.reactjs.org/docs/react-component.html" target="_blank" rel="noopener">React.Component</a></p><h2 id="对-React-时间操作节流与防抖"><a href="#对-React-时间操作节流与防抖" class="headerlink" title="对 React 时间操作节流与防抖"></a>对 React 时间操作节流与防抖</h2><ul><li>节流：节流阻止函数在给定时间窗口内被调不能超过一次。</li><li>防抖：防抖确保函数不会在上一次被调用之后一定量的时间内被执行。当必须进行一些费时的计算来响应快速派发的事件时（比如鼠标滚动或键盘事件时），防抖是非常有用的。</li></ul><p>以前在进行按钮提交，鼠标滚动等操作的时候，都会进行截留或者是防抖。但是都是自己写的，有时候或者是有的地方会忘记添加。</p><p><a href="https://lodash.com" target="_blank" rel="noopener">lodash</a>中已经有相关的函数了</p><ul><li><a href="https://lodash.com/docs/4.17.15#throttle" target="_blank" rel="noopener">throttle</a></li><li><a href="https://lodash.com/docs/4.17.15#debounce" target="_blank" rel="noopener">debounce</a></li></ul><p>但是，整个 lodash 的库应用进来有1.4M，太大了。不过还好，npm 上面已经有 throttle 和 debounce 的提取包了。</p><ul><li><p><a href="https://www.npmjs.com/package/lodash.throttle" target="_blank" rel="noopener">https://www.npmjs.com/package/lodash.throttle</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save lodash.throttle</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.npmjs.com/package/lodash.debounce" target="_blank" rel="noopener">https://www.npmjs.com/package/lodash.debounce</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save lodash.debounce</span><br></pre></td></tr></table></figure></li></ul><p>都接收两个参数，第一个是操作的函数，第二个是时间间隔(ms)。</p>]]></content>
    
    <summary type="html">
    
      react读书笔记，来自于文档，书籍等资料中的见解以及感悟
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="react" scheme="https://blog.lyt007.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react项目报错集锦</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/react%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A6.html"/>
    <id>https://blog.lyt007.cn/技术/react项目报错集锦.html</id>
    <published>2020-01-03T03:08:36.000Z</published>
    <updated>2020-04-13T03:13:34.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Warning-Can’t-perform-a-React-state-update-on-an-unmounted-component-This-is-a-no-op-but-it-indicates-a-memory-leak-in-your-application-To-fix-cancel-all-subscriptions-and-asynchronous-tasks-in-the-componentWillUnmount-method"><a href="#Warning-Can’t-perform-a-React-state-update-on-an-unmounted-component-This-is-a-no-op-but-it-indicates-a-memory-leak-in-your-application-To-fix-cancel-all-subscriptions-and-asynchronous-tasks-in-the-componentWillUnmount-method" class="headerlink" title="Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method."></a>Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.</h2><p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20200103111012.png" alt="错误截图"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方法上面其实以及说到了。只需要找到对象的文件，在 <code>componentWillUnmount</code> 中取消所有的订阅以及异步执行即可。</p><p>下面是代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Avatar <span class="keyword">from</span> <span class="string">'@img/common/avatar.jpeg'</span></span><br><span class="line"><span class="keyword">import</span> Stance <span class="keyword">from</span> <span class="string">'@img/common/stance.png'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CusImage</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> defaultImage = props.isAvatar ? Avatar : Stance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      src: defaultImage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">const</span> THIS = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123;imgSrc&#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">    img.src = imgSrc</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      THIS.setState(&#123;</span><br><span class="line">        src: imgSrc</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加以下代码</span></span><br><span class="line">  componentWillUnmount()&#123;</span><br><span class="line">    <span class="comment">// 如果有定时器需要清除</span></span><br><span class="line">    <span class="comment">// clearTimeout(this.timer)</span></span><br><span class="line">    <span class="keyword">this</span>.setState = <span class="function">(<span class="params">state, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render ()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;src&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> &#123;className, alt = <span class="string">"cus-img"</span>&#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;img className=&#123;className&#125; src=&#123;src&#125; alt=&#123;alt&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CusImage</span><br></pre></td></tr></table></figure></p><h2 id="react-dom-development-js-12427-Warning-componentWillMount-has-been-renamed-and-is-not-recommended-for-use-See-https-fb-me-react-unsafe-component-lifecycles-for-details"><a href="#react-dom-development-js-12427-Warning-componentWillMount-has-been-renamed-and-is-not-recommended-for-use-See-https-fb-me-react-unsafe-component-lifecycles-for-details" class="headerlink" title="react-dom.development.js:12427 Warning: componentWillMount has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details."></a>react-dom.development.js:12427 Warning: componentWillMount has been renamed, and is not recommended for use. See <a href="https://fb.me/react-unsafe-component-lifecycles" target="_blank" rel="noopener">https://fb.me/react-unsafe-component-lifecycles</a> for details.</h2><p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20200103143951.png" alt="错误截图"></p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>在 react 16.8 之后的版本中，修改了一下生命周期，移除了一些方法，<code>componentWillMount</code>就是其中一个。现在如果要使用这个，使用 <code>UNSAFE_componentWillMount</code> 替换。但是不建议使用这个方法</p>]]></content>
    
    <summary type="html">
    
      react项目报错(警告)以及处理方式
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="react" scheme="https://blog.lyt007.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端中的直播</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E7%9B%B4%E6%92%AD.html"/>
    <id>https://blog.lyt007.cn/技术/前端中的直播.html</id>
    <published>2019-11-05T02:50:55.000Z</published>
    <updated>2020-04-13T03:13:34.970Z</updated>
    
    <content type="html"><![CDATA[<p>因为公司是做在线抓娃娃的，涉及到直播推流这一部分的工作。之前一直都是在App上面进行游戏，所以关于直播这一部分也是与安卓与IOS有关，与前端是没有关系的。但是现在新的需求就是要求这个在线抓娃娃要能够在网页上面进行游戏。所以，我的事情来了。对于没有涉及到前端音视频的这部分的需求，所以初入这一行，还是有点马马虎虎，花了一周多的时间终于是弄明白了。</p><p>要了解前端视频方面的东西，还是要从基础的说起。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>2019年了，HTML5已经走进千家万户，同时，直播也在全球盛行。App端的姑且不说，web端的使用视频播放的话，一般都是在用HTML5中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video" target="_blank" rel="noopener">video</a> 标签了。然而，video标签的限制实在是太多了，尤其是对于播放格式这一项，仅仅是支持 <code>MP4</code> <code>OGG</code> <code>WebM</code> 格式，现在可能还支持 <code>m3u8</code> 格式的视频。</p><p>但是，再来看看现在的直播方面的知识</p><h2 id="直播简介"><a href="#直播简介" class="headerlink" title="直播简介"></a>直播简介</h2><p>关于直播，大概的过程是：<strong>推流—&gt;源站—&gt;客户端拉流—&gt;客户端播放</strong></p><ol><li>推流：指的是把采集阶段封包好的内容传输到服务器的过程。</li><li>拉流：一般是一个URL地址，即播放地址，有多种类型的流。</li></ol><p>视频直播服务目前常用的包含三种协议（当前时间阿里云的直播推流也是这三种协议），分别是RTML， HLS， (HTTP-)FLV。</p><p>下面附上一张知乎上面的推流拉流图</p><p><img src="https://pic2.zhimg.com/80/7cb543431f65ddc2d328856f1fcc47fc_hd.jpg" alt="推流拉流图"></p><p>###<br>RTMP: RTMP是Real Time Messaging Protocol（实时消息传输协议）的缩写，是Adobe公司为Flash/AIR平台和服务器之间音、视频及数据传输开发的实时消息传送协议。RTMP协议基于TCP，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP协议中，视频必须是H264编码，音频必须是AAC或MP3编码，且多以flv格式封包。RTMP是目前最主流的流媒体传输协议，对CDN支持良好，实现难度较低，是大多数的直播平台的选择。不过RTMP有着一个最大的不足——不支持浏览器，且Adobe已不再更新。因此直播服务要支持浏览器的话，需要另外的推送协议支持。</p><p>优点：</p><ul><li>延时低，稳定性好，支持摄像头格式多</li></ul><p>缺点：</p><ul><li>浏览器需要加载flash才可以播放（预计2020年底所有浏览器最新版本都不在支持flash）</li><li>RTMP是私有协议（Adobe的私有协议），很多设备无法播放。同时移动端不支持flash。所以，这种格式的视频基本无法再移动端使用。</li><li>安全性问题</li></ul><h3 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h3><p><a href="https://www.jianshu.com/p/426425cad08a" target="_blank" rel="noopener">HLS</a>（Http Live Streaming) 是一个由苹果公司提出的基于HTTP的流媒体网络传输协议，直接把流媒体切片成一段段，信息保存到<code>m3u(m3u8)</code>列表文件中， 可以将不同速率的版本切成相应的片；播放器可以直接使用http协议请求流数据。</p><p>优点：</p><ul><li>可以在不同速率的版本间自由切换，实现无缝播放</li><li>省去使用其他协议的烦恼</li></ul><p>缺点：</p><ul><li>延时高，不适合做直播</li><li>因为采用ts切片，所以一个文件可能会被切成成百上千个小文件，对存储和缓存都有一定的挑战</li></ul><p>这个流一般用于苹果web浏览器的直播，因为FLV和RMTP都不支持IOS的移动端（手机与平板）</p><h3 id="HTTP-FLV"><a href="#HTTP-FLV" class="headerlink" title="HTTP-FLV"></a>HTTP-FLV</h3><p>关于FLV在目前来说还是一个更好的方案，关于FLV方面的介绍可以查看<a href="https://github.com/gwuhaolin/blog/issues/3" target="_blank" rel="noopener">使用flv.js做直播</a>。上面有详细的介绍。</p><p>因为bilibili开源flv.js的原因，使得flv在目前的直播中用的更多，尤其是在移动端中使用flv流。</p><p>上面的三种方案RTMP是最好的，不管是延时还是性能问题。所以，最好的方案就是PC端采用RTMP，移动端采用HTTP-FLV。但是要考虑一点就是2020年的flash的问题。</p><h2 id="前端做直播"><a href="#前端做直播" class="headerlink" title="前端做直播"></a>前端做直播</h2><p>在视频播放方面，前端有一个开源的插件<a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">videojs</a>。可以播放HTML5的视频格式以及Flash方面的视频。但是，在6.X开始的版本后，videojs不在支持flash，需要单独引用<a href="https://github.com/videojs/videojs-flash" target="_blank" rel="noopener">videojs-flash</a>插件，或者是使用6.X以下的版本。</p><p><strong>重点注意：videojs+flash不支持移动端</strong>。当初在这里纠结了两天的时间，实在是没有办法。</p><p>我使用的是react框架开发的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> videojs <span class="keyword">from</span> <span class="string">'video.js'</span></span><br><span class="line"><span class="comment">// import videozhCN from 'video.js/dist/lang/zh-CN.json'; //播放器中文，不能使用.js文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'video.js/dist/video-js.css'</span>;  <span class="comment">//样式文件注意要加上</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'videojs-flash'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoPlayer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// console.log(flvjs);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// instantiate Video.js</span></span><br><span class="line">    <span class="comment">//这里的this.props是上级传进来的video的options</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.player = videojs(<span class="keyword">this</span>.videoNode, <span class="keyword">this</span>.props, <span class="function"><span class="keyword">function</span> <span class="title">onPlayerReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'onPlayerReady'</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    videojs.addLanguage(<span class="string">'zh-CN'</span>, videozhCN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this.player.liveTracker.on('liveedgechange', () =&gt; &#123;</span></span><br><span class="line">      <span class="comment">// console.log('跟随直播');</span></span><br><span class="line">      <span class="comment">// this.player.liveTracker.seekToLiveEdge();</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// destroy player on unmount</span></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.player) &#123;</span><br><span class="line">      <span class="keyword">this</span>.player.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wrap the player in a div with a `data-vjs-player` attribute</span></span><br><span class="line">  <span class="comment">// so videojs won't create additional wrapper in the DOM</span></span><br><span class="line">  <span class="comment">// see https://github.com/videojs/video.js/pull/3856</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt; </span><br><span class="line">        &lt;div data-vjs-player&gt;  &#123;<span class="comment">/*这个带有属性的div目前没看到作用，可以去掉*/</span>&#125;</span><br><span class="line">          &lt;video ref=&#123; node =&gt; <span class="keyword">this</span>.videoNode = node &#125; className=<span class="string">"video-js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VideoPlayer</span><br></pre></td></tr></table></figure><p>引用 VideoPlayer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; storage &#125; <span class="keyword">from</span> <span class="string">'@utils'</span></span><br><span class="line"><span class="keyword">import</span> &#123; constant &#125; <span class="keyword">from</span> <span class="string">'@data/constant'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      videoSrc: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.videoJsOptions = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">const</span> THIS = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> token = storage.getItem(constant.TOKEN)</span><br><span class="line">    <span class="keyword">var</span> toyid = <span class="number">913</span></span><br><span class="line">    <span class="keyword">var</span> URL = <span class="string">`wss://XXX.XXX.com//websocket/1.0.0/WEB/<span class="subst">$&#123;toyid&#125;</span>/<span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">    <span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(URL);</span><br><span class="line">    socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(msg.data)</span><br><span class="line">      <span class="comment">// var cmd = data.cmd</span></span><br><span class="line">      <span class="comment">// var code = data.code</span></span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 没有登录</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> data.data === <span class="string">"string"</span>) <span class="keyword">return</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// users  data.data.room.users.users</span></span><br><span class="line">      <span class="keyword">let</span> users = data.data.room.users.users</span><br><span class="line">      <span class="keyword">let</span> currentPlayer = users.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.play === <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">let</span> waitingPlayers = users.filter(<span class="function"><span class="params">v</span> =&gt;</span> v.play === <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">let</span> videoSrc = data.data.room.video.split(<span class="string">','</span>)[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">let</span> newState = &#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> (currentPlayer.length) &#123;</span><br><span class="line">        newState.currentPlayer = currentPlayer[<span class="number">0</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (waitingPlayers.length) &#123;</span><br><span class="line">        newState.waitingPlayers = waitingPlayers</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (videoSrc) &#123;</span><br><span class="line">        <span class="comment">// videoSrc = videoSrc.replace("rtmp", "http") + ".flv"</span></span><br><span class="line">        <span class="built_in">console</span>.log(videoSrc);</span><br><span class="line">        </span><br><span class="line">        newState.videoSrc = videoSrc</span><br><span class="line">        THIS.setOptions(videoSrc)</span><br><span class="line">      &#125;</span><br><span class="line">      THIS.setState(newState)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setOptions(videoSrc) &#123;</span><br><span class="line">    <span class="keyword">const</span> videoContainer = <span class="keyword">this</span>.refs[<span class="string">"video-container"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 播放器的配置</span></span><br><span class="line">    <span class="keyword">const</span> videoJsOptions = &#123;</span><br><span class="line">      autoplay: <span class="literal">true</span>,  <span class="comment">//自动播放</span></span><br><span class="line">      language: <span class="string">'zh-CN'</span>, </span><br><span class="line">      <span class="comment">// controls: true,  //控制条</span></span><br><span class="line">      preload: <span class="literal">true</span>,  <span class="comment">//自动加载</span></span><br><span class="line">      <span class="comment">// errorDisplay: true,  //错误展示</span></span><br><span class="line">      width: videoContainer.clientWidth,  <span class="comment">//宽</span></span><br><span class="line">      height: videoContainer.clientHeight,  <span class="comment">//高</span></span><br><span class="line">      <span class="comment">// fluid: true,  //跟随外层容器变化大小，跟随的是外层宽度</span></span><br><span class="line">      <span class="comment">// controlBar: false,  // 设为false不渲染控制条DOM元素，只设置controls为false虽然不展示，但还是存在</span></span><br><span class="line">      <span class="comment">// textTrackDisplay: false,  // 不渲染字幕相关DOM</span></span><br><span class="line">      userActions: &#123;</span><br><span class="line">        <span class="comment">// hotkeys: true  //是否支持热键</span></span><br><span class="line">      &#125;,</span><br><span class="line">      sources: [</span><br><span class="line">        &#123;</span><br><span class="line">          src: videoSrc,</span><br><span class="line">          <span class="comment">// src: 'http://live2.get.cpxlive.com/live2/front124.m3u8',</span></span><br><span class="line">          <span class="comment">// src: "http://snowman.mobilecpx.com/video/wifi-socket.mp4",</span></span><br><span class="line">          <span class="comment">// type: "rmtp/flv"</span></span><br><span class="line">          type: <span class="string">"application/x-mpegURL"</span>,  <span class="comment">//类型可加可不加，目前未看到影响</span></span><br><span class="line">          <span class="comment">// type: 'video/mp4',</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.videoJsOptions = videoJsOptions</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; videoSrc &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"cpx-game flex-content"</span>&gt;</span><br><span class="line">        &lt;section ref=<span class="string">"video-container"</span> className=<span class="string">"cpx-game-video"</span>&gt;</span><br><span class="line">          &#123;videoSrc &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">VideoPlayer</span> &#123;<span class="attr">...this.videoJsOptions</span>&#125;/&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Game</span></span><br></pre></td></tr></table></figure><blockquote><p>注意注意：上面的视频能够播放了，但是。播放的时候中间会出现一个<img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20191108150821.png" alt="我还要自己去点击播放？">。没错，自己点击播放。真没意思。如果要解决这个问题，需要引入 <code>video-js.swf</code> 。这个在 <code>node_modules/videojs-swf</code> 下面有一个 video-js.swf 文件。我是直接把把他引入到了<img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20191108151102.png" alt="同级目录">下面。这样处理完成后就可以自动播放了。真是操蛋了。</p></blockquote><p>VidePlayer.js修改如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> videojs <span class="keyword">from</span> <span class="string">'video.js'</span></span><br><span class="line"><span class="comment">// import videozhCN from 'video.js/dist/lang/zh-CN.json'; //播放器中文，不能使用.js文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'video.js/dist/video-js.css'</span>;  <span class="comment">//样式文件注意要加上</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'videojs-flash'</span>  <span class="comment">//如果要播放RTMP要使用flash 需要先npm i videojs-flash</span></span><br><span class="line"><span class="comment">// 引用这个中间就不会出现那个 SB 的Flash播放按钮</span></span><br><span class="line">+ <span class="keyword">import</span> swf <span class="keyword">from</span> <span class="string">'./video-js.swf'</span></span><br><span class="line">+ videojs.options.flash.swf = swf</span><br></pre></td></tr></table></figure><p>上面的PC的，采用的是RTMP的流</p><p>如果是flv的流，react可以使用<a href="https://github.com/gwuhaolin/reflv" target="_blank" rel="noopener">reflv</a>这个插件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Reflv <span class="keyword">from</span> <span class="string">'reflv'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoPlayer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;url&#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Reflv</span><br><span class="line">        url=&#123;url&#125;</span><br><span class="line">        type=<span class="string">"flv"</span></span><br><span class="line">        isLive</span><br><span class="line">        cors</span><br><span class="line">      /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VideoPlayer</span><br></pre></td></tr></table></figure><p>更多的配置参数查看<a href="https://gwuhaolin.github.io/reflv/" target="_blank" rel="noopener">https://gwuhaolin.github.io/reflv/</a></p>]]></content>
    
    <summary type="html">
    
      web播放器，前web直播
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="直播" scheme="https://blog.lyt007.cn/tags/%E7%9B%B4%E6%92%AD/"/>
    
      <category term="前端直播" scheme="https://blog.lyt007.cn/tags/%E5%89%8D%E7%AB%AF%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>移动端web页面开发的一些问题</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html"/>
    <id>https://blog.lyt007.cn/技术/移动端web页面开发的一些问题.html</id>
    <published>2019-10-30T01:34:55.000Z</published>
    <updated>2020-04-13T03:13:34.972Z</updated>
    
    <content type="html"><![CDATA[<p>前端涉及到的领域不单单只是PC浏览器了，现在是移动为王的时代，所以大部分的时候还是在做移动端的页面适配。所以这里记录一下在移动端开发的时候遇到的一些问题。</p><h1 id="1、移动端隐藏手机浏览器的地址栏以及底部的菜单栏"><a href="#1、移动端隐藏手机浏览器的地址栏以及底部的菜单栏" class="headerlink" title="1、移动端隐藏手机浏览器的地址栏以及底部的菜单栏"></a>1、移动端隐藏手机浏览器的地址栏以及底部的菜单栏</h1><p>在设置移动端页面的宽高为100%的时候，里面的元素设置<code>flex:1</code>的时候，因为浏览器的地址栏以及下面的工具栏的问题会导致在有的手机上面的页面显示不全的问题。因为我们不好计算每一个浏览器的地址栏以及工具栏的高度，所以我们直接把它隐藏起来即可，下面的隐藏的代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- webApp全屏显示，IOS设备 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">'apple-mobile-web-app-capable'</span> <span class="attr">content</span>=<span class="string">'yes'</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通用的浏览器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">'full-screen'</span> <span class="attr">content</span>=<span class="string">'true'</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ浏览器（X5内核）独有的META --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">'x5-fullscreen'</span> <span class="attr">content</span>=<span class="string">'true'</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 360浏览器独有的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">'360-fullscreen'</span> <span class="attr">content</span>=<span class="string">'true'</span> /&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2、移动端网页自适应"><a href="#2、移动端网页自适应" class="headerlink" title="2、移动端网页自适应"></a>2、移动端网页自适应</h1><p>在开发网页的时候适配是一个老生常谈的话题。现在的适配基本都是使用的rem布局。而跟标签（html标签）的自己大小根据手机的屏幕大小来设置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  (<span class="function"><span class="keyword">function</span> <span class="params">(doc, win)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> docEl = doc.documentElement,</span></span><br><span class="line"><span class="javascript">        resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</span></span><br><span class="line"><span class="actionscript">        recalc = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> clientWidth = docEl.clientWidth;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span>(clientWidth&gt;=<span class="number">640</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                docEl.style.fontSize = <span class="string">'100px'</span>;</span></span><br><span class="line"><span class="actionscript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">                docEl.style.fontSize = <span class="number">100</span> * (clientWidth / <span class="number">640</span>) + <span class="string">'px'</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="actionscript">    win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span></span><br><span class="line"><span class="actionscript">    doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">  &#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的一段代码则是自动修的HTML的跟标签的字体大小的标签，然后就可以使用rem来设置元素的宽高了。但是，rem不能设置字体的自适应。</p><p>对于我而言，现在都是9102了，vw,vh,vmin,vmax这几个属性。来看看<a href="https://caniuse.com/#search=vw" target="_blank" rel="noopener">can i use</a>上面的兼容性检测。</p><p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20191030100525.png" alt="Viewport units: vw, vh, vmin, vmax"></p><p>其实可以看到还是挺不错的，安卓4.4以上的都是兼容的。所以在9102这个年代了，可以放心大胆的使用了，就算是华为手机自带的浏览器也没有毛病。关于华为浏览器的问题可以查看我的另一篇文章 <a href="./关于使用react16以上在华为手机上面显示出现问题的解决方法.html">关于使用react16以上在华为手机上面显示出现问题的解决方法</a></p><p>关于rem以及vw, vh, vmin, vmax的具体可以查看<a href="https://yanhaijing.com/css/2017/09/29/principle-of-rem-layout/" target="_blank" rel="noopener">Rem布局的原理解析</a>。本来想放大漠的文章，今天去看突然就要付费才可以看了。</p><h1 id="3、移动端-a-标签点击会有蓝色的背景色"><a href="#3、移动端-a-标签点击会有蓝色的背景色" class="headerlink" title="3、移动端 a 标签点击会有蓝色的背景色"></a>3、移动端 a 标签点击会有蓝色的背景色</h1><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>添加<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">-webkit-tap-highlight-color</span>:transparent; &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      移动端web开发的一些问题以及解决方法
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="移动端web" scheme="https://blog.lyt007.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb/"/>
    
  </entry>
  
  <entry>
    <title>关于使用react16以上在华为手机上面显示出现问题的解决方法</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8react16%E4%BB%A5%E4%B8%8A%E5%9C%A8%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html"/>
    <id>https://blog.lyt007.cn/技术/关于使用react16以上在华为手机上面显示出现问题的解决方法.html</id>
    <published>2019-10-29T06:06:37.000Z</published>
    <updated>2020-04-13T03:13:34.969Z</updated>
    
    <content type="html"><![CDATA[<p>项目的网站开发了一段时间了，最近也忙着华为应用市场的上架。所以关于华为的事情也是需要着手考虑一下。</p><h1 id="问题一：使用16-8的react以及reactDOM华为自带浏览器白屏"><a href="#问题一：使用16-8的react以及reactDOM华为自带浏览器白屏" class="headerlink" title="问题一：使用16.8的react以及reactDOM华为自带浏览器白屏"></a>问题一：使用16.8的react以及reactDOM华为自带浏览器白屏</h1><p>在使用react开发的项目中，所有的浏览器（自己用的，公司没有测试）都能够跑起来。但是在使用华为手机自带的浏览器的时候，却出现了一片空白的情况。</p><p>开发用到的依赖如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">"axios": "^0.18.0",</span><br><span class="line">"babel-polyfill": "^6.26.0",</span><br><span class="line">"core-js": "^3.3.5",</span><br><span class="line">"customize-cra": "^0.5.0",</span><br><span class="line">"firebase": "^6.1.0",</span><br><span class="line">"i18next": "^15.1.3",</span><br><span class="line">"i18next-browser-languagedetector": "^3.0.1",</span><br><span class="line">"i18next-xhr-backend": "^2.0.1",</span><br><span class="line">"js-cookie": "^2.2.0",</span><br><span class="line">"mescroll.js": "^1.4.1",</span><br><span class="line">"moment": "^2.24.0",</span><br><span class="line">"node-sass": "^4.12.0",</span><br><span class="line">"payment": "^2.3.0",</span><br><span class="line">"prerender-spa-plugin": "^3.4.0",</span><br><span class="line">"qs": "^6.7.0",</span><br><span class="line">"react": "^16.8.6",</span><br><span class="line">"react-app-rewired": "^2.1.3",</span><br><span class="line">"react-confirm-alert": "^2.4.1",</span><br><span class="line">"react-credit-cards": "^0.7.0",</span><br><span class="line">"react-dom": "^16.8.6",</span><br><span class="line">"react-ga": "^2.6.0",</span><br><span class="line">"react-i18next": "^10.10.0",</span><br><span class="line">"react-paypal-express-checkout": "^1.0.5",</span><br><span class="line">"react-redux": "^7.0.3",</span><br><span class="line">"react-router-dom": "^5.0.0",</span><br><span class="line">"react-scripts": "3.0.1",</span><br><span class="line">"react-switch": "^5.0.0",</span><br><span class="line">"react-toastify": "^5.1.1",</span><br><span class="line">"redux": "^4.0.1"</span><br></pre></td></tr></table></figure><p>版本是 <code>16.8</code> 的react以及reactDOM。</p><p>查询很多资料，最后得知 reactDOM 在16开始的时候就是使用的ES6的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">Map</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">Set</a>。而华为浏览器以及其他的一些未知浏览器使用的还是低版本的浏览器内核。</p><p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/华为自带浏览器UA.jpg" alt="华为自带浏览器UA"></p><p>37.0.0.0.0 这可是4年轻的内核了。所以是不兼容了。</p><p>React官方给出了<a href="https://reactjs.org/docs/javascript-environment-requirements.html" target="_blank" rel="noopener">说明</a></p><p>但是使用<code>babel-polyfill</code>仍然无法解决</p><p>所以，这里使用 <code>core-js</code>,使用如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'core-js/es/map'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js/es/set'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这样就可以解决华为手机无法显示（或者说是显示空白的问题）。</p><h1 id="问题二：使用fixed定位的时候没有显示出来"><a href="#问题二：使用fixed定位的时候没有显示出来" class="headerlink" title="问题二：使用fixed定位的时候没有显示出来"></a>问题二：使用fixed定位的时候没有显示出来</h1><p>项目中有一个支付需求需要在页面弹出支付通道选择（信用卡，paypal等），但是设置显示的时候出现了没有弹出选择界面的情况，但是实际上又确实有这个页面（只显示它的时候）。修的定位层级的时候也是无法显示。最后发现，<strong>在华为等低端浏览器内核的手机上面同时需要设置定位的位置才可以（left:0, top:0）</strong>，高版本的内核的浏览器没有这个问题，我猜想是自己默认就是（left:0, top:0）了。</p>]]></content>
    
    <summary type="html">
    
      关于使用react16以上在华为手机上面显示出现问题的解决方法
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="react" scheme="https://blog.lyt007.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react项目预渲染开发</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/react%E9%A1%B9%E7%9B%AE%E9%A2%84%E6%B8%B2%E6%9F%93%E5%BC%80%E5%8F%91.html"/>
    <id>https://blog.lyt007.cn/技术/react项目预渲染开发.html</id>
    <published>2019-09-27T06:15:03.000Z</published>
    <updated>2020-04-13T03:13:34.967Z</updated>
    
    <content type="html"><![CDATA[<p>react越来越火了，是开react开发的人员而是越来越多。但是因为单页应用SEO的问题，我们也不得不去解决这个问题。不管是哪里，都提供了两种方案，一种是SSR服务端渲染，另一种则是预渲染方式。本篇文章主要是阐述预渲染的方案。</p><h2 id="什么是预渲染"><a href="#什么是预渲染" class="headerlink" title="什么是预渲染"></a>什么是预渲染</h2><p>在一般的react项目中（比如使用create-react-app创建的项目），我们在最后打包的时候只会生成一个HTML，JS与CSS文件，或许你会采用一些方法，比如公共文件拆分，路由懒加载等等生成多个文件，但是也无法从根本上解决这个问题，所有的资源还是通过JS动态的生成渲染的。</p><p>所以，<strong>所谓的预渲染</strong>就是在单页应用中，将用户交互不多，同时需要SEO的页面单独提取出来的一种方法，提取出来的就是一个HTML文件。</p><h2 id="怎么使用预渲染"><a href="#怎么使用预渲染" class="headerlink" title="怎么使用预渲染"></a>怎么使用预渲染</h2><p>开发react项目的时候，一般都是结合者webpack使用的。目前用的最多的预渲染的方法，就是使用webpack插件<a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a>。这是一个webpack插件，所以使用直接在webpack的插件配置项中添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">  routes: [<span class="string">"/"</span>, <span class="string">"/download"</span>, <span class="string">"/prize"</span>, <span class="string">"/news"</span>, <span class="string">"/news/detail?id=1"</span>, <span class="string">"/support"</span>],</span><br><span class="line">  staticDir: path.join(__dirname, <span class="string">'build'</span>),</span><br><span class="line">  renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">    renderAfterTime: <span class="number">50000</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中<code>routes</code>是需要预渲染的route，一般都是react-router-dom配置的路由。 <code>staticDir</code>是输出的目录。因为这里使用了create-react-app，默认的输出目录是build，所以，这里也是build，如果你是自己搭建或者使用的是其他的方式，或许目录名字会有所不同。</p><p>更多具体的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘取自github</span></span><br><span class="line"><span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">  <span class="comment">// Required - The path to the webpack-outputted app to prerender.</span></span><br><span class="line">  staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional - The path your rendered app should be output to.</span></span><br><span class="line">  <span class="comment">// (Defaults to staticDir.)</span></span><br><span class="line">  outputDir: path.join(__dirname, <span class="string">'prerendered'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional - The location of index.html</span></span><br><span class="line">  indexPath: path.join(__dirname, <span class="string">'dist'</span>, <span class="string">'index.html'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Required - Routes to render.</span></span><br><span class="line">  routes: [ <span class="string">'/'</span>, <span class="string">'/about'</span>, <span class="string">'/some/deep/nested/route'</span> ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional - Allows you to customize the HTML and output path before</span></span><br><span class="line">  <span class="comment">// writing the rendered contents to a file.</span></span><br><span class="line">  <span class="comment">// renderedRoute can be modified and it or an equivelant should be returned.</span></span><br><span class="line">  <span class="comment">// renderedRoute format:</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   route: String, // Where the output file will end up (relative to outputDir)</span></span><br><span class="line">  <span class="comment">//   originalRoute: String, // The route that was passed into the renderer, before redirects.</span></span><br><span class="line">  <span class="comment">//   html: String, // The rendered HTML for this route.</span></span><br><span class="line">  <span class="comment">//   outputPath: String // The path the rendered HTML will be written to.</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  postProcess (renderedRoute) &#123;</span><br><span class="line">    <span class="comment">// Ignore any redirects.</span></span><br><span class="line">    renderedRoute.route = renderedRoute.originalRoute</span><br><span class="line">    <span class="comment">// Basic whitespace removal. (Don't use this in production.)</span></span><br><span class="line">    renderedRoute.html = renderedRoute.html.split(<span class="regexp">/&gt;[\s]+&lt;/gmi</span>).join(<span class="string">'&gt;&lt;'</span>)</span><br><span class="line">    <span class="comment">// Remove /index.html from the output path if the dir name ends with a .html file extension.</span></span><br><span class="line">    <span class="comment">// For example: /dist/dir/special.html/index.html -&gt; /dist/dir/special.html</span></span><br><span class="line">    <span class="keyword">if</span> (renderedRoute.route.endsWith(<span class="string">'.html'</span>)) &#123;</span><br><span class="line">      renderedRoute.outputPath = path.join(__dirname, <span class="string">'dist'</span>, renderedRoute.route)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> renderedRoute</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optional - Uses html-minifier (https://github.com/kangax/html-minifier)</span></span><br><span class="line">  <span class="comment">// To minify the resulting HTML.</span></span><br><span class="line">  <span class="comment">// Option reference: https://github.com/kangax/html-minifier#options-quick-reference</span></span><br><span class="line">  minify: &#123;</span><br><span class="line">    collapseBooleanAttributes: <span class="literal">true</span>,</span><br><span class="line">    collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">    decodeEntities: <span class="literal">true</span>,</span><br><span class="line">    keepClosingSlash: <span class="literal">true</span>,</span><br><span class="line">    sortAttributes: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Server configuration options.</span></span><br><span class="line">  server: &#123;</span><br><span class="line">    <span class="comment">// Normally a free port is autodetected, but feel free to set this if needed.</span></span><br><span class="line">    port: <span class="number">8001</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The actual renderer to use. (Feel free to write your own)</span></span><br><span class="line">  <span class="comment">// Available renderers: https://github.com/Tribex/prerenderer/tree/master/renderers</span></span><br><span class="line">  renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">    <span class="comment">// Optional - The name of the property to add to the window object with the contents of `inject`.</span></span><br><span class="line">    injectProperty: <span class="string">'__PRERENDER_INJECTED'</span>,</span><br><span class="line">    <span class="comment">// Optional - Any values you'd like your app to have access to via `window.injectProperty`.</span></span><br><span class="line">    inject: &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional - defaults to 0, no limit.</span></span><br><span class="line">    <span class="comment">// Routes are rendered asynchronously.</span></span><br><span class="line">    <span class="comment">// Use this to limit the number of routes rendered in parallel.</span></span><br><span class="line">    maxConcurrentRoutes: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional - Wait to render until the specified event is dispatched on the document.</span></span><br><span class="line">    <span class="comment">// eg, with `document.dispatchEvent(new Event('custom-render-trigger'))`</span></span><br><span class="line">    renderAfterDocumentEvent: <span class="string">'custom-render-trigger'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional - Wait to render until the specified element is detected using `document.querySelector`</span></span><br><span class="line">    renderAfterElementExists: <span class="string">'my-app-element'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional - Wait to render until a certain amount of time has passed.</span></span><br><span class="line">    <span class="comment">// NOT RECOMMENDED</span></span><br><span class="line">    renderAfterTime: <span class="number">5000</span>, <span class="comment">// Wait 5 seconds.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other puppeteer options.</span></span><br><span class="line">    <span class="comment">// (See here: https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions)</span></span><br><span class="line">    headless: <span class="literal">false</span> <span class="comment">// Display the browser window when rendering. Useful for debugging.</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>renderAfterTime</code> 这个属性最好配置，可以在等待一定时间后在来导出另一个路由文件，如果不添加，可能会出<code>Unable to perrender all routes</code>的错误。</p><h2 id="上线到服务器"><a href="#上线到服务器" class="headerlink" title="上线到服务器"></a>上线到服务器</h2><p>打包后可以先在本地的服务器上面测试，这里推荐一个npm包： <a href="https://www.npmjs.com/package/serve" target="_blank" rel="noopener">serve</a> 安装后通过 <code>serve 文件夹名字</code>启动一个本地服务。</p><p>需要注意的是：</p><ol><li><p>当项目正常运行，同时包含多个路由的时候，当我们在除了首页以外的其他的目录刷新页面的时候都是404，这是因为服务器的配置问题。本地这里无法实现。</p></li><li><p>开发的时候必须使用 History 路由而不能使用 Hash 路由。</p></li></ol><p>1, 2 文件的解决方法就是修改nginx的配置如下</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> /&#123;</span><br><span class="line">    <span class="keyword">index</span>  <span class="keyword">index</span>.html <span class="keyword">index</span>.htm;</span><br><span class="line">    <span class="keyword">if</span> (!-e $request_filename) &#123;</span><br><span class="line">        rewrite ^/(.*) /<span class="keyword">index</span>.html last;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对于动态路由，如<code>/news/detail/:id</code>是不支持的，推荐使用query路由，如<code>/new/detail?id=</code></li></ol>]]></content>
    
    <summary type="html">
    
      react 项目SEO，预渲染模式的SEO
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="react" scheme="https://blog.lyt007.cn/tags/react/"/>
    
      <category term="SEO" scheme="https://blog.lyt007.cn/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>前端基础算法</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.html"/>
    <id>https://blog.lyt007.cn/技术/前端基础算法.html</id>
    <published>2019-09-10T08:05:02.000Z</published>
    <updated>2020-04-23T09:05:46.932Z</updated>
    
    <content type="html"><![CDATA[<p>对于前端初学者而言，这样的一个功能你做出来了那就很好，慢慢的，我们的工作年限越来越长，如果我们还继续那样做，这样，迟早会淘汰。这个时候，就需要对你的项目进行优化。之前讲到过对于<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/react%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96.html">react项目的优化</a>。这更多是针对于单页应用的优化，避免首页时间加载过长，打包文件加载过大，是针对于打包后文件来说的。这篇文章主要是针对于算法相关的代码进行优化，从而是程序的运行速度更快，已达到程序的优化。</p><p>算法更多的是针对于数据的增删改查，或许你认为前端涉及不到，如果这样想，那你就错了。前端可能用的不多，但不会涉及不到，同时，了解算法，那么对于以后的职业道路也会有所帮助。</p><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><p><a href="https://zh.wikipedia.org/wiki/二分搜索算法" target="_blank" rel="noopener">二分查找</a>在进行查找<strong>有序数组</strong>中某一项数据的时候非常有用，可以加快程序的运行速度，尤其是在具有大量数据的时候。</p><p>二分查找的原理是从数组的中间开始查找，如果被查找对象刚好就是中间这一项，那直接退出查找。如果被查找对象大于中间，那么所需要的对象是在<em>中间-最后</em>这一区间，所以有针对于这一区间再次进行二分。如此下去，找到所需要的即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; list  待查找的有序数组</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; item 待查找的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">list, item</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果list不是数组返回list</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(list)) <span class="keyword">return</span> list</span><br><span class="line">    <span class="comment">// 定义查找的起始位置</span></span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> high = list.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="comment">// 定义中间的位置</span></span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> midValue = list[mid]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( midValue == item ) <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midValue &lt; item)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midValue &gt; item)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来看看一个具体的效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    arr.push(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> need = <span class="number">6734</span></span><br><span class="line"><span class="keyword">let</span> res;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"for"</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ele = arr[i];</span><br><span class="line">  <span class="keyword">if</span>( ele === need ) &#123;</span><br><span class="line">    res = i</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"for"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"binarySearch"</span>)</span><br><span class="line">res = binarySearch(arr, need)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"binarySearch"</span>)</span><br></pre></td></tr></table></figure><p><img src="https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/20190910163005.png" alt></p><p>可以看到很明显二分查找比普通的循环遍历快了许多。</p><p>可视化链接</p><p><a href="https://algorithm-visualizer.org/branch-and-bound/binary-search" target="_blank" rel="noopener">https://algorithm-visualizer.org/branch-and-bound/binary-search</a></p><p>时间复杂度 <strong>O(\log n)</strong></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>上面讲到的二分查找虽然性能很好，当时有一个必要的条件就是这个list需要是一个有序数组，否则使用二分查找则是不成立的。所以，对于一个无序的数组，我们首先就是需要把它重新排序。<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">选择排序</a>就是其中一种。</p><p>选择排序的原理是从数组中选出一个最大（小）的数，放在另一个数组的开始，然后从剩余数组中继续选择最大（小）的数进行操作，如此重复，直到数组重组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(list)) <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个数组存放排序后的数组</span></span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> smallestIndex = findSmallest(list)</span><br><span class="line">    arr.push(list.splice(smallestIndex, <span class="number">1</span>)[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找最小的数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findSmallest</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> smallest = list[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> smallestIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ele = list[i];</span><br><span class="line">    <span class="keyword">if</span> (ele &lt; smallest) &#123;</span><br><span class="line">      smallest = ele</span><br><span class="line">      smallestIndex = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> smallestIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      前端基础算法，二分，快排
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="https://blog.lyt007.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>各种IT网站收藏</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/%E5%90%84%E7%A7%8DIT%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F.html"/>
    <id>https://blog.lyt007.cn/技术/各种IT网站收藏.html</id>
    <published>2019-09-03T02:26:30.000Z</published>
    <updated>2020-05-13T02:50:16.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-command"><a href="#git-command" class="headerlink" title="git command"></a>git command</h2><ul><li><a href="https://www.yiibai.com/git" target="_blank" rel="noopener">git command</a></li></ul><h2 id="前端九部-前端入门手册"><a href="#前端九部-前端入门手册" class="headerlink" title="前端九部-前端入门手册"></a>前端九部-前端入门手册</h2><ul><li><a href="https://www.yuque.com/fe9/basic/zw24qu" target="_blank" rel="noopener">前端九部-前端入门手册</a></li></ul><h3 id="Vuejs开源项目"><a href="#Vuejs开源项目" class="headerlink" title="Vuejs开源项目"></a>Vuejs开源项目</h3><ul><li><a href="https://github.com/opendigg/awesome-github-vue" target="_blank" rel="noopener">vuejs开源项目汇总</a></li></ul><h3 id="react开源项目汇总"><a href="#react开源项目汇总" class="headerlink" title="react开源项目汇总"></a>react开源项目汇总</h3><ul><li><a href="https://github.com/zuiidea/antd-admin" target="_blank" rel="noopener">一套优秀的中后台前端解决方案</a></li><li><a href="https://github.com/trazyn/ieaseMusic" target="_blank" rel="noopener">网易云音乐第三方</a></li><li><a href="https://github.com/bailicangdu/react-pxq" target="_blank" rel="noopener">一个 react + redux 的完整项目 和 个人总结</a></li><li><a href="https://github.com/yezihaohao/react-admin" target="_blank" rel="noopener">react 后台管理系统解决方案</a></li><li><a href="https://github.com/crazycodeboy/GitHubPopular" target="_blank" rel="noopener">这是一个用来查看GitHub最受欢迎与最热项目的App,它基于React Native支持Android和iOS双平台</a></li><li><a href="https://github.com/stoneWeb/elm-react-native" target="_blank" rel="noopener">RN写的饿了么，还原度相当高，实现了各类动效</a></li><li><a href="https://github.com/race604/ZhiHuDaily-React-Native" target="_blank" rel="noopener">仿知乎日报</a></li><li><a href="https://github.com/biaochenxuying/blog-react" target="_blank" rel="noopener">react + Ant Design + 支持 markdown 的博客前台展示</a></li><li><a href="https://github.com/gershonv/react-blog" target="_blank" rel="noopener">使用 react hooks + koa2 + sequelize + mysql 搭建的前后台的博客</a></li><li><a href="https://github.com/fxy5869571/blog-react" target="_blank" rel="noopener">基于typescript koa2 react的个人博客</a></li></ul><h3 id="前端面试题"><a href="#前端面试题" class="headerlink" title="前端面试题"></a>前端面试题</h3><ul><li><a href="https://github.com/haizlin/fe-interview" target="_blank" rel="noopener">前端每日3+1</a></li><li><a href="https://muyiy.cn/question/" target="_blank" rel="noopener">壹题汇总-木易杨</a></li></ul><h3 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h3><ul><li><a href="https://github.com/bailicangdu/node-elm" target="_blank" rel="noopener">基于 node.js + Mongodb 构建的后台系统</a></li><li><a href="https://github.com/cnodejs/nodeclub" target="_blank" rel="noopener">Nodeclub 是使用 Node.js 和 MongoDB 开发的社区系统</a></li><li><a href="https://github.com/tumobi/nideshop-mini-program" target="_blank" rel="noopener">基于Node.js+MySQL开发的开源微信小程序商城（微信小程序）</a></li><li><a href="https://github.com/tumobi/nideshop" target="_blank" rel="noopener">NideShop 开源微信小程序商城服务端 API（Node.js + ThinkJS）</a></li><li><a href="https://github.com/Nealyang/React-Express-Blog-Demo" target="_blank" rel="noopener">React+Express+Mongo -&gt;前后端博客网站</a></li><li><a href="https://github.com/biaochenxuying/blog-node" target="_blank" rel="noopener">基于 node + express + mongodb 的博客网站后台</a></li></ul><h3 id="免费视频"><a href="#免费视频" class="headerlink" title="免费视频"></a>免费视频</h3><ul><li><a href="https://jspang.com/posts/2017/01/11/all-video-list.html" target="_blank" rel="noopener">技术胖免费视频</a></li></ul><h3 id="react-native"><a href="#react-native" class="headerlink" title="react native"></a>react native</h3><ul><li><a href="https://www.jianshu.com/p/c7a8f115dca0" target="_blank" rel="noopener">React Native 第三方组件之–UI类</a></li></ul><h3 id="日本输入邮编自动填充地址"><a href="#日本输入邮编自动填充地址" class="headerlink" title="日本输入邮编自动填充地址"></a>日本输入邮编自动填充地址</h3><ul><li><a href="https://zipaddr.github.io/" target="_blank" rel="noopener">https://zipaddr.github.io/</a></li></ul>]]></content>
    
    <summary type="html">
    
      IT网站收藏
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="网站收藏" scheme="https://blog.lyt007.cn/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>通过自己实现函数 call,apply,bind 来了解他们的原理</title>
    <link href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/%E9%80%9A%E8%BF%87%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0-call-apply-bind-%E6%9D%A5%E4%BA%86%E8%A7%A3%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8E%9F%E7%90%86.html"/>
    <id>https://blog.lyt007.cn/技术/通过自己实现函数-call-apply-bind-来了解他们的原理.html</id>
    <published>2019-08-21T03:00:53.000Z</published>
    <updated>2020-05-12T02:10:46.402Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道函数中的call，apply，bind都是可以修改函数的this指向。关于函数的this指向问题可以转到<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/javascript-this%E7%9A%84%E6%8C%87%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98.html">Javascript this 指向问题</a>这篇文章。</p><p>在<a href="https://blog.lyt007.cn/%E6%8A%80%E6%9C%AF/javascript-this%E7%9A%84%E6%8C%87%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98.html">Javascript this 指向问题</a>一篇中我们知道函数运行时候this是取决于调用这个函数的对象。如果一个函数定义在了全局，那么这个this就指向window。</p><p>来看一段代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"tal"</span></span><br><span class="line"><span class="keyword">var</span> sex = <span class="string">"boy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tal = &#123;</span><br><span class="line">  name: <span class="string">"踏浪"</span>,</span><br><span class="line">  sex: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br><span class="line">person() <span class="comment">// tal boy</span></span><br></pre></td></tr></table></figure></p><p>上面的<code>person</code>是定义在全局中的一个函数，<code>person()</code>调用的时候相当于是<code>window.person()</code>，是由window调用的，所以，<code>this.name</code>和<code>this.sex</code>都需要在window对象中寻找，即全局变量中找。所以，最后的值会是<code>tal</code>与<code>boy</code>。</p><p>再来。我们来调用一下原生的<code>call</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"tal"</span></span><br><span class="line"><span class="keyword">var</span> sex = <span class="string">"boy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tal = &#123;</span><br><span class="line">  name: <span class="string">"踏浪"</span>,</span><br><span class="line">  sex: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br><span class="line">person.call(tal) <span class="comment">// 踏浪 男</span></span><br></pre></td></tr></table></figure><p>在调用了<code>call</code>函数以后，最后的值是<code>踏浪 男</code>。得到的是对象<code>tal</code>中的两个属性值。此时函数中的this指向了对象<code>tal</code>。结合上面的例子，直接调用<code>person</code>函数的时候，相当于是<code>window.person()</code>的执行，所以那时this指向了window。那现在既然指向了<code>tal</code>，换言之，就是相当于<code>tal.person()</code>执行了。</p><h2 id="call-的实现"><a href="#call-的实现" class="headerlink" title="call 的实现"></a>call 的实现</h2><p>所以我们可以这样实现<code>mycall</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  context.fn()</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mycall</code>接收一个参数，即一个对象，最终的this指向这个对象。函数内部实现在这个传入的对象中绑定上我们需要执行的这个函数，即<code>context.fn = this</code>一行。最后调用<code>context.fn()</code>。因为我们这样操作修改了传入对象的属性（添加了一个fn属性），所以最后需要删除这个fn属性。这样，第一版的call的实现已经完成。</p><p>接下来，原生 call 函数是可以接收参数的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tal = &#123;</span><br><span class="line">  name: <span class="string">"踏浪"</span>,</span><br><span class="line">  sex: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br><span class="line">person.call(tal, <span class="number">18</span>) <span class="comment">// 踏浪 男</span></span><br></pre></td></tr></table></figure><p>那我们自己实现的mycall要想能够接收参数，怎么实现呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args.join(<span class="string">","</span>) + <span class="string">')'</span>)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们需要在 mycall 调用的时候传递参数，而且参数的个数不确定，所以需要使用 arguments 。同时因为第一个参数以及确定了是我们需要的一个对象，this指向这个对象。所以 arguments 需要从 <strong>1</strong> 开始。我们用一个数组把需要的东西存放起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [];</span><br><span class="line"><span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">  args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是这样的话，我传递过去后数组 <code>args = [18, &quot;成都&quot;]</code> 里面的每一项要怎么传递到 <code>context.fn()</code> 里面并且执行呢？或许你会想到时候 <code>join(&quot;,&quot;)</code> 方法，OK，没有问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = args.join(<span class="string">","</span>);</span><br><span class="line">context.fn(res);</span><br></pre></td></tr></table></figure><p>这样么？不是。res的值是 <code>18,成都</code> 没问题，但是这就是一个字符串而已，我们要实现传递两个参数，所以，想到了把字符串与函数拼接。即有了 <code>&#39;context.fn(&#39; + args.join() + &#39;)&#39;</code>。这样最后就可以了。但是这只是一个字符串，怎么运行呢？这个时候就需要用到 <strong>ES3中的eval</strong> 直接传递这个参数进度即可。</p><p>上面的 join 方法其实就是把一个数组转换成了字符串，除了 join，你还能想到什么呢？对。可以使用字符转换来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="string">""</span> + args + <span class="string">""</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">res = args.toString()</span><br></pre></td></tr></table></figure><p>因为每一个隔开的方式是 <code>,</code> 所以可以使用上面的两种，其他的就不行咯。</p><p>所以最终的 mycall</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mycall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args.join(<span class="string">","</span>) + <span class="string">')'</span>)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply的实现"><a href="#apply的实现" class="headerlink" title="apply的实现"></a>apply的实现</h2><p>有个实现call的过程，在来实现apply就容易多了。唯一不同的就是apply传递的参数是一个数组，而call是具体的每一项。只需要在参数上面做处理即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myapply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> array = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> array !== <span class="string">"object"</span> || !(array <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"The 2'rd args must be Array."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; len = array.length, i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="string">'array['</span> + i + <span class="string">']'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args.toString() + <span class="string">')'</span>)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>arguments[1]</code> 是一个数组了。我们需要对它遍历，并且判断它是不是一个数组。其余的与 call 一样。</p><h2 id="bind的实现"><a href="#bind的实现" class="headerlink" title="bind的实现"></a>bind的实现</h2><p>原生的bind有两种方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tal = &#123;</span><br><span class="line">  name: <span class="string">"踏浪"</span>,</span><br><span class="line">  sex: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.bind(tal)(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">person.bind(tal, <span class="number">18</span>)()</span><br></pre></td></tr></table></figure><p>所以。使用bind都需要调用两次，而第一次就是返回一个函数。原函数的参数可以在bind中调用，也可以在第二次运行时候调用。所以，根据调用bind时候传递的参数的个数确定最后是返回那种函数，有了下面的这段代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span> (len === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 mybind 的参数的个数只有一个，那么剩余参数在调用的时候传入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> sub_args = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; len = <span class="built_in">arguments</span>.length, i &lt; len; i++) &#123;</span><br><span class="line">        sub_args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + sub_args.toString() + <span class="string">')'</span>)</span><br><span class="line">      <span class="keyword">delete</span> context.fn</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 这里不能使用 arguments，这里面的 arguments 是这个 return 函数的而不是最开始的。</span></span><br><span class="line">      <span class="keyword">var</span> str = <span class="string">'context.fn('</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; len = args.length, i &lt; len; i++) &#123;</span><br><span class="line">        str += <span class="string">"args["</span>+i+<span class="string">"],"</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> newStr = str.replace(<span class="regexp">/,$/</span>, <span class="string">")"</span>)</span><br><span class="line">      <span class="built_in">eval</span>(newStr)</span><br><span class="line">      <span class="keyword">delete</span> context.fn</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过自己实现 call， apply， bind 这三种方法，能够更深刻的理解到这三个函数的原理，同时涉及到的只是点也多：this指向，arguments类数组，每一个对象都要的toSting方法（另一个是valueOf），eval方法的使用（不是滥用，webpack中就使用了这个方法），函数对象可以使用 delete 删除（使用var 定义的无法使用delete删除）。或许你已经明白了，但是代码种东西，还是自己动动手，印象更深刻。</p><h2 id="补充于2020年5月12日"><a href="#补充于2020年5月12日" class="headerlink" title="补充于2020年5月12日"></a>补充于2020年5月12日</h2><p>因为我们已经实现了 <code>bind</code>，所以之前的 <code>call</code> 和 <code>apply</code> 就可以直接使用 bind 来实现了。</p><p>new call</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> otherArgs = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'this.mybind(context)('</span> + otherArgs.join(<span class="string">','</span>) + <span class="string">')'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new apply</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arguments_1_length = <span class="built_in">arguments</span>[<span class="number">1</span>].length;</span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>[<span class="number">1</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The 2rd argument must be an Array. But get '</span> + type);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arguments_1_length; i++) &#123;</span><br><span class="line">    args.push(<span class="built_in">arguments</span>[<span class="number">1</span>][i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'this.myBind(context)('</span> + args.join(<span class="string">','</span>) + <span class="string">')'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      通过自己实现函数 call,apply,bind 来了解他们的原理
    
    </summary>
    
      <category term="技术" scheme="https://blog.lyt007.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="https://blog.lyt007.cn/tags/JavaScript/"/>
    
      <category term="手写源码分析原理" scheme="https://blog.lyt007.cn/tags/%E6%89%8B%E5%86%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
