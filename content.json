{"meta":{"title":"踏浪 - 前端技术分享","subtitle":"所谓天才，不过是每一天的积累成才","description":"踏浪个人博客 -- 用代码震撼世界","author":"踏浪","url":"https://blog.lyt007.cn"},"pages":[{"title":"","date":"2020-04-13T03:13:34.975Z","updated":"2020-04-13T03:13:34.975Z","comments":true,"path":"baidu_verify_CUgZQVmgan.html","permalink":"https://blog.lyt007.cn/baidu_verify_CUgZQVmgan.html","excerpt":"","text":"CUgZQVmgan"},{"title":"","date":"2020-04-13T03:13:34.976Z","updated":"2020-04-13T03:13:34.976Z","comments":true,"path":"google8da757c4599fccb5.html","permalink":"https://blog.lyt007.cn/google8da757c4599fccb5.html","excerpt":"","text":"google-site-verification: google8da757c4599fccb5.html"},{"title":"categories","date":"2019-04-06T11:28:43.000Z","updated":"2020-04-13T03:13:34.976Z","comments":false,"path":"categories/index.html","permalink":"https://blog.lyt007.cn/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-04-07T13:19:09.000Z","updated":"2020-04-13T03:13:34.975Z","comments":false,"path":"about/index.html","permalink":"https://blog.lyt007.cn/about/index.html","excerpt":"","text":"本站是由Hexo结合GitHub搭建的一个技术分享型博客。 主要分享 前端方面的基础知识，包含html，js，css 前端框架，包含vue，react以及其他框架的使用以及见解 影视图书感悟以及见解 世上无难事，只怕有心人 任何的困难在有心人面前都不是一件难事，还请有幸来到我的博客的贵人请您记住这句话。 博主简介本名：刘玉田 笔名：踏浪 邮箱：liuyutian_web@163.com mrliu819@foxmail.com 微信号：liuyutian930819 介绍：博主是一个非IT专业大专毕业的学生，距离今日写这个简介的时候已经有快四年了。其实最开始并不是从事IT行业的，正如前面说的我不是IT专业的毕业生。最开始和广大人民一样，是一个工地搬砖的人。至于后面从事IT行业，主要还是因为认清了自己（知道自己的爱好，发展方向等）。在从事了一年的搬砖工人以后转行到了IT行业。 读者寄语访客，您好！ 您能来到我的博客也是一种缘分，或许你现在身居高位，小日子过得不错；或许你现在仍然处于人生的低谷，人生路上充满了疑惑，迷茫；或许你现在还是一个面临大学毕业的学生，对自己的未来没有方向…… 没关系，我曾经也是这样，也有过纠结的时候，找不到前方的道路。但是，不管怎么样，人生路上，再是需要活着走下去。想要让自己在这条路上面走的更好一点，我认为必须要对自己有一个全面的认识。相信来到这里的人很多都不知道自己究竟是什么样子。当然，这里指的不仅仅是你的外貌。更重要的是你的 学历：我的学历如何？我还需要继续提升自己的学历么？ 梦想：我的梦想是什么？为了这个梦想我需要具备什么样的前置条件？待所有的前置条件都已经具备了，那么你就离你的梦想不远了 未来的规划：对自己的未来有一定的规划，自己未来需要达到什么样的地步，有了规划，那么你就有一定的方向奋斗。 自制力：这个非常的重要，很多人都具有前面的三种，但是，所有的计划都已经定制好了，但是，最后还是竹篮打水一场空。我们都是成年人了，不需要父母老师的监督了，有强烈自制能力的人比其他的人更容易成功。 希望您能用一点时间仔细的想一下自己究竟是什么样的人，清楚地认清了自己，了解了自己梦想，想法以后，你会对自己的未来清晰很多。"},{"title":"友情链接","date":"2018-12-27T07:35:20.000Z","updated":"2020-04-13T03:13:34.979Z","comments":true,"path":"links/index.html","permalink":"https://blog.lyt007.cn/links/index.html","excerpt":"","text":""},{"title":"影视图书","date":"2019-04-07T13:40:07.000Z","updated":"2020-04-23T09:05:46.976Z","comments":false,"path":"movie-book/index.html","permalink":"https://blog.lyt007.cn/movie-book/index.html","excerpt":"","text":"影视 电视剧《都挺好》 感悟 图书"},{"title":"tags","date":"2019-04-07T12:45:27.000Z","updated":"2020-04-13T03:13:34.979Z","comments":false,"path":"tags/index.html","permalink":"https://blog.lyt007.cn/tags/index.html","excerpt":"","text":""},{"title":"时光轴","date":"2018-12-27T07:34:30.000Z","updated":"2020-04-13T03:13:34.980Z","comments":true,"path":"timeline/index.html","permalink":"https://blog.lyt007.cn/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"react+antd+webpack4 构建项目框架","slug":"react-antd-webpack4构建项目框架","date":"2020-04-15T07:02:37.000Z","updated":"2020-04-23T08:44:12.840Z","comments":true,"path":"技术/react-antd-webpack4构建项目框架.html","link":"","permalink":"https://blog.lyt007.cn/技术/react-antd-webpack4构建项目框架.html","excerpt":"","text":"入职新公司，要求自己搭建一个react的开发模板，而不是使用现有的 create-react-app 。所以自己搭建了一个 涉及到的功能： react, react-dom, react-router ESlint + Aribnb prettier 具体使用还是不使用状态管理库（redux or mobx），视情况而定，不复杂使用 React.crateContext() 使用less不使用scss 热更新，不是热重载 其他的功能自己适适当配置 项目地址：https://github.com/tal007/react-antd-webpack loadersbabel-loader处理js，jsx，ts，tsx语法 style-loader，css-loader，less-loader，postcss-loader处理css style-loader：添加到js中，这样修改才会热更新，在开发环境中需要加上，生产环境如果使用mini-css-extract-plugin抽离css，那么不要加上style-loader 注意loader使用顺序 使用less-loader需要同时安装less库 postcss-loader处理css中的一些问题，压缩等，同时可以使用postcss插件，例如postcss-flexbugs-fixes, postcss-cssnext, cssnano 等。 file-loader处理文件（字体，图片，影视频等）并重新命名 url-loader处理图片，设置路径以及base64图片压缩 pluginshtml-webpack-plugin设置html模板以及输出路径等 webpack.ProvidePlugin设置webpack全局变量 1234new webpack.ProvidePlugin(&#123; // 这样就不用每个文件都引用react了，但是需要在eslintrc中配置eslint语法检测 React: 'react',&#125;), mini-css-extract-plugincss代码抽离，详见config/webpack.prod.js clean-webpack-plugin清除之前打包的代码 热更新webpack.HotModuleReplacementPlugin 与 webpack.NamedModulesPlugin()。前者使用热更新，后者在控制台展示热更新名字。 热更新需要同时使用 react-hot-loader。 npm i –save-dev react-hot-loader 使用详见： src/App.jsx。还需要在 .babelrc 中配置 plugins 代码规范ESlint + Prettier npm i –save-dev eslint 配合VSCode使用VSCode 安装插件 Prettier - Code formatter ESLint .eslintrc.js中添加 1234\"plugins\": [\"prettier\"],\"rules\": &#123; \"prettier/prettier\": \"error\"&#125; 添加 .ptettierrc.js 配置如下，可自行修改 12345678910// configs see https://prettier.io/docs/en/options.htmlmodule.exports = &#123; trailingComma: 'es5', singleQuote: true, tabWidth: 2, semi: true, bracketSpacing: true, arrowParens: 'always'&#125; 在settings.json 中添加如下 1234567891011// jsx自动修复有问题，取消js的format\"editor.formatOnSave\": false,// Enable/disable default JavaScript formatter (For Prettier)\"javascript.format.enable\": false,\"prettier.singleQuote\": true,// 点击保存时，根据 eslint 规则自定修复，同时集成 prettier 到 eslint 中\"prettier.eslintIntegration\": true,// 保存自动修复\"editor.codeActionsOnSave\": &#123; \"source.fixAll.eslint\": true&#125;, 问题使用 BrowserRouter 刷新 404在 devServer 中 添加 historyApiFallback: true 使用 webpack alias 的时候路径提示根目录添加 jsconfig.json 文件，与 alias 中的对应 1234567891011121314&#123; \"compilerOptions\": &#123; \"experimentalDecorators\": true, \"baseUrl\": \"./\", \"paths\": &#123; \"@/*\": [\"./src\"], \"@comp/*\": [\"./src/components\"], \"@img/*\": [\"./src/img\"], \"@styl/*\": [\"./src/style\"], \"@pages/*\": [\"./src/pages\"], &#125; &#125;, \"exclude\": [\"node_modules\", \"dist\"]&#125; 使用git commit 规范git-commit规范可以查看优雅的提交你的 Git Commit Message 项目地址：https://github.com/tal007/react-antd-webpack","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[]},{"title":"使用nextjs进行react项目的服务端渲染","slug":"使用nextjs进行react项目的服务端渲染","date":"2020-03-24T01:42:40.000Z","updated":"2020-04-23T09:05:46.956Z","comments":true,"path":"技术/使用nextjs进行react项目的服务端渲染.html","link":"","permalink":"https://blog.lyt007.cn/技术/使用nextjs进行react项目的服务端渲染.html","excerpt":"","text":"react作为前端三大框架之一，用的人自然是很多的。我也是一直使用react进行项目的开发，不管是移动端还是PC端，不管是大项目还是小项目，大部分都是使用的是react进行开发的。当然，其他的框架（vue等）也是使用的。当然，客户端渲染的弊端也是很明显的，首页加载缓慢，网站SEO问题等等。 如果功能不是太复杂又要SEO，可以尝试预渲染的模式react项目预渲染开发 React服务端渲染可以解决这个问题。以前在没有nextjs的时候，我们通常都是使用react提供的renderToString方法在结合express等来实现的服务端渲染。当然也可以实现。但是正所谓专业的人做专业的事。自己搭建一个服务端渲染先不说麻烦，自己要踩得坑也是很多的。所以，如果是要上正式环境，在自己构建不熟悉的情况下，使用服务端渲染框架也是很不错的。 目前用的比较多的就是nextjs。 关于nextjs的使用在官网上面说的很明确。可以自己去看看。这里我记录一下实际使用的时候遇到的一些问题。 1.项目部署。构建自己的项目后，并成功添加页面，在本地跑起来都是没有问题的。这时候就需要部署到服务端了。 123456789101112131415161718192021&#123; \"name\": \"hello-next\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"dev\": \"next\", \"build\": \"next build\", \"start\": \"next start\", \"export\": \"npm run build &amp;&amp; next export\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"axios\": \"^0.19.2\", \"next\": \"^9.2.2\", \"react\": \"^16.13.0\", \"react-dom\": \"^16.13.0\" &#125;&#125; 使用yarn build以后会生成一个.next目录的文件夹，里面就是我们需要部署的内容。然后使用yarn start就可以跑起来了。可以在本地试试。 执行 yarn start 之前必须先执行 yarn build。因为 start 需要的就是 .next 文件夹里面的东西。 所以，我们在服务器上面只需要上传 .next 和 package.json 就可以了。 这样操作以后，就可以在服务器3000端口访问了。但是，如果一关闭命令窗口，那么久GG了，无法访问。 使用pm2托管node项目在服务器上面安装pm2 然后使用 pm2 start --name=&#39;nextjs&#39; npm -- start 运行项目。这样就可以解决上面的问题。 启动成功，这样就可以在对应的端口查看了 http://118.24.6.33:3000/ 关于pm2的一系列操作可以查看PM2常用命令 路由页面与路由需要对应开始学习的时候，我创建组件也是按照传统的创建组件（首字母大写）的方式创建的，而路由跳转又是小写的，本地一切正常，但是在部署后，就出问题了。找不到对应的小写的js的文件。这就是问题所在。 两种解决： 使用小写，或者说路由与文件名字一样 使用自定义路由而不是用默认的路由 配置域名一直使用域名 + 端口访问是很愚蠢的。所以我们需要绑定域名。在你的域名里面添加一个二级域名解析，我这里是nextjs.lyt007.cn。 然后需要配置服务器上的nginx。 1234567891011121314151617181920# 定义了一个名字upstream nodenext &#123; server 127.0.0.1:3000; #next项目 监听端口 keepalive 64;&#125;server &#123; listen 80; server_name nextjs.lyt007.cn; location / &#123; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $host; proxy_set_header X-Nginx-Proxy true; proxy_cache_bypass $http_upgrade; # 这里使用这个名字反向代理 proxy_pass http://nodenext; #反向代理 &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"react","slug":"react","permalink":"https://blog.lyt007.cn/tags/react/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"https://blog.lyt007.cn/tags/服务端渲染/"}]},{"title":"JavaScript-从使用new到手写new","slug":"JavaScript-从使用new到手写new","date":"2020-03-21T07:10:16.000Z","updated":"2020-04-13T03:13:34.972Z","comments":true,"path":"技术/JavaScript-从使用new到手写new.html","link":"","permalink":"https://blog.lyt007.cn/技术/JavaScript-从使用new到手写new.html","excerpt":"","text":"new new运算符创建一个用户定义的对象类型的实例或者具有构造函数的内置对象类型之一 在手写 new 之前，我们来看看 new 实现了那些功能。 Demo： 12345678910111213141516171819// 狗的类function Dog (name, age) &#123; this.name = name; this.age = age; this.habit = \"Ball\";&#125;Dog.prototype.weight = 50;Dog.prototype.run = function() &#123; console.log(\"I am\" + this.name + \", i am run...\");&#125;;// 一条白色的狗var whiteDog = new Dog('xiao bai', '2');console.log(whiteDog.name); // xiao baiconsole.log(whiteDog.age); // 2console.log(whiteDog.weight); // 50whiteDog.run(); // I am xiao bai, i am run... 从上面的Demo中可以看出来，实例 whiteDog 可以： 访问到 Dog 构造函数中的属性； 访问到 Dog.prototype 中的属性； 所以。我们可以简单的实现一个 new。 因为new是关键字，我们无法覆盖，所以我们用new2来表示我们的new 使用的时候呢如下： 12345function Dog(...)&#123;...&#125;;// 使用newvar whiteDog = new Dog(...);// 使用new2var whiteDog = new2(Dog,...); 初步实现分析： 因为 new 的结果会返回一个对象，所以在模拟实现它的时候，我们也要建立一个新的对象，假设这个对象叫 obj。因为 obj 会具有构造函数（这里指Dog）里面的属性。我们使用 Dog.allpy(obj, arguments) 来给 obj 添加新的属性。 补充两点： __proto__ 和 constructor 属性是对象所独有的； prototype 属性是函数所独有的。 第一版代码 12345678function new2() &#123; var obj = &#123;&#125;; var Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125; 其实上面的代码已经可以生效了。不信你可以复制下面的代码运行一下。 1234567891011121314151617181920212223242526272829303132// 狗的类function Dog (name, age) &#123; this.name = name; this.age = age; this.habit = \"Ball\";&#125;Dog.prototype.weight = 50;Dog.prototype.run = function() &#123; console.log(\"I am\" + this.name + \", i am run...\");&#125;;// 一条白色的狗的实例var whiteDog = new Dog('xiao bai', '2');// console.log(whiteDog.name); // xiao bai// console.log(whiteDog.age); // 2// console.log(whiteDog.weight); // 50// whiteDog.run(); // I am xiao bai, i am run...function new2() &#123; var obj = &#123;&#125;; // 这里通过定制传参规则，获取第一个参数，即我们需要继承的对象。 // 同时因为使用的数组的 shift 方法，最后的 arguments 是少了第一项的 var Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125;var blackDog = new2(Dog, \"xiao hei\", '1');console.log(blackDog.name); // xiao hei 但是有一个问题。 什么问题呢？那就是如果我的构造函数不是默认的返回值而是自己添加了一个返回值呢？ Demo2 12345678910111213function Dog (name, age) &#123; this.weight = 60; this.age = age; return &#123; name: name, habit: 'Games' &#125;&#125;var dog = new Dog('Kevin', '18');console.log(dog.name) // Kevinconsole.log(dog.habit) // Gamesconsole.log(dog.weight) // undefinedconsole.log(dog.age) // undefined 在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。 而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个 基本类型 的值呢？ Demo3: 12345678910function Dog (name, age) &#123; this.weight = 60; this.age = age; return \"Kevin\" // 你可以试试其他基本类型，包括ES6中的 Symbol();&#125;var dog = new Dog('Kevin', '18');console.log(dog.name) // undefinedconsole.log(dog.habit) // undefinedconsole.log(dog.weight) // 60console.log(dog.age) // 18 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。 所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。 所以我们有了第二版的 new2 12345678// 第二版的代码function new2() &#123; var obj = &#123;&#125;, Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var res= Constructor.apply(obj, arguments); return typeof res === 'object' ? res: obj;&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://blog.lyt007.cn/tags/javaScript/"}]},{"title":"PM2常用命令","slug":"PM2常用命令","date":"2020-03-11T06:42:09.000Z","updated":"2020-04-13T03:13:34.973Z","comments":true,"path":"技术/PM2常用命令.html","link":"","permalink":"https://blog.lyt007.cn/技术/PM2常用命令.html","excerpt":"","text":"pm2常用命令记录 pm2 start app.js # 启动app.js应用程序 pm2 start app.js -i 4 # cluster mode 模式启动4个app.js的应用实例 4个应用程序会自动进行负载均衡 pm2 start app.js --name=&quot;api&quot; # 启动应用程序并命名为 “api” pm2 start app.js --watch # 当文件变化时自动重启应用 pm2 start script.sh # 启动 bash 脚本 pm2 list # 列表 PM2 启动的所有的应用程序 pm2 monit # 显示每个应用程序的CPU和内存占用情况 pm2 show [app-name] # 显示应用程序的所有信息 pm2 logs # 显示所有应用程序的日志 pm2 logs [app-name] # 显示指定应用程序的日志 pm2 flush # 清空所有日志文件 pm2 stop all # 停止所有的应用程序 pm2 stop 0 # 停止 id为 0的指定应用程序 pm2 restart all # 重启所有应用 pm2 reload all # 重启 cluster mode下的所有应用 pm2 gracefulReload all # Graceful reload all apps in cluster mode pm2 delete all # 关闭并删除所有应用 pm2 delete 0 # 删除指定应用 id 0 pm2 scale api 10 # 把名字叫api的应用扩展到10个实例 pm2 reset [app-name] # 重置重启数量 pm2 startup # 创建开机自启动命令 pm2 save # 保存当前应用列表 pm2 resurrect # 重新加载保存的应用列表 pm2 update # Save processes, kill PM2 and restore processes pm2 generate # Generate a sample json configuration file 补充pm2 start npm -- start # pm2 启动 npm 命令。scripts中名字为 start pm2文档地址：https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"pm2","slug":"pm2","permalink":"https://blog.lyt007.cn/tags/pm2/"}]},{"title":"移动端UI框架","slug":"移动端UI框架","date":"2020-03-02T01:32:10.000Z","updated":"2020-04-13T03:13:34.974Z","comments":true,"path":"技术/移动端UI框架.html","link":"","permalink":"https://blog.lyt007.cn/技术/移动端UI框架.html","excerpt":"","text":"UI框架作为前端一门必须要了解并且熟练掌握的一门技术，关于目前不同的js框架对应的不同的框架还是有必要说说。 关于PC端的UI框架是在是太多了。 react：目前常用的得数蚂蚁金服出的Ant Design了。而最新刚刚发布了4.0版本。移除了对IE9/10的支持，同时也支持 React Hook。当然还有其他的 vue：目前常用的算得上是饿了么出的ElementUI了。当然还有其他的 移动端的UI框架也挺多。不过这是针对于VUE来说的。 Vant UI。有赞公司出的一套电商类的UI框架，如果是做移动端电商的，想必这款UI框架用的是得心应手了吧 Muse UI。社区人员维护的一套UI框架。 Mand Mobile。也是社区活跃挺高的一款UI。同时还包含了React Native的UI。 VUE的可以说有很多，但也有很多都不再维护了。比如滴滴公司的Cube UI，京东的Nut UI等等。 再来看看React，相对来说就很少了。我一直都是在使用react开发网站，不管是PC还是H5的。PC的当然是首选了 Ant Design，但是H5端的ant是真的没有PC的好用。所以最开始在开发移动端的时候都是自己写的样式，交互体验也比较差。后面觉得是在是不行了。就到处找，找了一款国外的UI框架 Framework7。 Framework7其实最开始是专注于 WebApp 开发的，而且在IOS的上面的体验几乎与原生媲美，安卓上性能就差很多了。不多最近我在使用这个框架的时候，其中的大部分功能还是挺不错的，在使用React开发的时候可以选择这款UI框架。不过如果是做H5，那最好就不要使用UI框架自带的路由了，真的太差了。 如果你有其他的react的UI框架推荐，欢迎留言。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://blog.lyt007.cn/tags/移动端/"},{"name":"UI","slug":"UI","permalink":"https://blog.lyt007.cn/tags/UI/"}]},{"title":"不打算在使用BootCND","slug":"不打算在使用BootCND","date":"2020-02-24T02:13:15.000Z","updated":"2020-04-13T03:13:34.974Z","comments":true,"path":"技术/不打算在使用BootCND.html","link":"","permalink":"https://blog.lyt007.cn/技术/不打算在使用BootCND.html","excerpt":"","text":"今天（2020年02月24日）上班来到公司，一如既往的开机准备开开心心的敲代码了。结果，日了狗了。网站报错了。 结果。就是因为使用了 BootCND 导致的网站无法访问。 出问题了。可能会亏损几个亿吧。当然，几个亿是不可能的。 所以。这件事情以后，打算不再使用CDN了。还是老老实实的放本地吧。 或者 https://cdnjs.com/ 可能也是一个不错的选择。 记在这里，就当给自己一个教训。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"https://blog.lyt007.cn/tags/CDN/"}]},{"title":"React Hook","slug":"React-Hook","date":"2020-01-16T09:25:27.000Z","updated":"2020-04-22T03:28:52.454Z","comments":true,"path":"技术/React-Hook.html","link":"","permalink":"https://blog.lyt007.cn/技术/React-Hook.html","excerpt":"","text":"React Hook 在 react 16.8及以后的版本中才会有 React Hook 解决的问题1. 组件之间复用状态逻辑2. 减少组件的复杂程度在传统的 class 中，会使用 componentDidMount 和 componentDidUpdate 获取数据。同时 componentDidMount 中也会处理一些其他的事务，例如事件监听，定时器等等。而后还需要在 componentWillUnmount 中取消。万一忘记其中某一个部分或者处理的时间过多，很可能导致一些可怕的bug。 3. 关于 class 类与函数组件 this 的问题对于一部分人来说，理解 class 中的 this 会比理解函数组件中的 this 更加困难，而且增加了学习成本。但是，react 中并不会移除 class 这种方法 YouTube上面的视频 State Hook传统的 React 组件的 state 都是这样的，创建一个 state 与更新（this.setState）1234567891011121314import React from 'react';class Demo extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; count: 0 &#125; &#125; render()&#123; return (&lt;div onClick=&#123;_ =&gt; this.setState(&#123;count: this.state.count++&#125;)&#125;&gt;&#123;this.state.count&#125;&lt;/div&gt;) &#125;&#125; 使用 React Hook 后123456import React, &#123; useState &#125; from 'react'function Demo()&#123; let [count, setCount] = useState(0) return (&lt;div onClick=&#123;_ =&gt; setCount(count++)&#125;&gt;&#123;count&#125;&lt;/div&gt;)&#125; 可以看到。使用 Hook 后的代码简洁了很多。但是，使用 useState 不会把新的 state 和旧的 state 进行合并。 上面，我们只是用了一个 count。但是通常一个组件都不会只有一个 state 的，这时候可以多次使用 useState。 同时，定义 state 的时候定义在一个数组里面，可以猜到， useState 返回的不是一个不同的数字或者字符串，而是一个对象（数组）。这里这样定义，使用了 ES6 中的解构赋值 Effect HookuseState 其实不难理解，唯一需要注意的就是 this.setState 是修改后的 state 与之前的 state 对比合并，而采用 useState 则是直接替换。 作为使用过一段时间的 React Hook 的程序员，个人认为 Effect Hook 才需要更多的理解。 React官方文档中这样定义的 你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。 所以，我们使用 Hook 后，数据获取、订阅或者手动修改过 DOM等都需要在 useEffect 中进行了。 不要以为 useEffect 和 componentDidMount、componentDidUpdate 和 componentWillUnmount 一样只能使用一次，他与 useState 一样，可以多次使用。 默认情况下，React 会在每次渲染后调用副作用函数(useEffect) —— 包括第一次渲染的时候。所以，在 useEffect 函数中可以直接使用 props 和 state useEffect 接收两个参数。第一个参数是一个函数，第一个参数相当于 componentDidMount 和 componentDidUpdate，第一个参数可以有一个返回值（一般就是一个函数，我们将之称为清除函数），相当于与 componentWillUnmount。这样一说，你可能就理解了。再来举个例子，更形象的说明一下 1234567891011class Demo extends React.Component &#123; componentDidMount()&#123; this.timer = setInterval(() =&gt; doSomething(), 1000) &#125; componentWillUnmount()&#123; if(this.timer) clearInterval(this.timer) &#125; ...&#125; 上面的是传统的方式，添加以及移除定时器的操作。因为需要在 componentWillUnmount 中进行判断，有时候（大部分时候）可能都会遗忘。 再来看看使用 useEffect 的代码123456789101112function Demo()&#123; let timer = null useEffect(() =&gt; &#123; timer = setInterval(() =&gt; doSomething(), 1000) // return 一个函数，将会在组件将要卸载的时候调用 相当于 componentWillUnmount return () =&gt; clearInterval(timer) &#125;) return ...&#125; 可以看出，使用 useEffect 不单单是代码更简洁，同时使我们的代码逻辑看起来更直观。设置定时器与清除定时器是放在一个API里面的，代码的耦合更高。更能体现这是一个整体，也避免了遗忘。 为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。 React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。 如果不涉及到异步，订阅等操作，可以不用返回清除函数 上面只是 useEffect 的一个简单的事例，它的功能不止于此。因为之前还说过，处理数据请求也是在里面处理的。那么怎么使用呢 12345function Demo()&#123; useEffect(() =&gt; &#123; // do ajax request &#125;)&#125; 如果只是上面那样写，会有一个严重的问题。之前说过， useEffect 是会在DOM初次加载完成以及DOM更新完成的时候调用，所以上面的请求会在每一次DOM更新的时候再次执行，而如果请求返回的结果会使DOM更新，那么，这就是一个无限循环的过程了。 那么怎么处理这个副作用呢？这时候就需要 useEffect 的第二个参数了。一般是一个数组 如果两次需要更新的数据没有变化，只需要在第二个参数（数组）中添加对应的变量，例如123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 仅在 count 更改时更新 但是如果是上面的处理 ajax request 的 effect 。只需要传递一个空数组即可。这样，这个 effect 只会执行一次。 React 会对数组中的数据进行更新前后数据的对比，如果没有变化，那么则不更新 这个方法对于有清除函数的 effect 同样适用。 React官网中说到：未来版本，可能会在构建时自动添加第二个参数。期待他的到来，这将大大减少可能出现的bug。 其他 Hook除了 useState 和 useEffect 两个常用的 Hook， 还有一些其他的 Hook， 这些可能用的不多。 useContext1const value = useContext(MyContext); 这个 Hook 用于连接 React 上下文。使用过 React.createContext 的老铁应该知道，这是创建一个 React 上下文 1234567const Context = React.createContext;// 上层组件&lt;Context.Provider&gt;&lt;/Context.Provider&gt;// 消费这个 Context 的组件&lt;Context.Consumer&gt;&lt;/Context.Consumer&gt; 使用 useContext123const Context = React.createContext;useContext(Context) 例子123456789101112131415161718192021222324252627282930313233343536373839const themes = &#123; light: &#123; foreground: \"#000000\", background: \"#eeeeee\" &#125;, dark: &#123; foreground: \"#ffffff\", background: \"#222222\" &#125;&#125;;const ThemeContext = React.createContext(themes.light);function App() &#123; return ( &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; );&#125;function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;function ThemedButton() &#123; // 通过 useContext 使用 React.createContext(themes.light) 创建的 Context const theme = useContext(ThemeContext); return ( &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt; I am styled by theme context! &lt;/button&gt; );&#125; useReducer1const [state, dispatch] = useReducer(reducer, initialArg, init); useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。) 1234567891011121314151617181920212223const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;count: state.count + 1&#125;; case 'decrement': return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;function Counter() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125; 既然作用类似于 Redux， 那么可以用这个取代 Redux 么？答案是可以的，不过需要结合 useContext 来使用。掘金上面有码友给出了一个例子用 useContext + useReducer 替代 redux。 你可以在新项目中或者涉及状态管理不多的项目中尝试使用，现有的大型项目不建议重构，使用 Redux 依然是不错的方案。 useCallback123456const memoizedCallback = useCallback( () =&gt; &#123; doSomething(a, b); &#125;, [a, b],); 返回一个 memoized 回调函数。 把内联回调函数及依赖项数组作为参数传入 useCallback ，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate ）的子组件时，它将非常有用。 useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。 useMemo1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 返回一个 memoized 值。 useCallback 与 useMemo 都可以用于 React 性能优化的手段。 useRef1const refContainer = useRef(initialValue); useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。 所以，这个方法就相当于 class 中的 ref 属性，用于获取具体的DOM元素。 12345678910111213function TextInputWithFocusButton() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); &#125;; return ( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type=\"text\" /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/&gt; );&#125; useImperativeHandleuseLayoutEffectuseDebugValue上面未说明的 Hook 可以查看 React 官网 Hook 规则Hook 永远是在最顶层调用，不能在条件判断语句或者其他语句中。123456789101112131415function Demo()&#123; // 正确 useEffect(() =&gt; &#123; if(name === 'tal')&#123; // do something &#125; &#125;) // 错误 if (name === 'tal') &#123; useEffect(() =&gt; &#123; // do something &#125;) &#125;&#125; 如果你害怕你写错了，但是没有检查出来，可以使用 eslint-plugin-react-hooks 这个插件来检测。 自定义 HookHook 我们也是可以自定义的。那么为什么需要自定义。答案是 逻辑共享。 假如有一个 state 需要在多个组件中使用，我们不应该在多个组件中都单独的去创建这个 state， 而是应该逻辑共享。把这个 state 以及操作这个 state 的方法定义在我们自己的 Hook 中。那这个 Hook 就是我们自定义的 Hook，其实，他也是一个函数，接收参数，返回你需要的值。唯一需要注意的是：自定义 Hook 必须以 use 开头，不管怎么变，使用需要遵循 React Hook 以 use 开头的规则。 下面是一个获取window视窗的hook 123456789101112131415161718192021222324import &#123; useState, useCallback, useEffect &#125; from 'react';// 获取窗口大小function useWinSize() &#123; const [size, setSize] = useState(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;); const onResize = useCallback(() =&gt; &#123; setSize(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;); &#125;, []); useEffect(() =&gt; &#123; window.addEventListener('resize', onResize); return () =&gt; &#123; window.removeEventListener('resize', onResize); &#125;; &#125;, []); return size;&#125;export default useWinSize; 官网介绍","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"react","slug":"react","permalink":"https://blog.lyt007.cn/tags/react/"}]},{"title":"react 读书笔记","slug":"react-读书笔记","date":"2020-01-09T02:46:51.000Z","updated":"2020-04-13T03:13:34.973Z","comments":true,"path":"技术/react-读书笔记.html","link":"","permalink":"https://blog.lyt007.cn/技术/react-读书笔记.html","excerpt":"","text":"在 React 组件中，代码重用的主要方式是组合而不是继承。 We strongly recommend against creating your own base component classes. In React components, code reuse is primarily achieved through composition rather than inheritance. 这句话来自于react的官方网站 为什么要提及这句话呢。因为现在我的项目中也有自己的创建的组件类，然后其余的组件来继承它。 其实最开始我也是一步一步的使用class App extends React.Component来写我自己的组件，这样确实有点复杂，但是还算过得去。或许是因为初学react或者是对react的了解不深入，所以，一直就这样。去年了解了一下同事的安卓开发，他们都会建一个基础的类来继承于这个类，这个基础的类实现了一些公用的方法，所以继承于这个基础类的组件也会有这些方法，而且不用每一次都引入。这样理念确实很不错。自己用了一段时间，某些地方也确实方便，尤其是在组件数据请求的时候，需要渲染不同的组件（loading，completed，empty，request_error and so on），而且目前还没有发现有什么不一样的地方，因为这些继承于基础类的组件也是可以使用React的生命周期。直到今天，我才知道，原来这是违背了react的开发理念。那要怎么实现呢。正如上面所说 code reuse is primarily achieved through composition rather than inheritance. 通过组件的组合来实现，通过props参数来实现，具体查看Composition vs Inheritance。 虽说这样开发可能会复杂一点（或许是自己的技术能力有限），不过这样也算是符合react的理念。 组件的生命周期react组件的生命周期作为react开发人员面试的必考知识，还是很有必要实时掌握，并且实时更新。 React生命周期有一份图谱。上面可以查看react的生命周期(新版)。 react的组件的生命周期在react16.3及以后的版本中已经不一样了。但是总的几个阶段是不变的，不管是新的版本还是老的版本，都分为 组件挂载 组件更新 组件卸载 这样的几个阶段。 React16.3以前的生命周期(作为了解)1.组件挂载 getDefaultProps()：加载的时候调用一次，设置默认的props，也可以使用组件名.defaultProps = {}设置默认属性。 getInitialState()：加载的时候调用一次，可以初始化state。 componentWillMount()：只在组件挂载的时候调用，且整个生命周期只调用一次，此时可以修改state。但是一般不使用 render()：react的最重要的步骤，创建虚拟DOM，进行diff算法,更新DOM树都在此运行 componentDidMount()：组件渲染之后（执行rendeer后）调用一次 2.组件更新 componentWillReceiveProps(nextProps)：组件加载时不使用，组件接收新的props是调用 shouldComponentUpdate(nextProps, nextState)：组件接收到新的props或state时调用，函数必须有一个返回值（true or false），为true的时候组件更新，为 flase 的时候组件不更新。默认返回的是true。这个方法很重要，一个组件的优化都在这里面进行。 componentWillUpdata(nextProps, nextState) render()：react的最重要的步骤，创建虚拟DOM，进行diff算法,更新DOM树都在此运行 componentDidUpdate()：组件挂载时不调用，组件更新完成调用 3.卸载阶段 componentWillUnmount()：组件将要移除时候调用。一般在这个函数里面清除定时器，异步操作等 React16.3以后的生命周期1.挂载阶段 constructor()：在这个构造函数中一般处理初始化state或者进行方法的绑定，如不需要，则可以不使用此方法 static getDerivedStateFromProps()：会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。 render() componentDidMount() *.componentWillMount方法在新的生命周期中已经过期，应该替换成UNSAFE_componentWillMount，不过也将在react17中移除 2.更新阶段 static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate(prevProps, prevState)：此方法并不常使用 componentDidUpdate() *. 老方法的componentWillUpdate以及componentWillReceiveProps即将过期，应该避免使用它们 3.卸载阶段 componentWillUnmount() 错误处理 static getDerivedStateFromProps() componentDidCatch(error, info)：此生命周期在后代组件抛出错误后被调用 总的来说新的生命周期移除了一些不必要的函数。具体的可以查看React.Component 对 React 时间操作节流与防抖 节流：节流阻止函数在给定时间窗口内被调不能超过一次。 防抖：防抖确保函数不会在上一次被调用之后一定量的时间内被执行。当必须进行一些费时的计算来响应快速派发的事件时（比如鼠标滚动或键盘事件时），防抖是非常有用的。 以前在进行按钮提交，鼠标滚动等操作的时候，都会进行截留或者是防抖。但是都是自己写的，有时候或者是有的地方会忘记添加。 lodash中已经有相关的函数了 throttle debounce 但是，整个 lodash 的库应用进来有1.4M，太大了。不过还好，npm 上面已经有 throttle 和 debounce 的提取包了。 https://www.npmjs.com/package/lodash.throttle 1npm i --save lodash.throttle https://www.npmjs.com/package/lodash.debounce 1npm i --save lodash.debounce 都接收两个参数，第一个是操作的函数，第二个是时间间隔(ms)。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"react","slug":"react","permalink":"https://blog.lyt007.cn/tags/react/"}]},{"title":"react项目报错集锦","slug":"react项目报错集锦","date":"2020-01-03T03:08:36.000Z","updated":"2020-04-13T03:13:34.974Z","comments":true,"path":"技术/react项目报错集锦.html","link":"","permalink":"https://blog.lyt007.cn/技术/react项目报错集锦.html","excerpt":"","text":"Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method. 解决方案解决方法上面其实以及说到了。只需要找到对象的文件，在 componentWillUnmount 中取消所有的订阅以及异步执行即可。 下面是代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React, &#123; Component &#125; from 'react'import Avatar from '@img/common/avatar.jpeg'import Stance from '@img/common/stance.png'class CusImage extends Component &#123; constructor(props)&#123; super(props) const defaultImage = props.isAvatar ? Avatar : Stance this.state = &#123; src: defaultImage &#125; &#125; componentDidMount()&#123; const THIS = this const &#123;imgSrc&#125; = this.props const img = new Image() img.src = imgSrc img.onload = function()&#123; THIS.setState(&#123; src: imgSrc &#125;) &#125; &#125; // 添加以下代码 componentWillUnmount()&#123; // 如果有定时器需要清除 // clearTimeout(this.timer) this.setState = (state, callback) =&gt; &#123; return &#125; &#125; render ()&#123; const &#123;src&#125; = this.state const &#123;className, alt = \"cus-img\"&#125; = this.props return ( &lt;img className=&#123;className&#125; src=&#123;src&#125; alt=&#123;alt&#125;/&gt; ) &#125;&#125;export default CusImage react-dom.development.js:12427 Warning: componentWillMount has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details. 解决方案在 react 16.8 之后的版本中，修改了一下生命周期，移除了一些方法，componentWillMount就是其中一个。现在如果要使用这个，使用 UNSAFE_componentWillMount 替换。但是不建议使用这个方法","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"react","slug":"react","permalink":"https://blog.lyt007.cn/tags/react/"}]},{"title":"前端中的直播","slug":"前端中的直播","date":"2019-11-05T02:50:55.000Z","updated":"2020-04-13T03:13:34.970Z","comments":true,"path":"技术/前端中的直播.html","link":"","permalink":"https://blog.lyt007.cn/技术/前端中的直播.html","excerpt":"","text":"因为公司是做在线抓娃娃的，涉及到直播推流这一部分的工作。之前一直都是在App上面进行游戏，所以关于直播这一部分也是与安卓与IOS有关，与前端是没有关系的。但是现在新的需求就是要求这个在线抓娃娃要能够在网页上面进行游戏。所以，我的事情来了。对于没有涉及到前端音视频的这部分的需求，所以初入这一行，还是有点马马虎虎，花了一周多的时间终于是弄明白了。 要了解前端视频方面的东西，还是要从基础的说起。 介绍2019年了，HTML5已经走进千家万户，同时，直播也在全球盛行。App端的姑且不说，web端的使用视频播放的话，一般都是在用HTML5中的 video 标签了。然而，video标签的限制实在是太多了，尤其是对于播放格式这一项，仅仅是支持 MP4 OGG WebM 格式，现在可能还支持 m3u8 格式的视频。 但是，再来看看现在的直播方面的知识 直播简介关于直播，大概的过程是：推流—&gt;源站—&gt;客户端拉流—&gt;客户端播放 推流：指的是把采集阶段封包好的内容传输到服务器的过程。 拉流：一般是一个URL地址，即播放地址，有多种类型的流。 视频直播服务目前常用的包含三种协议（当前时间阿里云的直播推流也是这三种协议），分别是RTML， HLS， (HTTP-)FLV。 下面附上一张知乎上面的推流拉流图 ###RTMP: RTMP是Real Time Messaging Protocol（实时消息传输协议）的缩写，是Adobe公司为Flash/AIR平台和服务器之间音、视频及数据传输开发的实时消息传送协议。RTMP协议基于TCP，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP协议中，视频必须是H264编码，音频必须是AAC或MP3编码，且多以flv格式封包。RTMP是目前最主流的流媒体传输协议，对CDN支持良好，实现难度较低，是大多数的直播平台的选择。不过RTMP有着一个最大的不足——不支持浏览器，且Adobe已不再更新。因此直播服务要支持浏览器的话，需要另外的推送协议支持。 优点： 延时低，稳定性好，支持摄像头格式多 缺点： 浏览器需要加载flash才可以播放（预计2020年底所有浏览器最新版本都不在支持flash） RTMP是私有协议（Adobe的私有协议），很多设备无法播放。同时移动端不支持flash。所以，这种格式的视频基本无法再移动端使用。 安全性问题 HLSHLS（Http Live Streaming) 是一个由苹果公司提出的基于HTTP的流媒体网络传输协议，直接把流媒体切片成一段段，信息保存到m3u(m3u8)列表文件中， 可以将不同速率的版本切成相应的片；播放器可以直接使用http协议请求流数据。 优点： 可以在不同速率的版本间自由切换，实现无缝播放 省去使用其他协议的烦恼 缺点： 延时高，不适合做直播 因为采用ts切片，所以一个文件可能会被切成成百上千个小文件，对存储和缓存都有一定的挑战 这个流一般用于苹果web浏览器的直播，因为FLV和RMTP都不支持IOS的移动端（手机与平板） HTTP-FLV关于FLV在目前来说还是一个更好的方案，关于FLV方面的介绍可以查看使用flv.js做直播。上面有详细的介绍。 因为bilibili开源flv.js的原因，使得flv在目前的直播中用的更多，尤其是在移动端中使用flv流。 上面的三种方案RTMP是最好的，不管是延时还是性能问题。所以，最好的方案就是PC端采用RTMP，移动端采用HTTP-FLV。但是要考虑一点就是2020年的flash的问题。 前端做直播在视频播放方面，前端有一个开源的插件videojs。可以播放HTML5的视频格式以及Flash方面的视频。但是，在6.X开始的版本后，videojs不在支持flash，需要单独引用videojs-flash插件，或者是使用6.X以下的版本。 重点注意：videojs+flash不支持移动端。当初在这里纠结了两天的时间，实在是没有办法。 我使用的是react框架开发的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from 'react';import videojs from 'video.js'// import videozhCN from 'video.js/dist/lang/zh-CN.json'; //播放器中文，不能使用.js文件import 'video.js/dist/video-js.css'; //样式文件注意要加上import 'videojs-flash'class VideoPlayer extends React.Component &#123; componentDidMount() &#123; // console.log(flvjs); // instantiate Video.js //这里的this.props是上级传进来的video的options console.log(this.props); this.player = videojs(this.videoNode, this.props, function onPlayerReady() &#123; console.log('onPlayerReady', this) &#125;); videojs.addLanguage('zh-CN', videozhCN); // this.player.liveTracker.on('liveedgechange', () =&gt; &#123; // console.log('跟随直播'); // this.player.liveTracker.seekToLiveEdge(); // &#125;); &#125; // destroy player on unmount componentWillUnmount() &#123; if (this.player) &#123; this.player.dispose() &#125; &#125; // wrap the player in a div with a `data-vjs-player` attribute // so videojs won't create additional wrapper in the DOM // see https://github.com/videojs/video.js/pull/3856 render() &#123; return ( &lt;div&gt; &lt;div data-vjs-player&gt; &#123;/*这个带有属性的div目前没看到作用，可以去掉*/&#125; &lt;video ref=&#123; node =&gt; this.videoNode = node &#125; className=\"video-js\"&gt;&lt;/video&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;export default VideoPlayer 引用 VideoPlayer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import React, &#123; Component &#125; from 'react'import &#123; storage &#125; from '@utils'import &#123; constant &#125; from '@data/constant'class Game extends Component &#123; constructor(props)&#123; super(props) this.state = &#123; videoSrc: \"\" &#125; this.videoJsOptions = null &#125; componentDidMount()&#123; const THIS = this const token = storage.getItem(constant.TOKEN) var toyid = 913 var URL = `wss://XXX.XXX.com//websocket/1.0.0/WEB/$&#123;toyid&#125;/$&#123;token&#125;` const socket = new WebSocket(URL); socket.onmessage = function(msg)&#123; var data = JSON.parse(msg.data) // var cmd = data.cmd // var code = data.code console.log(data) // 没有登录 if (typeof data.data === \"string\") return // users data.data.room.users.users let users = data.data.room.users.users let currentPlayer = users.filter(v =&gt; v.play === true) let waitingPlayers = users.filter(v =&gt; v.play === false) let videoSrc = data.data.room.video.split(',')[0] let newState = &#123;&#125; if (currentPlayer.length) &#123; newState.currentPlayer = currentPlayer[0] &#125; if (waitingPlayers.length) &#123; newState.waitingPlayers = waitingPlayers &#125; if (videoSrc) &#123; // videoSrc = videoSrc.replace(\"rtmp\", \"http\") + \".flv\" console.log(videoSrc); newState.videoSrc = videoSrc THIS.setOptions(videoSrc) &#125; THIS.setState(newState) &#125; &#125; setOptions(videoSrc) &#123; const videoContainer = this.refs[\"video-container\"] // 播放器的配置 const videoJsOptions = &#123; autoplay: true, //自动播放 language: 'zh-CN', // controls: true, //控制条 preload: true, //自动加载 // errorDisplay: true, //错误展示 width: videoContainer.clientWidth, //宽 height: videoContainer.clientHeight, //高 // fluid: true, //跟随外层容器变化大小，跟随的是外层宽度 // controlBar: false, // 设为false不渲染控制条DOM元素，只设置controls为false虽然不展示，但还是存在 // textTrackDisplay: false, // 不渲染字幕相关DOM userActions: &#123; // hotkeys: true //是否支持热键 &#125;, sources: [ &#123; src: videoSrc, // src: 'http://live2.get.cpxlive.com/live2/front124.m3u8', // src: \"http://snowman.mobilecpx.com/video/wifi-socket.mp4\", // type: \"rmtp/flv\" type: \"application/x-mpegURL\", //类型可加可不加，目前未看到影响 // type: 'video/mp4', &#125; ] &#125;; this.videoJsOptions = videoJsOptions &#125; render()&#123; const &#123; videoSrc &#125; = this.state return ( &lt;div className=\"cpx-game flex-content\"&gt; &lt;section ref=\"video-container\" className=\"cpx-game-video\"&gt; &#123;videoSrc &amp;&amp; &lt;VideoPlayer &#123;...this.videoJsOptions&#125;/&gt;&#125; &lt;/section&gt; &lt;/div&gt; ) &#125;&#125;export default Game 注意注意：上面的视频能够播放了，但是。播放的时候中间会出现一个。没错，自己点击播放。真没意思。如果要解决这个问题，需要引入 video-js.swf 。这个在 node_modules/videojs-swf 下面有一个 video-js.swf 文件。我是直接把把他引入到了下面。这样处理完成后就可以自动播放了。真是操蛋了。 VidePlayer.js修改如下 12345678import React from 'react';import videojs from 'video.js'// import videozhCN from 'video.js/dist/lang/zh-CN.json'; //播放器中文，不能使用.js文件import 'video.js/dist/video-js.css'; //样式文件注意要加上import 'videojs-flash' //如果要播放RTMP要使用flash 需要先npm i videojs-flash// 引用这个中间就不会出现那个 SB 的Flash播放按钮+ import swf from './video-js.swf'+ videojs.options.flash.swf = swf 上面的PC的，采用的是RTMP的流 如果是flv的流，react可以使用reflv这个插件。 123456789101112131415161718import React from 'react';import Reflv from 'reflv'class VideoPlayer extends React.Component &#123; render() &#123; const &#123;url&#125; = this.props return ( &lt;Reflv url=&#123;url&#125; type=\"flv\" isLive cors /&gt; ) &#125;&#125;export default VideoPlayer 更多的配置参数查看https://gwuhaolin.github.io/reflv/","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"直播","slug":"直播","permalink":"https://blog.lyt007.cn/tags/直播/"},{"name":"前端直播","slug":"前端直播","permalink":"https://blog.lyt007.cn/tags/前端直播/"}]},{"title":"移动端web页面开发的一些问题","slug":"移动端web页面开发的一些问题","date":"2019-10-30T01:34:55.000Z","updated":"2020-04-13T03:13:34.972Z","comments":true,"path":"技术/移动端web页面开发的一些问题.html","link":"","permalink":"https://blog.lyt007.cn/技术/移动端web页面开发的一些问题.html","excerpt":"","text":"前端涉及到的领域不单单只是PC浏览器了，现在是移动为王的时代，所以大部分的时候还是在做移动端的页面适配。所以这里记录一下在移动端开发的时候遇到的一些问题。 1、移动端隐藏手机浏览器的地址栏以及底部的菜单栏在设置移动端页面的宽高为100%的时候，里面的元素设置flex:1的时候，因为浏览器的地址栏以及下面的工具栏的问题会导致在有的手机上面的页面显示不全的问题。因为我们不好计算每一个浏览器的地址栏以及工具栏的高度，所以我们直接把它隐藏起来即可，下面的隐藏的代码。 12345678&lt;!-- webApp全屏显示，IOS设备 --&gt;&lt;meta name='apple-mobile-web-app-capable' content='yes' /&gt;&lt;!-- 通用的浏览器 --&gt;&lt;meta name='full-screen' content='true' /&gt;&lt;!-- QQ浏览器（X5内核）独有的META --&gt;&lt;meta name='x5-fullscreen' content='true' /&gt;&lt;!-- 360浏览器独有的 --&gt;&lt;meta name='360-fullscreen' content='true' /&gt; 2、移动端网页自适应在开发网页的时候适配是一个老生常谈的话题。现在的适配基本都是使用的rem布局。而跟标签（html标签）的自己大小根据手机的屏幕大小来设置。 12345678910111213141516171819&lt;script&gt; (function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; if(clientWidth&gt;=640)&#123; docEl.style.fontSize = '100px'; &#125;else&#123; docEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; &#125; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); &#125;)(document, window);&lt;/script&gt; 上面的一段代码则是自动修的HTML的跟标签的字体大小的标签，然后就可以使用rem来设置元素的宽高了。但是，rem不能设置字体的自适应。 对于我而言，现在都是9102了，vw,vh,vmin,vmax这几个属性。来看看can i use上面的兼容性检测。 其实可以看到还是挺不错的，安卓4.4以上的都是兼容的。所以在9102这个年代了，可以放心大胆的使用了，就算是华为手机自带的浏览器也没有毛病。关于华为浏览器的问题可以查看我的另一篇文章 关于使用react16以上在华为手机上面显示出现问题的解决方法 关于rem以及vw, vh, vmin, vmax的具体可以查看Rem布局的原理解析。本来想放大漠的文章，今天去看突然就要付费才可以看了。 3、移动端 a 标签点击会有蓝色的背景色解决方案：添加1a &#123; -webkit-tap-highlight-color:transparent; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"移动端web","slug":"移动端web","permalink":"https://blog.lyt007.cn/tags/移动端web/"}]},{"title":"关于使用react16以上在华为手机上面显示出现问题的解决方法","slug":"关于使用react16以上在华为手机上面显示出现问题的解决方法","date":"2019-10-29T06:06:37.000Z","updated":"2020-04-13T03:13:34.969Z","comments":true,"path":"技术/关于使用react16以上在华为手机上面显示出现问题的解决方法.html","link":"","permalink":"https://blog.lyt007.cn/技术/关于使用react16以上在华为手机上面显示出现问题的解决方法.html","excerpt":"","text":"项目的网站开发了一段时间了，最近也忙着华为应用市场的上架。所以关于华为的事情也是需要着手考虑一下。 问题一：使用16.8的react以及reactDOM华为自带浏览器白屏在使用react开发的项目中，所有的浏览器（自己用的，公司没有测试）都能够跑起来。但是在使用华为手机自带的浏览器的时候，却出现了一片空白的情况。 开发用到的依赖如下 1234567891011121314151617181920212223242526272829\"axios\": \"^0.18.0\",\"babel-polyfill\": \"^6.26.0\",\"core-js\": \"^3.3.5\",\"customize-cra\": \"^0.5.0\",\"firebase\": \"^6.1.0\",\"i18next\": \"^15.1.3\",\"i18next-browser-languagedetector\": \"^3.0.1\",\"i18next-xhr-backend\": \"^2.0.1\",\"js-cookie\": \"^2.2.0\",\"mescroll.js\": \"^1.4.1\",\"moment\": \"^2.24.0\",\"node-sass\": \"^4.12.0\",\"payment\": \"^2.3.0\",\"prerender-spa-plugin\": \"^3.4.0\",\"qs\": \"^6.7.0\",\"react\": \"^16.8.6\",\"react-app-rewired\": \"^2.1.3\",\"react-confirm-alert\": \"^2.4.1\",\"react-credit-cards\": \"^0.7.0\",\"react-dom\": \"^16.8.6\",\"react-ga\": \"^2.6.0\",\"react-i18next\": \"^10.10.0\",\"react-paypal-express-checkout\": \"^1.0.5\",\"react-redux\": \"^7.0.3\",\"react-router-dom\": \"^5.0.0\",\"react-scripts\": \"3.0.1\",\"react-switch\": \"^5.0.0\",\"react-toastify\": \"^5.1.1\",\"redux\": \"^4.0.1\" 版本是 16.8 的react以及reactDOM。 查询很多资料，最后得知 reactDOM 在16开始的时候就是使用的ES6的 Map 和 Set。而华为浏览器以及其他的一些未知浏览器使用的还是低版本的浏览器内核。 37.0.0.0.0 这可是4年轻的内核了。所以是不兼容了。 React官方给出了说明 但是使用babel-polyfill仍然无法解决 所以，这里使用 core-js,使用如下 12345678910import 'core-js/es/map';import 'core-js/es/set';import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root')); 这样就可以解决华为手机无法显示（或者说是显示空白的问题）。 问题二：使用fixed定位的时候没有显示出来项目中有一个支付需求需要在页面弹出支付通道选择（信用卡，paypal等），但是设置显示的时候出现了没有弹出选择界面的情况，但是实际上又确实有这个页面（只显示它的时候）。修的定位层级的时候也是无法显示。最后发现，在华为等低端浏览器内核的手机上面同时需要设置定位的位置才可以（left:0, top:0），高版本的内核的浏览器没有这个问题，我猜想是自己默认就是（left:0, top:0）了。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"react","slug":"react","permalink":"https://blog.lyt007.cn/tags/react/"}]},{"title":"react项目预渲染开发","slug":"react项目预渲染开发","date":"2019-09-27T06:15:03.000Z","updated":"2020-04-13T03:13:34.967Z","comments":true,"path":"技术/react项目预渲染开发.html","link":"","permalink":"https://blog.lyt007.cn/技术/react项目预渲染开发.html","excerpt":"","text":"react越来越火了，是开react开发的人员而是越来越多。但是因为单页应用SEO的问题，我们也不得不去解决这个问题。不管是哪里，都提供了两种方案，一种是SSR服务端渲染，另一种则是预渲染方式。本篇文章主要是阐述预渲染的方案。 什么是预渲染在一般的react项目中（比如使用create-react-app创建的项目），我们在最后打包的时候只会生成一个HTML，JS与CSS文件，或许你会采用一些方法，比如公共文件拆分，路由懒加载等等生成多个文件，但是也无法从根本上解决这个问题，所有的资源还是通过JS动态的生成渲染的。 所以，所谓的预渲染就是在单页应用中，将用户交互不多，同时需要SEO的页面单独提取出来的一种方法，提取出来的就是一个HTML文件。 怎么使用预渲染开发react项目的时候，一般都是结合者webpack使用的。目前用的最多的预渲染的方法，就是使用webpack插件prerender-spa-plugin。这是一个webpack插件，所以使用直接在webpack的插件配置项中添加 1234567new PrerenderSPAPlugin(&#123; routes: [\"/\", \"/download\", \"/prize\", \"/news\", \"/news/detail?id=1\", \"/support\"], staticDir: path.join(__dirname, 'build'), renderer: new Renderer(&#123; renderAfterTime: 50000 &#125;)&#125;) 其中routes是需要预渲染的route，一般都是react-router-dom配置的路由。 staticDir是输出的目录。因为这里使用了create-react-app，默认的输出目录是build，所以，这里也是build，如果你是自己搭建或者使用的是其他的方式，或许目录名字会有所不同。 更多具体的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 摘取自githubnew PrerenderSPAPlugin(&#123; // Required - The path to the webpack-outputted app to prerender. staticDir: path.join(__dirname, 'dist'), // Optional - The path your rendered app should be output to. // (Defaults to staticDir.) outputDir: path.join(__dirname, 'prerendered'), // Optional - The location of index.html indexPath: path.join(__dirname, 'dist', 'index.html'), // Required - Routes to render. routes: [ '/', '/about', '/some/deep/nested/route' ], // Optional - Allows you to customize the HTML and output path before // writing the rendered contents to a file. // renderedRoute can be modified and it or an equivelant should be returned. // renderedRoute format: // &#123; // route: String, // Where the output file will end up (relative to outputDir) // originalRoute: String, // The route that was passed into the renderer, before redirects. // html: String, // The rendered HTML for this route. // outputPath: String // The path the rendered HTML will be written to. // &#125; postProcess (renderedRoute) &#123; // Ignore any redirects. renderedRoute.route = renderedRoute.originalRoute // Basic whitespace removal. (Don't use this in production.) renderedRoute.html = renderedRoute.html.split(/&gt;[\\s]+&lt;/gmi).join('&gt;&lt;') // Remove /index.html from the output path if the dir name ends with a .html file extension. // For example: /dist/dir/special.html/index.html -&gt; /dist/dir/special.html if (renderedRoute.route.endsWith('.html')) &#123; renderedRoute.outputPath = path.join(__dirname, 'dist', renderedRoute.route) &#125; return renderedRoute &#125;, // Optional - Uses html-minifier (https://github.com/kangax/html-minifier) // To minify the resulting HTML. // Option reference: https://github.com/kangax/html-minifier#options-quick-reference minify: &#123; collapseBooleanAttributes: true, collapseWhitespace: true, decodeEntities: true, keepClosingSlash: true, sortAttributes: true &#125;, // Server configuration options. server: &#123; // Normally a free port is autodetected, but feel free to set this if needed. port: 8001 &#125;, // The actual renderer to use. (Feel free to write your own) // Available renderers: https://github.com/Tribex/prerenderer/tree/master/renderers renderer: new Renderer(&#123; // Optional - The name of the property to add to the window object with the contents of `inject`. injectProperty: '__PRERENDER_INJECTED', // Optional - Any values you'd like your app to have access to via `window.injectProperty`. inject: &#123; foo: 'bar' &#125;, // Optional - defaults to 0, no limit. // Routes are rendered asynchronously. // Use this to limit the number of routes rendered in parallel. maxConcurrentRoutes: 4, // Optional - Wait to render until the specified event is dispatched on the document. // eg, with `document.dispatchEvent(new Event('custom-render-trigger'))` renderAfterDocumentEvent: 'custom-render-trigger', // Optional - Wait to render until the specified element is detected using `document.querySelector` renderAfterElementExists: 'my-app-element', // Optional - Wait to render until a certain amount of time has passed. // NOT RECOMMENDED renderAfterTime: 5000, // Wait 5 seconds. // Other puppeteer options. // (See here: https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions) headless: false // Display the browser window when rendering. Useful for debugging. &#125;)&#125;) renderAfterTime 这个属性最好配置，可以在等待一定时间后在来导出另一个路由文件，如果不添加，可能会出Unable to perrender all routes的错误。 上线到服务器打包后可以先在本地的服务器上面测试，这里推荐一个npm包： serve 安装后通过 serve 文件夹名字启动一个本地服务。 需要注意的是： 当项目正常运行，同时包含多个路由的时候，当我们在除了首页以外的其他的目录刷新页面的时候都是404，这是因为服务器的配置问题。本地这里无法实现。 开发的时候必须使用 History 路由而不能使用 Hash 路由。 1, 2 文件的解决方法就是修改nginx的配置如下 1234567location /&#123; index index.html index.htm; if (!-e $request_filename) &#123; rewrite ^/(.*) /index.html last; break; &#125;&#125; 对于动态路由，如/news/detail/:id是不支持的，推荐使用query路由，如/new/detail?id=","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"react","slug":"react","permalink":"https://blog.lyt007.cn/tags/react/"},{"name":"SEO","slug":"SEO","permalink":"https://blog.lyt007.cn/tags/SEO/"}]},{"title":"前端基础算法","slug":"前端基础算法","date":"2019-09-10T08:05:02.000Z","updated":"2020-04-23T09:05:46.932Z","comments":true,"path":"技术/前端基础算法.html","link":"","permalink":"https://blog.lyt007.cn/技术/前端基础算法.html","excerpt":"","text":"对于前端初学者而言，这样的一个功能你做出来了那就很好，慢慢的，我们的工作年限越来越长，如果我们还继续那样做，这样，迟早会淘汰。这个时候，就需要对你的项目进行优化。之前讲到过对于react项目的优化。这更多是针对于单页应用的优化，避免首页时间加载过长，打包文件加载过大，是针对于打包后文件来说的。这篇文章主要是针对于算法相关的代码进行优化，从而是程序的运行速度更快，已达到程序的优化。 算法更多的是针对于数据的增删改查，或许你认为前端涉及不到，如果这样想，那你就错了。前端可能用的不多，但不会涉及不到，同时，了解算法，那么对于以后的职业道路也会有所帮助。 二分查找法二分查找在进行查找有序数组中某一项数据的时候非常有用，可以加快程序的运行速度，尤其是在具有大量数据的时候。 二分查找的原理是从数组的中间开始查找，如果被查找对象刚好就是中间这一项，那直接退出查找。如果被查找对象大于中间，那么所需要的对象是在中间-最后这一区间，所以有针对于这一区间再次进行二分。如此下去，找到所需要的即可。 123456789101112131415161718192021222324252627282930/** * 二分查找 * @param &#123;Array&#125; list 待查找的有序数组 * @param &#123;Number&#125; item 待查找的数据 */function binarySearch(list, item)&#123; // 如果list不是数组返回list if (!Array.isArray(list)) return list // 定义查找的起始位置 let low = 0; let high = list.length - 1; while (low &lt;= high) &#123; // 定义中间的位置 let mid = Math.floor((low + high) / 2) let midValue = list[mid] if ( midValue == item ) return mid if (midValue &lt; item)&#123; low = mid + 1 &#125; if (midValue &gt; item)&#123; high = mid - 1 &#125; &#125; return -1&#125; 最后来看看一个具体的效果 12345678910111213141516171819202122const arr = []for (let i = 0; i &lt; 10000; i++) &#123; arr.push(i)&#125;const need = 6734let res;console.time(\"for\")for (let i = 0; i &lt; arr.length; i++) &#123; const ele = arr[i]; if( ele === need ) &#123; res = i break &#125;&#125;console.log(res);console.timeEnd(\"for\")console.time(\"binarySearch\")res = binarySearch(arr, need)console.log(res)console.timeEnd(\"binarySearch\") 可以看到很明显二分查找比普通的循环遍历快了许多。 可视化链接 https://algorithm-visualizer.org/branch-and-bound/binary-search 时间复杂度 O(\\log n) 选择排序上面讲到的二分查找虽然性能很好，当时有一个必要的条件就是这个list需要是一个有序数组，否则使用二分查找则是不成立的。所以，对于一个无序的数组，我们首先就是需要把它重新排序。选择排序就是其中一种。 选择排序的原理是从数组中选出一个最大（小）的数，放在另一个数组的开始，然后从剩余数组中继续选择最大（小）的数进行操作，如此重复，直到数组重组。 1234567891011121314151617181920212223242526272829// 选择排序function selectSort(list)&#123; if (!Array.isArray(list)) return list // 定义一个数组存放排序后的数组 const arr = []; for (let i = list.length - 1; i &gt;= 0; i--) &#123; const smallestIndex = findSmallest(list) arr.push(list.splice(smallestIndex, 1)[0]) &#125; return arr&#125;// 寻找最小的数function findSmallest(list)&#123; let smallest = list[0] let smallestIndex = 0 for (let i = 0; i &lt; list.length; i++) &#123; const ele = list[i]; if (ele &lt; smallest) &#123; smallest = ele smallestIndex = i &#125; &#125; return smallestIndex&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.lyt007.cn/tags/算法/"}]},{"title":"各种IT网站收藏","slug":"各种IT网站收藏","date":"2019-09-03T02:26:30.000Z","updated":"2020-04-13T03:13:34.970Z","comments":true,"path":"技术/各种IT网站收藏.html","link":"","permalink":"https://blog.lyt007.cn/技术/各种IT网站收藏.html","excerpt":"","text":"git command git command 前端九部-前端入门手册 前端九部-前端入门手册 Vuejs开源项目 vuejs开源项目汇总 react开源项目汇总 一套优秀的中后台前端解决方案 网易云音乐第三方 一个 react + redux 的完整项目 和 个人总结 react 后台管理系统解决方案 这是一个用来查看GitHub最受欢迎与最热项目的App,它基于React Native支持Android和iOS双平台 RN写的饿了么，还原度相当高，实现了各类动效 仿知乎日报 react + Ant Design + 支持 markdown 的博客前台展示 使用 react hooks + koa2 + sequelize + mysql 搭建的前后台的博客 基于typescript koa2 react的个人博客 前端面试题 前端每日3+1 壹题汇总-木易杨 Nodejs 基于 node.js + Mongodb 构建的后台系统 Nodeclub 是使用 Node.js 和 MongoDB 开发的社区系统 基于Node.js+MySQL开发的开源微信小程序商城（微信小程序） NideShop 开源微信小程序商城服务端 API（Node.js + ThinkJS） React+Express+Mongo -&gt;前后端博客网站 基于 node + express + mongodb 的博客网站后台 免费视频 技术胖免费视频 react native React Native 第三方组件之–UI类","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"网站收藏","slug":"网站收藏","permalink":"https://blog.lyt007.cn/tags/网站收藏/"}]},{"title":"通过自己实现函数 call,apply,bind 来了解他们的原理","slug":"通过自己实现函数-call-apply-bind-来了解他们的原理","date":"2019-08-21T03:00:53.000Z","updated":"2020-04-23T09:05:47.000Z","comments":true,"path":"技术/通过自己实现函数-call-apply-bind-来了解他们的原理.html","link":"","permalink":"https://blog.lyt007.cn/技术/通过自己实现函数-call-apply-bind-来了解他们的原理.html","excerpt":"","text":"我们知道函数中的call，apply，bind都是可以修改函数的this指向。关于函数的this指向问题可以转到Javascript this 指向问题这篇文章。 在Javascript this 指向问题一篇中我们知道函数运行时候this是取决于调用这个函数的对象。如果一个函数定义在了全局，那么这个this就指向window。 来看一段代码12345678910111213var name = \"tal\"var sex = \"boy\"var tal = &#123; name: \"踏浪\", sex: \"男\"&#125;function person() &#123; console.log(this.name) console.log(this.sex)&#125;person() // tal boy 上面的person是定义在全局中的一个函数，person()调用的时候相当于是window.person()，是由window调用的，所以，this.name和this.sex都需要在window对象中寻找，即全局变量中找。所以，最后的值会是tal与boy。 再来。我们来调用一下原生的call函数 12345678910111213var name = \"tal\"var sex = \"boy\"var tal = &#123; name: \"踏浪\", sex: \"男\"&#125;function person() &#123; console.log(this.name) console.log(this.sex)&#125;person.call(tal) // 踏浪 男 在调用了call函数以后，最后的值是踏浪 男。得到的是对象tal中的两个属性值。此时函数中的this指向了对象tal。结合上面的例子，直接调用person函数的时候，相当于是window.person()的执行，所以那时this指向了window。那现在既然指向了tal，换言之，就是相当于tal.person()执行了。 call 的实现所以我们可以这样实现mycall函数 12345Function.prototype.mycall = function (context) &#123; context.fn = this context.fn() delete context.fn&#125; mycall接收一个参数，即一个对象，最终的this指向这个对象。函数内部实现在这个传入的对象中绑定上我们需要执行的这个函数，即context.fn = this一行。最后调用context.fn()。因为我们这样操作修改了传入对象的属性（添加了一个fn属性），所以最后需要删除这个fn属性。这样，第一版的call的实现已经完成。 接下来，原生 call 函数是可以接收参数的 1234567891011var tal = &#123; name: \"踏浪\", sex: \"男\"&#125;function person(age) &#123; console.log(age) console.log(this.name) console.log(this.sex)&#125;person.call(tal, 18) // 踏浪 男 那我们自己实现的mycall要想能够接收参数，怎么实现呢 12345678910Function.prototype.mycall = function (context) &#123; var args = []; var len = arguments.length; for (var i = 1; i &lt; len; i++) &#123; args.push(arguments[i]); &#125; context.fn = this eval('context.fn(' + args.join(\",\") + ')') delete context.fn&#125; 因为我们需要在 mycall 调用的时候传递参数，而且参数的个数不确定，所以需要使用 arguments 。同时因为第一个参数以及确定了是我们需要的一个对象，this指向这个对象。所以 arguments 需要从 1 开始。我们用一个数组把需要的东西存放起来。 12345var args = [];var len = arguments.length;for (var i = 1; i &lt; len; i++) &#123; args.push(arguments[i]);&#125; 如果是这样的话，我传递过去后数组 args = [18, &quot;成都&quot;] 里面的每一项要怎么传递到 context.fn() 里面并且执行呢？或许你会想到时候 join(&quot;,&quot;) 方法，OK，没有问题。 12var res = args.join(\",\");context.fn(res); 这样么？不是。res的值是 18,成都 没问题，但是这就是一个字符串而已，我们要实现传递两个参数，所以，想到了把字符串与函数拼接。即有了 &#39;context.fn(&#39; + args.join() + &#39;)&#39;。这样最后就可以了。但是这只是一个字符串，怎么运行呢？这个时候就需要用到 ES3中的eval 直接传递这个参数进度即可。 上面的 join 方法其实就是把一个数组转换成了字符串，除了 join，你还能想到什么呢？对。可以使用字符转换来实现。 123res = \"\" + args + \"\"// orres = args.toString() 因为每一个隔开的方式是 , 所以可以使用上面的两种，其他的就不行咯。 所以最终的 mycall 12345678910Function.prototype.mycall = function (context) &#123; var args = []; var len = arguments.length; for (var i = 1; i &lt; len; i++) &#123; args.push(arguments[i]); &#125; context.fn = this eval('context.fn(' + args.join(\",\") + ')') delete context.fn&#125; apply的实现有个实现call的过程，在来实现apply就容易多了。唯一不同的就是apply传递的参数是一个数组，而call是具体的每一项。只需要在参数上面做处理即可。 12345678910111213Function.prototype.myapply = function (context) &#123; var args = []; var array = arguments[1]; if ( typeof array !== \"object\" || !(array instanceof Array) ) &#123; throw new Error(\"The 2'rd args must be Array.\") &#125; for (var i = 0; len = array.length, i &lt; len; i++) &#123; args.push('array[' + i + ']'); &#125; context.fn = this eval('context.fn(' + args.toString() + ')') delete context.fn&#125; 这里的 arguments[1] 是一个数组了。我们需要对它遍历，并且判断它是不是一个数组。其余的与 call 一样。 bind的实现原生的bind有两种方式 123456789101112131415var tal = &#123; name: \"踏浪\", sex: \"男\"&#125;function person(age) &#123; console.log(age) console.log(this.name) console.log(this.sex)&#125;person.bind(tal)(18)// 或者person.bind(tal, 18)() 所以。使用bind都需要调用两次，而第一次就是返回一个函数。原函数的参数可以在bind中调用，也可以在第二次运行时候调用。所以，根据调用bind时候传递的参数的个数确定最后是返回那种函数，有了下面的这段代码。 123456789101112131415161718192021222324252627282930Function.prototype.mybind = function (context) &#123; var args = []; var len = arguments.length; for (var i = 1; i &lt; len; i++) &#123; args.push(arguments[i]); &#125; context.fn = this if (len === 1) &#123; // 如果 mybind 的参数的个数只有一个，那么剩余参数在调用的时候传入 return function()&#123; var sub_args = []; for (var i = 0; len = arguments.length, i &lt; len; i++) &#123; sub_args.push('arguments[' + i + ']'); &#125; eval('context.fn(' + sub_args.toString() + ')') delete context.fn &#125; &#125; else &#123; return function()&#123; // 这里不能使用 arguments，这里面的 arguments 是这个 return 函数的而不是最开始的。 var str = 'context.fn(' for (var i = 0; len = args.length, i &lt; len; i++) &#123; str += \"args[\"+i+\"],\" &#125; var newStr = str.replace(/,$/, \")\") eval(newStr) delete context.fn &#125; &#125;&#125; 总结通过自己实现 call， apply， bind 这三种方法，能够更深刻的理解到这三个函数的原理，同时涉及到的只是点也多：this指向，arguments类数组，每一个对象都要的toSting方法（另一个是valueOf），eval方法的使用（不是滥用，webpack中就使用了这个方法），函数对象可以使用 delete 删除（使用var 定义的无法使用delete删除）。或许你已经明白了，但是代码种东西，还是自己动动手，印象更深刻。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.lyt007.cn/tags/JavaScript/"},{"name":"手写源码分析原理","slug":"手写源码分析原理","permalink":"https://blog.lyt007.cn/tags/手写源码分析原理/"}]},{"title":"深入解析CSS样式优先级","slug":"深入解析CSS样式优先级","date":"2019-08-17T01:38:27.000Z","updated":"2020-04-13T03:13:34.971Z","comments":true,"path":"技术/深入解析CSS样式优先级.html","link":"","permalink":"https://blog.lyt007.cn/技术/深入解析CSS样式优先级.html","excerpt":"","text":"作为前端多多少少都会对CSS样式的权重有一定的了解。最常用的方法就是对不同的选择器分配不同的权重比，常见的就是 选择器 权重值 !important标识 10000 行内样式 1000 id选择器 100 类选择器 10 标签选择器 1 通配符 * 0 具体的判断我们可以用一个矩阵来表示：(0, 0, 0, 0, 0)。那这里面的每一个矩阵的0表示的是 第一个：!important 的个数 第二个：行内的个数 第三个：id选择器的个数 第四个：类选择器的个数 第五个：标签选择器的个数 行内除了!important高于其他的样式。同时，这里的这个矩阵实际上是不存在的，是认为的构建出来的。因为!important始终最高，所以这里可以忽略第一个，最后矩阵为(0, 0, 0, 0)。 上面表格中是我们在写css样式的时候需要了解最的基本的知识，也是最为普通的选择器权重分配。权重值越高，权重越高，那么样式的优先级就越高。所以，!important的权重是最高的。正式因为这一点，所以!important在编写css样式的时候一般都不建议使用，因为使用了!important后，要想在修改样式，几乎是不可能的，即，样式会变得不好控制。 其次是行内样式。在现在前端开发中，为了更好的阅读代码，是代码调理更清晰，一般都会把CSS代码以及JS代码从HTML中分离，采用外链的方式引入CSS以及JS。所以，行内样式在一般的开发中，用的也不多。但是，在使用前端三大框架或者是需要使用JS来控制样式的时候，多多少少的都会涉及到把样式写在HTML元素行内的情况。 接着是ID选择器。在编写样式的时候，我们一般都不会使用ID选择器来控制样式，同时也不会在HTML文档中添加过多的ID选择器。ID选择器一般更多的是用于获取元素，而不是用来控制CSS样式。 再者是类选择器。这个在CSS样式的编写中用的算是最多的一种，因为一个标签可以添加多个类名，不像ID只能添加一个，编写不同的类名来控制不同的样式显示，同时根据权重来控制样式的覆盖。 然后是标签选择器，这个在开发中也是不建议使用，更多的是建议添加一个类名来控制，以实现复用，同时方便控制。 最后是通配符选择器，这个选择器的使用一般就是初始化文档结构。例如1234* &#123; margin: 0; padding: 0;&#125; 但是更多的公司采取的是具有针对的样式重置，比如reset.css。 以上就是常用的样式选择器以及他们的权重。 主要选择器的权重比较权重累加 上面的权重值我们已经知道了，那么具体怎么来算呢？个人认为，需要记住一这点就OK了。相同类型的权重值累加，然后在比较相同类型选择器的值。举个🌰 1&lt;div id=\"box\" class=\"box div\"&gt;&lt;/div&gt; 12345678910div &#123; width: 100px; height: 100px;&#125;#div &#123; background: green;&#125;div.div &#123; background: red;&#125; 上面的代码中，来看看这个div盒子的颜色应该是什么呢？分析一下CSS样式： 根据上面的矩阵(0, 0, 0, 0)来分析。 #div的矩阵为(0, 0, 1, 0, 0)，最后的权重值为：1*100 = 100。 div.div的矩阵为(0, 0, 0, 1, 1)，最后的权重值为：1 10 + 1 1 = 11。 所以最后的样式显示 background: green; 有了这样的结论，我这里又做了一个测试。有下面的一段html代码与样式 123456789101112131415161718192021&lt;div class=\"box\"&gt; &lt;div class=\"box1\"&gt; &lt;div class=\"box2\"&gt; &lt;div class=\"box3\"&gt; &lt;div class=\"box4\"&gt; &lt;div class=\"box5\"&gt; &lt;div class=\"box6\"&gt; &lt;div class=\"box7\"&gt; &lt;div class=\"box8\"&gt; &lt;div class=\"box9\"&gt; &lt;div id=\"box10\" class=\"box10\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910div &#123; width: 100px; height: 100px;&#125;#box10 &#123; background: green;&#125;.box .box1 .box2 .box3 .box4 .box5 .box6 .box7 .box8 .box9 .box10 &#123; background: red;&#125; 按理说 #box10 的权重为 100 * 1 = 100 .box .box1 .box2 .box3 .box4 .box5 .box6 .box7 .box8 .box9 .box10 的权重为 10 * 11 = 110 下面使用多个类的权重值理论上是高于上面只使用一个id选择器的情况，但是最后的结构却不是我们想象的那样。结果还是 green 。没错，后面的11个类的样式无效。经过这样的测试，我们可以猜想，在一个元素使用了ID选择器修饰了样式以后，如果在使用类选择器，这时候是是没有办法使相同的样式属性生效，生效的依然是那个ID选择器修饰的样式。为什么权重值大也没有用呢？我猜或许是因为写了太多类名的时候再和ID相比的话，浏览器会自己去判断，选择最优的那个，毕竟10多个类名在实际的开发中是不存在的。在张鑫旭大神的有趣：256个class选择器可以干掉1个id选择器有一个实验，但是这个实验室在2012年的时候，那个时候，还是使用的IE浏览器能够呈现出来。但是现在大部分的浏览器都不能够呈现出256个class干掉一个id的情况了。同时，也证明了，上面我们定义的矩阵(0, 0, 0, 0)其实并不严谨，id与class之前的差距我们这里以10作为一个标准，但是实际上可能达到100，或者1000。即1000个class干掉一个ID。但是由于现代编码一般要求class的层级书写的时候不要超过四层，所以，目前这个问题也就没有什么意义了。 因此，上面的矩阵也可以作为我们判断的标准。 其他类型选择器的权重比较上面说了几种常用的选择器了，但是还有一些选择器也是在开发中会出现，但是不是太常用的一些选择器。那么，有哪些呢？ w3c中样式选择器的权重优先级的排序如下 important &gt; 内嵌样式 &gt; ID &gt; 类 | 伪类 | 属性选择 &gt; 标签 | 伪元素 &gt; 伪对象 &gt; 继承 &gt; 通配符 | 子选择器 | 相邻选择器 伪类选择器，如:hover 属性选择器，如[type=&quot;text&quot;] 伪元素选择器，如::first-letter 子选择器&gt;，相邻兄弟选择器+等等 伪类的优先级(:)首先来看看伪类选择器的优先级。123456789101112131415161718192021222324252627&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; margin-top: 10px; height: 100px; width: 100px; &#125; .box1 &#123; background: lime; &#125; :hover &#123; background: pink; &#125; .box2 &#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\" class=\"box1\"&gt;&lt;/div&gt; &lt;div id=\"box\" class=\"box2\"&gt;&lt;/div&gt;&lt;/body&gt; 上面的代码在codePen中的具体效果，可以看到 当将鼠标分别移动到两个div盒子上面的时候，前面的绿色盒子的背景色会发生变化，而红色盒子不会。但是，都是 :hover 的一盒伪类。所以判定，伪类的权重与类的权重是相同的。 属性选择器的优先级同样是上面的代码，我们把样式改为1234567891011121314151617181920div &#123; margin-top: 10px; height: 100px; width: 100px;&#125;.box1 &#123; background: purple;&#125;[class=\"box1\"] &#123; background: lime;&#125;:hover &#123; background: pink;&#125;[class=\"box2\"] &#123; background: red;&#125;.box2 &#123; background: purple;&#125; 唯一不同的就是样式中添加了属性选择器[class=&quot;box1&quot;]与[class=&quot;box2&quot;]。同时顺序发生了改变。 代码可看[https://codepen.io/Anthony-Wilson/pen/YzKWZpL]https://codepen.io/Anthony-Wilson/pen/YzKWZpL 。 所以，属性选择的权重 = 类的权重 = 伪类的权重。三者是相等的，都是(0, 0, 1, 0); 伪元素选择器(::)伪元素作为一种特殊的存在，我认为它不应该放在优先级里面同其他的选择器相比。比如 ::before 和 ::after 这两种伪元素都是在文档中添加一个假的元素，并不能够设置 id class 等属性。所以这里可以把它作为一个唯一的存在。那么他的权重我们可以看为1。同时没有和他比较的。 子选择器&gt;，相邻兄弟选择器+123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1 span &#123; color: yellow; &#125; .box &gt; span &#123; color: blue; &#125; .box2 span &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box box1\"&gt;&lt;span&gt;我&lt;/span&gt;是一个盒子&lt;/div&gt; &lt;div class=\"box box2\"&gt;&lt;span&gt;我&lt;/span&gt;是一个盒子&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面的例子在codePen中的运行结果 可以看到，第一个我是蓝色，第二个我是红色。结合上面的代码，可以看出来子元素选择器和普通的空格其实没有太多的区别，同理兄弟选择器其实也是一样的。遇到这种情况，直接比较 class 与 标签的个数就可以了。即同基本的权重判断是相同的。 结果总结经过上面的推想测试，可以大致的得出一个优先级的结论： !important &gt; ID &gt; class = 属性 = 伪类 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器自带属性 在使用选择器的时候尽可能的选择使用 class选择器或者属性选择器（针对于input这一类）来对元素设置样式。一个是使用class可以复用，第二个可以更好的控制元素样式。同时，关于class命名的规范建议使用BEM命名规范。 补充：2019年08月22日在网上看到这样的一道题 问题：已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。 &lt;img src=”1.jpg” style=”width:480px!important;”&gt; 期初看到这段代码一下子就想到这都 !important 了还有办法限制它的宽度？真的是被无知限制了想象力。 这里提供几种方法实现修改宽度： 1、使用max-width虽然使用了 important ，但是也只是添加到了 width 属性上面，并不影响 max-width 。所以这里设置了 max-width 即可生效。 123img &#123; max-width: 300px;&#125; 2、使用 transform:scale123img &#123; transform: scaleX(0.625);&#125; 3、使用 zoom这个和CSS3的缩放是一样的效果 123img &#123; zoom: 0.625：&#125; 4、使用 js这个和CSS3的缩放是一样的效果 1document.getElementsByTagName(\"img\")[0].setAttribute(\"style\",\"width:300px!important;\") 5、使用弹性盒模型这个和CSS3的缩放是一样的效果 1234img &#123; box-sizing: border-box; padding: 0 90px;&#125; 6、使用animation1234567891011img &#123; animation: width 0s forwards;&#125;@keyframes width &#123; from &#123; width: 300px; &#125; to &#123; width: 300px; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.lyt007.cn/tags/CSS/"}]},{"title":"使用socket实现即时通讯聊天室","slug":"使用socket实现即时通讯聊天室","date":"2019-08-06T01:45:59.000Z","updated":"2020-04-13T03:13:34.969Z","comments":true,"path":"技术/使用socket实现即时通讯聊天室.html","link":"","permalink":"https://blog.lyt007.cn/技术/使用socket实现即时通讯聊天室.html","excerpt":"","text":"websocket早在几年前就已经很流行了，主要就是用于即时通讯这一方面应用，可以是聊天，也可使是直播流传输等等。 今天，就来说说如何使用 create-react-app + socket.io 实现简单的即时聊天。 Demo地址 准备工作想要实现即时通讯，还是需要有服务器的支持，这里我使用的是一个简单配置的服务器 还是去年腾讯搞活动买的，还不错，有机会你们也可以去看看。阿里云腾讯云都会时不时的出一些活动，买一个服务器自己玩玩还是可以的。如果有活动，我可以在后面不断更新。 有了服务器以后就是敲代码了。 服务端实现服务端我这里使用的是Nodejs作为后端语言，使用express+socket.io作为技术支持，具体的代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const express = require(\"express\")const app = express()const http = require(\"http\").createServer(app)var io = require('socket.io')(http);app.use(express.static(__dirname + '/dist'))app.get(\"/\", (req, res) =&gt; &#123; res.header(\"Access-Control-Allow-Credentials\", \"true\"); res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With'); res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS'); // res.send(`&lt;h1&gt;Hello World!!!&lt;/h1&gt;`) res.send(__dirname + '/dist/index.html')&#125;)const userList = &#123;&#125;;let userCount = 0;const messageList = []io.on(\"connection\", socket =&gt; &#123; socket.on(\"login\", data =&gt; &#123; console.log(`$&#123;data.username&#125; 登录`); socket.uid = data.uid userList[data.uid] = data.username userCount++ io.emit('users', &#123; userCount, userList &#125;) // 发给自己 socket.emit(\"receive_message\", messageList) &#125;) socket.on(\"disconnect\", function() &#123; if( !socket.uid ) return const user = &#123; uid: socket.uid, username: userList[socket.uid] &#125; delete userList[socket.uid] userCount-- // 发送给所有用户 使用 io.emit // 发送给自己 使用 socket.emit io.emit('users', &#123; userCount, userList &#125;) console.log(`$&#123;user.username&#125; 登出了`); &#125;) socket.on(\"message\", data =&gt; &#123; if ( !data ) return // console.log(`发送信息 -- $&#123;data&#125;`); messageList.push(&#123; username: userList[socket.uid], message: data &#125;) if( messageList.length &gt; 30 )&#123; messageList.shift() &#125; // 发送给除了自己以外的其他所有用户 // socket.broadcast.emit(\"receive_message\", messageList) io.emit(\"receive_message\", messageList) &#125;)&#125;)http.listen(2000, _ =&gt; &#123; console.log('This server is running: http://localhost:2000');&#125;) 静态的文件是使用 create-react-app 开发的页面，build之后放到了服务器上面dist目录下面。 要使用socket.io，首先需要创建socket服务1var io = require('socket.io')(http); 接下来就是连接服务端与客户端了。服务端如果想要连接到客户端的用户，那么就需要有方法一直监听到客户端用户访问网站的方法。socket.io中就为我们提供了一个 connection 方法。 123io.on(\"connection\", socket =&gt; &#123; // do something&#125;) connection 之后所有的操作都是写在这个 connection 的监听之中。 上面的 connection 中的代码需要注意的有几点，知道了这几点，那么socket.io对你就不是难事 io.on(&#39;监听事件名字&#39;, () =&gt; {})方法是监听所有的用户。 connection方法中的 socket 值得是当前用户，所以socket.on(&#39;监听事件名字&#39;, () =&gt; {})是监听当前用户的操作。 io.emit(&#39;监听事件名字&#39;, 参数)是发送消息给客户端，此时客户端会有一个监听的事件，监听事件名字服务端需要与客户端相同。 socket.broadcast.emit(&quot;监听事件名字&quot;, 参数) 这个方法可以发送消息给除了自已以外的其他的所有的用户。 客户端与服务端一样。 记住以上四点秘诀，玩转socket不是梦。 客户端实现客户端使用create-react-app写的页面实现，下面贴出逻辑，就不放样式了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import React, &#123; Component &#125; from 'react';import './App.css';import io from 'socket.io-client'import &#123; Input, Button, Avatar, message &#125; from 'antd'const socket = io('http://118.24.6.33:2000');class App extends Component &#123; constructor(props)&#123; super(props) this.state = &#123; showLogin: true, users: &#123; userCount: 0, userList: &#123;&#125; &#125;, messageList: [] &#125; &#125; login = () =&gt; &#123; const username = this.refs.input.input.value.trim() const &#123; userList &#125; = this.state.users if( username.length )&#123; for (const k in userList) &#123; if( userList[k] === username )&#123; message.info(\"聊天室已经有这个用户了，请重新起一个名字\") return &#125; &#125; this.uid = this.get_uid() socket.emit(\"login\", &#123; username, uid: this.uid &#125;) this.setState(&#123; showLogin: false &#125;) &#125; else &#123; message.info(\"请输入一个用户名！！\") &#125; &#125; get_uid = _ =&gt; &#123; return `$&#123;new Date().getTime()&#125;$&#123;Math.floor(Math.random() * 89999)&#125;` &#125; send = _ =&gt; &#123; this.message = this.refs.message.input.value if (this.message.trim().length === 0) &#123; message.info(\"你还啥子都还没有输入就行发送了嘛\") return &#125; const id = `$&#123;new Date().getTime()&#125;$&#123;Math.floor(Math.random() * 9999)&#125;` const data = &#123; message: this.message.trim(), uid: this.uid, id &#125; socket.emit('message', data) // ant design 中清空输入的内容 this.refs.message.state.value = '' setTimeout(_ =&gt; this.refs.messages.scrollBy(0, 999999), 100) &#125; componentDidMount()&#123; socket.on(\"users\", data =&gt; &#123; this.setState(&#123;users: data&#125;) &#125;) socket.on(\"receive_message\", data =&gt; &#123; this.setState(&#123;messageList: data&#125;) &#125;) &#125; render()&#123; const &#123; showLogin, users, messageList &#125; = this.state const &#123; userCount, userList &#125; = users if (showLogin) &#123; return ( &lt;div className=\"App\"&gt; &lt;Input placeholder=\"输入一个名字撒\" allowClear ref='input' onPressEnter=&#123;this.login&#125;/&gt; &lt;Button onClick=&#123;this.login&#125; className=\"login\"&gt;登录&lt;/Button&gt; &lt;/div&gt; ); &#125; else &#123; return ( &lt;div className=\"room\"&gt; &lt;div className='inner'&gt; &lt;header&gt;欢迎来到踏浪聊天室，当前聊天室共&#123;userCount&#125;人&lt;/header&gt; &lt;div className=\"content\"&gt; &lt;ul className=\"user-list\"&gt; &#123; Object.entries(userList).map(v =&gt; &#123; return &lt;li className=\"user-list-item\" key=&#123;v[0]&#125; &gt; &lt;Avatar style=&#123;&#123; color: '#f56a00', backgroundColor: '#fde3cf' &#125;&#125;&gt; &#123;v[1].substring(0, 2)&#125; &lt;/Avatar&gt; &#123;v[1]&#125; &lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;ul className=\"message-list\" ref=\"messages\"&gt; &#123; messageList.map(v =&gt; &lt;li key=&#123;v.message.id&#125; className=&#123;v.message.uid === this.uid ? \"message-list-item me\" : \"message-list-item\"&#125; &gt; &#123;v.message.uid === this.uid &amp;&amp; &lt;span className=\"message-content\"&gt;&#123;v.message.message&#125;&lt;/span&gt;&#125; &lt;Avatar style=&#123;&#123; color: '#f56a00', backgroundColor: '#fde3cf' &#125;&#125;&gt; &#123;v.username &amp;&amp; v.username.substring(0, 2)&#125; &lt;/Avatar&gt; &#123;v.message.uid !== this.uid &amp;&amp; &lt;span className=\"message-content\"&gt;&#123;v.message.message&#125;&lt;/span&gt;&#125; &lt;/li&gt;) &#125; &lt;/ul&gt; &lt;/div&gt; &lt;footer&gt; &lt;Input placeholder=\"请输入消息\" ref='message' onPressEnter=&#123;this.send&#125; /&gt; &lt;Button className=\"send\" onClick=&#123;this.send&#125;&gt;发送&lt;/Button&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; ) &#125; &#125;&#125;export default App 客户端可是使用的socket.io。不过使用的是专门为客户端提供的socket.io-client。客户端首先需要连接到服务器，通过 const socket = io(&#39;http://118.24.6.33:2000&#39;); 就可以创建一个与服务端链接的 socket 请求。 接下来就是在 componentDidMount 中编写监听事件，同时 socket.on() 实现监听。 在事件中使用 socket.emit() 实现向后端发送消息。 整的逻辑的实现就是如此，摸清逻辑，后面的就不难了。 上面只是使用可socket.io的一些简单的API，关于更多的方法可以前往socket.io官网 最后，可以前往github查看源码","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://blog.lyt007.cn/tags/websocket/"},{"name":"即时通讯","slug":"即时通讯","permalink":"https://blog.lyt007.cn/tags/即时通讯/"}]},{"title":"递归与尾递归","slug":"递归与尾递归","date":"2019-08-01T01:32:34.000Z","updated":"2020-04-13T03:13:34.972Z","comments":true,"path":"技术/递归与尾递归.html","link":"","permalink":"https://blog.lyt007.cn/技术/递归与尾递归.html","excerpt":"","text":"在介绍递归与尾递归之前，我们来看看递归的定义：程序调用自身的编程技巧称为递归（ recursion） 百度对递归的定义：递归 接着，我们再来看看一道题 1编写一个函数fn，接收一个或者多个参数，其中一个参数为n，若 n=0 或者 n=1，函数返回 1， 否则函数返回 1+2+3+...+(n-1)+n 的总和 递归按照我们一般的思维，很快就能想到使用递归函数来解决这个问题，所以来看看递归是怎么解决的呢 123456function fn(n)&#123; if( n === 0 || n === 1 )&#123; return 1 &#125; return n + fn(n - 1)&#125; 如果 n=5 那么上面的函数运行流程 12345n = 5 ==&gt; 5 + fn(5 - 1)n = 4 ==&gt; 5 + 4 + fn(4 - 1)n = 3 ==&gt; 5 + 4 + 3 + fn(3 - 1)n = 2 ==&gt; 5 + 4 + 3 + 2 + fn(2 - 1)n = 1 ==&gt; 5 + 4 + 3 + 2 + 1 即：最后的结果是 5 + 4 + 3 + 2 + 1 = 15 可以看到，一般的递归，每一级递归都需要调用函数，同时这个函数还与其他的表达式运算，那这样的递归每一次都会创建新的栈。 随着递归深度的增加，创建的栈越来越多，最终造成爆栈 所以，递归虽然可以解决很多问题，但是也需要注意一下使用限制。 #尾递归如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。 百度定义：尾递归 尾递归基于函数的尾调用（尾调用：返回一个函数并且调用这个函数）, 每一级调用直接返回函数的返回值更新调用栈,而不用创建新的调用栈, 类似迭代的实现, 时间和空间上均优化了一般递归! 同样的问题，使用尾递归的来看看 123456function fn(n, total = 1)&#123; if(n === 1 || n === 0)&#123; return total &#125; return fn(n -1, total + n)&#125; 同样是 n=5，来看看运行过程 12345n = 5 ==&gt; fn(5, 1)n = 4 ==&gt; fn(4, 6)n = 3 ==&gt; fn(3, 10)n = 2 ==&gt; fn(2, 13)n = 1 ==&gt; fn(1, 15) 上面的运行每一次都是返回的一个单独的函数，没有其他的表达式与这个函数的结果运行，每一级递归的函数调用变成”线性”的形式。 上面就是关于一般递归与尾递归的说明。但是这里存在一个很大的问题，那就是JavaScript的 V8引擎 对尾递归的优化做的并不好，上面的代码尾递归还不如一般的递归。虽然在JavaScript中无法运行，但是其他的语言例如Java，C，C++等，使用尾递归的好处多余一般递归。 手动优化既然我们在JavaScript中无法使用尾递归，使用递归也害怕爆栈，那我们可以自己来一些方法实现相同的效果，例如上面的多个值相加 方案一：修改函数内部，使用循环1234567// n 是 正整数function fn(n, a=0, b=1)&#123; while (n--) &#123; [a, b] = [b, a + b] &#125; return a&#125; 这个方法采用了ES6中的解构赋值。如果你不了解结构复制，可以去看看，如果你了解结构复制，那么上面的你就很容易理解了。 其实这种优化方法就是支持尾递归运行的这些引擎对相应语言的优化，使用循环优化，只是JavaScript V8 中没有相应的优化。说白了，就是想Java等语言已经有人帮你做了这一步。 方案二：蹦床函数这是上面的尾递归的变形 1234567// 尾递归代码function fn(n, total = 1)&#123; if(n === 1 || n === 0)&#123; return total &#125; return fn(n -1, total + n)&#125; 这里我们来求一下 n=3 的时候的值，如果是使用尾递归，那么 n = 3 ==&gt; 6 首先来了解一下什么是蹦床函数，先来看一段代码 12345678function fn(n, total = 1)&#123; if(n === 1 || n === 0)&#123; return total &#125; return function()&#123; return fn(n -1, total + n) &#125;&#125; 同样是 n=3 1234// n = 3fn(3) ==&gt; Functionfn(3)() ==&gt; Functionfn(3)()() ==&gt; 6 从上面可以看到，如果 n 不是3而是一个很大的数字，那么我们就需要调用很多次函数调用来实现。为了简便，我们可以把这种调用形式写成函数，这样的函数就是蹦床函数。 12345678// 蹦床函数function trampoline(func, n)&#123; let result = func.call(func, n) while ( typeof result === 'function' )&#123; result = result() &#125; return result&#125; 这个蹦床函数有两个参数，第一个参数是一个函数，即我们需要实现逻辑的函数，本例中就是 12345678function fn(n, total = 1)&#123; if(n === 1 || n === 0)&#123; return total &#125; return function()&#123; return fn(n -1, total + n) &#125;&#125; 使用蹦床函数代码耗时相对较长。 以上就是关于递归与尾递归的说明以及优化，当然，如果你要更好的方案，欢迎在评论区留言。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.lyt007.cn/tags/JavaScript/"},{"name":"递归","slug":"递归","permalink":"https://blog.lyt007.cn/tags/递归/"},{"name":"尾递归","slug":"尾递归","permalink":"https://blog.lyt007.cn/tags/尾递归/"}]},{"title":"switch...case与if...else执行能力分析","slug":"switch-case与if-else执行能力分析","date":"2019-07-25T09:01:27.000Z","updated":"2020-04-13T03:13:34.968Z","comments":true,"path":"技术/switch-case与if-else执行能力分析.html","link":"","permalink":"https://blog.lyt007.cn/技术/switch-case与if-else执行能力分析.html","excerpt":"","text":"switch...case与if...else作为条件判断语句在程序中用的是非常多的。 对比基本用法1234567891011121314151617181920212223242526// switchswitch( 条件表达式 )&#123; case a: // do something break; case b: // do something break; case c: // do something break; default: // do something break;&#125;// if elseif ( 条件表达式1 ) &#123; // do something&#125; else if ( 条件表达式2 ) &#123; // do something&#125; else if ( 条件表达式 3) &#123; // do something&#125; else &#123; // do something&#125; 除了写法上的差异，两者在执行上面也是不同的。使用switch进行判断，执行的时间可能会更短，但是所消耗的空间会更多。 switch语句根据一个整数索引值进行多重分支，底层采用跳转表这种数据结构。跳转表是一个数组，表项 i 对应代码段的地址，当switch索引值等于表项i时采取对应的程序操作。 简单可理解为：执行switch时生成一个长度为最大case常量＋1的数组，程序首先判断switch变量是否大于最大case 常量，若大于，则跳到default分支处理；否则取得数组索引号为switch变量值大小，取得数组对应值即为相应case代码块地址，程序接着跳到此地址执行，完成分支的跳转。 所以，switch语句的执行速度相对于if语句执行速度会更快。但是因为switch会生成一个临时的数组，所以，占用的内存可能会更大。 对于if语句，则是系统自上而下的按照条件逐个去判断，知道匹配到合适的条件，否则会执行完整个if语句，所以执行的时间可能会很长，速断会更慢。因此，也得出，在编写代码的时候，需要将几率大的条件置于条件判断的最前面。 但是，switch在对于非常量的情况下面是无能为力的，比如 if(x &gt; 1 &amp;&amp; x &lt; 100) 这样的条件，使用switch是无法处理的，case语句不支持一个判断类型的表达式。但是，if语句就对这个就毫无压力。 所以，在只是处理常量的时候，推荐使用 switch 语句判断，如果涉及到了表达式，那么推荐使用 if…else 语句进行判断。 我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=2ijs33h17bi8k","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[]},{"title":"JavaScript中的单线程运行，宏任务与微任务，EventLoop","slug":"JavaScript中的单线程运行","date":"2019-07-10T02:32:36.000Z","updated":"2020-04-13T03:13:34.966Z","comments":true,"path":"技术/JavaScript中的单线程运行.html","link":"","permalink":"https://blog.lyt007.cn/技术/JavaScript中的单线程运行.html","excerpt":"","text":"在前端的面试中经常会问到关于代码执行顺序的问题，尤其是下面的一段代码123456789101112setTimeout( () =&gt; console.log(4))new Promise(resolve =&gt; &#123; resolve() console.log(1)&#125;).then( () =&gt; &#123; console.log(3)&#125;)Promise.resolve(5).then(() =&gt; console.log(5))console.log(2) 问题是：在浏览器上面 1 2 3 4 5 的打印的顺序。 上面这个问题看起来对有的同学可能很简单，到有的同学可能会比较复杂。对你不管是复杂还是简单，这其中涉及到的只是点都是一样的。JavaScript单线程，宏任务与微任务，EventLoop。这些就是这个题目的考点，理解了这些，那么上面的这道题对你来说那就是信手拈来，游刃有余。 我猜你应该知道，JavaScript除了在浏览器环境中运行，还可以在Node环境中运行，虽说都是JavaScript代码，但是在这两种环境下面执行的结果是可能不一样的。所以，我们需要分两种情况来分析他们的EventLoop。 什么是EventLoopEventLoop是一个执行模型，在不同的有不同的实现，浏览器和NodeJS基于不同的技术实现了各自的EventLoop。 浏览器的EventLoop是在HTML5规范中明确定义了的 NodeJS的EventLoop是基于libuv实现的。可以在libuv官网和NodeJS官网查看 libuv已经对NodeJS的EventLoop做出了实现，但是浏览器的HTML5规范只是定义了EventLoop的实现模型，具体的实现留给了浏览器厂商。 JavaScript中的单线程JavaScript是单线程脚本语言。所以，在一行代码的执行过程过，必然不会执行另一行代码的，就行你在使用了alert(1)以后在后面疯狂的console.log()，如果执行到 alert(1)，你没有关闭这个弹窗，后面的console.log()是永远都不会执行的，因为 alert() 这个任务还没有执行完成，下面的代码没法执行。通俗一点就是：如果你去食堂打饭，前面排了很长的队，如果你想要打到饭，那么你需要等前面的小可爱都能够顺利的打完饭才可以，你是不能够插队的。那什么是宏任务，什么又是微任务呢？ 同样是打饭的例子，你要打饭这件事请就是宏任务。这是一个大的事件。当轮到你打饭的时候，事件执行到你这里了，这个时候阿姨开始给你打饭，后面的同学还在等待着。但是你去打饭不单单的就是打饭，你会询问每种菜是什么，价格是多少，有没有XXX菜，有没有汤一样，那这些询问可以比作是微任务。当你的宏任务与微任务都执行完成了，相当于你的这一轮时间执行完成，这个时候开始执行下一轮事件，也就是下一个同学开始打饭了。同样的，下面的一轮循环中也可能存在微任务。 通过上面的例子，如果能有大概的明白了什么是宏任务，什么是微任务了。 宏任务macrotask，也叫 tasks，主要的工作如下 创建主文档对象,解析HTML,执行主线或者全局的javascript的代码,更改url以及各种事件。 页面加载,输入，网络事件，定时器。从浏览器角度看，宏任务是一个个离散的，独立的工作单元。 运行完成后，浏览器可以继续其他调度，重新渲染页面的UI或者去执行垃圾回收 一些异步任务的回调会以此进入 macrotask queue(宏任务队列)，等等后续被调用，这些异步函数包括： setTimeout setInterval setImmediate (Node) requestAnimationFrame (浏览器) I/O UI rendering (浏览器) 微任务microtask，也叫 jobs，注意的工作如下 微任务是更小的任务，微任务更新应用程序的状态，但是必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。 微任务包括Promise的回调函数，DOM发生变化等，微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。 微任务能使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使得应用状态不连续 另一些异步回调会进入 microtask queue(微任务队列) ，等待后续被调用，这些异步函数包括： process.nextTick (Node) Promise.then() catch finally Object.observe MutationObserver 这里有一点需要注意的：Promise.then() 与 new Promise(() =&gt; {}).then() 是不同的，前面的是一个微任务，后面的 new Promise() 这一部分是一个构造函数，这是一个同步任务，后面的 .then() 才是一个微任务，这一点是非常重要的。 浏览器中的EventLoop关于宏任务与微任务我们看看下面的执行流程 最开始有一个执行栈，当执行到带有异步操作的宏任务的时候，比如 setTimeout 的时候就会将这个异步任务存在背景线程里面，待本次的事件执行完成以后再去执行微任务。即图中 Stack --&gt; Background Thread。但是需要注意到，从 Stack --&gt; Microtask Queue 还有一条路线，意思就是在当前这轮的任务中还有执行微任务的操作。当前轮的微任务优先于宏任务异步操作先执行，执行完成到 loop 中，进入到下一轮。下一轮执行之前的宏任务的异步操作，比如 setTimeout 。此时，如果这个异步任务中还有微任务，那么就会执行完成这个微任务，在执行下一个异步任务。就这样一次的循环。 回到最开始的那道题上面123456789101112setTimeout( () =&gt; console.log(4))new Promise(resolve =&gt; &#123; resolve() console.log(1)&#125;).then( () =&gt; &#123; console.log(3)&#125;)Promise.resolve(5).then(() =&gt; console.log(5))console.log(2) 整个这一串代码我们所在的层级我们看做一个任务，其中我们先执行同步代码。第一行的 setTimeout 是异步代码，跳过，来到了 new Promise(...) 这一段代码。前面提到过，这种方式是一个构造函数，是一个同步代码，所以执行同步代码里面的函数，即 console.log(1)，接下来是一个 then 的异步，跳过。在往下，是一个Promise.then() 的异步，跳过。最后一个是一段同步代码 console.log(2)。所以，这一轮中我们知道打印了1, 2两个值。接下来进入下一步，即之前我们跳过的异步的代码。从上午下，第一个是 setTimeout，还有两个是 Promise.then()。setTimeout 是宏任务的异步，Promise.then()是微任务的异步，微任务是优先于宏任务执行的，所以，此时会先跳过 setTimeout 任务，执行两个 Promise.then() 的微任务。所以此时会执行 console.log(3) 和 console.log(5) 两个函数。最后就只剩下 setTimeout 函数没有执行，所以最后执行 console.log(4)。 综上：最后的执行结果是 1, 2, 3, 5, 4。 这只是我们的推测的结果，我们来看看在浏览器中的实际的打印结果是什么？ 从图中可以看到，实际的运行结果与我们推测的结果是一一致的。所以，我们上面的分析步骤是正确的。 但是有一个问题，什么呢？可以看到，在浏览器中，会有一个 undefined 的返回值。为什么呢？这是因为浏览器将上面的一整段代码当成一个函数，而这个函数执行完成以后返回了 undefined。那么？这就完了吗？没有。我们看看浏览器返回的截图中，3,5 两个数字其实是在 undefined 前面。3,5两个数是两个 Promise.then() 中的 console.log() 的打印值，而 undefined 在这里可以作为一轮任务的结束。这表明的意思就是，微任务会在下一轮任务开始前执行。 这一切都是针对于浏览器的EventLoop。在NodeJS的环境中，可能就会有不同的结果。至于结果如何，我们暂时先不讨论，在来看一段代码。 1234567891011121314151617181920212223242526272829setTimeout( () =&gt; &#123; new Promise(resolve =&gt; &#123; resolve() console.log(4) &#125;).then(() =&gt; &#123; console.log(7) &#125;)&#125;)new Promise(resolve =&gt; &#123; resolve() console.log(1)&#125;).then( () =&gt; &#123; console.log(3)&#125;)setTimeout( () =&gt; &#123; Promise.resolve(6).then(() =&gt; console.log(6)) new Promise(resolve =&gt; &#123; resolve() console.log(8) &#125;).then(() =&gt; &#123; console.log(9) &#125;)&#125;)Promise.resolve(5).then(() =&gt; console.log(5))console.log(2) 在浏览器中执行结果：点击查看 var eventloopBtn = document.getElementById(\"evnetloop-btn\"); var eventloopResult = document.getElementById(\"evnetloop-result\"); eventloopBtn.addEventListener(\"click\", () => { eventloopResult.innerHTML = \"1，2，3，5，4，7，8，6，9\" }) 上面就是关于在浏览器中的EventLoop。附上浏览器上面的可视化操作 NodeJS中的EventLoop虽然NodeJS中的JavaScript运行环境也是V8，也是单线程，但是，还是有一些与浏览器中的表现是不一样的。 上面的图片的上半部分来自NodeJS官网。下面的图片来自互联网。 同样的两段代码，我们在node环境中执行一下，看看结果。 从上面的图中可以看到，实际的运行结果与浏览器中的运行结果并无二致。 在来看看另一段代码1234567891011121314151617181920212223242526272829setTimeout( () =&gt; &#123; new Promise(resolve =&gt; &#123; resolve() console.log(4) &#125;).then(() =&gt; &#123; console.log(7) &#125;)&#125;)new Promise(resolve =&gt; &#123; resolve() console.log(1)&#125;).then( () =&gt; &#123; console.log(3)&#125;)setTimeout( () =&gt; &#123; Promise.resolve(6).then(() =&gt; console.log(6)) new Promise(resolve =&gt; &#123; resolve() console.log(8) &#125;).then(() =&gt; &#123; console.log(9) &#125;)&#125;)Promise.resolve(5).then(() =&gt; console.log(5))console.log(2) 他的执行结果是：1，2，3，5，4，8，7，6，9。与浏览器的1，2，3，5，4，7，8，6，9不同。 对比浏览器与NodeJS的不同在大部分情况下，浏览器与NodeJS的运行没有区别，唯一有区别的是在第二轮事件执行的时候，如果有多个宏任务(setTimeout)，浏览器会依次的执行宏任务，上一个宏任务执行完成了在执行下一个宏任务。在NodeJS中，则是相当于并行执行，相当于把所有的宏任务组合到一个宏任务中，再在这个组合后宏任务中，依次执行同步代码 --&gt; 微任务 --&gt; 宏任务。 NodeJS中的process.nextTick关于 process.nextTick，就只需要记住一点，那就是 process.nextTick 优先于其他的微任务执行。 所以，下面的代码中：123456789101112131415161718192021222324252627282930313233343536console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 分析（以Node作为运行环境，因为process在node中才存在）： 第一轮事件循环流程： 整体的script代码作为第一个宏任务进入主线程，执行同步代码，遇到console.log(1)，输出 1 遇到setTimeout，其回调函数被分发到宏任务的 Event Queue 中，等待执行。这里标记为setTimeout1 遇到process.nextTick，其回调函数被分发到微任务的 Event Queue 中，等待执行。 遇到new Promise，这是一个构造函数，new Promise构造函数直接执行，遇到console.log(7)，输出 7。接着Promise.then()函数被分发到微任务的 Event Queue 中，等待执行。遇到setTimeout，其回调函数被分发到宏任务的 Event Queue 中，等待执行。这里标记为setTimeout2 将上面的统计一下 宏任务Event Queue 微任务Event Queue setTimeout1 process.nextTick setTimeout2 Promise.then() 第一轮事件循环同步代码执行完成，接下来执行微任务。 微任务有两个，一个是 process.nextTick ，里一个是 Promise.then()。 前面说了，process.nextTick优先于其他的微任务执行，所以 执行process.nextTick：输出 6 执行Promise.then()：输出 8 到此，第一轮事件循环结束，最终第一轮事件的输出为 1,7,6,8。开始执行第二轮事件循环（setTimeout）。 第二轮事件循环分析 在 setTimeout1 与 setTimeout2 中先找同步代码 setTimeout1 中遇到 console.log(2),输出2 setTimeout1 中遇到 process.nextTick，放在第二轮的微任务的Event Queue中，等待执行。这里标记为process_1 setTimeout1 中遇到 new Promise ，执行同步代码，输出 4, Promise.then() 放到微任务的Event Queue中，等待执行。这里标记为Promise_1 setTimeout2 中遇到 console.log(9),输出9 setTimeout2 中遇到 process.nextTick，放在第二轮的微任务的Event Queue中，等待执行。这里标记为process_2 setTimeout2 中遇到 new Promise ，执行同步代码，输出 11, Promise.then() 放到微任务的Event Queue中，等待执行。这里标记为Promise_2 第二轮的统计 第二轮宏任务Event Queue 第二轮微任务Event Queue process_1 Promise_1 process_2 Promise_2 第二轮没有事件循环中没有宏任务，有四个微任务。 四个微任务中，有两个 process 依次执行 process_1 和 process_2。输出：3, 10 一次执行 Promise_1 和 Promise_2。输出：5, 12 所以第二轮输出：2，4，9，11，3，10，5，12 最终的输出为：1，7，6，8，2，4，9，11，3，10，5，12。 如果是在浏览器中，排除掉process的输出，结果为：1，7，8，2，4，5，9，11，12 NodeJS中 setImmediate 与 setTimeout 的区别在官方文档中的定义，setImmediate 为一次Event Loop执行完毕后调用。setTimeout 则是通过计算一个延迟时间后进行执行。 但是同时还提到了如果在主进程中直接执行这两个操作，很难保证哪个会先触发。因为如果主进程中先注册了两个任务，然后执行的代码耗时超过XXs，而这时定时器已经处于可执行回调的状态了。所以会先执行定时器，而执行完定时器以后才是结束了一次Event Loop，这时才会执行setImmediate。 12setTimeout(() =&gt; console.log('setTimeout'))setImmediate(() =&gt; console.log('setImmediate')) node环境下执行上面的代码，可以看到如下结果 这两个console的结果是随机的。 我们可以通过一些处理，使得我们可以先执行 setTimeout 或者是 setImmediate。 但是如果后续添加一些代码以后，就可以保证setTimeout一定会在setImmediate之前触发了：123456setTimeout(_ =&gt; console.log('setTimeout'))setImmediate(_ =&gt; console.log('setImmediate'))let countdown = 1e9while(countdonn--) &#123; &#125; // 我们确保这个循环的执行速度会超过定时器的倒计时，导致这轮循环没有结束时，setTimeout已经可以执行回调了，所以会先执行`setTimeout`再结束这一轮循环，也就是说开始执行`setImmediate` 如果在另一个宏任务中，必然是setImmediate先执行：123456require('fs').readFile(__dirname, _ =&gt; &#123; setTimeout(_ =&gt; console.log('timeout')) setImmediate(_ =&gt; console.log('immediate'))&#125;)// 如果使用一个设置了延迟的setTimeout也可以实现相同的效果 上面的为什么有这样的解决方法，从上面的定义中就可以看出来。 关于 async/await 函数因为，async/await本质上还是基于Promise的一些封装，而Promise是属于微任务的一种。所以在使用await关键字与Promise.then效果类似 1234567891011setTimeout(() =&gt; console.log(4))async function main() &#123; console.log(1) await Promise.resolve() console.log(3)&#125;main()console.log(2) 输出的结果是：1，2，3，4。 可以理解为，await 以前的代码，相当于与 new Promise 的同构代码，以后的代码相当于 Promise.then。到await的时候就会执行await后面的函数（相当于和前面的代码同步执行）。 总结之前了解过JavaScript单线程，也了解过JavaScript代码的执行顺序，但是宏任务与微任务也是最近才听说的，这对于一个从事两年前端的开发者真的是，我自己的过失。或需又是因为我是转行的，没有过相关的基础，没有接触到这方面的只是。不过现在我很高兴，因为我对JavaScript的执行有了更多的了解，相比于之前的只是，真的是了解了很多。学习永远都不晚，就怕你从来都不想去了解。在了解EventLoop，宏任务与微任务，JavaScript单线程的时候，参考了一些文档 Tasks, microtasks, queues and schedules Understanding JS: The Event Loop NodeJS EventLoop HTML5 EventLoop 标准 博客园的一位大佬，最后的ES7的 async/await 就是从这里看到的 到底什么是时间循环 Event loop in JavaScript","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.lyt007.cn/tags/JavaScript/"}]},{"title":"Flutter lesson 9: Flutter的网络（HTTP）请求","slug":"Flutter-lesson-9-Flutter的网络（HTTP）请求","date":"2019-07-09T07:14:59.000Z","updated":"2020-04-13T03:13:34.966Z","comments":true,"path":"技术/Flutter-lesson-9-Flutter的网络（HTTP）请求.html","link":"","permalink":"https://blog.lyt007.cn/技术/Flutter-lesson-9-Flutter的网络（HTTP）请求.html","excerpt":"","text":"Flutter中网络请求有两种，一个是使用Flutter自带的网络请求，另一种则是使用第三方HTTP请求插件dio Flutter中自带的HTTP请求如果要使用Flutter自带的HTTP请求，需要引入下面两个库12import 'dart:io';import 'dart:convert'; dart:io 用于发起http请求。这个库里面才有 HttpClient。1var httpClient = new HttpClient(); 因为网络请求需要时间，我们需要在网络请求成功后在来更新数据，所以，我们需要使用到异步。Flutter 官网建议我们使用 async/await 来进行处理异步（借鉴了前端中的ES7的异步处理）。 使用Flutter自带的HTTP请求一般包含以下几个步骤： 创建 client。 new HttpClient()，这个对象下面有许多方法，get，post等等。见下图 构造 Uri。不同于前端（HTML）的网页请求，直接一个 URL 链接就可以了。在Flutter中，请求需要使用 Uri 而不是 Url。关于 URL 与 URI 的区别，可以HTTP 协议中 URI 和 URL 有什么区别？。 发起请求，等待请求，同时您也可以配置请求的headers，body等等。 关闭请求。等待响应。 解码响应的内容。 看看下面的代码，代码来源于Flutter中文网12345678get() async &#123; var httpClient = new HttpClient(); var uri = new Uri.http( 'example.com', '/path1/path2', &#123;'param1': '42', 'param2': 'foo'&#125;); var request = await httpClient.getUrl(uri); var response = await request.close(); var responseBody = await response.transform(utf8.decoder).join();&#125; 因为在请求中，返回的数据一般都是 JSON 格式的数据，但是在Flutter中不能直接拿出来就用，这里需要转一下，这时候就需要用到 dart:convert。 使用dart:convert库可以简单解码和编码JSON。 有关其他的JSON文档，请参阅JSON和序列化。 看看最后的代码，下面两个都是get，使用了不同的方式，第二个还带了参数。如果要使用post或者其他请求，可以自己尝试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import 'dart:io';import 'dart:convert';import 'package:flutter/material.dart';void main() =&gt; runApp(LocaleHttp());class LocaleHttp extends StatefulWidget &#123; LocaleHttp(&#123;Key key&#125;) : super(key: key); _LocaleHttpState createState() =&gt; _LocaleHttpState();&#125;class _LocaleHttpState extends State&lt;LocaleHttp&gt; &#123; var data; Map _person = &#123; \"name\": \"点击按钮开始请求\", \"joinTime\": \"点击按钮开始请求\", \"email\": \"点击按钮开始请求\" &#125;; _getData() async &#123; var url = \"http://rap2api.taobao.org/app/mock/162174/common/content\"; var httpClient = new HttpClient(); String result; try &#123; var request = await httpClient.getUrl(Uri.parse(url)); var response = await request.close(); // 上面的两个一步执行完成后在来执行下面的判断 if( response.statusCode == HttpStatus.ok ) &#123; // 如果返回的状态是 200 那么请求成功 var json = await response.transform(utf8.decoder).join(); var data = jsonDecode(json); result = data['data'][0][\"description\"]; &#125; &#125; catch(err) &#123; result = \"Some Error\"; &#125; setState(() &#123; data = result; &#125;); &#125; _getPerson() async &#123; var httpClient = new HttpClient(); var uri = new Uri.http('rap2api.taobao.org', \"app/mock/162174/common/get-test\", &#123; \"id\": \"1\" &#125;); Map result = new Map(); setState(() &#123; _person = &#123; \"name\": \"请求中\", \"joinTime\": \"请求中\", \"email\": \"请求中\" &#125;; &#125;); try &#123; var request = await httpClient.getUrl(uri); var response = await request.close(); // 上面的两个一步执行完成后在来执行下面的判断 if( response.statusCode == HttpStatus.ok ) &#123; // 如果返回的状态是 200 那么请求成功 // 将返回的数据转一次格式，下面一行代码写法可以固定了 var json = await response.transform(utf8.decoder).join(); var data = jsonDecode(json)[\"res\"]; result = data; &#125; &#125; catch(err) &#123; result = &#123; \"name\": \"请求失败\", \"joinTime\": \"请求失败\", \"email\": \"请求失败\" &#125;; &#125; setState(() &#123; _person = result; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Container( child: Column( children: &lt;Widget&gt;[ RaisedButton( child: Text('获取数据'), onPressed: _getData, ), Text(data == null ? \"空\" : data), RaisedButton( child: Text('获取人物信息'), onPressed: _getPerson, ), Text(_person[\"name\"]), Text(_person[\"joinTime\"]), Text(_person[\"email\"]), ], ), ); &#125;&#125; 上面的代码中用到了 Map 对象，注意注意的是 Map 中的对象的每一个字段的值在最开始如果已经确定好了（比如都是字符串），在后面 setState 中，如果返回的数据中有其他的数据类型（比如 number ），那这个时候你在设置的时候就会报错 type int is not a subtype of type &quot;String&quot;。或者你会遇到其他的错误，这个不会像在 JavaScript 中那样随意。 使用 dio使用 dio 需要修安装 dio 插件，当前我使用的是最新的版本 2.1.11 1234567dependencies: flutter: sdk: flutter flutter_webview_plugin: ^0.3.5 image_picker: 0.6.0+9 fluttertoast: ^3.1.0 dio: 2.1.11 dio 具体的时候方法可以去 dio-github 上面查看，很简单，这里就不做过多说明。总之，相比于原生的 HTTP 请求，dio可谓是方便实用了需要，从下面的代码中就可以看出来。就绪在前端中，原生的 XMLHttpRequest几乎看不见，实际开发用的基本都是 axios 一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import 'package:flutter/material.dart';import 'package:dio/dio.dart';void main() =&gt; runApp(DioHttp());class DioHttp extends StatefulWidget &#123; DioHttp(&#123;Key key&#125;) : super(key: key); _DioHttpState createState() =&gt; _DioHttpState();&#125;class _DioHttpState extends State&lt;DioHttp&gt; &#123; var data; Map _person = &#123; \"name\": \"点击按钮开始请求\", \"sex\": -1, \"joinTime\": \"点击按钮开始请求\", \"email\": \"点击按钮开始请求\" &#125;; _getData() async &#123; var url = \"http://rap2api.taobao.org/app/mock/162174/common/content\"; Dio dio = new Dio(); String result; try &#123; Response response = await dio.get(url); print(response.data[\"data\"]); // 不要使用 response.data.data[0].description 这样的形势，获取不到 result = response.data[\"data\"][0][\"description\"]; &#125; catch(err) &#123; result = \"Some Error\"; &#125; setState(() &#123; data = result; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Container( child: Column( children: &lt;Widget&gt;[ RaisedButton( child: Text('获取数据'), onPressed: _getData, ), Text(data == null ? \"空\" : data) ], ), ); &#125;&#125; 具体的App的源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.lyt007.cn/tags/Flutter/"}]},{"title":"linux的简单介绍以及常用简单命令","slug":"linux的简单介绍以及常用简单命令","date":"2019-07-08T08:19:01.000Z","updated":"2020-04-13T03:13:34.966Z","comments":true,"path":"技术/linux的简单介绍以及常用简单命令.html","link":"","permalink":"https://blog.lyt007.cn/技术/linux的简单介绍以及常用简单命令.html","excerpt":"","text":"基本知识 12345678# 关机正常关机shutdown(腾讯云使用这个就关机了)shutdown -h now(虚拟机上是这样的 centOS 6.5)halt(关闭内存) 因为计算机没有内存无法开机，因此等同于关机init 0() 文件与目录1234567891011Bin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。Dev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似windows下的分配盘符）。Etc：该目录主要存储一些配置文件。Home：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的User/用户目录。Proc:process，表示进程，该目录中存储的是Linux运行时候的进程。Root：该目录是root用户自己的家目录。Sbin：全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。Imp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。Usr：存放的是用户自己安装的软件。类似于windows 下的program files。Var：存放的程序/系统的日志文件的目录。Mnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。 指令注：文中所有的 中括号 [] 表示可选 基本 commond not found 指令没有找到 一个完整的指令的基本格式# 指令 [选项] [操作对象] 一个指令可以包含多个选项 操作对象也可以是多个 例如：需要让张三同学帮忙去楼下小卖铺买一瓶农夫山泉水和清风餐巾纸，在这个指令中“买东西”是指令的主体，买的水和餐巾纸是操作的对象，农夫山泉、清风是操作的选项。| 基础指令ls 指令含义：ls（list） 列表清单的意思123456789用法1# ls含义：列出当前工作目录下的所有文件/文件夹的名称用法2# ls 路径含义：列出指定路径下的所有文件/文件夹的名称路径可以是相对路径（../上一级目录 || ./当前目录）也可以是绝对路径(/)` 123456用法3 # ls 选项 路径含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示。常见的语法： # ls -l 路径 --》 以列表的形式，列出当前目录的文件，不包含隐藏文件 # ls -la 路径 --》 以列表的形式，列出当前目录的文件，包含隐藏文件 上述列表中的第一列字符表示文档的类型，其中“-”表示改行对应的文档类型为文件，“d”表示文档类型为文件夹。隐藏的文档.开头1234用法4# ls -lh 路径v含义：列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候以可读性较高的形式显示 pwd命令123用法# pwd含义：print working directory，打印当前工作目录 打印的是绝对路径 cd命令作用：change directory 切换当前的工作目录1语法 # cd 路径 补充：在Linux中有一个特殊的符号“~”，表示当前用户的家目录。切换的方式：# cd ~ mkdir作用： make directory，创建目录12语法1# mkdir 路径 123语法2# mkdir -p作用：多层创建文件夹 上图如果不使用-p，name则无法创建文件夹 在使用-p后则可以创建多层文件夹 123语法3mkdir 路径1 路径2 路径3含义：在同一个目录下创建多个文件夹 上图创建了css，js，images三个文件夹 touch作用：创建文件123456语法# touch 文件路径路径可以是文件名或者是路径# touch 路径1 路径2 ...创建多个文件 cp作用：复制文件或者文件夹到指定的位置 copy12用法1 复制文件# cp 被复制的文件路径 文件被复制到的路径 注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致。 12用法2 复制目录# cp -r 被复制的目录路径 目录被复制到的路径 注意：当使用cp命令进行文件夹复制操作的时候需要添加选项“-r”【-r表示递归复制】否则目录将被忽略 mv作用1：移动，剪切文档到新的位置，语法与cp类似，移动文件夹不需要加 -r 作用2：重命名1# mv 需要移动的文档路径 需要保存的路径 rm作用：remove 移除或者删除一个或者多个文档1234# rm 选项 需要移除的文档路径选项： -f 强制删除，这样就没有提示了 -r 删除文件夹 上图输入 y（yes） n（no） 删除文件，如果添加了-f则不会删除 注意：删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询间，所以移除目录的时候一般需要使用-rf选项。 其中*称之为通配符，意思表示任意的字符，Linux*，则表示只要文件以Linux开头，后续字符则不管。 vim作用：打开文件，创建文件1234# vim 文件路径退出文件:q 回车 输出重定向一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。 &gt;：覆盖输出，会覆盖掉原先的文件内容 &gt;&gt;：追加输出，不会覆盖原始文件内容，会在原始内容未尾继续输出 123# 正常的命令 &gt; 文件的路径# 正常的命令 &gt;&gt; 文件的路径如果后面的文件路径不存在则会创建 cat12作用1：直接打开一个文件，与`vim`相比，他不需要使用 `:q` 退出# cat 文件的路径 12作用2：对多个文件进行合并# cat 文件的路径1 文件的路径2 文件的路径3 ... &gt; 输出的文件路径 进阶指令df作用：查看磁盘空间12# df -h-h表示以可读性较高的形式展示大小 free指令作用：查看内存使用情况1# free -m 一般使用-m即可，单位是mb Swap：用于临时内存，当系统真实内存不够用的时候可以临时使用磁盘空间来充当内存。| head作用：查看一个文件的前 n 行，如果不指定 n，则默认显示前10行1# head -n 文件路径 n表示数字 tail12作用1：查看一个文件的末尾 n 行 ，如果不指定 n，则默认显示末尾10行# tail -n 文件路径 n表示数字 如果n=-1 则显示最后一行 12作用2：用过tail查看一个文件的动态变化# tail -f 文件路径 退出按 q less 指令作用：查看文件，以较少的内容进行输出，按下辅助功能键查看更多 辅助键：数字+回车，空格（翻页），上下键1# less 需要查看的文件路径 wc 指令作用：用于统计文件内容信息（行数 -l，单词数 -w，字节数 -c）1# wc -lwc 文件路径 date （重点）作用：表示操作时间日期（读取与设置）12# date# date +%F 12345678%F：表示完整的年月日%T：表示完整的时分秒%Y：表示四位年份%m：表示两位月份（带前导0）%d：表示日期（带前导0）H：表示小时（带前导0）M：表示分钟（带前导0）%S：表示秒数（带前导0） 更多的命令可以查看：http://man.linuxde.net/date cal作用：用来操作日历123语法1：#cal 等价于 #cal -1 直接输出当前月份的日历语法2：#cal -3 表示输出上一个月+本月+下个月的日历语法3：#cal y 年份 表示输出某一个年份的日历 clear、CRTL+L作用：清屏12# clear快捷键：crtl+l 管道(重要)管道符号：| 作用：用于过滤，特殊用法，一些扩展用法。不能单独使用，需要配合前面所讲的那些 过滤案例：需要通过管道查询出根目录下包含“y”字母的文档名称。1# ls 路径 |grep y grep 的作用就是过滤 过滤当前路径下面有 0 的文件 特殊用法案例：通过管道的操作方法来实现less的等价效果（了解） 之前通过less查看一个文件，可以 # less 路径 现在通过管道还可以这么：# cat 路径 | less 扩展处理：请使用学过的命令，来统计某个目录下的文档的总个数？ 答：#s/Iwc-| 高级指令hostname作用：操作服务器的主机名（读取，设置），一般只是读取，不会去修改12语法1：# hostname 含义：表示输出完整的主机名 12语法2：# hostname -f 含义：表示输出当前主机名中的FQDN（全限定域名）,本地服务器的localhost id作用：用于查看一个用户的一些基本信息（用户ID，用户组ID，附加组ID等），如果不指定用户则默认当前用户1# id 1# id 用户名 whoami作用：获取当前用户的用户名，一部用于shell脚本，用户获取当前操作的用户名方便记录日志。1# whoami ps -ef(重点)作用：主要查看服务器的进程信息123选项含义： -e：等价于 -A 表示列出全部的进程 -f：显示全部的列（显示器全字段） 123456789列的含义：UID：该进程执行的用户id；PID：进程id；PPID：该进程的父级进程id，如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程；C:Cpu的占用率，其形式是百分数；STIME：进行的启动时间；TTY：终端设备，发起该进程的设备识别符号，如果显示“？”则表示该进程并不是由终端设备发起；TIME：进程的执行时间；CMD：该进程的名称或者对应的路径； top（重点）作用：查看服务器的进程占用的资源12进入命令：# top退出：按 q 12345678910111213表头含义：PID：进程id；USER：该进程对应的用户；PR：优先级；VIRT：虚拟内存；RES：常驻内存；SHR：共享内存； 计算一个进程实际使用的内存=常驻内存（RES）-共享内存（SHR）s：表示进行的状态（sleeping，其中s表示睡眠，R表示运行）；%CPU：表示CPU的占用百分比；%MEM：表示内存的占用百分比；TIME+：执行的时间；COMMAND：进程的名称或者路径； 在运行top的时候，可以按下方便的快捷键：123M：表示将结果按照内存（MEM）从高到低进行降序排列；P：表示将结果按照CPU使用率从高到低进行降序排列；1：当服务器拥有多个cpu的时候可以使用“1”快捷键来切换是否展示显示各个cpu的详细信息","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[]},{"title":"云服务器安装node+nginx+MongoDB","slug":"云服务器安装node-nginx-MongoDB","date":"2019-07-05T01:42:47.000Z","updated":"2020-04-13T03:13:34.968Z","comments":true,"path":"技术/云服务器安装node-nginx-MongoDB.html","link":"","permalink":"https://blog.lyt007.cn/技术/云服务器安装node-nginx-MongoDB.html","excerpt":"","text":"很早就买了一个云服务器，在腾讯云上面买的，当时买了好几年，用了几百块吧。具体的配置如下 本来就是想用来练手node+nginx+MongoDB的，一直没时间（其实是太懒了），所以没有着手做此项目。以前也弄过，不过总是断断续续的，而且没有记录，现在再想搭建的时候，已经忘得差不多了。写这篇文章的目的纯粹是为了记录下我搭建的步骤，以供以后查询。 购买服务器首先就是需要购买一个服务器，不管是1+1+1（1G1核1M）还是其他的配置，只有有服务器就行，因为就是个练手的，没必要那么好。当然，如果你有钱，你可以选择黄金配置。腾讯云阿里云时不时的会有一些活动出来，如果有活动，我会放在本文的下方，以供你们参考。 安装系统云服务器也是需要安装系统的，以腾讯云的云服务器为例 点击右边更多 ==&gt; 重装（安装）系统 ==&gt; 选择系统配置，输入密码开始重装 我这里是用的centerOS系统，你可以使用别的系统，当然，如果是其他的系统，那么安装工具的方法可能会有不同。 Tip：密码可能在第一次使用的时候需要重置。 进入服务器安装工具上面的配置好了基本上就可以进入服务器安装工具（node+nginx+MongoDB等等）了。 那么，怎么进入呢？同样是腾讯云服务器 链接服务器 登录方式不同的操作系统是不同的，具体的操作系统可在在相关云服务器网站上面找到。 mac和linux用自带的终端或者使用 Item2 ，windows使用 Putty 是不错的选择。 以下操作按照mac的来 使用Item2连接服务器 1234ssh 用户名@IP地址# 或者ssh 用户名@IP地址 -p 端口号 链接错误 12345678910111213@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:Ppgtgxjj3hnHqRH19D0hz5Vl34vUW0Dah1AJdpLoX6M.Please contact your system administrator.Add correct host key in /Users/cpx/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /Users/cpx/.ssh/known_hosts:6ECDSA host key for 118.24.6.33 has changed and you have requested strict checking.Host key verification failed. 解决：删除之前的 known_hosts 文件 1234rm -rf ~/.ssh/known_hosts# 或者更靠谱的方法ssh-keygen -f .ssh/known_hosts -R 192.168.2.108(你的IP) 之后重新执行命令就可以链接成功 安装工具安装可以使用centerOS中的 yum 工具，不过使用之前最好先 yum update 一波（可选操作） Node到Node官网复制linux包（Linux Binaries (x64)）链接，我当前版本的链接是 https://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.xz 。不是Source Code。 下载1wget https://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.xz 解压12345# 如果是 tar.gz 结尾的，使用 tar xvzf 解压tar xvzf node-v10.16.0-linux-x64.tar.gz# 如果是 tar.xz 结尾的，使用 tar xvJf 解压 注意 J 是大写的tar xvJf node-v10.16.0-linux-x64.tar.zx 进入解压的node文件夹1cd node-v10.16.0 安装必要的运行文件1sudo yum install gcc gcc-c++ 配置node，npm软连接，这样就可以在所有目录下使用，注意 -s 不要忘记了，不然会报错。12ln -s /root/node-v10.16.0-linux-x64/bin/node /usr/local/bin/nodeln -s /root/node-v10.16.0-linux-x64/bin/npm /usr/local/bin/npm 如果你不小心写错了软链，那么你可能会把它删除 查看 node, npm 版本12node -vnpm -v 出现如下请求，即创建成功 安装Nginx1yum install nginx 启动nginx1service nginx start 每一次修改了 nginx.conf 文件后都需要停止 nginx 并重启 12强制停止： pkill -9 nginx重启：service nginx restart 这里我使用的是yum安装的nginx，默认的安装目录是在 /etc/nginx 这个目录，nginx的配置文件也是在 /etc/nginx/nginx.conf 这里 配置 nginx 代理，编辑 nginx.conf nginx 默认的服务配置只有一个80端口，配置如下 1234567891011121314151617181920server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; 这时候我想要添加一个8090端口，我的配置代码如下12345678910111213141516171819server &#123; listen 8090; server_name _; root /data/www/test/index.html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; 此时报了错了，访问 118.24.6.33:8090 的时候出现了 403 Forbidden 的错误。 我们知道 HTTP 状态码中，403表示的是没有权限的意思，意思是上面的 /data/www/test/index.html; 我们没有权限访问 这个是因为nginx默认的配置文件中，第 5 行的代码中 user nginx;1234user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid; 我们需要将 user nginx; 改成 user root; 接着停止重启nginx服务。 这时候访问 118.24.6.33:8090 的时候出现了 404 Not Found 的错误。 再来看看HTTP协议中 404 表示的是没有资源，WHAT？WHY？ 里面明明就有这个东西啊？ 既然里面已经放了东西了，还是 404， 值得我们思考。我们看看默认的 80 端口的 root 配置为 /usr/share/nginx/html。在看看里面呢 里面是有一个html文件的。所以。这个 root 的值是一个目录而不是一个文件，所以，把 /data/www/test/index.html; 改成 /data/www/test 即可。这时候就可以访问 118.24.6.33:8090 了。 nginx接触的不多，所以会出现一些问题，不过都是在问题中慢慢摸索。当然，你也可以看看nginx的配置官网。不过东西有点多，大部分可能涉及不到，所以还是采坑了。 安装git或许你会用到git clone以前的项目练手，或许你不会。不过还是说一下 使用 yum 安装（推荐。这个安装方便）,安装后可直接使用1yum install git 到网站git linux 下载你需要的git版本。 下载解压与 node 相同，不在过多说明。 安装 git 的时候你可能还需要安装 curl-devel1yum install curl-devel 你还需要生成一个 key 用于git的识别 生成 sshkey，敲三次回车即可1ssh-keygen -t rsa -C\"xxxxx@xxxxx.com\" 查看你的 public key，并把他添加到github1cat ~/.ssh/id_rsa.pub 安装MongoDB前往MongoDB官网选择对应版本，复制下面的链接1wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.21.tgz 12345678910# 解压tar vxzf mongodb-linux-x86_64-3.4.21# 重命名mv mongodb-linux-x86_64-3.4.21 mongodb# 进入文件夹，变量创建 data 和 logs 文件夹cd mongodbmkdir -p logsmkdir -p data 进入bin文件夹创建 mongodb.conf，并配置此文件。注意：mongodb 3.6以上版本不支持下面的配置1234567891011121314# 设置数据文件的存放目录dbpath = /mongodb/data# 设置日志文件的存放目录及其日志文件名logpath = /mongodb/logs/mongodb.log# 设置端口号（默认的端口号是 27017）port = 27017# 设置为以守护进程的方式运行，即在后台运行fork = true# nohttpinterface = truenohttpinterface = true 启动：在bin文件夹下执行1234./mongod --config mongodb.conf以修复模式启动 mongodb：./mongod --repair -f mongodb.conf 安装yarn（可选）因为在本地使用npm的时候老是出问题，在本地基本上都是使用的是yarn。我怕在服务器上面如果安装依赖包的时候使用npm也像在本地一样出问题，所以还是觉得使用yarn更好 123curl --silent --location https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.reposudo yum install yarn 安装pm2这个依赖是可以在服务器上面运行node项目的，相比于原生的node启动的文件 1234npm install -g pm2# 设置软链ln -s node的具体路径/bin/pm2 /usr/local/bin/pm2 PM2 的主要特性 内建负载均衡（使用 Node cluster 集群模块） 后台运行 0 秒停机重载，我理解大概意思是维护升级的时候不需要停机. 具有 Ubuntu 和 CentOS 的启动脚本 停止不稳定的进程（避免无限循环） 控制台检测 提供 HTTP API 远程控制和实时的接口 API ( Nodejs 模块,允许和 PM2 进程管理器交互 ) 具体的使用方法12345#启动pm2 start xxx.js#停止 (AppName|id) 如下放图pm2 stop (AppName|id) 注意：这里pm2启动的是node的项目。而不是react，vue这些项目。我刚开始犯错了。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"云服务器","slug":"云服务器","permalink":"https://blog.lyt007.cn/tags/云服务器/"}]},{"title":"Flutter lesson 8:输入框,时间日期选择","slug":"Flutter-lesson-8-输入框-时间日期选择","date":"2019-07-04T06:20:25.000Z","updated":"2020-04-13T03:13:34.965Z","comments":true,"path":"技术/Flutter-lesson-8-输入框-时间日期选择.html","link":"","permalink":"https://blog.lyt007.cn/技术/Flutter-lesson-8-输入框-时间日期选择.html","excerpt":"","text":"日期时间选择Flutter自带的 showDatePicker 和 showTimePicker 两个方法可以进行时间和日期的选择。 使用的时候直接使用者两个方法即可，不过有一点需要注意：在使用的时候，一般不要在 onPress 下直接调用，而是需要单独写一个方法。同时，因为这两个方法是异步实现的，所以，这里使用了ES8中的 async...await 下面我们来看看具体的代码实现 1234567891011121314151617181920212223242526var _chooseDate;var _chooseTime;_showDatePicker() async &#123; var date = await showDatePicker( context: context, initialDate: DateTime.now(), firstDate: DateTime(1970), lastDate: DateTime(2050) ); setState(()&#123; this._chooseDate = date.toString().split(\" \")[0]; &#125;);&#125;_showTimePicker() async &#123; var time = await showTimePicker( context: context, initialTime: TimeOfDay.now() ); print(time); setState(() &#123; this._chooseTime = time.toString().split(\"TimeOfDay(\")[1].split(\")\")[0]; &#125;);&#125; 选择时间日期还是挺简单的，不过需要注意的是12flutter: 选择的日期是：2019-07-30 00:00:00.000flutter: 选择的时间是：TimeOfDay(21:34) 两个方法选择时间，日期后，时间日期的格式是上面那样的，如果你要使用，或许你需要处理一下。 选择时间是使用的 TimeOfDay，选择日期使用的是 DateTime ，两个是不同的方法，没有选择日期又选择时间的，或许在dart.pub上面有一些第三方的插件可以。 输入框 TextFieldTextField 是Flutter中的用户输入框，属性挺多的，不同的配置出不同的效果，就像是HTML中的 input 一样。123456789101112131415161718192021222324252627282930313233343536const TextField(&#123; Key key, this.controller, //编辑框的控制器，跟文本框的交互一般都通过该属性完成，如果不创建的话默认会自动创建 this.focusNode, //用于管理焦点 this.decoration = const InputDecoration(), //输入框的装饰器，用来修改外观 TextInputType keyboardType, //设置输入类型，不同的输入类型键盘不一样 this.textInputAction, //用于控制键盘动作（一般位于右下角，默认是完成），搜送，下一步等 this.textCapitalization = TextCapitalization.none, this.style, //输入的文本样式 this.strutStyle, this.textAlign = TextAlign.start, //输入的文本位置 this.textDirection, //输入的文字排列方向，一般不会修改这个属性 this.autofocus = false, //是否自动获取焦点 this.obscureText = false, //是否隐藏输入的文字，一般用在密码输入框中 this.autocorrect = true, //是否自动校验 this.maxLines = 1, //最大行 this.minLines, this.expands = false, this.maxLength, //能输入的最大字符个数 this.maxLengthEnforced = true, //配合maxLength一起使用，在达到最大长度时是否阻止输入 this.onChanged, //输入文本发生变化时的回调 this.onEditingComplete, //点击键盘完成按钮时触发的回调，该回调没有参数，()&#123;&#125; this.onSubmitted, //同样是点击键盘完成按钮时触发的回调，该回调有参数，参数即为当前输入框中的值。(String)&#123;&#125; this.inputFormatters, //对输入文本的校验 this.enabled, //输入框是否可用 this.cursorWidth = 2.0, //光标的宽度 this.cursorRadius, //光标的圆角 this.cursorColor, //光标的颜色 this.keyboardAppearance, this.scrollPadding = const EdgeInsets.all(20.0), this.dragStartBehavior = DragStartBehavior.start, this.enableInteractiveSelection, this.onTap, //点击输入框时的回调()&#123;&#125; this.buildCounter, this.scrollPhysics,&#125;) TextField最简单的使用方法就是无参数调用，你可以看到上面的参数，没有一个参数是必传的。但是，没有经过修饰的输入框真的好丑。 1TextField() 但是问题来了，我们只是输入，但是我们怎么获取到输入的值呢？这时候就需要用到 controller 属性，也难怪会排在最前面。 两种方法 使用 controller 进行监听123456789101112131415161718192021222324252627282930class _GetInputValueState extends State&lt;GetInputValue&gt; &#123; var _controllerValue; @override Widget build(BuildContext context) &#123; TextEditingController controller = TextEditingController(); controller.addListener(()&#123; print(controller.text); &#125;); return Container( child: Column( children: &lt;Widget&gt;[ TextField( controller: controller, ), TextField( onChanged: (text)&#123; setState(() &#123; _controllerValue = text; &#125;); &#125;, ), Text(_controllerValue == null ? \"输入框没有值\" : _controllerValue), ], ), ); &#125;&#125; 这种方法有几个问题需要注意： 用于常用的获取值与赋值的操作 在使用 controller.addListener 的时候，我无法在里面设置 setState 方法修改状态，或者说是达不到预期的效果。因为如果在 controller.addListener 里面设置了 setState 方法，每一次状态值都会更新两次，第一次是输入的值，第二次则是清空的值。所以，如果要使用这种方式，那么你可能是要直接处理这个值，用于搜索接口的调用，而不是进行数据绑定。 使用 onChange 方法同样是上面的代码，我把它提取出来 1234567TextField( onChanged: (text)&#123; setState(() &#123; _controllerValue = text; &#125;); &#125;,), 这样的好处就是我可以获取数据并且能够进行数据双向绑定。 decoration ==》 InputDecorationdecoration 用于对输入框进行样式修饰，这个属性很重要，下面图中的修饰都是使用了 decoration 我们来看看源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import 'package:flutter/material.dart';import 'package:fluttertoast/fluttertoast.dart';void main() =&gt; runApp(InuptStyle());class InuptStyle extends StatefulWidget &#123; InuptStyle(&#123;Key key&#125;) : super(key: key); _InuptStyleState createState() =&gt; _InuptStyleState();&#125;class _InuptStyleState extends State&lt;InuptStyle&gt; &#123; // 输入字数限制 var _inputLength = 0; var _maxWords = 16; @override Widget build(BuildContext context) &#123; return Container( child: Column( children: &lt;Widget&gt;[ TextField( decoration: InputDecoration( icon: Icon(Icons.person), labelText: '手机号', labelStyle: TextStyle( color: Colors.red ), helperText: \"用于下方的提示：请输入手机号\", prefixText: \"+86\" ), textInputAction: TextInputAction.next, keyboardType: TextInputType.phone ), TextField( decoration: InputDecoration( icon: Icon(Icons.lock), labelText: '密码', // 帮助信息 helperText: \"用于下方的提示：请输入密码\", helperStyle: TextStyle( color: Colors.green ), hintText: \"输入框的提示文字\", suffixIcon: Icon(Icons.remove_red_eye) ), keyboardType: TextInputType.text ), TextField( decoration: InputDecoration( // border 还有一个 UnderlineInputBorder 就是默认的 // InputBorder.none 可以设置为没有边框，可以去掉边框 border: OutlineInputBorder( borderSide: BorderSide( color: Colors.red, width: 10 ) ), icon: Icon(Icons.recent_actors), labelText: '输入字数限制', hintText: \"输入框的提示文字\", suffixIcon: Icon(Icons.remove_red_eye), // 右下角显示输入的字数 counterText: \"$_inputLength/$_maxWords\" ), maxLength: _maxWords, onChanged: (text)&#123; if( text.length &gt; 16 )&#123; Fluttertoast.showToast( msg: \"输入超出长度限制\" ); &#125; else &#123; setState(() &#123; _inputLength = text.length; &#125;); &#125; &#125;, keyboardType: TextInputType.text ) ], ), ); &#125;&#125; 具体的说明就不多说了，常用的属性也就是上面涉及到的属性 关于 TextField 的其他的属性，可以自己尝试一下，比如自动聚焦，光标设置等等，在最上面的属性列表中都有注释，可以自行研究。 最近工作有点忙，加上要准备自考了，没有太多时间来写博客写文章，或者说很多东西可能没有涉及到，讲的不是很清楚，欢迎在下方留言，有时间我们一起探讨。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.lyt007.cn/tags/Flutter/"}]},{"title":"react项目打包优化","slug":"react项目打包优化","date":"2019-06-28T08:48:06.000Z","updated":"2020-04-23T09:05:46.899Z","comments":true,"path":"技术/react项目打包优化.html","link":"","permalink":"https://blog.lyt007.cn/技术/react项目打包优化.html","excerpt":"","text":"新公司所有的项目基本上都是使用 react 进行开发，之前的工程师是自己使用 webpack 搭建的项目，因为涉及到的东西不多，而且存在一些问题，已经启用。同时因为项目时间原因没有太多时间自己搭建，而且自己较懒，所以选择了使用 create-react-app 进行项目的开发。 其实开发还是很简单的，主要就是优化的问题，这篇文章主要就是讲关于页面优化的问题，同时也是为了记录一下，避免下次使用的时候在到处找（因为之前写过，最近一次项目又去找之前的配置去了） 问题产生原因使用 create-react-app 打包项目后，本地运行还可以，但是在服务器上面特别的卡，看了一下文件大小。一个JS文件，打包出来有1.4M的大小 这样大的js可能真的有点大了。包括打包后的CSS文件也有500多KB。这两个文件都很大，用户在访问浏览器请求数据的时候这两个文件请求的时间较长，加上使用react的原意，造成首次加载的时候大部分时间页面是白屏的。这里我们怎么优化呢？ 按需加载第一次看见按需加载这个词的时候是在使用 Ant Design 的时候。获取是因为我比较落后吧，之前一直都不知道这个东西，但是学习永远不要嫌晚，不然你会没有动力的。它里面讲到了为什么要使用按需加载：如果我们在使用一个组件的时候，默认是没有样式的，需要把样式也引用进来才会生效。但是如果你在使用 antd 的时候，用的组件并不多，可是却引入了全部的样式，所以会导致打包出来的文件特别的大。怎么解决呢？如果你使用了 antd ，那么官网上面已经有了很好的说明。 1yarn add react-app-rewired customize-cra 因为这里讲的是使用 create-react-app 创建的项目，此时我们需要对 create-react-app 的默认配置进行自定义，这里我们使用 react-app-rewired （一个对 create-react-app 进行自定义配置的社区解决方案）。 引入 react-app-rewired 并修改 package.json 里的启动配置。由于新的 react-app-rewired@2.x 版本的关系，你还需要安装 customize-cra。 将默认的 package.json 里面的 scripts 代码修改为一下 12345\"scripts\": &#123; \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\",&#125; 然后在根目录创建一个 config-overrides.js 用于修改默认配置。1234module.exports = function override(config, env) &#123; // do stuff with the webpack config... return config;&#125;; 使用 babel-plugin-importbabel-plugin-import 是一个用于按需加载组件代码和样式的 babel 插件（原理），现在我们尝试安装它并修改 config-overrides.js 文件。 12345678910111213141516171819const &#123; override, fixBabelImports &#125; = require('customize-cra');const addCustom = () =&gt; config =&gt; &#123; let plugins = [] config.plugins = [...config.plugins, ...plugins] return config&#125;module.exports = &#123; webpack: override( addCustom(), fixBabelImports('import', &#123; libraryName: 'antd', libraryDirectory: 'es', style: 'css', &#125;) )&#125; 上面的代码经过一些处理，可以添加一部分其他的 Plugin。 antd 官网上面有这样的一段说明 注意：antd 默认支持基于 ES module 的 tree shaking，js 代码部分不使用这个插件也会有按需加载的效果。 所以，在你使用 import { Button } from &#39;antd&#39;; 这种语法的时候可以不用这个插件。但是如果你是用的是 import Button from &#39;antd/es/button&#39;; 这种语法，那么就需要了。同时可以不用引入整个CSS静态文件了。 路由懒加载使用react开发一般使用的路由模块都是react-router-dom这个插件。当然，如果你使用其他的插件，我想应该也是可以的，不过具体的用法可能需要你自己探索。 正常情况下在使用路由的时候，你多半是按照下面的代码进行配置的 12345678910111213141516171819202122232425262728293031323334353637import React, &#123;Suspense &#125; from 'react'import &#123; BrowserRouter, Route &#125; from 'react-router-dom'import &#123; Loading &#125; from '../components/common'import Home from '../components'import Download from '../components/download/'import Login from '../components/login'import Prize from '../components/prize'import News from '../components/news'import NewsDetail from '../components/news/detail'import Support from '../components/support'import Me from '../components/me'import Pay from '../components/pay'const App = () =&gt; ( // 使用 BrowserRouter 的 basename 确保在服务器上也可以运行 basename 为服务器上面文件的路径 &lt;BrowserRouter basename='/'&gt; &lt;Route path='/' exact component=&#123;Home&#125; /&gt; &lt;Route path='/download' exact component=&#123;Download&#125; /&gt; &lt;Route path='/prize' exact component=&#123;Prize&#125; /&gt; &lt;Route path='/news' exact component=&#123;News&#125; /&gt; &lt;Route path='/news/detail' exact component=&#123;NewsDetail&#125; /&gt; &lt;Route path='/support' exact component=&#123;Support&#125; /&gt; &lt;Route path='/me' component=&#123;Me&#125; /&gt; &lt;Route path='/pay' component=&#123;Pay&#125; /&gt; &lt;Login /&gt; &lt;/BrowserRouter&gt;)// 因为使用了多语言配置，react-i18next 邀请需要返回一个函数export default function Main() &#123; return ( &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt; &lt;App /&gt; &lt;/Suspense&gt; );&#125; 这种写法也是官网上面的写法。这样写可以，但是有一个问题，就是上面的所有引入也会直接打包在 bundle.js 里面，导致整个js与CSS特别的大。这里我们可以做路由的懒加载：即这个路由页面在使用到的时候在进行引入加载，而不是一开始就加载。有点类似于上面所说的按需加载 修改于 2019年11月14日 react 16.8 已经提供 React.lazy 方法实现路由懒加载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import React, &#123;Suspense &#125; from 'react'import &#123; BrowserRouter, Route &#125; from 'react-router-dom'import &#123; Loading &#125; from '../components/common'+ const Home = React.lazy(_ =&gt; import('@pages/home'))+ const Download = React.lazy(_ =&gt; import('@pages/download/'))+ const Login = React.lazy(_ =&gt; import('@containers/Login/SetIsShowLoginModal'))+ const Prize = React.lazy(_ =&gt; import('@pages/prize'))+ const News = React.lazy(_ =&gt; import('@pages/news'))+ const NewsDetail = React.lazy(_ =&gt; import('@pages/news/detail'))+ const Support = React.lazy(_ =&gt; import('@pages/support'))+ const GameRoom = React.lazy(_ =&gt; import('@pages/GameRoom'))+ const Me = React.lazy(_ =&gt; import('@pages/me'))- const Home = asyncComponent(() =&gt; import('../components'))- const Download = asyncComponent(() =&gt; import('../components/download/'))- const Login = asyncComponent(() =&gt; import('../components/login'))- const Prize = asyncComponent(() =&gt; import('../components/prize'))- const News = asyncComponent(() =&gt; import('../components/news'))- const NewsDetail = asyncComponent(() =&gt; import('../components/news/detail'))- const Support = asyncComponent(() =&gt; import('../components/support'))- const Me = asyncComponent(() =&gt; import('../components/me'))- const Pay = asyncComponent(() =&gt; import('../components/pay'))- // 异步按需加载component- function asyncComponent(getComponent) &#123;- return class AsyncComponent extends React.Component &#123;- static Component = null;- state = &#123; Component: AsyncComponent.Component &#125;;- componentDidMount() &#123;- if (!this.state.Component) &#123;- getComponent().then((&#123; default: Component &#125;) =&gt; &#123;- AsyncComponent.Component = Component- this.setState(&#123; Component &#125;)- &#125;)- &#125;- &#125;- //组件将被卸载- componentWillUnmount() &#123;- //重写组件的setState方法，直接返回空- this.setState = (state, callback) =&gt; &#123;- return;- &#125;;- &#125;- render() &#123;- const &#123; Component &#125; = this.state- if (Component) &#123;- return &lt;Component &#123;...this.props&#125; /&gt;- &#125;- return null- &#125;- &#125;- &#125;const App = () =&gt; ( // 使用 BrowserRouter 的 basename 确保在服务器上也可以运行 basename 为服务器上面文件的路径 &lt;BrowserRouter basename='/'&gt; &lt;Route path='/' exact component=&#123;Home&#125; /&gt; &lt;Route path='/download' exact component=&#123;Download&#125; /&gt; &lt;Route path='/prize' exact component=&#123;Prize&#125; /&gt; &lt;Route path='/news' exact component=&#123;News&#125; /&gt; &lt;Route path='/news/detail' exact component=&#123;NewsDetail&#125; /&gt; &lt;Route path='/support' exact component=&#123;Support&#125; /&gt; &lt;Route path='/me' component=&#123;Me&#125; /&gt;v &lt;Route path='/pay' component=&#123;Pay&#125; /&gt; &lt;Login /&gt; &lt;/BrowserRouter&gt;)// 因为使用了多语言配置，react-i18next 邀请需要返回一个函数export default function Main() &#123; return ( &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt; &lt;App /&gt; &lt;/Suspense&gt; );&#125; 上面编写了一个一步加载路由的方法 asyncComponent。方法接收一个函数，这个函数可以从上面的引入看到，是返回一个 import 的函数。import &#39;XXX&#39; 最后返回的是一个Promise，所以下面使用了 .then() 方法。之后就是修改这个组件了。不过需要注意的是 1234567render() &#123; const &#123; Component &#125; = this.state if (Component) &#123; return &lt;Component &#123;...this.props&#125; /&gt; &#125; return null&#125; render 中如果 Component 是null。即还没有引入的时候，返回的是一个null 因为返回一个null，所以会有一个闪屏，第二次加载的时候就没有了。这里可以做一个Loading。不过想过可能不大，或者说设置一个定时器延时修改Component状态，或许效果就不那么明显了。这个这样做的好处就是可以把异步加载的这些组件的js以及CSS单独的打包出来，这样就不用一次加载过大的js文件了。 这也和之前讲到的桌面浏览器前端优化策略中说到的消除阻塞页面渲染的CSS以及Javascript和避免运行耗时的 Javascript中说到的相符合。 使用SSR渲染使用SSR渲染不仅可以对SEO优化有一定的帮助，同时，还可以对react项目首屏优化的项目有一定的优化作用，所以，如果有需要，可以采用SSR渲染的模式进行开发。关于SSR渲染你可以自己在create-react-app项目中写同构应用，也可以使用现有的服务端渲染的框架，如 nextjs等。这里不做过多说明。 补充 2019-07-16 10:00:54webpack 提取公共代码webpack打包自带了提供公共代码的功能，在webpack 3中可以使用 CommonsChunkPlugin 进行公共代码的提取，使用方式如下： 12345678// 在 plugin 中添加，下面代码是提取 node_modules 里面的代码new webpack.optimize.CommonsChunkPlugin(&#123; name:'vender', // 提取出来的JS的文件的名字，注意不要.js后缀 minChunks: function (module) &#123; // this assumes your vendor imports exist in the node_modules directory return module.context &amp;&amp; module.context.includes('node_modules'); &#125;&#125;) 具体的使用可以查看 https://webpack.js.org/plugins/commons-chunk-plugin/ 上面的是 webpack 3 的使用方法。在 webpack 4 中，配置发生了改变。 在 webpack 4 中，提取代码不在放在 plugin 数组下面，而是单独成为了一个属性（与plugin同级了）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657optimization.splitChunks = &#123; // 修改于2020年4月23日16:45:14 - cacheGroups: &#123; - // 其次: 打包业务中公共代 码 - common: &#123; - name: \"common\" , - chunks: \"all\" , - minSize: 1 , - priority: 0 - &#125; , - // 首先: 打包node_modules中的文 件 - vender: &#123; - name: \"vendor\" , - test: /[\\\\/]node_modules[\\\\/]/ , - chunks: \"all\" , - priority: 1 0 - &#125; - &#125; , // 修改后 + cacheGroups: &#123; + vendors: &#123; + test: /[\\\\/]node_modules[\\\\/]/, + name: 'vendors', + minSize: 50000, + minChunks: 1, + chunks: 'initial', + priority: 1, // 该配置项是设置处理的优先级，数值越大越优先处理，处理后优先级低的如果包含相同模块则不再处理 + &#125;, + commons: &#123; + test: /[\\\\/]src[\\\\/]/, + name: 'commons', + minSize: 50000, + minChunks: 2, + chunks: 'initial', + priority: -1, + reuseExistingChunk: true, // 这个配置允许我们使用已经存在的代码块 + &#125;, + antdDesign: &#123; + name: 'antd-design', // 单独将 antd-design 拆包 + priority: 20, + test: /[\\\\/]node_modules[\\\\/]@ant-design[\\\\/]/, + chunks: 'all', + &#125;, + lodash: &#123; + name: 'lodash', // 单独将 lodash 拆包 + priority: 20, + test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/, + chunks: 'all', + &#125;, + reactLib: &#123; + name: 'react-lib', // 单独将 lodash 拆包 + priority: 20, + test: /[\\\\/]node_modules[\\\\/](react|react-dom|react-router-dom)[\\\\/]/, + chunks: 'all', + &#125;, + &#125;,&#125; cacheGroups 下面添加你要提取的代码的属性，vender 一般提取的就是 node_modules 目录中的js代码，而且node_modules中插件的版本不会轻易的变化，这样，这个 vender 就可以一直缓存在浏览器中，除非特殊情况发生。你可可以添加其他的，有限打包权使用priority区分就行，权重越高，越优先打包。具体的其他的属性配置查看https://webpack.js.org/plugins/split-chunks-plugin/ 关于cacheGroups的理解可以看 理解webpack4.splitChunks之cacheGroups 使用 webpack-bundle-analyzer使用 webpack-bundle-analyzer 对现有项目打包文件进行分析 安装 webpack-bundle-analyzer 插件 1yarn add -D webpack-bundle-analyzer 使用就直接在 plugin 中添加插件使用即可 12const BundleAnalyzerPlugin = require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin;new BundleAnalyzerPlugin(); 打包后你会看到如下分析图 如果有过大的文件，可以继续进行拆分 补充 2019-11-13大型库外链通过上面的打包后的分析图可以看出来总的大小是1.58M，vendorjs是1.37M。其他的都是几十K，如果是通过gzip压缩，那么大小在合理的范围内。但是那个1.37M的就过于庞大了。这时候在看看图上面。大的区域有 ant-design firebase react-dom swiper momentjs etc…… 这个时候，可以将一些大型库外链。即通过script的方式引入这些库。 webpack 提供了一个属性 externals 可以配置我们需要外链的库 123456789if (process.env.NODE_ENV === 'production') &#123; ... config.externals = &#123; \"react\": \"React\", \"react-dom\": \"ReactDOM\", \"Swiper\": \"swiper\" &#125;&#125; 这里我配置了外链react，react-dom，swiper三个库 1234&lt;script crossorigin src=\"https://unpkg.com/react@16/umd/react.production.min.js\"&gt;&lt;/script&gt;&lt;script crossorigin src=\"https://unpkg.com/react-dom@16/umd/react-dom.production.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcss.com/Swiper/4.5.0/js/swiper.min.js\"&gt;&lt;/script&gt;&lt;link href=\"https://cdn.bootcss.com/Swiper/4.5.0/css/swiper.min.css\" rel=\"stylesheet\"&gt; 注意，是打包的时候添加外链，externals 属性与entry，output属于同级。 这样处理后，打包就不会把需要外链的库打包进去 至于 ant-design ，因为配置了按需加载，可以不用使用外链。 合理使用第三方模块上面看到有一个momentjs还是挺大的。但是我的项目中使用momentjs就是用来处理了时间格式，仅仅是着一个小功能就用这样大的一个库，确实是有一点过分了。所以合理的选择第三方库也是一个优化办法。最终我把 momentjs 替换成了 dateformat 123补充于2020年4月23日16:54:45momentjs 可以 替换成 [dayjs](https://github.com/iamkun/dayjs) 这样处理后，既解决了问题，有减少了不必要的处理。 使用 HappyPack 和 DllPlugin这个方法我这里还没有试过，不过网上有很多这方面的博客，需要的可以去google。以后用到了在进行补充 现成 webpack+antd+react 的架子（补充于2020-4-23 16:59:20）写了一个 webpack+antd+react 的架子，可以查看 react+antd+webpack4 构建项目框架 。不断完善中……","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"react","slug":"react","permalink":"https://blog.lyt007.cn/tags/react/"},{"name":"create-react-app","slug":"create-react-app","permalink":"https://blog.lyt007.cn/tags/create-react-app/"}]},{"title":"Flutter lesson 7: Flutter组件之基础组件（三）","slug":"Flutter-lesson-7-Flutter组件之基础组件（三）","date":"2019-06-19T09:12:52.000Z","updated":"2020-04-23T09:05:46.932Z","comments":true,"path":"技术/Flutter-lesson-7-Flutter组件之基础组件（三）.html","link":"","permalink":"https://blog.lyt007.cn/技术/Flutter-lesson-7-Flutter组件之基础组件（三）.html","excerpt":"","text":"上一节我们介绍了Row, Column, Image, Text四个基础组件，这一节我们来看看下面几个组件。 IconIcon就是图标，字体图标，矢量图。在web前端中我们使用图标可以自己定义字体与SVG，使用阿里图标上面的图标。在Flutter中，google则为我们集成了一些常用的图标。 看看Icon的属性有哪些12345678const Icon( this.icon, &#123; Key key, this.size, this.color, this.semanticLabel, this.textDirection,&#125;) : super(key: key); 我们能够用到的就是 size 与 color 两个属性，第一个是字体。使用Icons类。下面有很多图标。 12345678910111213141516171819child: Column( crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Icon( Icons.speaker, color: Colors.red, size: 100, ),Icon( Icons.star_half, color: Colors.blue, size: 100, ),Icon( Icons.volume_up, color: Colors.red, size: 100, ) ],) 当然，这些都是 Flutter material 中自带的一些图标，如果我们需要自己定义图标怎么弄呢？这也是可以的，就像我们在web中使用 iconfont 一样。 123456789Icon( MyIcons.weChat, color: Colors.green, size: 100,),Icon( MyIcons.qq, color: Colors.blue, size: 100,) 上面的代码中出现了 MyIcons 这个类。哪里来的呢？其实这个是我们自己创建的类，怎么创建的来看看。 12345678910111213141516import 'package:flutter/material.dart';class MyIcons &#123; // 微信图标 static const IconData weChat = const IconData( 0xe63d, fontFamily: \"MyIcons\", matchTextDirection: true ); static const IconData qq = const IconData( 0xe6ca, fontFamily: \"MyIcons\", matchTextDirection: true );&#125; MyIcons 是我们自己创建的类，里面定义了两个Icon，一个名字是weChat，另一个是qq。使用的是IconData这个类创建，里面有三个参数。Icon的Unicode编码，这个在阿里图标上表示在这里 我们把上面的 &amp;# 换成 0 就可以了。 fontFamily呢？是我们自己定义的字体 字体呢就是我们在阿里图标上面下载下来的文件。 这些就是关于 Icon 的简单介绍。 RaisedButton其实这就是一个按钮，一个凸起的材质矩形的按钮。 12345678910111213141516171819202122const RaisedButton(&#123; Key key, @required VoidCallback onPressed, // 按钮点击事件，必选 ValueChanged&lt;bool&gt; onHighlightChanged, //水波纹高亮变化回调,按下返回true,抬起返回false 使用默认值就可以 ButtonTextTheme textTheme, //按钮的主题 Color textColor, //按钮文字的颜色 Color disabledTextColor, //按钮禁用时候文字颜色 Color color, //按钮背景色 Color disabledColor, //按钮禁用时候背景色 Color highlightColor, // 点击或者toch控件高亮的时候显示在控件上面，水波纹下面的颜色 Color splashColor, //水波纹的颜色 Brightness colorBrightness, //按钮主题高亮 double elevation, //按钮下面的阴影 double highlightElevation, //高亮时候的阴影 double disabledElevation, //禁用时候的阴影 EdgeInsetsGeometry padding, ShapeBorder shape, //设置形状 Clip clipBehavior = Clip.none, MaterialTapTargetSize materialTapTargetSize, Duration animationDuration, Widget child, // 子元素，一般是文字，如果是icon，有专门的icon图标&#125;) 属性有很多，能用到的也就那么几个，大部分都是使用的默认值。 下面是App中的源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677child: Column( children: &lt;Widget&gt;[ RaisedButton( onPressed: () &#123;&#125;, child: Text(\"textColor文本的颜色，color背景颜色，highlightColor按钮按下的颜色\"), textColor: Color(0xffff0000), color: Color(0xfff1f1f1), highlightColor: Color(0xff00ff00), ), RaisedButton( onPressed: () &#123;&#125;, child: Text(\"disabledTextColor禁用时文本颜色，disabledColor禁用时背景颜色\"), disabledTextColor: Color(0xff999999), disabledColor: Color(0xffff0000), ), RaisedButton( onPressed: () &#123;&#125;, child: Text(\"splashColor水波的颜色，disabledColor禁用时背景颜色\"), splashColor: Color(0xffff0000), ), RaisedButton( onPressed: () &#123;&#125;, child: Text(\"colorBrightness按钮主题高亮 Brightness.light\"), colorBrightness: Brightness.light, ), RaisedButton( onPressed: () &#123;&#125;, child: Text(\"colorBrightness按钮主题高亮 Brightness.dark\"), colorBrightness: Brightness.dark, ), Container( margin: EdgeInsets.only(top: 20.0), child: RaisedButton( onPressed: () &#123;&#125;, child: Text( \"elevation按钮下面的阴影,highlightElevation高亮时候的阴影,disabledElevation按下的时候的阴影\"), elevation: 5.0, ), ), Container( margin: EdgeInsets.only(top: 20.0), child: RaisedButton( onPressed: () &#123;&#125;, child: Text( \"elevation按钮下面的阴影,highlightElevation高亮时候的阴影,disabledElevation按下的时候的阴影\"), highlightElevation: 5, ), ), Container( margin: EdgeInsets.only(top: 20.0), child: RaisedButton( onPressed: () &#123;&#125;, child: Text( \"elevation按钮下面的阴影,highlightElevation高亮时候的阴影,disabledElevation按下的时候的阴影\"), disabledElevation: 5.0, ), ), RaisedButton( onPressed: () &#123;&#125;, child: Text( \"onHighlightChanged 水波纹高亮变化回调,按下返回true,抬起返回false\"), onHighlightChanged: (bool b) =&gt; Fluttertoast.showToast( msg: '$b', toastLength: Toast.LENGTH_LONG, fontSize: 12 ), ), RaisedButton( onPressed: () =&gt; Fluttertoast.showToast( msg: '你点击了按钮', toastLength: Toast.LENGTH_LONG, fontSize: 12 ), child: Text(\"onPressed点击事件\"), ), ],)v 就像上面的代码中看到的，除了onPressed是必选以外，其余的属性基本上用的不是特别的多，有一些没有涉及到的属性，有兴趣可以自己下来了解。 Scaffold之前简单提到过Scaffold，因为我们用到这个Widget的时候实在是太多了。 12345678910111213141516171819const Scaffold(&#123; Key key, this.appBar, this.body, this.floatingActionButton, this.floatingActionButtonLocation, this.floatingActionButtonAnimator, this.persistentFooterButtons, this.drawer, this.endDrawer, this.bottomNavigationBar, this.bottomSheet, this.backgroundColor, this.resizeToAvoidBottomPadding, this.resizeToAvoidBottomInset, this.primary = true, this.drawerDragStartBehavior = DragStartBehavior.start, this.extendBody = false,&#125;) Scaffold可以说是一个容器，里面可以设置很多地方的Widget，比如AppBar，drawer，bottomNavigationBar等等。下面的每一部分又有自己单独的设置方法。还是来看看怎么使用。 AppBar123456789101112131415161718192021AppBar(&#123; Key key, this.leading, this.automaticallyImplyLeading = true, this.title, this.actions, this.flexibleSpace, this.bottom, this.elevation, this.shape, this.backgroundColor, this.brightness, this.iconTheme, this.actionsIconTheme, this.textTheme, this.primary = true, this.centerTitle, this.titleSpacing = NavigationToolbar.kMiddleSpacing, this.toolbarOpacity = 1.0, this.bottomOpacity = 1.0,&#125;) 来看看AppBar中每一部分的布局，下面图片来自Flutter官网 leading正如上面的图片中看到的，这个属性可以设置AppBar左侧的内容 123456789appBar: AppBar( title: Text('AppBar'), leading: IconButton( onPressed: () =&gt; &#123;&#125;, icon: Icon( Icons.nature ), ),), 这里设置的是一个 nature 图标，当然，你也可以设置其他的图标，或者是其他的Widget，文字，图片等等。 automaticallyImplyLeading官方的解释为 Controls whether we should try to imply the leading widget if null 我理解为：如果没有设置leading属性，是否需要将leading默认设置为null。左右可能就是做一个站位。默认是true，使用默认值就行。 title标题。不用多说。 actions正如上面的图片中看到的，这个属性可以设置AppBar中右侧的显示。上面图片中显示了三个，说明这是一个Widget List。 1actions: &lt;Widget&gt;[Icon(Icons.book), Icon(Icons.satellite),Center(child: Text('action'))] flexibleSapce这个最上面的图也有解释。整个AppBar相当于采用flex布局，flexibleSapce空间属于AppBar中除了整个空间。包含了leading，title以及bottom区间。值是一个Widget。 为什么这样说呢？ 12345flexibleSpace: Container( color: Colors.green, // alignment: Alignment.center, child: Text(\"flexibleSpace\")) 上面的代码中我们把alignment属性注释掉了，结果如下 接着我们取消注释 这就是原因。不过这个属性好像不怎么用得着啊。整个AppBar可能用得多的地方就是leading，title和actions了吧。 bottom一个 AppBarBottomWidget 对象，通常是 TabBar。用来在 Toolbar 标题下面显示一个 Tab 导航栏 1234bottom: PreferredSize( child: Text('bottom区间'), preferredSize: Size.fromHeight(100),), 你还可以在bottom中添加TabBar，这样就更加充分利用了bottom这个属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import 'package:flutter/material.dart';void main() =&gt; runApp(ScaffoldInfo());class ScaffoldInfo extends StatelessWidget &#123; ScaffoldInfo(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override Widget build(BuildContext context)&#123; return Scaffold( appBar: AppBar( title: Text(title), ), bottomNavigationBar: Text('1'), body: Container( padding: const EdgeInsets.fromLTRB(20, 10, 20, 10), child: DefaultTabController( length: 6, child: Scaffold( appBar: AppBar( title: Text('AppBar'), leading: IconButton( onPressed: () =&gt; &#123;&#125;, icon: Icon( Icons.nature ), ), automaticallyImplyLeading: true, actions: &lt;Widget&gt;[Icon(Icons.book), Icon(Icons.satellite),Center(child: Text('action'))], flexibleSpace: Container( color: Colors.green, alignment: Alignment.center, child: Text(\"flexibleSpace\") ), bottom: TabBar( isScrollable: true, tabs: &lt;Widget&gt;[ Tab(text: 'Tab 1'), Tab(text: 'Tab 2'), Tab(text: 'Tab 3'), Tab(text: 'Tab 4'), Tab(text: 'Tab 5'), Tab(text: 'Tab 6'), ], ), // elevation: 20, backgroundColor: Colors.red, brightness: Brightness.dark, // centerTitle: true, ), body: TabBarView( children: &lt;Widget&gt;[ Center(child: Text('Tab 1')), Center(child: Text('Tab 2')), Center(child: Text('Tab 3')), Center(child: Text('Tab 4')), Center(child: Text('Tab 5')), Center(child: Text('Tab 6')), ], ) ), ) ) ); &#125;&#125; 这里收涉及到了TabBar以及TabBarView两个类。这里不多讲，需要注意的是这两个都需要设置一个controller属性，如果不设置，可以使用DefaultTabController创建默认的容器。 elevation这个属性是设置整个AppBar的阴影的大小，值是一个double。 下面是设置了elevation: 20,的前后对比，还是使用默认的就可以了 backgroundColorAppBar的背景色。如果flexibleSapce设置了背景色，这个背景色将会被覆盖。 brightnessAppBar的主题，有两个选择，Brightness.dark 或者 Brightness.light。 centerTitle标题是否居中显示，默认值根据不同的操作系统，显示方式不一样。安卓可能在左侧，IOS则是居中。 body主题内容区域，这个区域就不介绍了，body可以设置各种Widget。 floatingActionButton这是一个浮动按钮，注意参数就是一个child（一般是一个Icon），其次就是 onPressed 点击事件。其余的可以使用默认属性，或者你修改一下背景色等等。 1234567891011121314151617const FloatingActionButton(&#123; Key key, this.child, this.tooltip, // 长按时显示的提示 this.foregroundColor, this.backgroundColor, this.heroTag = const _DefaultHeroTag(), //hero效果使用的tag,系统默认会给所有FAB使用同一个tag,方便做动画效果 this.elevation, this.highlightElevation, this.disabledElevation, @required this.onPressed, this.mini = false, this.shape, this.clipBehavior = Clip.none, this.materialTapTargetSize, this.isExtended = false,&#125;) 在右下角增加一个浮动按钮1234floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed: () =&gt; &#123;&#125;,), floatingActionButtonLocation前面讲的是设置一个浮动按钮，这个浮动按钮的位置默认是在右下角。如果是要设置这个浮动按钮的位置，就需要用到FloatingActionButtonLocation 1floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, persistentFooterButtons在footer设置一系列的button，值是一个Widget list 12345persistentFooterButtons: &lt;Widget&gt;[ Icon(Icons.satellite), Icon(Icons.save), Icon(Icons.share),], 在设置bottomNavigationBar的时候，可能页面会很丑，我们可以放弃使用这个属性 drawer 与 endDrawer这两个都是抽屉盒子，drawer是从左往右滑动的时候出现，endDrawer是从右往左画的时候出现123456drawer: Container( child: Text('drawer'),),endDrawer: Container( child: Text('endDrawer'),), 具体的内容还要自己实现。 bottomNavigationBar在底部设置一个导航组件 1234567891011bottomNavigationBar: BottomAppBar( shape: CircularNotchedRectangle(), child: Row( children: [ IconButton(icon: Icon(Icons.home), onPressed: () =&gt; &#123;&#125;), SizedBox(), //中间位置空出 IconButton(icon: Icon(Icons.business), onPressed: () =&gt; &#123;&#125;), ], mainAxisAlignment: MainAxisAlignment.spaceAround, //均分底部导航栏横向空间 ),), 可以看到这样出来的效果很丑，这是因为我们之前设置了persistentFooterButtons这个属性，占据了上面一部分空间。一般这个属性我们都不会设置的，我们把persistentFooterButtons属性注释掉在来看看。 这样看起来好看多了。 bottomSheet底部划出组件，一般很少直接使用，而是使用showModalBottomSheet弹出，比如从底部弹出分享框。 1234567891011121314floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed: () =&gt; showModalBottomSheet( context: context, builder: (BuildContext context) &#123; return new Container( height: 300.0, child: Text('弹出的东东'), ); &#125;, ).then((val) &#123; print(val); &#125;),), 点击 + 按钮会弹出这个 总结Flutter的基础的组件就讲到这里，涉及到的大都是常用的组件，部分东西没有涉及到或者说没有详细说明，可能是因为我认为不用过多说明，可能是因为没有太多时间，也可能是因为我自己也不看明白，如果你不懂，我们可以一起探讨，在评论框留言，有问题我们一起探讨。 在下面的课程中，我们将会介绍一些Flutter的中高级的Widget。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.lyt007.cn/tags/Flutter/"}]},{"title":"桌面浏览器前端优化策略","slug":"桌面浏览器前端优化策略","date":"2019-06-03T14:53:56.000Z","updated":"2020-04-13T03:13:34.971Z","comments":true,"path":"技术/桌面浏览器前端优化策略.html","link":"","permalink":"https://blog.lyt007.cn/技术/桌面浏览器前端优化策略.html","excerpt":"","text":"在前端项目开发完成，我们肯定是需要对前端的项目进行测试优化。我们可以先用一些第三方工具对网站进行分析。工具例如 YSlow：YaHoo发布的一款Firefox的浏览器插件 Google页面访问速度测试，需要小飞机 WHATWG Html 代码检测，这个是关于HTML代码书写规范的检测，算作是补充 其他 这些工具可以对网站的性能进行分析，并提相关的优化建议。 下图是博客在Google页面访问速度测试上面的分析结果以及优化建议，如果你是在做企业的项目，建议你按照上面的建议尽可能的进行优化 那么我们需要说的优化策略总体上分为两大类 网络加载类 页面渲染类 网络加载类减少HTTP请求次数在前端页面中，通常建议尽可能的合并静态资源图片（雪碧图）、javascript或者CSS代码，减少页面请求数量和资源消耗请求，这样可以缩短页面首次访问的用户等待时间。还要尽量的避免重复的资源，防止增加多余的请求。 减少HTTP请求大小减少没必要的图片（使用雪碧图）、javascript、CSS以及HTML代码（移出代码中的注释），对文件进行压缩优化，或者使用gzip有所传输内容等都可以用来减小文件大小，缩短网络传输等待延时。减小文件的大小，就减小了HTTP请求的大小。 将CSS或者javascript代码放到外部文件，通过外链的方式引用，避免直接使用&lt;style&gt;或者&lt;script&gt;标签直接引入在HTML中使用外链的的方式引用资源可以有效的利用浏览器的静态资源缓存。 如果是移动端，有时候若是CSS或者javascript比较简单的情况下为了减少HTTP的请求，也建议将CSS或者javascript代码直接写到&lt;style&gt;或者&lt;script&gt;标签中，放到HTML中。移动端需要根据具体的文件大小以及业务场景来分析。PC端因为网络的原因可以直接通过外链的方式。 避免页面中出现空的 href 和 src当然，这个问题基本上不会出现，但是有时候你可能会一不注意就犯错了。虽说一般不会出现，但还是要说说。 当link标签的href属性为空或者是&lt;script&gt;、&lt;img&gt;、&lt;ifram&gt;标签的src属性为空时，浏览器在渲染的过程中仍会将href属性或者src属性中的空内容进行加载，直到加载失败，这样就阻塞了页面中其他资源的下载进程，可以最总加载的资源又是无效的，所以要避免出现这样的错误。 为HTML指定Cache-control或Expires为HTML设置Cache-control或Expires都可以将HTML页面内容进行缓存，避免重复的想服务器端发送请求 1234&lt;!-- 设置缓存时间 7200ms --&gt;&lt;meta http-equiv=\"Cache-control\" content=\"max-age=7200\"&gt;&lt;!-- 设置过期时间 --&gt;&lt;meta http-equiv=\"Expires\" content=\"Mon, 1 Dec 2020 00:00:00 GMT\"&gt; 如果页面缓存了，浏览器将直接从缓存中读取，不再向服务器发送请求。 合理的设置Etag和Last-Modified合理的设置Etag和Last-Modified使用浏览器缓存，对于未修改的文件，静态资源服务器会向浏览器返回304，让浏览器从缓存中读取文件，减少web资源下载的带宽并降低服务器的负载。1&lt;meta http-equiv=\"Expires\" content=\"Mon, 1 Dec 2020 00:00:00 GMT\"&gt; 使用方法类似于上面的Cache-control或Expires 减少页面重定向页面每次重定向都会延长页面内容返回的等待延时，一次重定向大约需要600ms的开销，为了保证用户尽快看到页面内容，需要尽量避免页面重定向。 使用静态资源分域存放来增加下载并行数浏览器在同一时间向同一个域名请求文件的并行下载数量是有限的，因此可以利用多个域名的主机来存放不同的静态资源，增大页面加载时资源的并行下载数，缩短页面资源加载的时间。通常根据多个域名来分别存储Javascript、CSS和图片文件，尤其是图片文件 使用静态资源CND来存储文件如果条件允许（公司能够支付这一笔费用等），可以利用CND网络加快同一个地区内重复静态资源文件的响应下载速度，缩短资源请求时间。 使用CND Combo 下载传输内容CDN Combo是在CDN服务器端将多个文件请求打包成一个文件的形式来返回的技术，这样可以实现HTTP连续传输的一次性复用，减少浏览器的HTTP请求数，加快资源下载速度。 写法12&lt;link rel=\"stylesheet\" href=\"//g.alicdn.com/msui/sm/0.6.2/css/??sm.min.css,sm-extend.min.css\"&gt;&lt;script type='text/javascript' src='//g.alicdn.com/msui/sm/0.6.2/js/??sm.min.js,sm-extend.min.js' charset='utf-8'&gt;&lt;/script&gt; 上面的一个CSS请求同时返回了sm.min.css,sm-extend.min.css，js请求同时返回了sm.min.js,sm-extend.min.js 下面是淘宝上面的写法 其实这个原理也是在同一并发的时候增加了文件的请求数量。 使用可缓存的AJAX对于返回内容相同的请求，没必要每次都直接才服务器上面拉取，合理的使用AJAX的缓存能加快AJAX的响应素的并减轻服务器的压力。 在发起AJAX请求的时候，添加上cache: true属性即可。 使用GET来完成AJAX请求你可能不知道，使用GET请求比使用POST请求的效率更高。 在使用XMLHttpRequest的时候，浏览器中的POST方法发送请求首先发送文件头，然后发送HTTP正文数据。而使用GET请求时只发送头部信息，所以在拉取服务器端数据时候使用GET的效率更高。 减少Cookie的大小并进行Cookie隔离HTTP请求通常情况下默认会带上浏览器端的Cookie一起发送给服务器，所以在非必要的情况下，要尽量减少Cookie来减小HTTP请求的大小。对于静态资源，尽量使用不同的域名来存放，因为Cookie默认是不能够跨域的，这样就做到了不同域名下静态资源请求的Cookie隔壁。 缩小favicon.ico并缓存有利用重复加载favicon.ico，因为一般一个web应用的 favicon.ico 是很少发生变化的。 推荐使用异步加载javascript资源异步加载Javascript资源不会阻塞文档解析，所以允许在浏览器中有限渲染页面，延时加载脚本。 12&lt;script src='main.js' async/&gt;&lt;script src='main.js' defer/&gt; 使用async时候，加载和渲染后续文档元素的过程和main.js加载与执行是并行的。 使用defer时候，加载和渲染后续文档元素的过程和main.js加载是并行的，main.js的执行要的所有页面元素解析完成后才开始执行。 消除阻塞页面渲染的CSS以及Javascript对于页面中加载时间过长的CSS以及Javascript文件，需要进行合理拆分或延后加载，保证关键路径的资源能快速加载完成。 避免使用 CSS import 引用加载 CSS 资源在CSS中使用@import可以冲另一个样式文件中引入文件，但是这样会增加CSS资源加载的关键路径长度，带有@import的CSS样式需要在CSS文件串行解析到@import时才会加载另外的CSS文件，大大延后CSS渲染完成对的时间。 推荐使用&lt;link/&gt;外链的方式加载CSS文件。如果是在使用SCSS、LESS的CSS预处理工具的时候可以使用@import，因为最后的样式是会被编译的。 页面渲染类把 CSS 资源引用放在HTML文件头部把CSS资源引用放在HTML文件头部，即&lt;head&gt;中，这样浏览器可以优先加载CSS并尽早完成页面渲染。 把 Javascript 资源引用放在HTML文件地底部把CSS资源引用放在HTML文件头部，即&lt;/body&gt;之前，这样防止因为 Javascript 的加载与解析造成的页面阻塞。当然，你也可以使用前面说到的async 和 defer。 不要在HTML中直接缩放图片在HTML中直接缩放图片会导致页面内容的重排重绘，此时可能会使页面中其他的操作产生卡顿。这里的缩放一般指的是用过Javascript代码改变图片的宽高而不是使用CSS3的scale进行缩放，使用CSS3的scale进行缩放不会改变图片占据空间的大小，从而不会造成也，， 重排重绘。 减少DOM元素的数量和深度HTML中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花费的时间就越长，所以要尽可能保持DOM元素简洁和层级较少。 eg.12&lt;!-- 较差，可以直接使用 img 标签而不需要在嵌套一层 div --&gt;&lt;div&gt;&lt;img src='XXX.svg' alt='图片'/&gt;&lt;/div&gt; 尽量避免使用table和iframe等慢元素&lt;table&gt;内容的渲染是将table的DOM渲染树全部生成并一次性绘制到页面上，所以在绘制长表格渲染时会很消耗性能，因该尽量避免使用它，可以考虑使用&lt;ul&gt;代替。 尽量使用异步的方式动态的添加iframe，因为iframe内资源的下载进程会阻塞父页面静态资源的下载与CSS以及HTML DOM的解析。 避免运行耗时的 Javascript长时间运行的Javascript会阻塞浏览器构建DOM树、DOM树渲染、页面渲染。所以，任何与页面初次渲染无关的逻辑功能都应该延时加载。 避免使用CSS表达式或者CSS滤镜CSS表达式或者CSS滤镜的解析渲染速度是比较慢的，在有其他解决方案的情况下要尽量避免使用。 总结以上就是关于PC端前端的优化策略，可能有的地方有错或者你有更好的建议，欢迎在文章下面留言。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"前端优化","slug":"前端优化","permalink":"https://blog.lyt007.cn/tags/前端优化/"}]},{"title":"Flutter lesson 6: Flutter组件之基础组件（二）","slug":"Flutter-lesson-6-Flutter组件之基础组件（二）","date":"2019-05-31T03:05:56.000Z","updated":"2020-04-23T09:05:46.956Z","comments":true,"path":"技术/Flutter-lesson-6-Flutter组件之基础组件（二）.html","link":"","permalink":"https://blog.lyt007.cn/技术/Flutter-lesson-6-Flutter组件之基础组件（二）.html","excerpt":"","text":"上一篇介绍了Container 这一篇我们来看看别的Widget。 RowRow这个Widget其实就是一个布局组件，类似于前端中flex-direction: row;。作用就是可以使Row中的子元素在水平方向上面排列，可以用来做走马灯轮播等效果。 Row可以设置一下几种属性12345678910Row(&#123; Key key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline textBaseline, List&lt;Widget&gt; children = const &lt;Widget&gt;[],&#125;) mainAxisAlignment这个属性在上一节介绍Container的时候已经涉及到了，他就是设置子元素在主轴方向上面的对其方式的。取值的话也是前端中对其方式的几种取值 start end center spaceBetween spaceAround spaceEvenly 唯一不同的是，在Flutter中新增加了一个spaceEvenly属性，即均匀的分配空间 crossAxisAlignment同mainAxisAlignment,不同的是他设置的是从轴方向。取值也有一点不同 start end center stretch : 垂直方向上面拉伸了 baseline 补充：上面说到了主轴从轴，那究竟是什么方向呢？以Row为例，这是一个水平方向上排列的Widget，那么他的主轴就是 horizontal（水平） ，从轴就是 vertical（垂直）。 mainAxisSize这个设置的是主轴的区间大小，值包含min和max两个。 textDirection顾名思义，这个属性设置的是文字的方向，值包含 ltr : 从左往右排列 rtl : 从右往左排列 两个。或许有的朋友觉得没有，那是因为你还没有涉及到从右往左的一个排列的方式。当你遇到阿拉伯语，希伯来语等语言的时候，那这个属性就是一个神器了。关于左右布局的方案可以查看我之前写的关于网站左右布局适配。 verticalDirection这个也是设置文字的方向，不过我觉得这个属性可能用的更少了，值包含 up : 从上往下排列 down : 从下往上排列 textBaseline设置文字的基线。这里的值没有前端中多。仅仅只有两个 alphabetic : 用于对齐字母字符底部的水平线。 ideographic : 用于对齐表意字符的水平线。 这个属性一般不会用到的，但是，如果你要设置 crossAxisAlignment 属性，那么可能需要设置 textBaseline 属性 children这个属性需要牢记，这个是设置Row子元素的属性，值是一个List集合（即数组），每一项都是一个Widget。 123456789child: Column( children: &lt;Widget&gt;[ Center(child: CustomTitle(title: \"说明\")), Text(\"Row是一个布局Widget，相当于是前端CSS3中弹性盒模型布局中：flex-direction: row;作用就是使内容水平方向排列。\"), Row( ) ],), Column如果你掌握了Row，那么Column对你来说就是易如反掌。Row是水平方向上面排列的，而Column则是垂直方向上面排列的。这是他们之前唯一的区别，他们的属性一模一样。这里就不在做过多说明。 Image图片Widget。 1234567891011121314151617const Image(&#123; Key key, @required this.image, // 图片 this.semanticLabel, this.excludeFromSemantics = false, this.width, // 用来指定显示图片区域的宽，并不是图片的宽度，默认图片的宽度 this.height, // 用来指定显示图片区域的高，并不是图片的高度，默认图片的高度 this.color, // 图片颜色，这个可以直接修改图片的颜色，相当于前端设置字体图标 this.colorBlendMode, // 颜色和图片混合，需要配合color使用才会生效 this.fit, // 设置图片填充 this.alignment = Alignment.center, // 用来控制图片摆放的位置 this.repeat = ImageRepeat.noRepeat, // 用来设置图片重复显示（repeat-x水平重复，repeat-y垂直重复，repeat两个方向都重复，no-repeat默认情况不重复） this.centerSlice, // 设置图片内部拉伸，相当于在图片内部设置了一个.9图，但是需要注意的是，要在显示图片的大小大于原图的情况下才可以使用这个属性，要不然会报错 this.matchTextDirection = false, this.gaplessPlayback = false, // 当图片发生改变之后，重新加载图片过程中的样式（1、原图片保留） this.filterQuality = FilterQuality.low, // 图片 filter 质量，用的不多&#125;) Image必须有一个image参数，设置图片，可以是网络图片可以是本地图片。 Image.asset：用来加载本地资源图片，等同于new AssetImage Image.file：用来加载本地（File文件）图片，等同于new FileImage Image.network：用来加载网络图片，等同于new NetworkImage Image.memory：用来加载Uint8List资源（byte数组）图片，等同于new MemoryImage Image.asset（or AssetImage）加载一个本地的资源图片。这里的本地的图片资源指的是什么呢？即你项目中用到的图片，比如logo。注意和接下来讲到的 Image.file 区分。 如果我们需要使用asset类的东西，需要在pubspec.yaml文件中进行配置。如果我们没有修改过初始化后的pubspec.yaml，你会在注释中看到这样的一段注释1234# To add assets to your application, add an assets section, like this:# assets:# - images/a_dot_burr.jpeg# - images/a_dot_ham.jpeg So。如果我们要使用图片，我们需要两个步骤： 在根目录下面新建images文件夹用来存放图片，也可以是其他地方，但是更推荐在根目录中 配置pubspec.yaml 为了更好的适配图片，还是建议使用多套图片，比如images/2.0x和images/3.0x两种类型的图片 pubspec.yaml中配置如下1234assets: - images/logo.png - images/2.0x/logo.png - images/3.0x/logo.png 具体使用就是AssetImage(&#39;images/logo.png) Image.file这个也是设置本地图片，不用于上面的asset，这个一般不会是项目中存在的图片。可以使相册中的图片或者是相机拍照的图片。 还有，你可能需要image_picker这个插件来完成图片的选择以及拍照。这个插件IOS需要配置一下，安卓不用。 注意：在Info.plist中设置权限的时候需要使用英文123456&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;&lt;string&gt;Use the gallery to select phonts&lt;/string&gt;&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;&lt;string&gt;Use the camare to take phonts&lt;/string&gt;&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;&lt;string&gt;Use the Microphone to get voice&lt;/string&gt; Image.network设置网络图片，使用就是直接传入一个网络图片的地址即可1new Image.network('/img/favicon-32x32.png') 使用网络图的时候因为是请求的网络上面的资源，有的时候可能会出现请求失败或者是请求错误的情况，这个时候我们需要使用一个占位图或者说是加载出错显示的图片，那么需要使用到FadeInImage 占位图123456FadeInImage.assetNetwork( placeholder: 'images/logo.png', image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=324769017,4079415235&amp;fm=26&amp;gp=0.jpg', width: 120, fit: BoxFit.fitWidth,) 上面代码中的placeholder属性就是站位属性，站位的图片是一个静态资源图片，你还可以设置透明的占位图。 但是我们无法设置网络图片加载出错显示的图片，这里可是使用第三方的工具cached_network_image1234567new CachedNetworkImage( width: 120, fit: BoxFit.fitWidth, placeholder: new CircularProgressIndicator(), imageUrl: imageUrl, errorWidget: new Icon(Icons.error),) Image.memory加载 Uint8List 图片。用来将一个 byte 数组加载成图片，用法如下：1new Image.memory(bytes) width&lt;Double&gt; and height&lt;Double&gt;这里的 width 和 height 并不是设置图片的宽高，而是设置这个Image容器的宽高，用来显示图片的宽高。123456789Image( image: AssetImage('images/logo.png'), width: 100, height: 100, alignment: Alignment.center, repeat: ImageRepeat.repeat, // fit: BoxFit.cover, filterQuality: FilterQuality.low,) 比如App上面的AssetImage案例 上面设置的图片width和height。但是图片其实是很小的，因为设置了repeat（重复）属性，所以可以看到很多个小图片。如果要设置图片的宽高，可以设置了width和height后在设置fit:BoxFit.cover属性。 semanticLabel&lt;String&gt;图像的语义描述，用于向Andoid上的TalkBack和iOS上的VoiceOver提供图像描述 talkback是一款由谷歌官方开发的系统软件,它的定位是帮助盲人或者视力有障碍的用户提供语言辅助 Voiceover功能是APPLE公司在2009年4月新推出的一种语音辅助程序 excludeFromSemantics&lt;Bool&gt;是否启用图像的语义描述。 color&lt;Colors&gt;颜色。设置图片的颜色，会覆盖图片原有的颜色，像是前端中的字体图标，可以指定颜色。一般会和colorBlendMode配合使用 colorBlendMode&lt;BlendMode&gt;用于将color与此图像组合。 默认为BlendMode.srcIn。在混合模式方面，color是来源，此图像是目的地。 fit&lt;FixBox&gt;图片如何在Image控件中显示，有以下几个值可选123456789enum BoxFit &#123; fill, // 填充整个容器，宽高都不超出容器 contain, // 按宽高中最小的那个来放大 cover, // 按宽高中最大的那个来放大 fitWidth, // 按照width放大 fitHeight, // 按照高度方法 none, // 不填充 scaleDown,&#125; 具体的效果可以查看[] FlutterApp案例源码 alignment用来控制图片的对齐方式，这个属性在介绍Container的时候已经介绍过了，如果你忘了，可以回头看看 repeat设置图片的重复。这个属性就像是CSS中设置背景重复一样包含以上几种属性，一般很少设置重复属性的。 noRepeat: 不设置重复。默认值 repeat: 重复X轴与Y轴 repeatX： 重复X轴 repeatY： 重复Y轴 Image其他的几个属性基本上都用不到。可能会用到的就是上面介绍到的，如果你有兴趣，可以自行了解。以上就是关于Image Widget的简单说明。 TextText Widget用的是非常多的一个组件，要显示文字就需要用到这个组件。使用也是很简单的。1234567891011121314const Text( this.data, &#123; Key key, this.style, this.strutStyle, this.textAlign, this.textDirection, this.locale, this.softWrap, this.overflow, this.textScaleFactor, this.maxLines, this.semanticsLabel,&#125;) 首先需要传一个data，即我们需要显示的文字。接下来就是其中的每一项属性了 textAlign对其方式 left 左对齐 right 右对齐 center 居中 justify 两端对齐 statr 开始对齐，大部分条件下等同于 left end 结束对齐，大部分条件下等同于 right textDirection文字方向，就两个值 ltr 与 rtl locale此属性很少设置，用于选择区域特定字形的语言环境 softWrap某一行中文本过长，是否需要换行。默认为true，如果为false，则文本中的字形将被定位为好像存在无限的水平空间 overflow超出文本的显示方式 TextOverflow.clip 超出部分裁剪 TextOverflow.ellipsis 超出部分显示省略号，用的更多 TextOverflow.fade 超出部分显示透明 textScaleFactor&lt;double&gt;每个逻辑像素的字体像素数。有点像是把文字放大多少倍。 maxLines&lt;int&gt;显示的文本的行数 semanticsLabel图像的语义描述，用于向Andoid上的TalkBack和iOS上的VoiceOver提供图像描述 talkback是一款由谷歌官方开发的系统软件,它的定位是帮助盲人或者视力有障碍的用户提供语言辅助 Voiceover功能是APPLE公司在2009年4月新推出的一种语音辅助程序 style这个属性才是用的更多的一个属性，主要是设置字体的样式，包括但不限于字体，字体大小，颜色，字体类型等。 使用的是TextStyle下面的类123456789101112131415161718192021222324const TextStyle(&#123; this.inherit = true, // 集成父级样式 this.color, // 设置颜色 this.backgroundColor, // 设置背景颜色 this.fontSize, // 设置字体大小 this.fontWeight, // 设置字体粗细 FontWeight.bold this.fontStyle, // 设置字体样式 FontStyle.normal FontStyle.italic斜体 this.letterSpacing, // 设置字间距 this.wordSpacing, // 设置词间距 this.textBaseline, // 文本基线 this.height, // 设置行高 this.locale, // 此属性很少设置，用于选择区域特定字形的语言环境 this.foreground, // 文字的前景色 this.background, // 文字的背景色 this.shadows, // 设置字体阴影 this.decoration, // 上划线，下划线以及删除线 this.decorationColor, // 划线的颜色 this.decorationStyle, // 划线的样式 这个style可能控制画实线，虚线，两条线，点, 波浪线等 this.decorationThickness, this.debugLabel, String fontFamily, // 字体 List&lt;String&gt; fontFamilyFallback, // 多个字体，是一个数组 String package,&#125;) 文字下划线123456789101112131415161718192021children: &lt;Widget&gt;[ Center(child: CustomTitle(title: \"Text Widget\")), TextDemo(), Center(child: Text(text, style: TextStyle( decoration: TextDecoration.lineThrough, decorationColor: Colors.red, decorationStyle: TextDecorationStyle.dotted, fontSize: 20, ))), Center(child: Text(text, style: TextStyle( decoration: TextDecoration.overline, decorationStyle: TextDecorationStyle.dashed, fontSize: 20, ))), Center(child: Text(text, style: TextStyle( decoration: TextDecoration.underline, decorationStyle: TextDecorationStyle.wavy, fontSize: 20, decorationColor: Colors.green ))),] 大部分的文字样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import 'package:flutter/material.dart';void main() =&gt; runApp(TextDemo());class TextDemo extends StatefulWidget &#123; TextDemo(&#123;Key key&#125;) : super(key: key); _TextDemoState createState() =&gt; _TextDemoState();&#125;class _TextDemoState extends State&lt;TextDemo&gt; &#123; TextAlign _textAlign = TextAlign.left; TextDirection _textDirection = TextDirection.ltr; TextOverflow _textOverflow = TextOverflow.visible; @override Widget build(BuildContext context) &#123; return Container( margin: EdgeInsets.only(top: 20), child: Column( children: &lt;Widget&gt;[ Container( width: 200, height: 100, decoration: BoxDecoration( border: Border.all( color: Colors.blue, width: 1, style: BorderStyle.solid ) ), child: Text( '踏浪-所谓天才，不过是每一天的积累成才', textAlign: _textAlign, textDirection: _textDirection, maxLines: 1, overflow: _textOverflow, textScaleFactor: 2, style: TextStyle( color: Colors.blue, backgroundColor: Colors.red ), ), ), ListTile( title: Text('textAlign'), trailing: DropdownButton( value: _textAlign, items: TextAlign.values.map((value) =&gt; DropdownMenuItem( child: Text(value.toString().substring('TextAlign.'.length)), value: value )).toList(), onChanged: (newVal)&#123; if( newVal != null )&#123; setState(() &#123; _textAlign = newVal; &#125;); &#125; &#125;, ) ), ListTile( title: Text('textDirection'), trailing: DropdownButton( value: _textDirection, items: TextDirection.values.map((value) =&gt; DropdownMenuItem( child: Text(value.toString().substring('TextDirection.'.length)), value: value )).toList(), onChanged: (newVal)&#123; if( newVal != null )&#123; setState(() &#123; _textDirection = newVal; &#125;); &#125; &#125;, ) ), ListTile( title: Text('overflow'), trailing: DropdownButton( value: _textOverflow, items: TextOverflow.values.map((value) =&gt; DropdownMenuItem( child: Text(value.toString().substring('TextOverflow.'.length)), value: value )).toList(), onChanged: (newVal)&#123; if( newVal != null )&#123; setState(() &#123; _textOverflow = newVal; &#125;); &#125; &#125;, ) ) ], ), ); &#125;&#125; 以上就是关于Text Widget的简单介绍。 这一节就介绍这四种Widget，后续再来介绍其他的Widget。 如果你喜欢文本，请支持一下博主，谢谢。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.lyt007.cn/tags/Flutter/"}]},{"title":"Flutter lesson 5: Flutter组件之基础组件（一）","slug":"Flutter-lesson-5-Flutter组件之基础组件（一）","date":"2019-05-23T01:35:03.000Z","updated":"2020-04-23T09:05:46.931Z","comments":true,"path":"技术/Flutter-lesson-5-Flutter组件之基础组件（一）.html","link":"","permalink":"https://blog.lyt007.cn/技术/Flutter-lesson-5-Flutter组件之基础组件（一）.html","excerpt":"","text":"说明：在介绍Widget的出后可能会涉及到一些属性，例如 Color, EdgeInsets等等。我会在其中穿插的说明，以后遇到这样的问题就不会再次说明。 ContainerContainer：一个拥有绘制，定位，调整大小的widget。 Container在使用的时候一般不会直接使用其作为容器组件，通常需要有一个父控件。例如：Center, Padding, Colunm, Row, Scaffold等等。 下面是Dart中Container的属性参数1234567891011121314Container(&#123; Key key, this.alignment, this.padding, Color color, Decoration decoration, this.foregroundDecoration, double width, double height, BoxConstraints constraints, this.margin, this.transform, this.child,&#125;) 继承关系 Object -&gt; Diagnosticable -&gt; DiagnosticableTree -&gt; Widget -&gt; StatelessWidget Container 属性colorcolor这个属性在大多数的Widget中都是可以设置的，表示的就是颜色的意思，无论是组件的背景色还是文字的颜色，都是需要用到color属性。但是这里如果要和color属性设置值的话，不会像在前端中一样设置字符串(例如red)或者16进制(例如#FFF)又或者是rgba这样的形式，需要转变一下思维。在Flutter中，这些常用颜色值以及用一个对象保存下来了，那就是Colors。所以我穿插的来讲讲Colors这个对象，看看他的用法。如果foregroundDecoration设置的话，可能会遮盖color效果。 Colors第一种使用方法就是直接调用Colors这个对象，我们可以看到会有提示，提示我们有哪些值 例如上图中的black的值就有好几种。但是我们并不能确定其中的12，26，38这些是什么。其实这些是颜色的透明度（Alpha Or Opacity） 第二种就是使用Color属性自己构建颜色，这里有三种表示方式。下面我们使用这三种方式来表示一个完全不透明的白色 8位16进制表示：0xFFFFFFFF。或许你没有接触过这种表示方式，更多的是使用#FFF或者#FFFFFF的形式表示。这种事ARGB的颜色表示形式，前面的A表示的就是透明度（Alpha Or Opacity），后面的就不用多说了。那前面的A是使用的FF，那是怎么算的哪？简单说明一下。透明度分为256阶（0-255），计算机上面使用16进制表示为（ 00 -ff ）。透明就是0阶，完全不透明就是255阶。加入透明度是50%，那就是256阶的一半。256 / 2 = 128，所以，你以为就是128了么，错了，因为256阶是从0开始的而不是从1开始的，所以还需要减一，就是128 - 1 = 127阶。那127在用16进制表示就是7F。关于10进制与16进制的转行可以前往在线进制转换。Colors中提供的颜色值就是这种方式写的。 .formARGB() : 第二个方法就是使用Color.formARGB(),接收四个参数，A，R，G，B，都是int整型的数字。取值范围都是[0, 255]。第一个A就是上面说到的透明度。 .formRGBO() : 与第二个方法的区别就是透明度放在了最后一个参数，而且值是double类型的。取值范围是[0.0, 1.0]。 这就是Flutter中颜色的集中设置方法。 Child顾名思义，就是设置他的子元素，可以设置也可以不设置，如果不设置，前面也已经说了结果了。 Alignment这个属性是可以设置子元素在Container容器中的对齐方式，值包含以下几种 上面的固定值不做过多说明，来谈谈lerp这个方法。Alignment.lerp(a, b, c)。这个方法相当于是区间取值，方法接收三个参数，前两个就是Alignment的固定的取值，比如说Alignment.center，第三个是一个double类型的数值，取值范围是[0.0, 1.0]。如果值是0.0，那么取a值，如果是1.0，那么取b值。 上面说到了lerp方法，不是那几个固定的值那么她是怎么取值的呢？其实就是取坐标中的点。附上一个图，在举个例子你就明白了 Alignment.topLeft 等价于 Alignment(-1.0, -1.0)。 需要注意的是Alignment直接使用的话，两个参数的取值范围是[-1.0, 1.0]。 下面是App中的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156import 'package:flutter/material.dart';void main() =&gt; runApp(AlignmentInfo());class AlignmentInfo extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _AlignmentInfo(); &#125; &#125;class _AlignmentInfo extends State&lt;AlignmentInfo&gt; &#123; Object position = Alignment.center; double _X = 0.0; double _Y = 0.0; @override Widget build(BuildContext context) &#123; return Center( child: Column( children: &lt;Widget&gt;[ Container( width: 100, height: 100, alignment: position, margin: EdgeInsets.all(10), color: Colors.blue, child: Text('踏浪', style: TextStyle( color: Colors.white, fontSize: 20 )), ), Row( mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ RaisedButton( child: Text('topLeft'), onPressed: () =&gt; setState(() &#123; this.position = Alignment.topLeft; this._X = -1.0; this._Y = -1.0; &#125;), ), RaisedButton( child: Text('topCenter'), onPressed: () =&gt; setState(() &#123; this.position = Alignment.topCenter; this._X = 0.0; this._Y = -1.0; &#125;), ), RaisedButton( child: Text('topRight'), onPressed: () =&gt; setState(() &#123; this.position = Alignment.topRight; this._X = 1.0; this._Y = -1.0; &#125;), ) ] ), Row( mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ RaisedButton( child: Text('centerLeft'), onPressed: () =&gt; setState(() &#123; this.position = Alignment.centerLeft; this._X = -1.0; this._Y = 0.0; &#125;), ), RaisedButton( child: Text('center'), onPressed: () =&gt; setState(() &#123; this.position = Alignment.center; this._X = 0.0; this._Y = 0.0; &#125;), ), RaisedButton( child: Text('centerRight'), onPressed: () =&gt; setState(() &#123; this.position = Alignment.centerRight; this._X = 1.0; this._Y = 0.0; &#125;), ) ] ), Row( mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ RaisedButton( child: Text('bottomLeft'), onPressed: () =&gt; setState(() &#123; this.position = Alignment.bottomLeft; this._X = -1.0; this._Y = 1.0; &#125;), ), RaisedButton( child: Text('bottomCenter'), onPressed: () =&gt; setState(() &#123; this.position = Alignment.bottomCenter; this._X = 0.0; this._Y = 1.0; &#125;), ), RaisedButton( child: Text('bottomRight'), onPressed: () =&gt; setState(() &#123; this.position = Alignment.bottomRight; this._X = 1.0; this._Y = 1.0; &#125;), ) ] ), Container(margin: EdgeInsets.all(10)), Text('Alignment X 的坐标'), Container( margin: EdgeInsets.all(10), child: Slider( value: _X, min: -1.0, max: 1.0, onChanged: (double value) &#123; this.setState(() &#123; this._X = value; this.position = Alignment(value, _Y); &#125;); &#125;, ), ), Text('Alignment Y 的坐标'), Container( margin: EdgeInsets.all(10), child: Slider( value: _Y, min: -1.0, max: 1.0, onChanged: (double value) &#123; this.setState(() &#123; this._Y = value; this.position = Alignment(_X, value); &#125;); &#125;, ), ) ], ), ); &#125;&#125; constraintsconstraints可以对Container元素设置最大最小宽高，使用的是BoxConstraint这个对象 上图中的四个属性就是分别设置最大最小宽高，看属性名字就可以知道，不多说 padding 与 margin在前端中这两个属性可是用的最多的两个属性了。padding是设置元素的内边距，margin是设置元素的外边距。以一个矩形盒子为例，四条边框为边界，边框以外的是外边距，边框以内的是内边距。 不同于前端的是，Flutter中添加边距需要使用到EdgeInsets对象。他有如下几个使用方法 EdgeInsets.all() EdgeInsets.symmetric() EdgeInsets.fromLTRB() EdgeInsets.only() EdgeInsets.all()参数接收一个number类型的值，设置为四周。比如margin: EdgeInsets.all(10.0)就是给元素设置一个10.0的外间距。 EdgeInsets.symmetric()这个可以分别设置水平方向与垂直方向上面的间距1234margin: EdgeInsets.symmetric( vertical: 20, horizontal: 0) 上面的代码中就是设置垂直方向上下间距是20，水平方向上面是0 EdgeInsets.fromLTRB()接收四个参数，分别设置L(left), T(top), R(right), B(bottom)的间距 EdgeInsets.only()设置四个方向上面哪一个不是0，换句话说，没有设置的就是012345678910111213141516171819202122232425262728293031323334353637383940414243444546margin: EdgeInsets.only( left: 10, top: 20)``` 上面的代码中，就是设置元素左，上的间距是10，20，而没有设置的右，下的间距都是0**padding与margin的用法是一样的**## width 与 height这两个属性就不多说了，设置宽高的两个属性，值是`number`## transform`transform`在CSS3中使用的也是非常多的，也包含位移，旋转，缩放等功能。但是使用方法也是和CSS3中略有不同。CSS3中不仅支持关键词还支持`Matrix`矩阵，而Flutter中一般就使用`Matrix4`。![transform](https://pic-go-1253455210.cos.ap-chengdu.myqcloud.com/blog/transform-flutter.gif)属性太多，就不一个一个介绍了，不过大部分的值的参数都是`number`类型的值。更多的属性以及关于矩阵的介绍可以查看[https://juejin.im/post/5be2fd9e6fb9a04a0e2cace0](https://juejin.im/post/5be2fd9e6fb9a04a0e2cace0)。在这里感谢掘金大佬提供的线索。## decoration`decoration`是修饰，装饰的意思，所以，这个属性也是对容器的一个修饰装饰的属性。比如背景图，边框等等这些就是修饰。`decoration`可以使用以下几种，分别介绍一下一下几种修饰的使用方法- BoxDecoration- FlutterLogoDecoration- ShapeDecoration- UnderlineTabIndicator### BoxDecorationBoxDecoration 可以设置一下几种属性```dartconst BoxDecoration(&#123; this.color, // 设置元素背景色 this.image, // 设置元素背景图 this.border, this.borderRadius, this.boxShadow, this.gradient, this.backgroundBlendMode, this.shape = BoxShape.rectangle,&#125;) color设置背景颜色 有一点需要注意的地方，那就是如果你给元素设置了修饰属性，那么你就不能给元素设置color属性了，因为decoration属性中也是可以设置背景颜色的。 image设置背景图片，使用的类是DecorationImage。这个图片会出现在背景色和渐变上层。通常使用NetworkImage(网络图片)和AssetImage(本地图片)。 123image: DecorationImage( image: NetworkImage('https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=324769017,4079415235&amp;fm=26&amp;gp=0.jpg')) 再来看看DecorationImage可以设置的属性123456789const DecorationImage(&#123; @required this.image, this.colorFilter, this.fit, this.alignment = Alignment.center, this.centerSlice, this.repeat = ImageRepeat.noRepeat, this.matchTextDirection = false,&#125;) 唯一要求的就是image这个属性，而image属性如何设置值上面已经提到了。那下面几个属性呢？colorFilter这个属性主要是对图片做处理，比如高亮，改变饱和度等等，这个属性用的不多。使用的话就是ColorFilter这个对象，有很多个值，有兴趣的可以自己试一试。 1234image: DecorationImage( image: NetworkImage('https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=324769017,4079415235&amp;fm=26&amp;gp=0.jpg'), colorFilter: ColorFilter.mode(Colors.red, BlendMode.screen)) 还可能用到的属性就是fit属性。这个有点像CSS3中的background-size属性，可以设置BoxFit.cover，用到的类就是BoxFit。其他的属性就不多说，基本使用默认的值就可以。 borderborder设置边框，用到的就是Border这个类1234border: Border.all( color: Colors.black, width: 10) 你可以使用Flutter给我们封装好的方法比如Border.all，也可以使用Border设置每一个边12345678border: Border( left: BorderSide( color: Colors.red, width: 1, style: BorderStyle.solid ), // other side), 上面的BorderSide,BorderStyle都是Border中的分类。 borderRadius设置容器的圆角1borderRadius: BorderRadius.all(Radius.circular(50)) 你还可以使用BorderRadius.horizontal，BorderRadius.vertical，BorderRadius.only来设置那个角是圆角。 这里关于BoxDecoration的见到介绍就到这里对了，如果你想了解gradient以及更多的其他属性，可以查看简书Flutter之BoxDecoration用法详解，感谢huoshe2019提供的优质文章。 FlutterLogoDecorationFlutterLogoDecoration在盒子修饰中用的不多，更多的是用在Logo的修饰中。而且，如果你一使用这个属性，那么就会出来一个Flutter的图标。123456789Container( width: 300, height: 300, decoration: FlutterLogoDecoration( darkColor: Colors.red, lightColor: Colors.green, textColor: Colors.green ),) ShapeDecorationShapeDecoration的大部分用法和BoxDecoration一直，需要注意的是他没有了设置圆角的功能，但是，border可是设置多个。每一个Border之间用 + 号链接。 123456789101112131415161718decoration: ShapeDecoration( color: Colors.red, shape: Border.all( color: Colors.black, width: 10 ) + Border.all( color: Colors.blue, width: 10 ) + Border.all( color: Colors.green, width: 10 ), image: DecorationImage( image: NetworkImage('https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=324769017,4079415235&amp;fm=26&amp;gp=0.jpg'), colorFilter: ColorFilter.mode(Colors.red, BlendMode.screen), fit: BoxFit.cover )) UnderlineTabIndicator这个属性也是基本上是不会使用的，只是给盒子添加一个下边框线1234567891011Text('UnderlineTabIndicator'),Container( width: 300, height: 300, decoration: UnderlineTabIndicator( borderSide: BorderSide( width: 10, color: Colors.red ) ),) 所以，关于decoration这个属性，需要掌握的更多的还是BoxDecoration这个类，功能比较多，但是常用的属性上面已经介绍到了，如果要想了解更多关于渐变以及图片滤镜方面的知识，可以查看Flutter之BoxDecoration用法详解。 foregroundDecorationforegroundDecoration的使用与decoration的使用时一样的，这里就不做过多的解释。 Container的绘制流程上面了解了Container的一些常用的属性，当时有的可能我们还处于一脸懵逼的状态，比如上面有了decoration，为什么还有使用方法一模一样的foregroundDecoration呢？其实这就和Container的绘制流程有关系。 Container的回执流程如下： 首先会绘制transform效果； 接着绘制decoration； 然后绘制child； 最后绘制foregroundDecoration。 记住这个流程，然后再记住后面的回执的样式会覆盖前面绘制的样式。 关于Container的介绍接到这里，Container是Flutter中非常重要的一个Widget，一定要掌握。 关于同步代码可以查看https://github.com/tal007/FlutterApp。 获取更多关于Flutter的知识点，点击踏浪博客查看。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.lyt007.cn/tags/Flutter/"}]},{"title":"Flutter Lesson 4: Flutter组件之App布局组件","slug":"Flutter-Lesson-4-Flutter组件之App布局组件","date":"2019-05-20T02:50:03.000Z","updated":"2020-04-13T03:13:34.964Z","comments":true,"path":"技术/Flutter-Lesson-4-Flutter组件之App布局组件.html","link":"","permalink":"https://blog.lyt007.cn/技术/Flutter-Lesson-4-Flutter组件之App布局组件.html","excerpt":"","text":"首先来看一下我怎么来学习Flutter，我要了解每一个组件，同时，这又是一个App，所以，我的目标是直接生产一个App，里面就是对Flutter组件的介绍，同时写上一些demo以及源代码，这一个点子源于React Native With Code这一款App，在我学习React Native的时候给予了我很大的帮助。如果要构建这样的一款App，我需要先构建一个App首页，包含了一个可以滚动的列表，如果可以，还可以添加一些其他的组件。以及基础的布局组件。 BuildContext官方文档中说到: A handle to the location of a widget in the widget tree.。这是对BuildContext的解释，他就是字面意思就是：它是整个widget tree中的某一个widget的把手。既然有把手，那么就有位置了，所以说的高深一点就是对构建的所有窗口小部件的树结构中的窗口小部件的位置的引用。 一个 BuildContext 只属于一个小部件。所有你会看到每一个Dart文件中的每一个类都只会有一个BuildContext。 一般 BuildContext 是和 StateLessWidget 使用，下面的写法算得上是一个固定的写法 12345678class MyApp extends StateLessWidget &#123; // @override 验证 @override 下面的方法名是否是你父类中所有的，如果没有则报错 @override // build方法是StateLessWidget的构建方法，传递一个BuildContent暴露其在文档流中的位置 Widget build(BuildContext context)&#123; // do something &#125;&#125; MaterialAppMaterialApp是Google给我们封装好的一个UI库，如果要是有MaterialApp，我们需要在Dart文件的开头引用 import &#39;package:flutter/material.dart&#39;; 使用12345678910class MyApp extends StateLessWidget &#123; // @override 验证 @override 下面的方法名是否是你父类中所有的，如果没有则报错 @override // build方法是StateLessWidget的构建方法，传递一个BuildContent暴露其在文档流中的位置 Widget build(BuildContext context)&#123; return MaterialApp( // 配置属性 ) &#125;&#125; 属性MaterialApp 的属性挺多的，不过常用的可能也就是 home , initialRoute 和 routes。 routes 就有点像react-router-dom，每一个route配置其对应的渲染页面。 下面是MaterialApp支持的属性123456789101112131415161718192021222324252627const MaterialApp(&#123; Key key, this.navigatorKey, this.home, this.routes = const &lt;String, WidgetBuilder&gt;&#123;&#125;, this.initialRoute, this.onGenerateRoute, this.onUnknownRoute, this.navigatorObservers = const &lt;NavigatorObserver&gt;[], this.builder, this.title = '', this.onGenerateTitle, this.color, this.theme, this.darkTheme, this.locale, this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const &lt;Locale&gt;[Locale('en', 'US')], this.debugShowMaterialGrid = false, this.showPerformanceOverlay = false, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false, this.showSemanticsDebugger = false, this.debugShowCheckedModeBanner = true,&#125;) 1234567891011121314151617181920class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context)&#123; return MaterialApp( initialRoute: '/', home:Scaffold( //创建一个Bar，并添加文本 appBar:AppBar( title:Text('Welcome to Flutter'), centerTitle: true, // backgroundColor: Colors.purple, ), //在主体的中间区域，添加一个hello world 的文本 body:Center( child: new HomeList(), ), ), ); &#125;&#125; ScaffoldScaffold的中文意思是脚手架的意思，顾名思义，这个是一个可以快速帮我们构建一个App的脚手架，从而我们不需要自己动手去搭建页面的头部底部或者是右下角按钮等等。悄悄告诉你，其实MaterialApp等大多数Widget中的Child属性返回的都是一个Scaffold。 下面是Scaffold中的一些属性12345678910111213141516171819const Scaffold(&#123; Key key, this.appBar, // 标题栏 this.body, // 内容 this.floatingActionButton, // 悬浮按钮 this.floatingActionButtonLocation, // 悬浮按钮位置 this.floatingActionButtonAnimator, // 悬浮按钮动画 this.persistentFooterButtons, // 底部持久化现实按钮 this.drawer, // 侧滑菜单 左侧 this.endDrawer, // 侧滑菜单 右侧 this.bottomNavigationBar, // 底部导航 this.bottomSheet, this.backgroundColor, // 背景色 this.resizeToAvoidBottomPadding, //自动适应底部padding this.resizeToAvoidBottomInset, this.primary = true, // 使用App主色，App主色在 MaterialApp 中可以设置 this.drawerDragStartBehavior = DragStartBehavior.start, // 抽屉拖拽表现 this.extendBody = false,&#125;) 因为Scaffold更多的相当于一个容器，主要的还是在于里面的内容，所以我们更多的是要去看看它里面的这些属性的用法，因为每一个属性我们都是需要单独的进行配置的。 AppBar这个是可以创建一个App标题栏的Widget，也支持很多的属性123456789101112131415161718192021AppBar(&#123; Key key, this.leading, // 导航widget，一般就是标题栏左侧的返回键 this.automaticallyImplyLeading = true, this.title, // 标题 this.actions, // 右侧附属，比如菜单或者是下拉 this.flexibleSpace, this.bottom, this.elevation, this.shape, this.backgroundColor, this.brightness, this.iconTheme, this.actionsIconTheme, this.textTheme, this.primary = true, this.centerTitle, this.titleSpacing = NavigationToolbar.kMiddleSpacing, this.toolbarOpacity = 1.0, this.bottomOpacity = 1.0,&#125;) 先来了解一下title和centerTitle属性，其余的我们可以在AppBar中详细的了解。 顾名思义，title就是标题的意思，centerTitle就是标题居中的意思。 Text很简单，Text就是文本的意思，我们要显示的文本都是放在Text Widget中的。Text属性也有很多1234567891011121314const Text( this.data, &#123; Key key, this.style, this.strutStyle, this.textAlign, this.textDirection, this.locale, this.softWrap, this.overflow, this.textScaleFactor, this.maxLines, this.semanticsLabel,&#125;) ContainerContainer是容器的意思，主要是负责容器的布局，有点类似HTML中的div标签，可以设置padding和margin。需要注意的是，在Flutter中，少数Widget才可以设置padding和margin，大部分Widget是不行的，所以如果要设置这些属性，我们需要使用Container进行包裹。而不是像HTML中一样，大部分都可以设置padding与margin 1234567891011121314Container(&#123; Key key, this.alignment, this.padding, Color color, Decoration decoration, this.foregroundDecoration, double width, double height, BoxConstraints constraints, this.margin, this.transform, this.child,&#125;) 部分代码展示123456789101112131415161718192021222324252627282930// 首页的ListView组件import 'package:flutter/material.dart';void main() =&gt; runApp(MaterialAppInfo());class MaterialAppInfo extends StatelessWidget &#123; MaterialAppInfo(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override Widget build(BuildContext context)&#123; return MaterialApp( home: Scaffold( appBar: AppBar( title: Text(title), ), body: Container( // padding: const EdgeInsets.fromLTRB(20, 10, 20, 10), child: RaisedButton( onPressed: ()&#123; Navigator.pop(context); &#125;, child: Text( '踏浪' ), ), ), ) ); &#125;&#125; ListView因为首页我们要显示的是一个长列表，所以我们需要使用ListView，这个在Flutter是一个简单的列表组件，Flutter中还包含了其余的多种列表组件，这些以后再介绍。 ListView有三种创建方式，最简单的就是直接使用ListView1234567891011121314151617181920ListView( padding: const EdgeInsets.all(8.0), children: &lt;Widget&gt;[ Container( height: 50, color: Colors.amber[600], child: const Center(child: Text('Entry A')), ), Container( height: 50, color: Colors.amber[500], child: const Center(child: Text('Entry B')), ), Container( height: 50, color: Colors.amber[100], child: const Center(child: Text('Entry C')), ), ],) 因为使用了ListView Widget，接收的不在是一个简单的子元素而是一堆数据，使用是children属性而不再是child了。children接收的是一个&lt;Widget&gt;数组。这是最简单的，但是也是死的。 但是如我我们要进行动态的产生数据，那么就不能一个一个的写死，所以需要使用到ListView.builder。1234567891011121314final List&lt;String&gt; entries = &lt;String&gt;['A', 'B', 'C'];final List&lt;int&gt; colorCodes = &lt;int&gt;[600, 500, 100];ListView.builder( padding: const EdgeInsets.all(8.0), itemCount: entries.length, itemBuilder: (BuildContext context, int index) &#123; return Container( height: 50, color: Colors.amber[colorCodes[index]], child: Center(child: Text('Entry $&#123;entries[index]&#125;')), ); &#125;); itemCount属性是生成的数据条数，一般就是我们ajax请求的数据了。itemBuilder就是构建我们的每一条数据，需要return一个Widget。 ListView还有一个方法ListView.separated。与builder的区别就是他可以画一条分割线，使用这个方法必须给他设置一个separatorBuilder属性，否则会报错。 123456789101112131415final List&lt;String&gt; entries = &lt;String&gt;['A', 'B', 'C'];final List&lt;int&gt; colorCodes = &lt;int&gt;[600, 500, 100];ListView.separated( padding: const EdgeInsets.all(8.0), itemCount: entries.length, itemBuilder: (BuildContext context, int index) &#123; return Container( height: 50, color: Colors.amber[colorCodes[index]], child: Center(child: Text('Entry $&#123;entries[index]&#125;')), ); &#125;, separatorBuilder: (BuildContext context, int index) =&gt; const Divider(),); Navigator最后就是关于路由的部分，来看看下面这张图 首页展示了列表，我们可以点击每一项进入到子页面，这个时候我们就需要使用到路由组件。 我们是点击，然后退出或是返回上一个页面，但是如果我们要添加点击事件，一般的组件还是不行的，需要使用Button才可以添加点击事件，却是没有web前端来的利索。我们这里使用了RaisedButton这个Widget1234567891011121314RaisedButton( onPressed: ()&#123; Navigator.push(context, new MaterialPageRoute( builder: (context) =&gt; new MaterialAppInfo(title: text) )); &#125;, child: Text( text, style: TextStyle( fontSize: 26, color: Colors.blue ), ),) 先来了解两个方法，push和pop。 push推出下一个页面，使用方法就是12345onPressed: ()&#123; Navigator.push(context, new MaterialPageRoute( builder: (context) =&gt; new MaterialAppInfo(title: text) ));&#125; 需要有两个参数，第一个参数context即可，可以理解为context关联上下文，和下一级页面关联起来，以便之后返回。第二个参数需要使用到new MaterialPageRoute调用一个组件，传递一个builder，这是一个函数，返回需要显示的组件即可。关于传值，就在返回的组件中传值即可。 poppop很简单123onPressed: ()&#123; Navigator.pop(context);&#125; 直接使用即可。但是同样需要绑定在按钮Widget下面才可以。 使用固定的路由名上面说到的路由其实只是Navigator的一种，还有一种就是使用固定的路由名，有点像react-router中我们定义一个Router把所有的路由都放在里面 下面看看主入口文件main.dart12345678910111213141516171819import 'package:flutter/material.dart';import './home/index.dart';import 'MaterialApp/index.dart';// 主函数，入口函数void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context)&#123; return MaterialApp( // title: \"Learn Flutter\", routes: &#123; \"materialAppInfo\": (BuildContext context) =&gt; MaterialAppInfo(title: 'materialAppInfo') &#125;, home: HomeList() ); &#125;&#125; 代码中的routes就是路由，如果要跳转到MaterialAppInfo这个页面123onPressed: ()&#123; Navigator.pushNamed(context, 'materialAppInfo');&#125;, 使用Navigator.pushNamed方法，第二个参数就是我们需要跳转的路由。 补充说明（very important）前文们提到了MaterialApp组件，这个组件其实一般就在main.dart中使用一次就可以了，因为如果在一个项目中使用了多次MaterialApp，同时你使用了固定路由配置，即routes配置路由，那么这个配置会以最后一个为参考，可能会出现不可控的错误。 子组件中，你如果首先想到的是时候MaterialApp，那么你可以考虑换成Scaffold或者其他的容器组件 end上面就是关于搭建这样一个App需要了解的一些基本的Widget以及其属性，上面并没有涉及到全部的属性，这些属性我们将在介绍每一个Widget的时候在详细说明，还请持续关注本博客。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.lyt007.cn/tags/Flutter/"}]},{"title":"Flutter Lesson 3：Flutter组件（widget）前篇","slug":"Flutter-Lesson-3：Flutter组件（widget）前篇","date":"2019-05-17T01:16:08.000Z","updated":"2020-04-23T09:05:46.932Z","comments":true,"path":"技术/Flutter-Lesson-3：Flutter组件（widget）前篇.html","link":"","permalink":"https://blog.lyt007.cn/技术/Flutter-Lesson-3：Flutter组件（widget）前篇.html","excerpt":"","text":"介绍完Flutter开发环境的搭建以及Dart基础语法，我们就可以着手进行开发了。一般我们开始学习一门技术或者是一门语言的时候，都会写一个Hello World的Demo。所以，撸起袖子开始干。不过在职之前，我们先来看看Flutter项目的默认文件以及目录结构。 目录结构 图中有几个关键的地方，我们首相来看看这个lib文件夹。这个文件夹里面主要就是存放我们自己编写的的代码了，其中默认有一个main.dart，这个文件是整个项目的入口文件，而且名字就是要是main.dart。还有就是项目的配置文件pubspec.yaml以及Android，IOS两个文件夹，我们在修改一些配置的时候会用到，但是目前用不到。 下面，我们就来看看项目中默认的main.dart文件吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import 'package:flutter/material.dart';// 项目的入口文件void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), // This trailing comma makes auto-formatting nicer for build methods. ); &#125;&#125; 因为我们已经介绍过了Dart的基本的语法，所以上面的代码，大部分你应该是能够看懂的。如果你没有看前面的文章，可以看看Dart语法简介。我们看不明白的可能就是类继承时使用到的 StatelessWidget 和 StatefulWidget 两个类（组件）以及一些Flutter Widget。 StatelessWidget 与 StatefulWidget我们可以根据名字来看，StatelessWidget 和 StatefulWidget 两个组件中都包含 state 和 widget 这两个单词。 state 是状态的意思， widget 是(小)部件的意思。 StatelessWidget : 不可变状态窗口部件，也就是你在使用时不可以改变，比如固定的文字（写上后就在那里了，死也不会变了）。像上面代码中MyApp类就是继承的这个组件，MyApp中也就是固定的文字，主题色等等，这些一般我们都不会改变的。 StatefulWidget : 具有可变状态的窗口部件，也就是你在使用应用的时候就可以随时变化，比如我们常见的进度条，随着进度不断变化。像上面代码中MyHomePage类就是继承的这个组件，因为HomePage中有一个计数的(+号点击)，这个是一个动态的组件，所以我们使用了StatefulWidget。 不管是StatelessWidget,StatefulWidget，还是代码中看到的Center，Column，Text等都是Flutter为我们封装好的Widget，我们可以直接使用，这些组件我们会在以后介绍。 编写Hello World我们修改我们的main.dart文件。 12345678910111213141516171819202122import 'package:flutter/material.dart';// 主函数，入口函数void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context)&#123; return MaterialApp( home:Scaffold( //创建一个Bar，并添加文本 appBar:AppBar( title:Text('Welcome to Flutter'), ), //在主体的中间区域，添加一个hello world 的文本 body:Center( child:Text('Hello World'), ), ), ); &#125;&#125; import &#39;package:flutter/material.dart&#39;;这行代码基本上每一个组件都会用到，因为所有的Widget都在这个包里面。 接下来的日子里，我们就来看看Flutter中都有哪些实用好看的Widget吧","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.lyt007.cn/tags/Flutter/"}]},{"title":"Flutter Lesson 2: Dart 语法简单介绍","slug":"Flutter-Lesson-2：Dart-语法简单介绍","date":"2019-05-13T02:26:45.000Z","updated":"2020-04-13T03:13:34.963Z","comments":true,"path":"技术/Flutter-Lesson-2：Dart-语法简单介绍.html","link":"","permalink":"https://blog.lyt007.cn/技术/Flutter-Lesson-2：Dart-语法简单介绍.html","excerpt":"","text":"Dart语法【Dart中文】可以说是Google因为为Flutter量身定做的一门语言，所以，我们之前基本上都没有接触过这门语言，在入手Flutter坑的时候，还必须了解一下Dart的语言特性。 Dart官网【Dart中文】上面已经有了很详细的说明，我这里只是见多的说说，提取一些重点，以便自己复习以及你们学习。v main每一个.Dart文件都会有一个mian()函数，这个称之为程序的入口文件，这就像是前端ES6语法中的export一样，都要有一个输出。其实，Dart的设计就有一点遵循前端的ES6语法，不过他还结合了一些c语言123456// 程序的入口文件main() &#123; /* 或者用这种注释 */ // main函数输出了一点东西，print 控制台输出 print('我是main函数，我是程序执行的入口');&#125; 代码都可以在DartPad上面运行，你也可以自行修改代码，不过不可能需要开着VPN才可以访问这个网站。 Dart关键字 关键字的意思就不用多说了，注意上图中的关键字，在变量命名的时候不要使用就行了。 重要的概念（重要） 在Dart中，所有的能够使用变量引用的都是对象，每一个对象都有一个实例，包括但不限于数字，方法，字符串，null。所有的对象都集成于Object类。这个需要注意，这个和JavaScript中的变量还是有很大的差别的 虽然Dart是强类型语言，但变量类型是可选的因为Dart可以自动推断变量类型 Dart支持顶层方法（如main方法），也支持类方法或对象方法，同时你也可以在方法内部创建方法 Dart支持顶层变量，也支持类变量或对象变量 Dart中的私有变量用_开头，有点像JS中我们自定义函数的时候默认_开头的为私有变量 Dart中变量可以以字母或下划线开头，后面跟着任意组合的字符或数字，不能使用$，这里面的$一般用于字符串拼接 变量每一种编程语言都会有变量，Dart也不例外，不过Dart的区别就是其声明变量的方式有多种。 var最简单的就是使用var关键字，你也可以使用dynamic,表示没有指定变量类型 12var name = 'tal';dynamic number = 0.5; 使用var定义变量，最好是定义局部变量 默认值如果你在定义了一个变量以后，同时并没有对其进行赋值，那么，这个变量最终的类型会是null(注意不是undefined)。 因为前面我已以及说过了，Dart中所有的变量引用都是对象。 可选类型在声明变量的时候我们可以加上他的类型，这个是google从TS中吸取到的经验123int number = 1;String name = 'tal'; 使用这种方式定义变量可以是全局变量和局部变量，但是如果是使用var定义变量，最好是用于定义局部变量。 Dart中内置了以下几种类型 Number String Boolean List ( means array ) Map Rune ( 用于在字符串中表示 Unicode 字符 ) Symbol 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void main() &#123; dynamic a = '没有指定变量类型'; print(a); // 没有指定变量类型 // number var na = 1; int nb = 2; double nc = 1.2; print(na); // 1 print(nb); // 2 print(nc); // 1.2 // String var sa = 'hello'; String sb = 'world'; print(sa); // hello print(sb); // world// 字符串插值，当然，你也可以使用 + 进行字符串拼接 print('$sa $&#123;sb&#125;'); // hello world // bool var bt = true; bool bf = false; // list var arr = [1, 'a', false]; List&lt;String&gt; arr1 = ['a', 'b', 'c']; List&lt;dynamic&gt; arr2 = [1, 'a', true]; print(arr); // [1, a, false] print(arr1); // [a, b, c] print(arr2); // [1, a, true]// map Map 是一个键值对相关的对象，有点像JS中的Object var person = &#123; \"name\": '踏浪', \"sex\": '男' &#125;; print(person); // &#123;name: 踏浪, sex: 男&#125; var company = new Map(); company['leader'] = '踏浪'; company['money'] = 10000; print(company); // &#123;leader: 踏浪, money: 10000&#125; // runes，Dart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符 var clapping = '\\u&#123;1f44f&#125;'; print(clapping); // 打印的是拍手emoji的表情 // symbols 使用 # 符号获取你 new 的这一个 symbol// 类似于JS中的Symbol，获取方式有点不同。在Dart项目中，获取你从来用不到Symbol print(#s == new Symbol(\"s\")); // true&#125; 需要注意的是，在Dart中，每一个语句结束必须加上 ; 以表示语句结束 final 与 constconst 就是JS中的const，声明一个变量(一般是常量)，从此不再修改。这里把final也放到这里，当然功效也是一样的12345678void main() &#123; var a = 10; final b = a; const c = 10; b = 2; c = 4;&#125; 如果你执行了上面的代码，你将会看到如下的错误 final 在声明的时候更多的声明一个变量，而 const 更多的时候声明的是一个常量，有点像JS中的 let 与 const，例如在Flutter初始化项目的时候有一个这样的代码。 1234567891011121314151617class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); // This widget is the home page of your application. It is stateful, meaning // that it has a State object (defined below) that contains fields that affect // how it looks. // This class is the configuration for the state. It holds the values (in this // case the title) provided by the parent (in this case the App widget) and // used by the build method of the State. Fields in a Widget subclass are // always marked \"final\". final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125; final 与 const的区别 final 要求变量只能初始化一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。而 const 要求在声明时初始化，并且赋值必需为编译时常量 final 是惰性初始化，即在运行时第一次使用前才初始化。而 const 是在编译时就确定值了。 函数Dart中的函数有三种12345678910111213141516171819// 声明返回值类型 intint add1(int a, int b)&#123; return a + b;&#125;// 不声明返回值类型add2(int a, int b)&#123; return a + b;&#125;// 使用箭头函数add3(a, b) =&gt; a + b;void main()&#123; print(add1(1, 2)); // 3 print(add2(1, 1)); // 2 print(add3('hello ', ' world')); // hello world&#125; 需要注意的是，Dart中函数中参数的类型需要有一定的限制，同时num与String是不可相加的123void main()&#123; print(1+'a'); // Error: The argument type 'String' can't be assigned to the parameter type 'num'. print(1+'a');&#125; 函数参数命名参数命名参数是有两种方式 type key 或者是 key: type 的形式，但是都必须使用 {} 括起来，例如12345person(&#123;String name, int age&#125;) =&gt; print('Hello, my name is $name, i am $age.');void main()&#123; person(name: '踏浪', age: 18);&#125; 传递参数的时候使用 key: value 的形式即可。 可选位置参数把一些方法的参数放到 [] 中就变成可选 位置参数了1234567String say(String from, String msg, [String device]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; return result;&#125; 不使用可选参数1print(say('Bob', 'Howdy')) // 'Bob says Howdy' 使用可选参数1print(say('Bob', 'Howdy', 'smoke signal')) // 'Bob says Howdy with a smoke signal' 参数默认值你可以给参数指定默认值，如果传递了参数，那么取代默认值，否则使用默认值123456person(String name = '踏浪') =&gt; 'My name is $name'void main()&#123; print(person()); // My name is 踏浪 print(person('Anthony')); // My name is Anthony&#125; 入口函数每一个.dart文件都应该有一个入口函数，即：12345678void main()&#123; // do something&#125;// 还可以有一个可选参数，参数类型是 Listvoid main(List&lt;String&gt; arguments)&#123; // do something&#125; 一等对象方法可以把方法当做参数调用另外一个方法。例如：12345678printElement(element) &#123; print(element);&#125;var list = [1, 2, 3];// Pass printElement as a parameter.list.forEach(printElement); 匿名函数同样是上面的例子123456var list = [1, 2, 3];// Pass printElement as a parameter.list.forEach((element) &#123; print(element);&#125;); forEach方法中的参数函数就是一个匿名函数 函数返回值所有的函数都有返回值，如果没有指定return语句，那么该函数的返回值为null。 操作符Dart中的操作符在大部分语言中都是有的，可以看看下面的表格|描述|操作符||—|—||unary postfix| expr++ expr– () [] . ?.||unary prefix| -expr !expr ~expr ++expr –expr ||multiplicative| / % ~/||additive| + -||shift| &lt;&lt; &gt;&gt;||bitwise AND| &amp;||bitwise XOR| ^||bitwise OR |||relational and type test| &gt;= &gt; &lt;= &lt; as is is!||equality| == != ||logical AND| &amp;&amp;||logical OR| || ||if null| ??||conditional| expr1 ? expr2 : expr3||cascade| ..||assignment| = = /= ~/= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |= ??=| 常见的就可以不用说了，主要说一下在JS中不怎么常见的。 type tset(类型判断) as：类型转换 is：类型判断，如果对象是指定的类型怎返回 true= is!：类型转换，与is相反 123456if (emp is Person) &#123; // 类型检测 emp.firstName = 'Bob';&#125;// 可以使用以下代码简化上面的代码(emp as Person).firstName = 'Bob'; 注意： 上面这两个代码效果是有区别的。如果 emp 是 null 或者不是 Person 类型， 则第一个示例使用 is 则不会执行条件里面的代码，而第二个情况使用 as 则会抛出一个异常。 赋值操作常用的赋值操作符都是=，dart中有一个??=123a = value; // 给 a 变量赋值b ??= value; // 如果 b 是 null，则赋值给 b； // 如果不是 null，则 b 的值保持不变 级联操作符（cascade） (..)级联操作有点像JQ中的链式调用，不同点是JQ的链式调用需要上一个方法返回这个对象自身，而级联操作是不需要的，使用级联操作后，自动返回自身 如果是在web前端中，我们要获取一个元素，修改他的一些属性12345var img = document.querySelector('img')img.alt = '图片'img.src = 'XXX'img.width = '100'img.height = '100' 如果是使用Dart中的..操作符，可以这样写（这里只是以此为例，不一定存在前端中的document等）12345document.querySelector('img') ..alt = '图片' ..src = 'XXX' ..width = '100' ..height = '100' 流程控制Dart中的流程控制与前端中的流程控制是一样的，也就以下几种 if and if...else for loops while and do-while break and continue switch and case try...catch and try...finally assert 还是有一些不同点的，需要注意 在 switch...case 语句中，case语句中的数据类型必须是跟switch中的类型一致 Dart中还有一个assert（断言），作用是：如果条件表达式结果不满足需要，则可以使用 assert 语句俩打断代码的执行。 12345// 确保 text 不是nunllassert(text != null);// 确保 number 的值 小于100assert(number &lt; 100); 但是：断言只在开发环境有效，如果是生产环境，则无效。 class 类前端在ES6中才引入了类的概念，即使用class关键字创建一个类12345678910111213141516class Point &#123; num x, y = 10; num z = 0; Point(num x, num y) &#123; this.x = x; this.y = y; &#125;&#125;void main()&#123; var p = new Point(1, 3); print(p.x); // 1 print(p.y); // 3 print(p.z); // 0&#125; 在使用class构建一个类的同时，在定义一个与类名字相同的方法就定义了一个构造函数，如上面的Point类中的Point方法。 由于把构造函数参数赋值给实例变量的场景太常见了， Dart 提供了一个语法糖来简化这个操作： 如下面的代码和之前的代码是完全一样的1234567891011121314class Point &#123; num x, y = 10; num z = 0; // 默认的构造方法 Point(this.x, this.y);&#125;void main()&#123; var p = new Point(1, 3); print(p.x); // 1 print(p.y); // 3 print(p.z); // 0&#125; 类的继承如果你是用过react进行开发前端项目，那么你一定对class ... extends ...非常的属性，不错，Dart中也是使用extends继承的 123456789101112class Human &#123; String name; Human.fromJson(Map data) &#123; print(\"Human's fromJson constructor\"); &#125;&#125;class Man extends Human &#123; Man.fromJson(Map data) : super.fromJson(data) &#123; print(\"Man's fromJson constructor\"); &#125;&#125; 由于Human类没有默认构造方法，只有一个命名构造方法 fromJson ，所以在Man类继承Human类时，需要调用父类的fromJson方法做初始化，而且必须使用Man.fromJson(Map data) : super.fromJson(data)这种写法 重定向构造函数有时候一个构造函数会调动类中的其他构造函数。 一个重定向构造函数是没有代码的，在构造函数声明后，使用 冒号 调用其他构造函数。12345678910class Point &#123; num x; num y; // The main constructor for this class. Point(this.x, this.y); // Delegates to the main constructor. Point.alongXAxis(num x) : this(x, 0);&#125; getters and settersgetters 和 setters 是用来设置和访问对象属性的特殊 函数。每个实例变量都隐含的具有一个 getter， 如果变量不是 final 的则还有一个 setter。 你可以通过实行 getter 和 setter 来创建新的属性， 使用 get 和 set 关键字定义 getter 和 setter: 123456789101112131415161718192021class Rectangle &#123; num left; num top; num width; num height; Rectangle(this.left, this.top, this.width, this.height); // Define two calculated properties: right and bottom. num get right =&gt; left + width; set right(num value) =&gt; left = value - width; num get bottom =&gt; top + height; set bottom(num value) =&gt; top = value - height;&#125;main() &#123; var rect = new Rectangle(3, 4, 20, 15); assert(rect.left == 3); rect.right = 12; assert(rect.left == -8);&#125; 抽象函数(抽象类)定义一个抽象类需要使用 abstract 关键字，然后在定义一个方法，类型是 void ，具体是实现，由子类实现1234567891011abstract class Doer &#123; // ...Define instance variables and methods... void doSomething(); // Define an abstract method.&#125;class EffectiveDoer extends Doer &#123; void doSomething() &#123; // ...Provide an implementation, so the method is not abstract here... &#125;&#125; 调用一个没实现的抽象函数会导致运行时异常。 运算符重载如果你定义了一个 Vector 类， 你可以定义一个 + 函数来实现两个向量相加。12345678910111213141516171819202122class Vector &#123; final int x; final int y; const Vector(this.x, this.y); /// Overrides + (a + b). Vector operator +(Vector v) =&gt; new Vector(x + v.x, y + v.y); /// Overrides - (a - b). Vector operator -(Vector v) =&gt; new Vector(x - v.x, y - v.y); printRes()&#123; print('X: $x , Y: $y '); &#125;&#125;main() &#123; final v = new Vector(2, 3); final w = new Vector(2, 2); (v + w).printRes(); // X: 4 (2+2) , Y: 5(3+2) (v - w).printRes(); // X: 0 (2-2) , Y: 1(3-2)&#125; 枚举类枚举类型通常称之为 enumerations 或者 enums， 是一种特殊的类，用来表现一个固定数目的常量。使用enum关键字定义 12345enum Color &#123; red, green, blue&#125; 枚举类型中的每个值都有一个 index getter 函数， 该函数返回该值在枚举类型定义中的位置（从 0 开始）,有点像数组的索引。 枚举类型具有如下的限制： 无法继承枚举类型、无法使用 mixin 、无法实现一个枚举类型 无法显示的初始化一个枚举类型 mixinsMixins 是一种在多类继承中重用 一个类代码的方法。 使用 with 关键字后面为一个或者多个 mixin 名字来使用 mixin。 1234567891011121314151617181920class A &#123; a() &#123; print(\"A's a()\"); &#125;&#125;class B &#123; b() &#123; print(\"B's b()\"); &#125;&#125;// 使用with关键字，表示类C是由类A和类B混合而构成class C = A with B;main() &#123; C c = new C(); c.a(); // A's a() c.b(); // B's b()&#125; 静态函数与变量使用 static 关键字来实现类级别的变量和函数。 12345678910class Person &#123; static String name = '踏浪'; static sayName() &#123; print('我的名字是$name'); &#125;&#125;void main()&#123; print(Person.name); Person.sayName();&#125; 可以看到，静态函数与变量我们可以直接调用，而不需要通过 new 实现实例后在进行处理。 Generics（泛型）1var names = new List&lt;String&gt;(); 上面的代码中，&lt;...&gt;表示的就是这个List中每一项的类型，上面的代码中是String，表示的就是这个List中的每一项都要是String类型，而不能是其他的类型。 泛型是什么呢？泛型就是这一个对象中的内容可以使任何的类型，通常情况下，在&lt;&gt;中使用一个字母来代表类型参数， 例如 E, T, S, K, 和 V 等。例如&lt;E&gt; 使用泛型的好处： 正确指定泛型类型会产生更好的生成代码。 泛型可以减小代码的复杂度 更多的泛型知识可以点击这里查看 Dart库使用 import 来指定一个库如何使用另外 一个库。12import 'dart:html'; // 导入 web 组件库import 'dart:math'; // 导入 数学计算库 更多官方库可以点击查看 我们也可以引用自己的.dart文件，类似于 ES6 中的 import12// add.dartadd(int a, int b) =&gt; a + b; 在另一个文件引入12345import './add.dart';void main()&#123; print(add(1,2));&#125; 使用 as 创建别名12345import 'package:lib1/lib1.dart';import 'package:lib2/lib2.dart' as lib2;// ...Element element1 = new Element(); // Uses Element from lib1.lib2.Element element2 = new lib2.Element(); // Uses Element from lib2. 使用 show and hide 过滤引入内容12345// Import only foo.import 'package:lib1/lib1.dart' show foo;// Import all names EXCEPT foo.import 'package:lib2/lib2.dart' hide foo; 使用 deferred as 来延时载入库1import 'package:deferred/hello.dart' deferred as hello; 异步支持Dart支持ES7的 async await 方法 下面的代码使用Dart从网络获取数据并打印出来12345678910111213import 'dart:async';import 'package:http/http.dart' as http;Future&lt;String&gt; getNetData() async&#123; http.Response res = await http.get(\"http://www.baidu.com\"); return res.body;&#125;main() &#123; getNetData().then((str) &#123; print(str); &#125;);&#125; 以上就是关于Dart语法的简单介绍，想要了解更多，可以参阅Dart官网 注：参考文献 https://www.jianshu.com/p/06aebcad0543 Dart中文 Dart官网","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.lyt007.cn/tags/Flutter/"}]},{"title":"Flutter Lesson 1：Flutter之环境搭建","slug":"Flutter-Lesson-1：Flutter之环境搭建","date":"2019-05-12T04:21:31.000Z","updated":"2020-04-13T03:13:34.963Z","comments":true,"path":"技术/Flutter-Lesson-1：Flutter之环境搭建.html","link":"","permalink":"https://blog.lyt007.cn/技术/Flutter-Lesson-1：Flutter之环境搭建.html","excerpt":"","text":"就在几天前(2019年05月08日)，Google发布了新一版本的Flutter，同时伴随着巨大的更新。之前的Flutter顶多就是跨Android与IOS平台，现在版本的Flutter就牛逼了，还支持了web，桌面以及嵌入式 阮一峰老师也说未来跨平台开发语言框架不再是React Native，而是Flutter，所以Flutter受到更多人的青睐，同时由于Dart语言会的人很少，所以对于大多数程序员来说，我们都是在同一起跑线上面，我也不例外。写教程的目的，一是为了能够熟悉熟悉一下Flutter，同时记录下自己的观点，二是可以为后来成提供一些用得到的东西。 废话不多说，我们先来看看Flutter的开发环境搭建。 Windows首先来说说使用Windows搭建怎么搭建。 FLutter的环境搭建其实还是挺简单的，相比于React Native来说简直是不要不要的。 下载包首先我们需要下载Flutter的运行包，直接去google的Flutter官网下载就可以了。当然，你过你不能够访问google，可以去Flutter中文网中下载。不过我建议，作为程序员，还是可以弄一个VPN。打个广告，冰山互联还不错，5元一个月30G流量已就够了。 下载完成后，建议解压解压放在C盘根目录下面，方便查找，当然你也可以放在其他目录下面，只要不是在Program File(s)下面就行。 。 打开flutter目录，找到flutter_console.bat 双击运行。 这会安装一系列的依赖，如果你是国内用户而没有开VPN，那么你需要设置一下国内镜像 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 配置环境变量安装好Flutter之后，你需要设置一下环境变量。以win10为例，在Cortana中搜索环境变量，进入到环境变量，找到path，添加Flutter目录+\\flutter\\bin 。 需要注意的是，配置完成以后，Flutter只能在Cmd以及pwoershell中生效，其他的第三方Shell例如GitBash以及Cmder等中是无效的。 运行检测打开一个新的Cmd或者powershell，运行以下命令1flutter doctor 这会检测我们的工具是否安装完成。 上面图片中，我们只需要注意两点，一个是安卓SDK，一个是连接设备。至于Android Studio中的 Flutter 以及 Dart Plugin可以暂时不用管。 我这里是安装成功的截图，如果你是第一次安装，那么可能会提示你安装Android SDK，所以我们需要下载安装Android Studio。 下载完成后一步一步安装就行了，这将安装最新的Android SDK，Android SDK平台工具和Android SDK构建工具，这是Flutter为Android开发时所必需的。 之后我们还需要安装一个模拟器设备。 点击create后选择这个手机设备就可以了。 上上述安装完成后可以再次执行flutter doctor看看安装情况。 mac其实mac的相对来说更简单一点，总的步骤与Windows上面基本一致 下载Flutter运行包并解压到适当目录。 配置Flutter的环境变量 当前窗口配置: export PATH=pwd/flutter/bin:$PATH 打开： $HOME/.bash_profile 运行检测 flutter doctor 安装XCode以及IOS模拟器，安装Android Studio以及模拟器 按照上图所示，直接运行命令行即可 配置编辑器作为前端工程师，我一直使用的是VS Code，VS Code的配置相对简单，只需要在插件市场下载Flutter插件以及Dart插件就行。 如果你是使用的 Android Studio 进行开发的，那么你需要在他的插件市场下载 Flutter 以及 Dart 插件，然后启动项目即可。 安装Flutter完成后在VSCode中 Ctrl+Shift+P 搜索Flutter，就会出现一系列的Flutter命名 我们可以选择Flutter：New Project新建一个项目 还有我们可以看到VSCode右下角有一个No Devices的标识，你可以点击 如果你成功的安装了安卓模拟器或者连接了真机，那么就会出俩设备供你选择。当然，你也可以选择Create New。 运行项目在VSCode中，点击左侧菜单栏的调试，在点击调试就可以开始运行项目。但首先要保证有模拟器或者真机连接。 温馨提示：第一次运行有点缓慢，请耐心等待。 至此，项目环境已经搭建完成，后续知识请在后续章节中查看，谢谢。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.lyt007.cn/tags/Flutter/"}]},{"title":"关于网站左右布局适配","slug":"关于网站左右布局适配","date":"2019-05-10T02:42:58.000Z","updated":"2020-04-13T03:13:34.969Z","comments":true,"path":"技术/关于网站左右布局适配.html","link":"","permalink":"https://blog.lyt007.cn/技术/关于网站左右布局适配.html","excerpt":"","text":"缘由新的一年加入新的公司，新的公司做新的项目。公司涉及到的项目基本都是海外的，没有国内的。做过国际化项目的同学应该知道，世界上每个国家的风俗习惯都不同。对于前端开发来说，就网页布局这方面就有正常的ltr布局，即：从左往右布局。但是在一些国家，比如阿拉伯，希伯来等国家，却有着和我们不一样的习惯，遵从了我们老祖先从右往左的阅读习惯，文字也是从右往左书写的习惯，当然是看不懂的。站在前端的角度就是rtl布局。 阿拉伯网站 需要番羽土啬 不难看出来，阿拉伯语的网站的布局样式了，箭头，文字与我们的都是相反的。 公司在做双语app，因为我不知道阿拉伯语是从右往左的阅读，在分析需求的时候也没有人讲明这一点，也是之后才知道，可是那个时候英语的页面布局已近差不多了（这也算是一个坑吧）。所以就要为后面阿语的布局采取解决方案。重写是不可能了，因为已经做了10多个页面了。 下面说一下我的处理方式。 采坑，填坑在网上找了一些资料 阿拉伯语网站 CSS 布局方案 阿拉伯语网站的CSS要点总结 【解决】阿拉伯语等右向左排版文字CSS解决方案 上面的网站其实都是阐明了一个宗旨，我们如果要进行CSS从右往左的布局，那么还需要使用到中国网站基本用不到的一个属性direction，值是ltr或者rtl。 经过自己的摸爬打滚，最终采取了一种方案：direction + 左右对称 + flex布局。 怎么说呢？意思就是我们的方向主要是由direction进行控制，比如我们要ltr布局，我们在只需要对HTML标签进行设置&lt;html dir=&#39;lrt&#39;/&gt;。这样就可以使html的布局成为从左往右布局，当然，html的默认的布局方式就是从左往右布局的。如果是从右往左布局的话，那么dir=&#39;rtl&#39;就可以了。 上面是的html进行属性设置，当然，还可以从CSS入手。 12345678html &#123; direction: ltr;&#125;/* or */html &#123; direction: rtl;&#125; 我建议还是直接写在标签上面，作为一个属性，我们更好获取与动态修改。 这就完了么？其实并没有。 我们来举个🌰： 这样的一个盒子，我们给了他左边距以及上边距各100px，html的布局是ltr 现在我们把html的dir属性改成rtl看看。 结果我们是大失所望。外边距的值仍然是左上两个方向，改变了dir属性以后，还是左上。而我们理想的应该是右上的。 所以我们得出：direction属性虽然可以改变文档的布局方式，但是，这并不能解决我们使用了left，right等位置控制的属性（比如：margin-left,padding-left,定位中的left，还有就是transform中的偏移等等）。 因为这个问题，前人已经为我们提供了一个框架rtlcss。这个框架可以帮我们吧CSS中设置的left和right等控制左右方向的属性互换。或者是使用webpack的rtl插件等也可以。 但是这样也有问题： 一是这样会创建两个CSS包，我们需要根据HTML的语言方向引入不同的CSS包模块。 二是这个插件无法控制js代码中动态生成的left以及right属性，如果是使用js我们也需要进行判断。 direction+左右对称+flex布局来看看如果我们采用direction+左右对称+flex布局来看看 同样是这个盒子，外层套了一个父容器，以供处理弹性盒模型，再给父容器一个内边距，使用flex-direction设置位置。这样在html的dir属性变成rtl后，我们无需改动任何的css样式，仍可以实现从右往左的布局方式。 flex属性的兼容性来看看 在2019这个年代了，大部分的浏览器都支持flex布局了，如果是老版本的浏览器，我们也可以考虑不兼容了，直接放弃这一部分的人，就不能惯着。所以这个模式还是可行的，更适合那些左右对称的布局方式。不过这个方式也有缺点，就是js控制的仍然无法得到合理的处理，如果是js，可以考虑flex。 其他网上还有一些大牛说可以使用css属性的transform，scale和rotate。 这种方式我试过，镜像翻转，这个方式有一个很大的弊端，又或许是我没有找到合适的解决方案。就是如果使用定位，层级高的镜像翻转后会在最下面，控制层级为负数也不一定可以，尤其是使用一些第三方的UI框架的时候。所以我认为目前这种方案可能不合适。 以上就是我关于网站ltr和rtl布局的一些理解和建议，每个方法都可行但是都有弊端，选取合适的方案来高效的开发自己的网站吧。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"布局，CSS","slug":"布局，CSS","permalink":"https://blog.lyt007.cn/tags/布局，CSS/"}]},{"title":"关于转行IT的一些感想","slug":"关于转行IT的一些感想","date":"2019-04-23T14:31:53.000Z","updated":"2020-04-13T03:13:34.969Z","comments":true,"path":"其他/关于转行IT的一些感想.html","link":"","permalink":"https://blog.lyt007.cn/其他/关于转行IT的一些感想.html","excerpt":"","text":"现在是北京时间 2019年4月23日 22:33:34，刚刚解答了一个正在转行Java的年轻人的疑惑。其实他并不是我第一次解疑答惑关于转行IT的人，之前还有3个。而距离我转行IT已经有三年了，所以想要趁着这个机会写一写我的感悟，我怕过了明天我就忘记了。 我的介绍其实我的自我介绍在博客个人中心其实已经有简单的介绍了，这里我还是自我介绍一下把。 我是踏浪，或许有人听过我的名号。我毕业于四川建筑职业技术学院，一个普普通通的大专院校毕业生，和大多数普通人一样，大学的时候没有认真学习的混到了大三，参加了学习的校园招聘，加入公司，进入社会。毕业的时候我进的是中国建筑第六工程局有限公司地铁分公司（以下简称六局），在亲戚朋友的羡慕中进入了国企，央企。 在六局工作了一年多以后我毅然的离职了，此时的亲戚朋友对我又是另一种眼神了，包括我的父母也曾多次劝说我不要离职，在国企带着多好。可是每个人都有梦想，都要想做的事情，所以最终还是在父母亲友的不满与责备中离职，此时的自己犹如重获新生，折断的翅膀再次衔接上，让我振翅高飞，自由翱翔。因为毕竟是自己的第一份工作，离职的时候还是多多少少有些不舍的。 离职后休息了一段时间，就开始了前端之旅。 我的前端学习之路其实在我们离职之后很多人（包括我）都会选择一段旅途让自己放松放松，时间短还可以，但是当你半个月一个月以后，体会到这种一直没有收入，看着自己的储蓄一点点减少甚至是到了拥有负债（不管是父母的钱还是信用卡或者其他机构借的钱）的地步，那么你的内心就会焦躁起来，这时候是多么的渴望拥有一份工种，哪怕工资低的和你一个月的正常消费齐平。 我最开始学习前端是自学的，因为在大学的时候就想要自己写一个淘宝客网站，在六局的时候还在当当上买了一本书：网页设计与前端开发从入门到精通，当时这本书被我看了一遍之后还是有很多的不明白，又反复的看，现在这本书已经被我翻烂了，是真的翻烂的，放在我家的书架上。当时我就觉得我需要有人指点，所以当时选择的一个在线教育的培训机构。为什么是在线教育呢？因为当时工作一年多，自己储蓄不多，而且六局一年转正，作为大专生的我拿了一年的实习工资，扣除了五险一金每个月到手的就只有2000多一点，所以没什么积蓄，也不愿意想父母借钱，只有考虑线上了。 不过当时我看直播可的时候看了不下10节课我就再也没有看过了，因为我个人感觉上课太拖拉，所以就去看以前的视频去了。专心的在家里学习，每天除了吃喝拉撒就是看视频敲代码，每天早上8点到晚上12点，中途累了玩一两把英雄联盟给自己提提神然后继续，有时候一个问题困扰我很久，可能晚上两点过才想明白，然后才瑟瑟发抖（那时候是冬天，而且家里没有空调，门也是漏风的）的钻进被窝，期待着明天造成的阳光。就这样，我坚持了四个月把从0基础都JQ的视频全部看完，并且课堂中的案例也都全部做了一遍，然后就出去找工作了。当然，所说是看视频，但是又不懂的问题还是会主动的去问老师的。 我觉得我的这一段经历我会终身难忘，因为这是我人生的第一个转折点，因为我的决定，我的努力，我的坚持，才有了现在的我。同时也很感谢在我刚刚培训完成能够收留我，并且培养我的潭州教育。 就像我之前写的《都挺好》的感悟一样，我们在对的时间遇到了对的人，并且自己足够努力，那么你终将会不一样。 当然，我写的可能很简单，几分钟的时间就能够读完，但是其中的心酸自有当事人才知道，或许你将来也会知道。 关于目前的IT行业文章开头就说了最近有人直接或者间接的问我关于目前的IT行业，因为他们认为我是一个转行比较成功的人。那么我就来说说吧。 目前的IT行业其实人才挺缺的，尤其是针对于大数据以及人工智能两方面，因为现在社会需要这方面的人才，前端与java方面都是缺乏中级以上的工程师，其他的语言相对来说较好。为什么呢？因为现在的社会与人。 目前市场上的培训机构很多，如果你是打算转行IT的人，全国型机构相信你们多多少少都听说过，还有很多我们都没有听过的地方型机构，比如今天这位朋友说的（聊天记录没找到这个机构的名字），还有我大学同学培训测试的那个机构。太多太多了。同时，因为社会IT行业的发展，工资待遇高，福利好的问题导致大多数的年轻人转行学习IT，甚至有的40岁的人还在转行，尤其是学习java和前端的人居多。因为java用的公司多，前端入门简单。所以目前的行情就是基础的工程师处于饱和甚至溢出的状态，而高级的工程师一直处于稀缺的状态。所以很多刚培训出来的人找不到工作，从而面临再次转行。 所以，如果你有幸的看到我的文章，同时你也打算转行IT行业的话，请你在打算转行或者有转行念头的时候仔细的想一想以下几个问题： 我为什么要转行IT，因为工资高待遇好还是因为我喜欢这个行业。如果只是因为工资待遇的问题，那么我相信我在六局也会有一番成就。 我转行后我还能一直保持积极向上，不断学习的状态么？如果不能，几年之后那么你就会被淘汰。 我能承受住这个行业带来的压力么？比如加班多，现在网上很火的996工作制等等。 我现在的年龄做转行做这个还有必要吗？时间还够吗？ 针对于第四点我想多说说。如果你现在的年纪已经过了30岁了，我建议你不要转行IT了，除非你是特别有自律力，时间规划特别充分，逻辑思维特别好的人，那么你可以。因为如果你此时转行，面临的不仅仅是和20多岁年轻小伙抢工作机会的事件，还有未来的发展，自己的身体种种原因。 所以，如果你要转行，还请郑重的考虑，不仅仅是对自己负责，更是对家人负责。 关于我们的自我提升《羊皮卷》的第一卷就是投资自我，所以，不管你是投资公司还是投资实业，都没有投资自我更有价值。或许你看过很多的理财书籍，受歧视股票，他们都会说到一点，买股票就是投资公司，如果要想选得一家好公司，那么你就需要对公司的经营状况，企业年报，公司盈利情况，负债率等等有一定的了解，虽说不是想专业的证券工作人员那样了解，但是也需要比普通的股民了解的多。但是作为一个外行，我们如果要能够看得懂这些数据，信息，那我们还是得投资自我，看看相关的书籍。 不光光是这些，我们还需要在学习中找到乐趣。 还记得去年8月份的时候在英语流利说App上面购买了499元半年的口语课程，让后按照每周5天的计划进行口语练习，我还真就坚持了半年，拿到了全额返现。期间有的课程我需要两个小时才能够完成，就是那仅仅的一小节。我一直想练习自己的口语，但是一直不知道从何说起，看到有一位朋友购买了流利说课程便咨询了他，他说还不错，我就果断的买入了。起初仅仅是为了能够拿到那500元的返额，但是后来确实越说越有兴趣，到目前为止虽不能听懂所有的英语语句，但是基本的OVA常速以及部分OVA快速都能够听懂，当然，除了不认识的单词。所以课程到期后，我就开始着力于单词的记忆，到目前记单词已经有40多天了。 所以，不管是学什么，做什么，从中找到乐趣，你才有做下去的动力。在使用流利说的期间不仅仅是让我提升了口语能力，更多的是让我养成了一个良好的习惯，每天都有目标，而且今日是今日毕。 还有就是平时有时间多看看有利的书籍，不管是技术方面的还是为人处世方面的，或者说是悬疑小说等等，重要的是我们需要从中学习到一些对自己有用的东西。 最后第一次写这么正式的文章，没有这么写过，大都是这几年来我工作中的自我总结以及感悟吧。如果其中有一些东西对你有帮助，那我很高兴能换帮助到你，如果没有帮助到你，也很感谢你能够抽出时间阅读我的文章。文章中你可能会看到一下机构公司的名字，请不要以为我是在打广告，因为我没有收一分钱，因为他们确实对我有帮助。再次感谢我以前的公司，同事，以及现在公司同事对我职业生涯做出的帮助。 像李开复的《做最好的自己》说的一样，要做最好的自己。每个行业都要人能有成功，因为他们处在了自己所喜爱擅长的领域，发挥了自己的价值，做出了最好的自己，所以，他们成功了。或许未来我也不会在混迹在IT行业，但是我至少现在还在，所以我还有说一句：把握住最好的现在。 最后送上两句话： 第一句是今天记单词打卡的英语语句：You will never know what you can do till you try. – 你永远不知道你可以做，直到你做了。 第二句是我无意中看到的一句话，现在在我的微信个人签名里面：所谓天才，不过是每一天的积累成才。","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.lyt007.cn/categories/其他/"}],"tags":[{"name":"转行","slug":"转行","permalink":"https://blog.lyt007.cn/tags/转行/"}]},{"title":"电视剧《都挺好》","slug":"电视剧《都挺好》","date":"2019-04-09T13:58:04.000Z","updated":"2020-04-13T03:13:34.971Z","comments":true,"path":"影视/电视剧《都挺好》.html","link":"","permalink":"https://blog.lyt007.cn/影视/电视剧《都挺好》.html","excerpt":"","text":"前段时间把火的一塌糊涂的以家庭矛盾为线索的电视剧《都挺好》看完了 故事简介： 表面上无限风光的苏家，随着苏母的突然离世，瞬间分崩离析。意想不到的隐患层层显露，对毫无主见却又自私、小气的苏父的安置和后续生活问题，打破了远在国外的大哥与本城的二哥、小妹三家的平静生活。父亲苏大强终于摆脱了妻子的铁腕，对几个孩子变本加厉，不断提出过分要求。在美国工作的老大苏明哲回到国内，一心要挑起家庭重担，却力不能及不堪重负，致使妻子孩子与其不断疏远。一直啃老的老二苏明成毫无悔改之心，贪慕虚荣一心发财，从而导致事业和家庭的双重惨败。最不受父母待见，十八岁起就和家里断绝经济往来的老小苏明玉，曾发誓与这个家庭划清界限，却因亲情牵绊，再次搅进了苏家的泥潭之中，在苏家的一次次危机中出手相助。最终，苏家人明白到，虽然有血脉相连，但是一家人彼此间的沟通也不能忽视，终于实现了亲情的回归– 来自百度百科 看完之后还是用一定的感悟的，归为一下几点： 真爱生命古话说得好，家家都有一本难念的经，每个家庭的状况都不一样，不管怎么样，我们都要坚强的活着，珍爱生命。苏明玉在18岁之前一直受气，自己的心愿得不到满足，而且母亲连教育经费的不愿意出，重男轻女，还经常被二哥欺负，但是仍然活的好好的。 人生有目标随着故事的发展，苏明玉到了18岁，受到一定的打击之后决心不再用家里一分钱，开始自己打工赚钱，努力学习，甚至有出国的梦想，并且为了这个目标不断的努力奋斗 人生需要导师（我认为这是非常重要的）苏明玉在遇到师傅以前一直都是攒够30W出国的梦想，可是从来没有想过合适才能够攒够这30W，直到遇到师傅，听了师傅的一番话以后改变自己的目标。 我们一生中可能一直都在为着自己的目标不断的奋斗，梦想就是挣很多很多的钱，但是我们却不知道为什么要这样做，如何做，怎么才能实现，直到听到某个人的一句话或者一些分享，我们后有所感悟。可能让我们之前所做的都付诸东流，又或者是如虎添翼，但是他们在我们的人生中起到了非常重要的作用。这个人可能是你的父母，你的老师，你的朋友，也可能是一个陌生人，所以，如果你遇到了这样的一个人，好好珍惜。 敢于推销自己，胆大，果断，有主见，要把握机会苏明玉在听了师傅的一番分析之后，立刻决定把自己给推销给自己的师傅（当时还只是陌生人），所以立刻把自己推销给了这位将来的师傅，所以才有了之后的苏明玉。 所以，现实中我们也需要敢于推销自己，敢于上台，同时也要把握每一个机会。一生中你可能会有很多的机遇，但是我们往往都是在不经意之间就与机会错过。所以我们需要留意生活，争取抓住每一个机会，或许其中一两个，就能给你带来不一样的生活 生活需要奋斗详细苏明玉在遇到师傅之后不会是一帆风顺的，虽然电视剧里面是直接跳过了，但是我们可以回到现实，自己思考一下，如果不是她一直不断努力，不得奋斗，怎么会有现在。包括后来二哥“洗白”，为了事业远去非洲也是一样的。 不要愚孝很简单，不要像大哥一样愚孝，什么无理的要求都答应了父亲。 珍惜眼前人一家人终归是一家人，就算是有不满，不和，但是总会有同甘共苦的时候，总会有美好的回忆。人的一生都不长，在的时候就要好好珍惜，不要以后追悔莫及。 注：以上纯属个人观点与感悟，如果有与你不和的观点，还请口下留情","categories":[{"name":"影视","slug":"影视","permalink":"https://blog.lyt007.cn/categories/影视/"}],"tags":[{"name":"影视","slug":"影视","permalink":"https://blog.lyt007.cn/tags/影视/"},{"name":"电视剧","slug":"电视剧","permalink":"https://blog.lyt007.cn/tags/电视剧/"}]},{"title":"WSL+cmder+oh-my-zsh美化win10命令工具（terminal）","slug":"WSL-cmder-oh-my-zsh美化win10命令工具（terminal）","date":"2019-03-29T03:22:29.000Z","updated":"2020-04-13T03:13:34.966Z","comments":true,"path":"其他/WSL-cmder-oh-my-zsh美化win10命令工具（terminal）.html","link":"","permalink":"https://blog.lyt007.cn/其他/WSL-cmder-oh-my-zsh美化win10命令工具（terminal）.html","excerpt":"","text":"最近在win10下面搭建了一个 WSL+cmder+oh-my-zsh 的程序员命令行环境，为什么呢？还不是买不起mac，加上自己的黑苹果瘫了，所有又回到了win10上面。不过上面不管是Cmd还是PowerShell都是难看的要死要死的，而且很多命令不支持，所以有了这一次的实践。 更新于2019年9月28日之前我们使用的是 cmder 这个工具。 在 windows 1903 以及以后的版本中，可以直接使用windows自带的 windows terminal ，可以直接从windwos 10 的应用商店里面下载。这个比 cmder 用起来更加的便捷。 检查window版本： windows + R 后 输入 winver 安装 windows terminal 以后我们可以自己去配置 terminal 的样式。 修改配置如下，其中 #XXX 为注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447&#123; \"$schema\": \"https://aka.ms/terminal-profiles-schema\", \"globals\" : &#123; \"alwaysShowTabs\" : true, \"copyOnSelect\" : true, \"defaultProfile\" : \"&#123;c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40&#125;\", #默认的终端，点击+号 \"initialCols\" : 120, \"initialRows\" : 30, \"keybindings\" : [ &#123; \"command\" : \"closePane\", \"keys\" : [ \"ctrl+shift+w\" ] &#125;, &#123; \"command\" : \"copy\", \"keys\" : [ \"ctrl+shift+c\" ] &#125;, &#123; \"command\" : \"duplicateTab\", \"keys\" : [ \"ctrl+shift+d\" ] &#125;, &#123; \"command\" : \"newTab\", \"keys\" : [ \"ctrl+shift+t\" ] &#125;, &#123; \"command\" : \"newTabProfile0\", \"keys\" : [ \"ctrl+shift+1\" ] &#125;, &#123; \"command\" : \"newTabProfile1\", \"keys\" : [ \"ctrl+shift+2\" ] &#125;, &#123; \"command\" : \"newTabProfile2\", \"keys\" : [ \"ctrl+shift+3\" ] &#125;, &#123; \"command\" : \"newTabProfile3\", \"keys\" : [ \"ctrl+shift+4\" ] &#125;, &#123; \"command\" : \"newTabProfile4\", \"keys\" : [ \"ctrl+shift+5\" ] &#125;, &#123; \"command\" : \"newTabProfile5\", \"keys\" : [ \"ctrl+shift+6\" ] &#125;, &#123; \"command\" : \"newTabProfile6\", \"keys\" : [ \"ctrl+shift+7\" ] &#125;, &#123; \"command\" : \"newTabProfile7\", \"keys\" : [ \"ctrl+shift+8\" ] &#125;, &#123; \"command\" : \"newTabProfile8\", \"keys\" : [ \"ctrl+shift+9\" ] &#125;, &#123; \"command\" : \"nextTab\", \"keys\" : [ \"ctrl+tab\" ] &#125;, &#123; \"command\" : \"openNewTabDropdown\", \"keys\" : [ \"ctrl+shift+space\" ] &#125;, &#123; \"command\" : \"openSettings\", \"keys\" : [ \"ctrl+,\" ] &#125;, &#123; \"command\" : \"paste\", \"keys\" : [ \"ctrl+shift+v\" ] &#125;, &#123; \"command\" : \"prevTab\", \"keys\" : [ \"ctrl+shift+tab\" ] &#125;, &#123; \"command\" : \"scrollDown\", \"keys\" : [ \"ctrl+shift+down\" ] &#125;, &#123; \"command\" : \"scrollDownPage\", \"keys\" : [ \"ctrl+shift+pgdn\" ] &#125;, &#123; \"command\" : \"scrollUp\", \"keys\" : [ \"ctrl+shift+up\" ] &#125;, &#123; \"command\" : \"scrollUpPage\", \"keys\" : [ \"ctrl+shift+pgup\" ] &#125;, &#123; \"command\" : \"switchToTab0\", \"keys\" : [ \"ctrl+alt+1\" ] &#125;, &#123; \"command\" : \"switchToTab1\", \"keys\" : [ \"ctrl+alt+2\" ] &#125;, &#123; \"command\" : \"switchToTab2\", \"keys\" : [ \"ctrl+alt+3\" ] &#125;, &#123; \"command\" : \"switchToTab3\", \"keys\" : [ \"ctrl+alt+4\" ] &#125;, &#123; \"command\" : \"switchToTab4\", \"keys\" : [ \"ctrl+alt+5\" ] &#125;, &#123; \"command\" : \"switchToTab5\", \"keys\" : [ \"ctrl+alt+6\" ] &#125;, &#123; \"command\" : \"switchToTab6\", \"keys\" : [ \"ctrl+alt+7\" ] &#125;, &#123; \"command\" : \"switchToTab7\", \"keys\" : [ \"ctrl+alt+8\" ] &#125;, &#123; \"command\" : \"switchToTab8\", \"keys\" : [ \"ctrl+alt+9\" ] &#125; ], \"requestedTheme\" : \"system\", \"showTabsInTitlebar\" : true, \"showTerminalTitleInTitlebar\" : true, \"wordDelimiters\" : \" ./\\\\()\\\"'-:,.;&lt;&gt;~!@#$%^&amp;*|+=[]&#123;&#125;~?\\u2502\" &#125;, \"profiles\" : [ &#123; \"acrylicOpacity\" : 0.5, \"backgroundImage\": \"C://Users//Administrator//Pictures//Saved Pictures//2.jpg\", #背景图片 \"backgroundImageOpacity\" : 0.6, #背景透明度 \"background\" : \"#012456\", \"closeOnExit\" : true, \"colorScheme\" : \"Campbell\", \"commandline\" : \"powershell.exe\", \"cursorColor\" : \"#FFFFFF\", \"cursorShape\" : \"bar\", \"fontFace\" : \"Cascadia Code\", #字体 \"fontSize\" : 12, \"guid\" : \"&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;\", #终端唯一编号 \"historySize\" : 9001, \"icon\" : \"ms-appx:///ProfileIcons/&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;.png\", \"name\" : \"Windows PowerShell\", #启动的终端 \"padding\" : \"0, 0, 0, 0\", \"snapOnInput\" : true, \"startingDirectory\" : \"%USERPROFILE%\", \"useAcrylic\" : false, \"tabTitle\" : \"Powershell\" &#125;, &#123; \"acrylicOpacity\" : 0.75, \"backgroundImage\": \"C://Users//Administrator//Pictures//Saved Pictures//1.jpg\", \"backgroundImageOpacity\" : 0.6, \"closeOnExit\" : true, \"colorScheme\" : \"Campbell\", \"commandline\" : \"cmd.exe\", \"cursorColor\" : \"#FFFFFF\", \"cursorShape\" : \"bar\", \"fontFace\" : \"Cascadia Code\", \"fontSize\" : 12, \"guid\" : \"&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;\", \"historySize\" : 9001, \"icon\" : \"ms-appx:///ProfileIcons/&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;.png\", \"name\" : \"cmd\", \"padding\" : \"0, 0, 0, 0\", \"snapOnInput\" : true, \"startingDirectory\" : \"%USERPROFILE%\", \"useAcrylic\" : true &#125;, &#123; \"acrylicOpacity\" : 0.59999999999999998, \"closeOnExit\" : false, \"colorScheme\" : \"Vintage\", \"commandline\" : \"Azure\", \"connectionType\" : \"&#123;d9fcfdfa-a479-412c-83b7-c5640e61cd62&#125;\", \"cursorColor\" : \"#FFFFFF\", \"cursorShape\" : \"bar\", \"fontFace\" : \"Cascadia Code\", \"fontSize\" : 12, \"guid\" : \"&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;\", \"historySize\" : 9001, \"icon\" : \"ms-appx:///ProfileIcons/&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;.png\", \"name\" : \"Azure Cloud Shell\", \"padding\" : \"0, 0, 0, 0\", \"snapOnInput\" : true, \"startingDirectory\" : \"%USERPROFILE%\", \"useAcrylic\" : true &#125;, &#123; \"acrylicOpacity\" : 0.5, \"backgroundImage\": \"C://Users//Administrator//Pictures//Saved Pictures//3.jpg\", \"backgroundImageOpacity\" : 0.4, \"guid\": \"&#123;c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40&#125;\", \"name\": \"Ubuntu-18.04\", \"closeOnExit\" : true, \"colorScheme\" : \"Campbell\", \"cursorColor\" : \"#FFFFFF\", \"cursorShape\" : \"bar\", \"fontFace\" : \"Cascadia Code\", \"fontSize\" : 12, \"source\": \"Windows.Terminal.Wsl\", \"padding\" : \"0, 0, 0, 0\", \"snapOnInput\" : true, \"historySize\" : 9001, \"tabTitle\" : \"Ubuntu (WSL)\", \"useAcrylic\" : false &#125; ], \"schemes\" : [ &#123; \"background\" : \"#0C0C0C\", \"black\" : \"#0C0C0C\", \"blue\" : \"#0037DA\", \"brightBlack\" : \"#767676\", \"brightBlue\" : \"#3B78FF\", \"brightCyan\" : \"#61D6D6\", \"brightGreen\" : \"#16C60C\", \"brightPurple\" : \"#B4009E\", \"brightRed\" : \"#E74856\", \"brightWhite\" : \"#F2F2F2\", \"brightYellow\" : \"#F9F1A5\", \"cyan\" : \"#3A96DD\", \"foreground\" : \"#CCCCCC\", \"green\" : \"#13A10E\", \"name\" : \"Campbell\", \"purple\" : \"#881798\", \"red\" : \"#C50F1F\", \"white\" : \"#CCCCCC\", \"yellow\" : \"#C19C00\" &#125;, &#123; \"background\" : \"#000000\", \"black\" : \"#000000\", \"blue\" : \"#000080\", \"brightBlack\" : \"#808080\", \"brightBlue\" : \"#0000FF\", \"brightCyan\" : \"#00FFFF\", \"brightGreen\" : \"#00FF00\", \"brightPurple\" : \"#FF00FF\", \"brightRed\" : \"#FF0000\", \"brightWhite\" : \"#FFFFFF\", \"brightYellow\" : \"#FFFF00\", \"cyan\" : \"#008080\", \"foreground\" : \"#C0C0C0\", \"green\" : \"#008000\", \"name\" : \"Vintage\", \"purple\" : \"#800080\", \"red\" : \"#800000\", \"white\" : \"#C0C0C0\", \"yellow\" : \"#808000\" &#125;, &#123; \"background\" : \"#282C34\", \"black\" : \"#282C34\", \"blue\" : \"#61AFEF\", \"brightBlack\" : \"#5A6374\", \"brightBlue\" : \"#61AFEF\", \"brightCyan\" : \"#56B6C2\", \"brightGreen\" : \"#98C379\", \"brightPurple\" : \"#C678DD\", \"brightRed\" : \"#E06C75\", \"brightWhite\" : \"#DCDFE4\", \"brightYellow\" : \"#E5C07B\", \"cyan\" : \"#56B6C2\", \"foreground\" : \"#DCDFE4\", \"green\" : \"#98C379\", \"name\" : \"One Half Dark\", \"purple\" : \"#C678DD\", \"red\" : \"#E06C75\", \"white\" : \"#DCDFE4\", \"yellow\" : \"#E5C07B\" &#125;, &#123; \"background\" : \"#FAFAFA\", \"black\" : \"#383A42\", \"blue\" : \"#0184BC\", \"brightBlack\" : \"#4F525D\", \"brightBlue\" : \"#61AFEF\", \"brightCyan\" : \"#56B5C1\", \"brightGreen\" : \"#98C379\", \"brightPurple\" : \"#C577DD\", \"brightRed\" : \"#DF6C75\", \"brightWhite\" : \"#FFFFFF\", \"brightYellow\" : \"#E4C07A\", \"cyan\" : \"#0997B3\", \"foreground\" : \"#383A42\", \"green\" : \"#50A14F\", \"name\" : \"One Half Light\", \"purple\" : \"#A626A4\", \"red\" : \"#E45649\", \"white\" : \"#FAFAFA\", \"yellow\" : \"#C18301\" &#125;, &#123; \"background\" : \"#002B36\", \"black\" : \"#073642\", \"blue\" : \"#268BD2\", \"brightBlack\" : \"#002B36\", \"brightBlue\" : \"#839496\", \"brightCyan\" : \"#93A1A1\", \"brightGreen\" : \"#586E75\", \"brightPurple\" : \"#6C71C4\", \"brightRed\" : \"#CB4B16\", \"brightWhite\" : \"#FDF6E3\", \"brightYellow\" : \"#657B83\", \"cyan\" : \"#2AA198\", \"foreground\" : \"#839496\", \"green\" : \"#859900\", \"name\" : \"Solarized Dark\", \"purple\" : \"#D33682\", \"red\" : \"#DC322F\", \"white\" : \"#EEE8D5\", \"yellow\" : \"#B58900\" &#125;, &#123; \"background\" : \"#FDF6E3\", \"black\" : \"#073642\", \"blue\" : \"#268BD2\", \"brightBlack\" : \"#002B36\", \"brightBlue\" : \"#839496\", \"brightCyan\" : \"#93A1A1\", \"brightGreen\" : \"#586E75\", \"brightPurple\" : \"#6C71C4\", \"brightRed\" : \"#CB4B16\", \"brightWhite\" : \"#FDF6E3\", \"brightYellow\" : \"#657B83\", \"cyan\" : \"#2AA198\", \"foreground\" : \"#657B83\", \"green\" : \"#859900\", \"name\" : \"Solarized Light\", \"purple\" : \"#D33682\", \"red\" : \"#DC322F\", \"white\" : \"#EEE8D5\", \"yellow\" : \"#B58900\" &#125; ]&#125; 上面我们用到了 Cascadia Code 字体。这里在推荐一下这个字体，这个月微软为编程人员出的一款字体，用起来简直舒服。下载地址 安装WSLwin10系统需要更新到1067及其以后的版本，并且是64位的系统才可以安装。相信做开发的都是64位系统吧。 win10打开程序和功能勾选适用于系统的Linux的子系统，然后重启系统。重启以后，此时我们已经可以使用Linux系统，但是我们还差一个系统，所以需要安装一个 我们在win10应用商店里面搜索linux，安装Ubuntu。 安装完成后在开始菜单里面找到程序，启动。 刚开始的时候需要等一下，在配置环境。完成后需要设置用户名以及密码。 安装cmdercmder有两个版本，Mini版与完整版（包含了git以及一些其他的命令）。推荐安装完整版。安装完成后打开，我们需要进行配置一下如上图，在tasks中添加一个task 名字为Ubuntu，这个名字随便你 下面的大框里面set &quot;PATH=%ConEmuBaseDirShort%\\wsl;%PATH%&quot; &amp; %ConEmuBaseDirShort%\\conemu-cyg-64.exe --wsl --distro-guid={9df562ee-848c-4af4-ab4e-aedad54ceba9} -cur_console:pm:/mnt。这里面的9df562ee-848c-4af4-ab4e-aedad54ceba9指的是Ubuntu的唯一标识符，如果重装了子系统，那么这个标识符实惠变得。可以在在注册表(regedit)中查找计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Lxss。win+R搜索regedit。 在常规里面设置刚刚的名字为默认的启动项。如果你要打开其他的，比如cmd，可以点窗口右下角的+，里面有所有的配置。 安装oh-my-zsh在Ubuntu系统中使用命令行而不是win中 安装任何包之前一定要先更新！sudo apt-get update 安装zshsudo apt-get install zsh 安装oh-my-zshsh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 安装成功 如果 遇到证书类似问题apt-get install ca-certificates 自动启动zshvim ~/.bashrc或者nano ~/.bashrc（推荐使用）打开编辑.bashrc文件，添加以下内容：123if test -t 1; then exec zshfi 如果你使用的是vim ~/.bashrc，编辑后使用:wq退出。 如果你使用的是nano ~/.bashrc，使用Ctrl+Shift+X保存并退出。 修改主题：1234nano ~/.zshrc# 主题名字ys，你可以搜索其他的主题使用，ys挺好的ZSH_THEME=\"ys\" 修改以后保存。 终端字体补全sudo apt-get install fonts-powerline 客户端字体补全注意： 有些字符在windows 上无法显示，所以需要安装字体nerdfonts.com，选择 Hack 修改cmder字体为当然，你也可以设置为其他你认为好看的字体。 这个是我的配置的最后的效果，还设置了透明度以及背景什么的，你们也可以自己进行配置。 在VSCode上使用WSL由于博主是做前端开发的，用的是VSCode所以这里说一下，怎么在VSCode上面使用。 在VSCode的设置文件中添加这一句1\"terminal.integrated.shell.windows\": \"C:\\\\\\\\Windows\\\\\\\\System32\\\\\\\\wsl.exe\", 如果需要使用node，npm等工具，WSL里面是不能够直接使用windows自带的这些环境变量的，我们需要在WSL中安装，具体的安装方法可以google–Ubuntu安装软件 说在结尾之前说的字体fonts-powerline，Hack Nerd Font Mono这个字体，其实还是挺好看的，大家可以使用，包括在PC上面也可以。这个字体可以使用Git下载https://github.com/powerline/fonts，不过这个实在是有点慢，这里我已经下载下来放在了这里。 下载下来以后使用PowerShell，到字体目录下，运行以下命令1.\\install.ps1 可能会遇到报错，此时先执行set-Executionpolicy Remotesigned 关于启动时候报错有时候我们启动子系统的时候会报错，错误代码：0x800703fa 具体错误内容：WslRegisterDistribution failed with error: 0x800703fa 此时win+R在运行窗口中执行“services.msc”指令，在本地服务中重启 LxssManager 服务即可 参考文献[1]. https://segmentfault.com/a/1190000016827068[2]. https://blog.joaograssi.com/windows-subsystem-for-linux-with-oh-my-zsh-conemu/","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.lyt007.cn/categories/其他/"}],"tags":[{"name":"terminal","slug":"terminal","permalink":"https://blog.lyt007.cn/tags/terminal/"},{"name":"win10","slug":"win10","permalink":"https://blog.lyt007.cn/tags/win10/"},{"name":"WSL","slug":"WSL","permalink":"https://blog.lyt007.cn/tags/WSL/"}]},{"title":"细说前端基础安全知识","slug":"细说前端基础安全知识","date":"2019-03-21T09:21:43.000Z","updated":"2020-04-13T03:13:34.972Z","comments":true,"path":"其他/细说前端基础安全知识.html","link":"","permalink":"https://blog.lyt007.cn/其他/细说前端基础安全知识.html","excerpt":"","text":"我们先列出常见的几种前端的安全问题，在逐一的解释每一个并谈谈简单的解决思路 XSS（Cross Site Script，跨站脚本攻击） SQL（Structured Query Language，结构化查询语言）注入 CSRF（Cross-site Request Forgery，跨站请求伪造） XSS（Cross Site Script，跨站脚本攻击）XSS通常是由带有页面解析内容的数据未经处理直接插入页面上解析导致的。而XSS根据攻击脚本的引入位置又可以分为以下三种： 存储型XSS 反射性XSS MXSS（DOM XSS） 存储型XSS常常是由前端提交的数据未经处理直接存储到数据库然后从数据库中读取出来后直接插入到页面中导致 例如1234567&lt;!-- 前端模版，content为后台得到的数据 --&gt;&lt;!-- 实际上content的内容为&lt;script&gt;alert(\"\")&lt;/script&gt; --&gt;&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;&lt;!-- 经过解析后，页面上展现的是 --&gt;&lt;div&gt;&lt;script&gt;alert(\"\")&lt;/script&gt;&lt;/div&gt; 上面的代码如果没有对&lt;，&gt;，/进行处理，那么就会直接的运行这一点script代码，这就是一个简单的存储型XSS。 反射性XSS一般产生的原因是在网页URL参数中注入了可解析内容的数据而导致的，如果直接获取URL中不合法的并插入页面中则可能出现页面上的XSS攻击。 MXSS一般是在渲染DOM属性是将攻击脚本插入DOM属性中被解析而导致的。 其实这三种的实质是一样的，都是页面中出现了我们本不想让其执行但是可执行的脚本，主要的防范与解决方法就是验证也，输入到页面上所有内容来源数据是否安全，如果有可能含有脚本标签等内容则需要进行转义。 HTML常见字符的转义123456789101112131415161718192021222324252627// HTML字符转义编码function htmlEncode(str)&#123; let s = ''; if ( str.length === 0 ) return ''; s = str.replace(/&amp;/g, '&amp;amp;'); s = str.replace(/&lt;/g, '&amp;lt;'); s = str.replace(/&gt;/g, '&amp;gt;'); s = str.replace(/ /g, '&amp;nbsp;'); s = str.replace(/\\'/g, '&amp;#39;'); s = str.replace(/\\\"/g, '&amp;quot;'); s = str.replace(/\\n/g, '&lt;br&gt;'); return s&#125;// HTML字符转移解码function htmlDecode(str)&#123; let s = ''; if ( str.length === 0 ) return ''; s = str.replace(/&amp;amp;/g, '&amp;'); s = str.replace(/&amp;lt;/g, '&lt;'); s = str.replace(/&amp;gt;/g, '&gt;'); s = str.replace(/&amp;nbsp;/g, ' '); s = str.replace(/&amp;#39;/g, \"\\'\"); s = str.replace(/&amp;quot;/g, '\\\"'); s = str.replace(/&lt;br&gt;/g, '\\n'); return s&#125; SQL（Structured Query Language，结构化查询语言）注入SQL注入攻击主要是因为页面提交数据到服务器后端，在服务器端未进行数据验证就将数据直接拼接到SQL语句中执行，因此产生执行与预期不同的现象。 主要的防范措施就是对前端网页提交的数据内容进行严格的检查校验。 例如1let sql = `select * from user_table where id=$&#123;id&#125;` 上面的一段查询语句接收一个参数id，如果前端页面所传递的id的值是100 or name=%user%，那么查询的结果就不只是id=100的用户了，所有需要对前端传递的数据进行校验，这一步一般由后台人员处理，不过前端人员也可以做一个简单的验证提示，更重要的还是在后台方面。 CSRF（Cross-site Request Forgery，跨站请求伪造）CSRF指非源站点按照源站点的数据请求格式提交非法数据给源站点服务器的一种攻击方法。通俗的讲就是用户进入一个页面，这个页面不是真正的官方页面，而是模仿度非常高的一个页面，用户认为他就是官网了，此时就是访问了伪站点页面（非源站点），用户提交的数据进过这个页面提交而不是官方提交就是非法提交，而非源站点页面还可以获取用户姓名等重要信息（常见的银行卡密码盗取，支付密码盗取等）。 这种问题常见的解决方法就是通过页面Token提交验证的方式来验证请求是否为源站点页面提交的，来阻止跨站伪请求的发生。Token也是需要进行加密解密的。 最后最后说一点，任何所谓的安全都是相对的，只是理论的破解时间变长了，而不容易被攻击。很多时候需要使用多种方法相结合的方式来一起增加网站的安全性，可以结合验证码等手段大大减少盗刷网站用户信息的频率等。进一步增强网站内容的安全性。","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.lyt007.cn/categories/其他/"}],"tags":[{"name":"前端安全","slug":"前端安全","permalink":"https://blog.lyt007.cn/tags/前端安全/"},{"name":"前端攻防","slug":"前端攻防","permalink":"https://blog.lyt007.cn/tags/前端攻防/"}]},{"title":"如何使用hexo与github搭建自己的博客（2）","slug":"如何使用hexo与github搭建自己的博客（2）","date":"2019-03-02T14:28:29.000Z","updated":"2020-04-23T09:05:46.976Z","comments":true,"path":"其他/如何使用hexo与github搭建自己的博客（2）.html","link":"","permalink":"https://blog.lyt007.cn/其他/如何使用hexo与github搭建自己的博客（2）.html","excerpt":"","text":"接着上一篇的讲，我们把该有的事情都已经准备好了，接下了就是怎么配置我们的博客了 hexo的配置文件是_config.yml，整个hexo项目里面有两个这样的文件，一个是在根目录下面，另一个是在文件夹theme里面，根目录的主要是对整个项目的配置，而theme里面的则主要是对你当前所应用的主题的一个设置。\b 例如：下面的代码就是我的根目录的配置项，写法如此，一个大的属性，大属性下面的小属性前面需要有空格（最后的效果和JSON一样，只不过这样写起来比JSON更直观） 我们说一下其中的一些属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 踏浪个人博客subtitle: 用代码震撼世界description: 踏浪个人博客 -- 用代码震撼世界keywords: 踏浪，IT技术，前端，html，css，js，react，vue，框架author: 踏浪language: - zh-cn - entimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://github.com/tal007root: /permalink: :category/:title.htmlpermalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: 技术category_map: 技术: tech-notes 金融: finance 其他: otherstag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: jsimple# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/tal007/tal007.github.io branch: masterbackup: type: git message: backup my blog https://github.com/tal007 repository: github: https://github.com/tal007/blog.git,master 首先是前面的Site，主要是对整个网站属性的的一些设置，包含网站的标题，【副标题】，描述，关键字等。这一部分很简单 123456# Category &amp; Tagdefault_category: 技术category_map: 技术: tech-notes 金融: finance 其他: others # Category &amp; Tag就是我们的导航，前面的中文是网页上面显示的，后面的是你的关键字，供程序读取识别 最后就是Deployment123456789101112# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/tal007/tal007.github.io branch: masterbackup: type: git message: backup my blog https://github.com/tal007 repository: github: https://github.com/tal007/blog.git,master 主要包含\bdeploy和backup。前一个是我们发布的一个地址，这个地址就是用我们上一节生成的那个带有.github.io的地址。\b后一个呢是我们备份的一个地址，需要注意的是后面的，master。 其他的配置就不多说，在hexo官网上面都是有具体的说明，需要的话可以自己看看。 至于主题下面的配置文件，每个主题\b可能不同，这个需要对照着自己的主题进行修改。 下面说说怎么创建发布在我们的根目录面下有一个文件夹scaffolds。这里面可能自带有一些md文件。其实这些都是我们默认的一些模版。1234567891011121314---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: 踏浪avatar: /images/favicon.pngauthorLink: https://github.com/tal007authorAbout: https://github.com/tal007authorDesc: 转行IT，用代码震撼世界categories: 技术tags:keywords:description: photos:--- 我们一般使用的都是page.md和post.md，这两个我设置的都是一样的，上面的title就是我们通过hexo n 你的心\b新的文档的名字(hexo n 是 hexo new 的简写)命令所输入的title，例如我们本篇文章1hexo n 如何使用hexo与github搭建自己的博客（2） \bdata就是发布时间，这个在配置文件里面可以设置时间格式。其余的属性根据不同的主题需求也是不同的。有一点需要说明，就是categories\b表示这篇文章所述的分类。 使用hexo new命令生成的是一个md格式的文件，接下来我们就是在这个文件里面写我们需要发布的内容 最后通过命令hexo g进行生成静态的文件，执行后可以看见我们的根目录下面多了一个public文件夹，\b我们所需要的html文件都在里面了。 你可以使用hexo s进行本地浏览测试，调试，带到没有问题以后则可以进行发布了。 使用hexo d进行发布，发布的地址就是我们在_config.yml中配置的deploy里面的repo的地址。 待github上面的代码同步了，我们就可以通过访问XXX.github.io进行访问自己的博客了。 最后还有一些关于博客的插件自己的博客的插件可以去hexo插件中去看看，包括评论，时间线等插件，这里就不一一介绍了。 最后说明一下，这里所介绍的知识一些简单的基础，更多的命令以及配置属性都可以上hexo上面看到，希望你有时间\b还是能够看一看，主要就是看看Docs这一部分 关于怎么使用hexo+github搭建自己的博客就先说到这里，如果有需要，以后可能会更新，还请\b随时关注，谢谢。","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.lyt007.cn/categories/其他/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.lyt007.cn/tags/hexo/"}]},{"title":"如何使用hexo与github搭建自己的博客（1）","slug":"如何使用hexo与github搭建自己的博客（1）","date":"2019-03-01T14:00:00.000Z","updated":"2020-04-13T03:13:34.970Z","comments":true,"path":"其他/如何使用hexo与github搭建自己的博客（1）.html","link":"","permalink":"https://blog.lyt007.cn/其他/如何使用hexo与github搭建自己的博客（1）.html","excerpt":"","text":"最近有一批人问我怎么使用hexo搭建博客，因为我的博客就是使用hexo搭建的。这里呢我就简单的说一下因该准备一些什么样的工作 这是我我们的第一节课吧，我们需要做一些什么样的准备 创建一个自己的github主页项目打开github官网，登录自己的账号，并创建一个小的项目（这一步怎么走到这里不进行\b说明） 接着就是按照下面的步骤来，注意红色字的提醒 需要的信息填写完成以后就可以确定提交了 接下来接下来我们需要在电脑本地创建一个项目，这里我们是做博客，那么就创建一个名字为myBlog的文件夹吧 在我们的github上面也需要创建一个项目，\b项目的名字\b也是myBlog，然后把这个项目拉去到自己的本地，这样我们的github上面的项目就在自己的本地了 接下来就是实际的操作了 因为我们使用的是hexo搭建博客，所以命令我们也需要使用hexo命令，这些\b命令可以去hexo官网查看 先来安装hexo，我在在全局安装hexo-cli库，保证我们可以在全局使用hexo命令。12# 这里就不在说明安装git，node等需要的东西npm install -g hexo-cli 安装完成后我们就需要在我们的myBlog文件夹下面执行以下命令，初始化我们的项目1234# floder文件夹名字（English）hexo init &lt;floder&gt;cd &lt;floder&gt;npm install 安装完成后，我们可以看见初始的目录如下12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 最后我们需要做的就是配置我们的项目，这一节我们在下面的章节里面说明","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.lyt007.cn/categories/其他/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.lyt007.cn/tags/hexo/"}]},{"title":"redux_todoList案例","slug":"redux-todoList案例","date":"2019-01-28T08:11:24.000Z","updated":"2020-04-13T03:13:34.967Z","comments":true,"path":"技术/redux-todoList案例.html","link":"","permalink":"https://blog.lyt007.cn/技术/redux-todoList案例.html","excerpt":"","text":"上一节我们说到了redux的基础以及如何理解redux。这一节我们用经典的案例redux-todoList来具体的说一下每一个部分作何解释。 todoList是什么todolist是一个经典的案例，代办项的意思。一般我们初学一门语言的时候基本都是会做一个todoList来验证自己所学的知识。我们这里用来理解redux也是一个不错的方法。 具体的功能可以查看http://www.todolist.cn/。一个输入框，输入代办事件，刚添加的归类到正在进行，我们可以点击具体的莫一项是他变成已完成。 我自己的代码以及托管到了github上面，之后的代码将会以我自己的代码为例，如果需要，可以去想clone。 梳理我们回顾一下之前说redux的三要素：action，reducer，store。我们要完成todolist需要做一下什么呢？\b接下来看看\b具体的步骤。 入口入口，即整个项目的入口文件。我们需要把我们需要的代码render（渲染到具体的某一个\b文件中）1234567891011121314151617181920import React, &#123; PureComponent &#125; from 'react'import ReactDOM from 'react-dom'import &#123;Provider&#125; from 'react-redux'import &#123;createStore&#125; from 'redux'import App from './src/index'import reducer from './src/reducers'require('./src/css/style.scss')const store = createStore(reducer)export default class Home extends PureComponent &#123; render() &#123; return &lt;Provider store=&#123;store&#125;&gt; &lt;App/&gt; &lt;/Provider&gt; &#125;&#125;ReactDOM.render(&lt;Home/&gt;, document.getElementById('root')) 首先是Provider组件，由react-reudx提供，作用就是作为整个项目的跟标签，我们把属性store传递到整个项目中去，供子组件使用。store就是由redux提供的createStore方法创建的。 我们说createStore方法接收一个参数，所有的reducer，那么reducer在哪里呢？接下来就是reducer。 reducer我们说reducer是一个函数，给定一个确定的输入必定有一个确定的输出。他的作用就是操作我们需要的state（状态）。 那么在todolist里面有那几个状态呢？ 所有的代办项，我们用一个数组表示，即todos todos的过滤，即我们当前所处一个\b状态，用visibilityFilter表示。 所以就有了以下的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; combineReducers &#125; from 'redux'let initState = &#123; todos: [], visibilityFilter: \"SHOW_ACTIVE\"&#125;const todos = (state=initState.todos, action) =&gt; &#123; switch (action.type) &#123; case \"ADD_TODO\": // 千万不要使用push，返回的是数组的长度 return [ ...state, &#123; text: action.text, complete: false, index: action.index &#125; ] case \"TOGGLE_TODO\": return state.map((item, index) =&gt; &#123; if( action.index == index ) &#123; return Object.assign(&#123;&#125;, item, &#123; complete: !item.complete &#125;) &#125; return item &#125;) default: return state &#125;&#125;const filterCompleteOrNot = (state=initState.visibilityFilter, action) =&gt; &#123; switch (action.type) &#123; case \"FILTER_COMPLETE_OR_NOT\": return action.filter default: return state &#125;&#125;const todoApp = combineReducers(&#123; todos, filterCompleteOrNot&#125;)export default todoApp 我们给定一个初始的状态initState，里面就有两个属性，todos与visibilityFilter，接下来就是编写纯函数了。 我们根据我们的状态来编写，todos会发生改变，什么情况下面会发生改变呢？ 添加todo 修改todo的状态 所以我们的纯函数是这样写的12345678910111213141516171819202122232425const todos = (state=initState.todos, action) =&gt; &#123; switch (action.type) &#123; case \"ADD_TODO\": // 千万不要使用push，返回的是数组的长度 return [ ...state, &#123; text: action.text, complete: false, index: action.index &#125; ] case \"TOGGLE_TODO\": return state.map((item, index) =&gt; &#123; if( action.index == index ) &#123; return Object.assign(&#123;&#125;, item, &#123; complete: !item.complete &#125;) &#125; return item &#125;) default: return state &#125;&#125; 更具我们操作的动作进行switch判断 接下来就是过滤todos，todos里面要显示那些东西呢12345678const filterCompleteOrNot = (state=initState.visibilityFilter, action) =&gt; &#123; switch (action.type) &#123; case \"FILTER_COMPLETE_OR_NOT\": return action.filter default: return state &#125;&#125; 这就是我们的reducer。因为我们写了两个纯函数，但是在我们创建store的时候，createStore方法只接受一个参数，即所有纯函数的集合。所以我们需要使用redux提供的combineReducers方法把所有的reducer集合起来。1234const todoApp = combineReducers(&#123; todos, filterCompleteOrNot&#125;) action再来看看action，和上面的关联起来了1234567891011121314151617181920212223242526272829let initNumber = 0const addTodo = (text) =&gt; (&#123; text, type: \"ADD_TODO\", index: initNumber++&#125;)const toggleTodo = (index) =&gt; (&#123; index, type: 'TOGGLE_TODO'&#125;)const filterCompleteOrNot = (filter) =&gt; (&#123; filter, type: 'FILTER_COMPLETE_OR_NOT'&#125;)const TODOS_TYPE = &#123; SHOW_ALL: \"SHOW_ALL\", SHOW_COMPLETE: \"SHOW_COMPLETE\", SHOW_ACTIVE: \"SHOW_ACTIVE\"&#125;module.exports = &#123; addTodo, toggleTodo, filterCompleteOrNot, TODOS_TYPE&#125; 我们知道action就是我们集体的操作，有哪一些呢？ 添加todo 修改单个todo的state 过滤todos 所以我们定义了三个action creater123456789101112131415const addTodo = (text) =&gt; (&#123; text, type: \"ADD_TODO\", index: initNumber++&#125;)const toggleTodo = (index) =&gt; (&#123; index, type: 'TOGGLE_TODO'&#125;)const filterCompleteOrNot = (filter) =&gt; (&#123; filter, type: 'FILTER_COMPLETE_OR_NOT'&#125;) 最后就是我们具体的展示层了因为我们使用的是redux，而redux又提倡数据域结构分离，所以在文件目录下面有components与containers两个文件夹。但是普通的component与container没有什么关系，普通的组件里面没有store的dispatch等方法。所以我们在其中的几个文件代码中可以看到mapStateToProps与mapDispatchToProps两个方法。字面意思就是遍历state（dispatch）到props。意思就是把redux中的state与dispatch方法传递到props中（即组件component）。123456789const mapStateToProps = state =&gt; &#123; return (&#123; todos: getVisibleTodos(state.todos, state.filterCompleteOrNot) &#125;)&#125;const mapDispatchToProps = dispatch =&gt; (&#123; toggleTodo: index =&gt; dispatch(toggleTodo(index))&#125;) 但是怎么传递呢？ 在react-redux中，我们使用react-redux提供的connect方法。他的作用就是把component与container链接起来。1234export default connect( mapStateToProps, mapDispatchToProps)(TodoList) connect是一个二阶函数，第一次运行后返回一个函数再次运行。第一个运行的参数就是我们需要传递的两个props，第二次运行的参数就是我们需要传递到的组件。所以在TodoList文件中1234567891011121314151617181920212223import React from 'react'import &#123; ListGroup&#125; from 'react-bootstrap'const TodoList = (&#123;todos, toggleTodo&#125;) =&gt; &#123; return ( &lt;ListGroup&gt; &#123; todos.map((item, index) =&gt; &lt;ListGroup.Item key=&#123;index&#125; onClick=&#123;() =&gt; toggleTodo(item.index)&#125; variant=&#123;item.complete ? 'success' : 'danger'&#125; &gt; &lt;span className='name'&gt;&#123;item.text&#125;&lt;/span&gt; &lt;span className='state'&gt;&#123;item.complete ? '已完成' : '未完成'&#125;&lt;/span&gt; &lt;/ListGroup.Item&gt;) &#125; &lt;/ListGroup&gt; )&#125;export default TodoList 我们才可以使用todos与toggleTodo，因为这两个参数都是我们使用mapStateToProps与mapDispatchToProps得到的。 其他的地方理解是一样的。 至于代码中用到的react-bootstrap，就是bootstrap封装的UI插件，集体可以看react-bootstrap","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"redux","slug":"redux","permalink":"https://blog.lyt007.cn/tags/redux/"}]},{"title":"redux基础","slug":"redux基础","date":"2019-01-19T08:31:53.000Z","updated":"2020-04-13T03:13:34.967Z","comments":true,"path":"技术/redux基础.html","link":"","permalink":"https://blog.lyt007.cn/技术/redux基础.html","excerpt":"","text":"redux概念简介redux是一个专门用于处理数据的第三方库（插件）,作用是使MVM，MVVM等框架使用起来视图与控制层更加明显。很多人听到redux都是因为react-redux这一个插件。其实react-redux只是redux的一部分而已。 redux就像Jquery一样，可以在任何的地方使用，只要你用得到他，就像最开始说的，他就是一个插件而已。 redux的三大要素redux用来处理数据，存在三大要素 如上面图上所示，redux存在三个重要的概念 action reducer store storestore\b的英文的意思是有：贮存, 贮备, 储藏, 存放。所以，我们这里的store也是如此，我们可以把吧他比作是一个仓库。这个仓库的作用就是把所有的我们需要的数据存在起来。拿react举例（这里假如你已经了解过react了），react中的所有的数据都是存放在这个仓库里面。一个项目只有唯一的一个store。 同样是以react为例，那么store里面究竟存放的是什么呢？ 我们知道，在react中，我们控制一个组件是通过\b这个组件内部的\bstate状态来实现的，如果\b我们需要修改一个组件的状态，那么\b我们就需要通过react的setState方法来实现，修改\b组件的状态。那么在redux的store中，这个仓库中存在的就是整个项目的state。当然，这里的\b整个项目的state可以是一个，也可以是无数个（即每一个组件单独的状态），仓库中的数据取决于你的项目。 reducerreducer的英文的意思是：减速器，减压器，还原剂的意思。那么在这里，他表示的是什么呢？其实这里我们也可以把它看做是还原(剂)的意思。即：还原。 那么他是还原的是什么呢？在react里面，还原的就是state。 在redux里面，reducer其实就是一个函数，一个\b纯函数（给定一个输入，必有有且只有一个唯一的输出）拿函数来，输入就是函数的参数，输出就是函数的返回值。\b 在redux里面，每一个reducer的输入都有：状态参数（action）以及目前的state。返回值是一个新的state状态值。这就把\breact中的state单独剥离出来了。 上面说到的\bstore，里面就\b同时也存放了这些reducer。 那么store是怎么来的呢。我们使用redux提供的createStore方法来创建store。 1let store = crateStore(reducers) 所有的reducer我们都需要绑定在一起，使用redux提供的combineReducers把每一个reducer合并成一个对象。 123456import &#123; combineReducers &#125; from 'redux';const reducders = combineReducers(&#123; reducer1, reducer2, ......&#125;) actionaction的意思是：动作，操作。这里也是一样，就是一个动作。 我们在说reducer的时候提到了\baction，action非常简单，我们就把他理解为一个信号表示。为了让程序读懂我们究竟是需要做什么样的动作，我们需要给\b\baction提供一个属性，\b表示他是整个项目中为一个那一个。这个属性\b就是：type。我们还可能给这个action添加一个其他的属性，那么这个action就成了一个对象了。比如： 1234&#123; type: 'ADD_TODO', text: '添加一个新的todo代办项'&#125; 但是这样写的话用起来可能会很麻烦，而且text属性无法进行扩展，所以，在使用action的时候，我们通常还是把它写成一个函数。\b即： 123456789function addTodo(text)&#123; return &#123; type: 'ADD_TODO', text &#125;&#125;# 使用ES6的写法const addTodo = text =&gt; &#123;type: 'ADD_TODO', text&#125; 这就是一个action。 简单的梳理我们用这样一个例子来简单的梳理一下原理。 在一个图书馆里面，有许多的书，他们有的被借阅了，有的仍然在书架上面放着，这些书的状态都在图书馆的电子屏幕上面显示着。这里的图书的是否被借阅的状态我们可以看做是一个state。有三个人甲，乙，丙，甲需要去借书A，借完书以后我们需要让乙和丙都知道图书被借阅了。电子屏幕上面的图上A的状态就会发生变化，即state\u001c的值\b发生了变化。\b这时候甲乙丙三个人都知道了图书A的状态了。这里的甲乙丙三个人可以看做是react中的组件。 但是上面的存在一个问题，甲去借书，不可能借完书就走了，或者直接就去拿书了。这时候我们需要有一个管理者，即reducer。他来判断\b甲是否可以借书，即他来控制图书A的状态而不是甲乙丙（组件）控制图书A的状态。 其次就是甲怎么让管理者知道我要借的书是A而不是其他的\b呢？这时候就需要一个为一个标识（\baction）。{type: ‘A’, name: ‘\b图书A’}。怎么让管理员知道呢？redux提供了createStore方法，这个方法返回了一个方法dispatch，分发的意思。接收一个action，即store.dispatch(action)，执行之后，管理员修改了图书A的状态。 最后，乙和丙怎么知道图书A的状态发生了变化呢？同样，edux提供了createStore方法，这个方法返回了一个方法subscribe，订阅的意思。乙和丙需要订阅图书A的信息才可以接收到图书A的状态变化，即store.subscribe(reducer)。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"redux","slug":"redux","permalink":"https://blog.lyt007.cn/tags/redux/"}]},{"title":"react-native修改APP的名字与图标","slug":"react-native修改APP的名字与图标","date":"2018-12-29T06:01:50.000Z","updated":"2020-04-13T03:13:34.962Z","comments":true,"path":"技术/react-native修改APP的名字与图标.html","link":"","permalink":"https://blog.lyt007.cn/技术/react-native修改APP的名字与图标.html","excerpt":"","text":"修改APP名称-Android1、找到读取app_name的地方 进入：android/app/src/main/AndroidManifest.xml, 找到 android:label=”@string/app_name”。这个对应的就是APP的名称。 @string类似于定义好的变量，直接调取即可。 2、进入：android/app/src/main/res/valuse/strings.xml目录下，修改即可123&lt;resources&gt; &lt;string name=\"app_name\"&gt;你的APP名称&lt;/string&gt;&lt;/resources&gt; 修改APP图标-Android1、找到读取APP图标的地方 进入目录：：android/app/src/main/AndroidManifest.xml 找到： android:icon=”@mipmap/ic_launcher” 这里的ic_launcher就是我的图标。这里也是从其他地方引用的，因此需要在被引用的地方修改。 2、修改图标进入目录：android/app/src/main/res/mipmap–xxx, （PS：这里需要注意，可能是mipmap,也可能是drawable）,我这里是mipmap。这里只需要保持一致即可。 如果是：是mipmap，则android:icon=”@mipmap/ic_launcher”如果是：是drawable，则android:icon=”@drawable/ic_launcher”。 这里面的图标大小都不一样，但是名字是一样的。图标分为48x48,72x72,96x96,144x144.适配安卓不同机型 修改App的名字与图标-IOSIOS的修改与配置到需要使用到XCode，当然也可以不用。不过既然都涉及到了IOS，那么你因该会有XCode吧。 点击图上面的右边的箭头进入修改。 或者是在~.../项目名字/ios/项目名字/Images.xcassets文件目录下添加。如果是需要添加IOS APP启动图，也是需要放在这里面，IOS可以使用一款名为App Icon Gear的软件生成。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://blog.lyt007.cn/tags/react-native/"}]},{"title":"javascript正则表达式","slug":"javascript正则表达式","date":"2018-12-27T08:45:26.000Z","updated":"2020-04-13T03:13:34.962Z","comments":true,"path":"技术/javascript正则表达式.html","link":"","permalink":"https://blog.lyt007.cn/技术/javascript正则表达式.html","excerpt":"","text":"正则表达式一直是一个令人头疼但却又是十分重要的一个东西。熟练的使用正则表达式可以让你的工作事半功倍。接下来，一起来看看正则表达式是什么吧！ 正则表达式概念正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式的基本语法1var reg = / pattern / flags; 就像上面的，正则表达式是由两个/符号包裹起来的，两个/里面的（上面的pattern）就是需要的任何简单或者是复杂的正则表达式。而在第二个/后面是一个或者是多个标志（flags），用来标明正则表达式的行为。flags有以下五种行为： g：表示全局（global）模式，即在匹配到第一个后继续匹配 i：忽略（ignore）大小写 m：便是多行（multiline）模式，即到达一行时继续查找下一行 y：(ES6新增的粘连修饰符) u：(ES6新增) 正则的规则分类下面根据JavaScript正则表达式的速查表中的分类来对每一下进行一个说明。 正则表达式基础基础里面呢主要有6需要记忆的东西，分别是： .：匹配除了换行以外其他所有字符 a：匹配字符a，衍生为匹配单个字母 ab：匹配字符串ab，衍生为匹配字符串 a|b：匹配a或者b，就是或者的意思 a*：匹配0次或者是多次a \\：转义符号，转义一个特殊的字符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// `.`的使用var reg = /./g;var text = \"abcdefg\";var res = text.match(reg);console.log(res); // (7) [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]// `a`的使用var reg = /A/gi; // 全局匹配。忽略大小写var text = \"abcdefg\";var res = text.match(reg);console.log(res); // (7) [\"a\"]// `ab`的使用var reg = /AbCdef/gi; // 全局匹配。忽略大小写var text = \"abcdefg\";var res = text.match(reg);console.log(res); // (7) [\"abcdef\"]// `a|b`的使用 一var reg = /a|b|c|d/; // 非全局匹配。var text = \"abcdefg\";var res = text.match(reg);console.log(res); // [\"a\", index: 0, input: \"abcdefg\"]// `a|b`的使用 二var reg = /a|b|c|d/g; // 全局匹配。var text = \"abcdefg\";var res = text.match(reg);console.log(res); // (4) [\"a\", \"b\", \"c\", \"d\"]。使用全局匹配。会在匹配对后继续匹配// `a*`的使用var reg = /a*/; var text = \"abcdcba\";var res = text.match(reg);console.log(res); // [\"a\", index: 0, input: \"abcdcba\"]// `a*`的使用var reg = /a*/g; // 全局匹配。var text = \"abcdcba\";var res = text.match(reg);console.log(res); // (8) [\"a\", \"\", \"\", \"\", \"\", \"\", \"a\", \"\"]。使用全局匹配会把之后没有匹配到的转化为空字符串// `\\`的使用 回到第一个 . 的使用那里。如果我把 . 前面加一个 \\ 符号，那么这个点就是一个普通的点了var reg = /\\./g; // 全局匹配。var text = \"abcdefg\";var res = text.match(reg);console.log(res); // null JavaScript中需要使用 \\ 的特殊符号有：( ) [ ] { } . | + * ? \\ ^ $ 以及 空白 。 正则表达式字符类 [ab-d]：a，b，c，d四个字符中的一个，衍生为使用[]，那就是匹配其中的一个 [^ab-d]：除了a，b，c，d四个字符其他的任意字符，衍生为使用[^]可以排除[]里面的东西 [\\b]：退格字符，了解 \\d：一个0-9的数字 \\D：一个非数字 \\s：一个空白字符 \\S：一个非空白字符 \\w：匹配一个字母，数字或者是下划线 \\W：匹配一个除字母,数字,下划线之外的任意字符 123456789101112131415161718192021222324252627282930313233343536// `[a-z]`的使用var reg = /[a-z]/g; // 全局匹配。匹配 a-z 的任意一个，因为是全局匹配。所以会一直找。但是不会有 1234var text = \"abcd1234\";var res = text.match(reg);console.log(res); // (4) [\"a\", \"b\", \"c\", \"d\"]// `[a-z]`的使用var reg = /[^a-z]/g; // 全局匹配。匹配 除了 a-z 的任意一个。所以是 1 2 3 4。因为是全局匹配。所以会一直找var text = \"abcd1234\";var res = text.match(reg);console.log(res); // (4) [\"1\", \"2\", \"3\", \"4\"]// `[\\b]`的使用var reg = /[\\b]/g; // 全局匹配。匹配 \\b，当然也可以匹配其他的特殊转义字符，见 正则表达式特殊字符var text = \"abcd\\b1234\";var res = text.match(reg);console.log(res); // (4) [\"1\", \"2\", \"3\", \"4\"]// `\\d`,`\\D`,`\\s`,`\\S`,`\\w`,`\\W`的使用var reg = /\\D\\d/g; // 全局匹配。匹配一个非数字与一个数字。两者紧靠在一起 注意顺序var text = \"abcd1234\";var res = text.match(reg);console.log(res); // [\"d1\"]// 如果是下面的一个，则匹配 nullvar reg = /\\D\\d/g; // 全局匹配。匹配一个数字与一个非数字。两者紧靠在一起 注意顺序var text = \"abcd1234\";var res = text.match(reg);console.log(res); // null// 匹配一个var reg = /\\D\\s\\w\\d/g; // 全局匹配。注意顺序 注意大小写var text1 = \"abcd1234\";var text2 = \"abcd _1234\";var res1 = text1.match(reg);var res2 = text2.match(reg);console.log(res1); // nullconsole.log(res2); // [\"d _1\"] 正则表达式量词 *：匹配0次或者多次。等价于{0,} +：匹配一次或者多次。等价于{1,} ?：匹配0次或者一次。等价于{0,1} {2}：只匹配2次 {2, 5}：匹配2-5次 {2,}：匹配2次或者多次 这里涉及到一个贪婪匹配与非贪婪匹配。贪婪匹配指的是使用以上量词的时候会按照最大次数进行匹配。非贪婪匹配则是按最小次数进行匹配。 使用非贪婪匹配只需在两次后面加上一个? 1234567891011121314151617181920212223242526272829303132333435// `*`的使用// 非全局匹配。var reg = /[a-z]*/; // 匹配 a-z 的0个或者多个var text = \"abcd1234\";var res = text.match(reg);console.log(res); // [\"abcd\", index: 0, input: \"abcd1234\"]// 全局匹配。var reg = /[a-z]*/g; // 匹配 a-z 的0个或者多个var text = \"abcd1234\";var res = text.match(reg);console.log(res); // (6) [\"abcd\", \"\", \"\", \"\", \"\", \"\"]。当匹配为 0 个的时候，会变成空字符串。对比 + 号// `+`的使用// 非全局匹配。var reg = /[a-z]+/; // 匹配 a-z 的0个或者多个var text = \"abcd1234\";var res = text.match(reg);console.log(res); // [\"abcd\", index: 0, input: \"abcd1234\"]// 全局匹配。var reg = /[a-z]+/g; // 匹配 a-z 的0个或者多var text = \"abcd1234\";var res = text.match(reg);console.log(res); // [\"abcd\"]。因为至少匹配一个，所以不会有空字符串。对比 * 号// `?`的使用// 非全局匹配。var reg = /[a-z]?/; // 匹配 a-z 的0个或者一个var text = \"abcd1234\";var res = text.match(reg);console.log(res); // [\"a\", index: 0, input: \"abcd1234\"]。匹配到一个就停下来// 全局匹配。var reg = /[a-z]?/g; // 匹配 a-z 的0个或者一个var text = \"abcd1234\";var res = text.match(reg);console.log(res); // [\"a\", \"b\", \"c\", \"d\", \"\", \"\", \"\", \"\", \"\"]。abcd匹配到了。1234则是空字符串。 以上说的都属于贪婪匹配。都是按最多个匹配的。如果是非贪婪匹配。则是按照最少的次数匹配。 12345678910111213141516171819202122// `*`的使用// 非全局匹配。贪婪匹配var reg = /[a-z]*/; // 匹配 a-z 的0个或者多个var text = \"abcd1234\";var res = text.match(reg);console.log(res); // [\"abcd\", index: 0, input: \"abcd1234\"]// 全局匹配。贪婪匹配var reg = /[a-z]*/g; // 匹配 a-z 的0个或者多个var text = \"abcd1234\";var res = text.match(reg);console.log(res); // (6) [\"abcd\", \"\", \"\", \"\", \"\", \"\"]。当匹配为 0 个的时候，会变成空字符串。对比 + 号// 非全局匹配。非贪婪匹配var reg = /[a-z]*?/; // 匹配 a-z 的0个或者多个var text = \"abcd1234\";var res = text.match(reg);console.log(res); // [\"\", index: 0, input: \"abcd1234\"]// 全局匹配。非贪婪匹配var reg = /[a-z]*?/g; // 匹配 a-z 的0个或者多个var text = \"abcd1234\";var res = text.match(reg);console.log(res); // (9) [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] 以上就是贪婪匹配与非贪婪匹配的区别。不过不管是如何。在匹配是0次的时候。空字符串的个数总是匹配不成功部分的字符串的长度+1 正则表达式捕获组与非捕获组 (...)：捕获组 (?...)：非捕获组 \\Y：匹配第Y个被捕获的组（也称反向引用）。其中Y是一个数字，这个数组取值范围是*，即{0,}。但是建议反向引用不要索引大于9的捕获性分组。捕获组1234var reg = /ab(cd(1234))/;var text = \"abcd1234\";var res = text.match(reg);console.log(res); // (3) [\"abcd1234\", \"cd1234\", \"1234\", index: 0, input: \"abcd1234\"] 分析： 捕获组就是在匹配 ()外面的字符之后在匹配 () 里面的。结果中的 “abcd1234” 捕获组里面还有捕获组会先忽略里面的捕获组匹配在一次匹配里面的捕获组。结果中的&quot;cd1234&quot;与&quot;1234&quot; 非捕获组1234var reg = /ab(?:cd(1234))/;var text = \"abcd1234\";var res = text.match(reg);console.log(res); // (3) [\"abcd1234\", \"1234\", index: 0, input: \"abcd1234\"] 分析：非捕获组就是不捕获，就行上面的结果中没有了&quot;cd1234&quot; 那么捕获与非捕获有什么区别呢？ 记得看宠物小精灵的时候小智看见新的小精灵扔球抓小精灵的时候就属于一个捕获，如果看见不扔球那就是不捕获。那捕获和不捕获有什么区别呢？就行抓小精灵一样，抓住了之后就可以用了嘛！所以被捕获的东西之后是可以使用的。那么怎么使用呢？ 问得好。这时候就需要使用到\\Y 了。 12345678var reg1 = /(a)/;var reg2 = /(a)\\1/; // 相当于是 /(a)a/var text1 = \"aabb1234\";var text2 = \"aabb1234\";var res1 = text1.match(reg1);var res2 = text2.match(reg2);console.log(res1); // [\"a\", \"a\", index: 0, input: \"aabb1234\"]console.log(res2); // [\"aa\", \"a\", index: 0, input: \"aabb1234\"] 上面的例子中，reg1 与 reg2 仅仅有一点不同。但是匹配后的东西是不同的。简单地说，就是，使用 \\Y 后会赋值第Y个捕获的组。以下代码说明通过$Y来接收相应的捕获组。不能从0开始 \\Y123456789var reg = /ab(cd(1234))/;var text = \"abcd1234\";var res = text.match(reg);console.log(res); // (3) [\"abcd1234\", \"cd1234\", \"1234\", index: 0, input: \"abcd1234\"]console.log(RegExp.$0); // undefinedconsole.log(RegExp.$1); // cd1234console.log(RegExp.$2); // 1234var res1 = text.replace(reg,\"$1$2\"); // 使用 $1 $2 取出捕获组的内容console.log(res1); // cd12341234 正则表达式断言 ^：字符串的开始必须是 $：字符串的结尾必须是 \\b：匹配文字（单词）边界 \\B：非文字（单词）边界 (?=...)：积极的前瞻（也叫前瞻或者是顺序肯定环视） (?!...)：消极的前瞻（也加后瞻或者是顺序否定环视） ^，$的使用12345678910var reg = /^b.*\\d$/; // 要求字符 b 开头，中间 * 个任意字符（除换行符），必须以数字结束var text1 = \"abcd1234\";var text2 = \"bcd\";var text3 = \"bcd1234\";var res1 = text1.match(reg);var res2 = text2.match(reg);var res3 = text3.match(reg);console.log(res1); // nullconsole.log(res2); // nullconsole.log(res3); // [\"bcd1234\", index: 0, input: \"bcd1234\"] \\b，\\B的使用12345678910var reg = /\\bhi\\b/; // var text1 = \"hi\"; var text2 = \"him\"; var text3 = \"history\";var res1 = text1.match(reg);var res2 = text2.match(reg);var res3 = text3.match(reg);console.log(res1); // [\"hi\", index: 0, input: \"hi\"]console.log(res2); // nullconsole.log(res3); // null 积极的前瞻 (?=…) 积极的前瞻 匹配后面是 … 的位置，不捕获匹配结果1234567var reg = /abcd(?=1234)/;var text = \"abcd1234\";var text1 = \"abcdefg\";var res = text.match(reg);var res1 = text1.match(reg);console.log(res) // [\"abcd\", index: 0, input: \"abcd1234\"]console.log(res1) // null 看上面的例子可以看出积极的前瞻匹配1234前面的abcd，不匹配def前面的abcd；而消极的前瞻恰恰相反，看下面的例子。 消极的前瞻 (?!…) 消极的前瞻 匹配后面不是 … 的位置，不捕获匹配结果1234567var reg = /abcd(?!=1234)/;var text = \"abcd1234\";var text1 = \"abcdefg\";var res = text.match(reg);var res1 = text1.match(reg);console.log(res) // nullconsole.log(res1) // [\"abcd\", index: 0, input: \"abcd1234\"] 正则表达式特殊字符 \\n：换行符 \\r：回车符 \\t：制表符 \\0：空字符 \\YYY：8进制字符 \\xYY：十六进制字符 \\uYYYY：十六进制字符 \\cY：控制符正则的特殊字符在实际中运用的比较少，具体的用法与之前讲到的[\\b]类似。上面的两个十六进制字符中，\\xYY主要匹配数字字母等。而\\uYYYY则是为了匹配汉字以及以下特殊的符号。 正则表达式替换正则表达式替换主要是替换一些字符。主要以下几个，可是在replace中使用。 $$：插入$ $&amp;：插入整个匹配 $`：插入匹配项前面的字符串 $&#39;：插入匹配项后面的字符串 $Y：插入第Y个捕获的组 1234var reg = /.&#123;2&#125;水(.)/;var text = \"君子之交淡如水，小人之交甘若醴\";var res = text.match(reg);console.log(res); // (2) [\"淡如水，\", \"，\", index: 4, input: \"君子之交淡如水，小人之交甘若醴\"] $$：插入$1234var reg = /.&#123;2&#125;水(.)/;var text = \"君子之交淡如水，小人之交甘若醴\";var newStr = text.replace(reg,\"$$\");console.log(newStr); // 君子之交$小人之交甘若醴 $&amp;：插入整个匹配1234var reg = /.&#123;2&#125;水(.)/;var text = \"君子之交淡如水，小人之交甘若醴\";var newStr = text.replace(reg,\"$&amp;\");console.log(newStr); // 君子之交淡如水，小人之交甘若醴 $`：插入匹配项前面的字符串1234var reg = /.&#123;2&#125;水(.)/;var text = \"君子之交淡如水，小人之交甘若醴\";var newStr = text.replace(reg,\"$`\");console.log(newStr); // 君子之交君子之交小人之交甘若醴 $&#39;：插入匹配项后面的字符串1234var reg = /.&#123;2&#125;水(.)/;var text = \"君子之交淡如水，小人之交甘若醴\";var newStr = text.replace(reg,\"$'\");console.log(newStr); // 君子之交小人之交甘若醴小人之交甘若醴 $Y：插入第Y个捕获的组1234var reg = /.&#123;2&#125;水(.)/;var text = \"君子之交淡如水，小人之交甘若醴\";var newStr = text.replace(reg,\"$1\");console.log(newStr); // 君子之交，小人之交甘若醴 正则表达式实例的方法exec() 最主要的方法此方法专门为捕获组设计的。此方法接收一个参数，及需要测试的字符串。返回数组或者是null。但返回的值包含两个额外的属性：index：匹配性在字符串中的位置input：应用正则的表达式1234var reg = /你(我他(与她))/var text = \"你我他与她\";var res = reg.exec(text);console.log(res); //(3) [\"你我他与她\", \"我他与她\", \"与她\", index: 0, input: \"你我他与她\"] [&quot;你我他与她&quot;, &quot;我他与她&quot;, &quot;与她&quot;, index: 0, input: &quot;你我他与她&quot;]的结果。使用res[下标]可以查看具体的匹配下。从第二项开始才是捕获项。使用res.index与res.input查看起始位置与匹配的字符串。 exec()方法始终返回一项，如果设置了全局匹配g，只会从上一次结束的敌法继续查找，而不会返回多项。1234567891011121314151617181920var text = \"bat, cat, fat\";var reg1 = /.at/;var res = reg1.exec(text);console.log(res.index); // 0console.log(res[0]); // batvar res = reg1.exec(text);console.log(res.index); // 0console.log(res[0]); // batvar reg2 = /.at/g;var res = reg2.exec(text);console.log(res.index); // 0console.log(res[0]); // batvar res = reg2.exec(text);console.log(res.index); // 5console.log(res[0]); // cat test()方法接收一个字符串作为参数，返回：true：匹配false：不匹配1234567var text = \"abcd1234\";var reg1 = /\\D/g;var reg2 = /\\s/g;var res1 = reg1.test(text);console.log(res1); // truevar res2 = reg2.test(text);console.log(res2); // false 关于使用RegExp构造函数语法：var reg = new RegExp(参数1[,参数2]);1234var reg = new RegExp(\"\\D\",\"gi\");var text = \"ABd1234\";var res = reg.exec(text);console.log(res); // [\"d\", index: 2, input: \"ABd1234\"] 看上面的例子。两个参数需要使用字符串。但是，上面的例子有一个问题。没有按照我们所想的出现一个A，而是一个d。同时，我们忽略大小写在看一下：1234var reg = new RegExp(\"\\D\",\"g\");var text = \"ABd1234\";var res = reg.exec(text);console.log(res); // null 所以，使用构造函数还有一个需要注意的就是所有的元字符都需要双重转义。将上面的代码换为下面的看看1234var reg = new RegExp(\"\\\\D\",\"g\");var text = \"ABd1234\";var res = reg.exec(text);console.log(res); // [\"A\", index: 0, input: \"ABd1234\"] 注意上面的\\\\D。这个才表示一个元字符。刚刚的就是一个\\一个D。所以。在正则的构造函数中使用元字符需要双重转义。 附上几个常用的正则匹配电话号码匹配：/^1[3-8]\\d{9}$/电子邮件：/[a-zA-z0-9_-]{6,12}@[a-zA-z0-9_-]+\\.[a-zA-z0-9]+/匹配特定了的邮件：/[a-zA-z0-9_-]{6,12}@(163|qq|gmail)\\.com/ 更多的匹配可查阅：最全的常用正则表达式大全 以上就是关于正则的一些使用概念以及使用方法。如果想要熟练的使用正则去匹配或者是修改字符串。还是需要不断的练习才是。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.lyt007.cn/tags/js/"}]},{"title":"javascript加载数据简述","slug":"javascript加载数据简述","date":"2018-12-27T08:45:02.000Z","updated":"2020-04-13T03:13:34.961Z","comments":true,"path":"技术/javascript加载数据简述.html","link":"","permalink":"https://blog.lyt007.cn/技术/javascript加载数据简述.html","excerpt":"","text":"加载资源的形式 输入url（或跳转页面）加载html 加载静态资源：图片，js，css，音视频等 加载一个资源的过程 浏览器根据DNS服务器得到域名的IP地址 向这个IP的机器发送http请求 服务器收到，处理并返回http请求 浏览器得到返回内容 浏览器渲染页面的过程 根据HTML结果生成DOM Tree 根据CSS生成CSSOM（CSS Object Model） 将DOM和CSSOM整合形成RenderTree 根据RenderTree开始渲染和展示 遇到&lt;script&gt;标签时，会执行并阻塞渲染渲染页面的过程","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.lyt007.cn/tags/js/"}]},{"title":"javascript数组","slug":"javascript数组","date":"2018-12-27T08:44:12.000Z","updated":"2020-04-13T03:13:34.961Z","comments":true,"path":"技术/javascript数组.html","link":"","permalink":"https://blog.lyt007.cn/技术/javascript数组.html","excerpt":"","text":"数组也是一种数据类型，用于存放数据。在各大语言中都存在数组，但是语法由于大同小异。在JavaScript中数组也是一个非常重要的东西，所以有必要好好的了解一下。 创建一个数组在JavaScript中数组是一中数据格式，不是一种数据类型。我们可以使用构造函数与字面量两种方式创建一个数组。 构造函数：12var arr = new Array()console.log(arr) // [] 我看可以在创建的时候传递参数：1234567891011var arr = new Array(10)console.log(arr) // (10) [empty × 10]var arr = new Array(-10)console.log(arr) // Uncaught RangeError: Invalid array lengthvar arr = new Array(10,10)console.log(arr) // (2) [10, 10]var arr = new Array(\"10\")console.log(arr) // [\"10\"] 可以看出，参数如果是 一个number，数组就是一个长度为number的数组，里面的每一项都为空，不支持负数（取值范围出错） 其他情况，就是数组的每一项，几个参数就是长度为几的数组 也可以使用字面量的方式创建一个新数组。字面量：1234567891011var arr = [];console.log(arr) // []var arr = [10]console.log(arr) // [10]var arr = [10,10]console.log(arr) // [10, 10]var arr = [\"10\"]console.log(arr) // [\"10\"] 与使用构造函数不同的是，使用字面量是无法一下创建一个长度为n的数组的，如果是要创建一个长度为10的数组，可以直接修改数组的长度。数组的长度是可读可写的。12345var arr = [];console.log(arr.length) // 0arr.length = 10;console.log(arr.length) // 10console.log(arr) // (10) [empty × 10] 如果修改长度后数组的长度大于原来的长度，那么多出来的这几项为空（empty，一些浏览器显示为undefined）。若果是小于原来数组的长度，那么就是从数组的末尾删除这个差值的项数。 也可以直接使用数组的下标添加或者是修改数组1234var arr = [0,1,2];arr[1] = \"1\";arr[5] = \"5\";console.log(arr) // (6) [0, \"1\", 2, empty × 2, \"5\"] 如果数组中原来就存放了这一下那么就是修改，arr[1] = &quot;1&quot;。否则就是添加这一项arr[5] = &quot;5&quot;。中间多出来的显示一个empty。 数组的方法数组的方法是非常多的。 添加与删除 push pop shift unshiftpush与unshiftpush与unshift方法都是添加数组。push是往数组后面添加一项，unshift是往数组前面添加一项。1234567var arr = [1,2,3]var res = arr.push(4)console.log(arr) // (4) [1, 2, 3, 4]console.log(res) // 4var res = arr.unshift(4)console.log(arr) // (5) [4, 1, 2, 3, 4]console.log(res) // 5 两个方法都接受至少0个参数。两个方法都是返回的新数组的长度。 pop与shiftpop与shift都是删除数组某一项的方法。pop是删除数组的这最后一项，shift是删除数组的第一项。分别与push与unshift方法对应。1234567var arr = [1,2,3]var res = arr.pop()console.log(arr) // (2) [1, 2]console.log(res) // 3var res = arr.shift()console.log(arr) // [2]console.log(res) // 1 两个方法都不需要参数两个方法都是返回的删除的这一项。 数组排序 reverse sort reverse反转数组12var arr = [3,5,1,6,4,7];console.log(arr.reverse()) // (6) [7, 4, 6, 1, 5, 3] 很简单，就是把数组倒序了。 sort数组排序12var arr = [3,5,1,6,4,7];console.log(arr.sort()) // (6) [1, 3, 4, 5, 6, 7] 如果只是一位数字没有问题，但是如果是多为数字就有问题。12var arr = [22,3,556,1,32,11,2]console.log(arr.sort()) // (7) [1, 11, 2, 22, 3, 32, 556] 因为sort()方法会根据测试字符串的结果来改变顺序比较2与11的时候比较的是字符串”2”与”11”。所以出现上面的结果。 sort方法可以接受一个函数作为参数，自己规定排序问题。1234var arr = [22,3,556,1,32,11,2]console.log(arr.sort(function(a,b)&#123; return a - b;&#125;)) // (7) [1, 2, 3, 11, 22, 32, 556] 参数函数接收两个参数，第一个参数因该位于第二个前面放回负数，位于之后返回正数，否则返回0。 数组拼接concatconcat 方法及拼接数组。在不改变原数组的情况下把多个数组拼接返回新数组。1234var arr = [1,2];var res = arr.concat([2,3])console.log(arr) // (2) [1, 2]console.log(res) // (4) [1, 2, 2, 3] 数组切割sliceslice方法可以把数组切割1234var arr = [1,2,3,4,5]console.log(arr.slice(1)) // (4) [2, 3, 4, 5]console.log(arr.slice(1,3)) // (4) [2, 3]console.log(arr) // (5) [1, 2, 3, 4, 5] slice接收两个参数，第一个是切割的开始位置。第二个可选，表示切割的结束位置（不包含这个索引对应的值），如果没有第二个参数，表示末尾。 如果slice中存在负数，则是倒数的。如果是slice(-1,3)则相当于是slice(4,3)。那么返回的是一个空数组。 数组的splice方法splice是一个非常强大的方法，之前除了排序其他的方法都可以使用splice实现。这个方法自身可以接收&gt;=2个参数。两个参数为删除：1234var arr = [1,2,3,4];var res = arr.splice(1,2);console.log(arr) // [1,4]console.log(res) // [2,3] 第一个参数是删除的开始位置，第二个删除的项数。上面的表示第下标为1开始删除两项。返回的是删除的内容。三个参数是插入：1234var arr = [1,2,3,4];var res = arr.splice(1,0,3,5);console.log(arr) // (6) [1, 3, 5, 2, 3, 4]console.log(res) // (2) [] 第三个及以后参数表示的是需要插入的项。 这样就可以实现替换的效果了。1234var arr = [1,2,3,4];var res = arr.splice(1,1,3,5);console.log(arr) // (5) [1, 3, 5, 3, 4]console.log(res) // (2) [2] 上面表示从第一项开始，删除一项并且替换为后面的东西。 位置判断indexOf与lastIndexOf两个方法都是查找，接收一个参数，如果有返回查找的东西在数组中出现的下标（位置）。没有返回-1。indexOf是正向查找，lastIndexOf是反向查找。12345var arr = [1,2,3,4,3,2,1]console.log(arr.indexOf(3)) // 2console.log(arr.indexOf(5)) // -1console.log(arr.lastIndexOf(3)) // 4console.log(arr.lastIndexOf(5)) // -1 数组的迭代方法 every some filter forEach map五个方法都可以接收两个参数。第一个参数是一个函数，第二个是第一个函数中的this的值，即：如果有第二个参数，那么第一个参数中使用了this，这个this就表示第二个参数。 第一个参数函数可以接收三个参数： 数组每一项的值 这一项在数组中的下标 数组本身 every与some两个方法是判读数组中每一项满不满足这个条件。every表示每一项都满足返回true，否则返回false。some表示数组中有满足的就返回true，否则false。123456789var arr = [1,2,3,4,5]var res = arr.every(function(item,index)&#123; return item &gt; 2&#125;)console.log(res) // falsevar res = arr.some(function(item,index)&#123; return item &gt; 2&#125;)console.log(res) // true","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.lyt007.cn/tags/js/"}]},{"title":"javascript-this的指向的问题","slug":"javascript-this的指向的问题","date":"2018-12-27T08:43:50.000Z","updated":"2020-04-13T03:13:34.961Z","comments":true,"path":"技术/javascript-this的指向的问题.html","link":"","permalink":"https://blog.lyt007.cn/技术/javascript-this的指向的问题.html","excerpt":"","text":"javasript函数中this的指向一直都是许多编程入门新手的一个问题，老师把这个this的指向弄错误。下面我们可以来看看关于this指向的几种情况。 不过在讲之前，请各位始终记住一句话：JavaScript中的this一直指向触发这个事件（函数）的这个Objoct（对象）。 第一种：函数直接添加在行内1&lt;button onclick=\"alert(this.innerHTML);\"&gt;this就是指向这个div盒子&lt;/button&gt; 点击看看： this就是指向这个div盒子此时的这个alert(this.innerHTML)；事件是直接写在button这个元素行内的。是这个button元素触发的这个事件。#### 第二种：通过对象.事件名来实现这是html代码1&lt;button id=\"box\"&gt;通过js事件的点击事件&lt;/button&gt;下面是js代码123document.getElementById(\"box\").onclcik = function()&#123; alert(this.innerHTML);&#125;通过js事件的点击事件 document.getElementById(\"box\").onclick = function(){ alert(this.innerHTML); } 以上的两种方式都很好理解，也不做过多的说明。 第三种：函数的调用的形式这种方式也是存在许多的变种，先来看看上面例子的一个变种。这是html代码1&lt;button id=\"box1\"&gt;通过js事件的点击事件&lt;/button&gt; 下面是js代码1234document.getElementById(\"box1\").onclick = a;function a()&#123; alert(this);&#125; 这一种形式的事件与上面的其实是一样的，不过是单独定义了一个函数，然后点击调用这个函数。 在看看下面的例子1&lt;button id=\"box1\"&gt;通过js事件的点击事件&lt;/button&gt; 下面是js代码123456document.getElementById(\"box1\").onclick = function()&#123; a();&#125;function a()&#123; alert(this);&#125; 此时的这个与上面的有很相似，不同的就是此时的这个a函数是在一个事件函数里面执行的。此时的逻辑是：我点击这个ID为box1的button,让后触发事件后面的函数function(){a();}。此时呢里面的a函数其实还没有执行。到这个函数执行的时候，执行到里面的函数了，a函数自己调用执行（函数加括号执行），那么问题来了，是谁调用的这个a函数呢？答案是：window。因为不存在上面说的两种以及Object.函数的形式。这个就有点像是定义了一个函数自执行。 像这样123456789function t()&#123; console.log(this);&#125;/** * 此时的这个 t 函数是由谁调用的呢（也就是鼠标哪一个对象让他执行的？） * 答案是的 null * 而在 js 中，如果 this 的指向是null会自动转换为 window */t(); 或者是这样：1234567function t()&#123; function t2()&#123; console.log(this); &#125; t2()&#125;t(); OK！接下来看看这个：123456function intro()&#123; console.log('名字是'+ this.name,this );&#125;var dog = &#123;name: \"狗\"&#125;;dog.intro = intro;dog.intro(); // 狗 分析一下：此时先定义了一个名字是intro的一个函数，在定义一个dog对象并赋值name=狗。下面的代码就是在dog这个对象上添加一个intro对象，赋值为一开始定义的那个函数intro。此时的这个dog对象就多了一个属性intro，值是函数。接着在调用这个dog.intro();。那么是谁调用的呢？很明显是这个dog对象调用的这个函数。所以此时的这个this就是指向dog对象。那this.name就是狗了。 OK！再来：12345678910function intro()&#123; console.log('名字是'+ this.name,this );&#125;var dog = &#123;name: \"狗\"&#125;;dog.intro = intro;dog.intro(); // 狗var cat = &#123;name:\"猫\"&#125;;cat.intro = dog.intro;cat.intro(); // 猫 现在多了一个cat,看这句cat.intro = dog.intro;。这个是把dog下面的intro方法赋值给了cat下面新建的一个intro方法。此时涉及到一个内存的问题。js中的对象，函数等都是存放在内存中，给其他对象赋值为这个函数的时候就是让这个对象的这个属性指向内存中的这个函数，所以，不管上面的是怎样赋值，cat与dog的intro的值是指向同一个函数的。不同的是调用他们的对象不同，导致this不同，所以最后的this.name的值不同。 再来看看这个呢？ 123456789101112131415161718192021222324function intro()&#123; console.log('名字是'+ this.name,this );&#125;var dog = &#123;name: \"狗\"&#125;;dog.intro = intro;dog.intro(); // 狗var cat = &#123;name:\"猫\"&#125;;cat.intro = dog.intro;cat.intro(); // 猫(cat.intro = dog.intro)(); // 空 this 指向window```javascriptfunction intro()&#123; console.log('名字是'+ this.name,this );&#125;var dog = &#123;name: \"狗\"&#125;;dog.intro = intro;dog.intro(); // 狗var cat = &#123;name:\"猫\"&#125;;cat.intro = dog.intro;cat.intro(); // 猫(cat.intro = dog.intro)(); // 空 this 指向window 此时的在上面的就是多了一句(cat.intro = dog.intro)();。那为什么就指向window了呢？上面的这个例子，涉及到的是关于计算机里面的计算，cat.intro = dog.intro 这是一个赋值运算，而赋值运算的结果是 = 右侧的值，此时这个值并不属于任何一个对象，而这个值是一个空，也可以说是一个 null ，所以此是为 null 转为指向 window。可以这么做一个比喻： 一天张三去面馆吃面，给老板说：“老板，一碗牛肉面”，做好面后，此时的这碗牛肉面这个值就有了。相当于上面的intro函数，此时呢他并不属于张三。当老板把这碗面端到张三面前，这是才属于张三。OK。李四也去吃面，进入面馆，看见张三的面。对老板说：“老板，来一碗和他一样的面”。此时老板需要计算，这碗面是什么面？相当于上面的cat.intro = dog.intro计算。老板计算后才知道这碗面是牛肉面。此时让一个值加括号执行，那肯定就不行了。此时的这碗面并不属于李四。赋值的结果是是什么呢？当老板把这碗面端到李四面前，这是才属于李四。这就是结果。 需要注意的点就是cat.intro = dog.intro只是一个赋值过程，值是=右边的东西。执行cat.intro = dog.intro会导致一个结果就是cat下面多了一个intro属性并且有值。 基本普通的函数中的this存在的问题就是这么多，其他的也就是上面的一些变种。 不过，可以发现，因为this指向window的存在，会导致污染全局，所以多数时候使用构造函数new的方式更可取，这样this才不会指向全局避免污染全局。 上面说了这么多。其实也就是最开始说的那句：JavaScript中的this一直指向触发这个事件（函数）的这个Objoct（对象）。 更新于2019年09月11日针对于ES6中的箭头函数目前用的非常多。使用箭头函数与普通函数相比，箭头函数有以下几点差异： 箭头函数中的this是在定义的时候所在的作用域的this而不再是函数执行时候确定 不可以使用arguments对象，该对象的在函数体内不存在。如果要使用，可以使用rest参数代替 不可以使用yield命令，因此箭头函数不能用作Generator函数 不可以使用new命令，因为（1）：没有自己的this，无法使用call，apply。（2）：没有prototype属性，而new命令在执行时需要将构造函数的prototype赋值给新的对象的proto","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.lyt007.cn/tags/js/"}]},{"title":"JavaScript绑定事件的三种方式","slug":"JavaScript绑定事件的三种方式","date":"2018-12-27T08:43:01.000Z","updated":"2020-04-13T03:13:34.960Z","comments":true,"path":"技术/JavaScript绑定事件的三种方式.html","link":"","permalink":"https://blog.lyt007.cn/技术/JavaScript绑定事件的三种方式.html","excerpt":"","text":"使用内联 使用.onclick的方式 使用事件监听addEventListener的方式 内联形式：1&lt;input type=\"button\" value=\"按钮\" onclick=\"alert(1);\"&gt; 这种方式就是在一个元素上面直接绑定了一个点击onclick事件，此事件为DOM 0级标准。同时，这个事件的优先级是最高的。 使用对象.事件的形式形式12345678&lt;input type=\"button\" value=\"按钮\"&gt;&lt;script type=\"text/javascript\"&gt; var bt = document.getElementsBytagname(\"input\")[0]; bt.onclick = function()&#123; alert(2) &#125;&lt;/script&gt; 使用这种形式也是可以给一个DOM元素添加上一个事件。这个也是DOM 0级标准。 以上的弊端以上两种方式都是存在一个弊端的，就是一个元素只能添加一个事件。第一种就不用说了，写在行内就一个属性。至于第二种，有的网友可能会说我可以再写一个，比如：123456789101112&lt;input type=\"button\" value=\"按钮\"&gt;&lt;script type=\"text/javascript\"&gt; var bt = document.getElementsBytagname(\"input\")[0]; bt.onclick = function()&#123; alert(2) &#125; bt.onclick = function()&#123; alert(3) &#125;&lt;/script&gt; 写是可以这么写。那么我们先来看一看这个写法的意思，这种写法的本质就是在一个对象上添加一个属性，就上面的例子，就是在bt这个对象上添加一个onclick属性。那么，如果在之后的代码中也存在bt.onclcik，只会吧前面的给覆盖了。所以这样的写法也只能添加一个事件。 那么，问题来了。我要给一个元素（DOM对象）添加两个甚至是多个事件，使用什么呢？此时，就需要使用addEventListener的方式来添加事件。 addEventListener形式：1234567891011&lt;input type=\"button\" value=\"按钮\"&gt;&lt;script type=\"text/javascript\"&gt; var bt = document.getElementsBytagname(\"input\")[0]; bt.addEventListener(\"click\", function()&#123; alert(1) &#125;) bt.addEventListener(\"click\", function()&#123; alert(2) &#125;)&lt;/script&gt; 上面的方式就可以给一个DOM对象绑定一个或者是多个事件。强烈推荐使用这一种绑定事件的方式。使用addEventListener的方式还可以拥有第三个参数。以下是W3C官网的一个话 三个参数： 事件类型，不需要添加上on 事件函数 是否捕获（布尔值），默认是false，即不捕获，那就是冒泡。 那么捕获和冒泡又是什么呢？下面来看一张图：这是三个盒子，相互嵌套的关系1234567&lt;div id=\"a\"&gt; a &lt;div id=\"b\"&gt; b &lt;div id=\"c\"&gt;c&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 那么捕获是什么意思呢？弓箭射过来，没穿过一个盒子，就捕获一次，这个过程就是捕获过程。而下面的就是冒泡 捕获和冒泡会影响到事件的执行顺序123456789101112131415161718192021222324var a = document.getElementById(\"a\");var b = document.getElementById(\"b\");var c = document.getElementById(\"c\");// 捕获a.addEventListener(\"click\", function()&#123; alert(\"b-a\")&#125;,true)b.addEventListener(\"click\", function()&#123; alert(\"b-b\")&#125;,true)c.addEventListener(\"click\", function()&#123; alert(\"b-c\")&#125;,true)// 冒泡a.addEventListener(\"click\", function()&#123; alert(\"m-a\")&#125;,false)b.addEventListener(\"click\", function()&#123; alert(\"m-b\")&#125;,false)c.addEventListener(\"click\", function()&#123; alert(\"m-c\")&#125;,false) 上面的代码的执行顺序为：b-a,b-b,b-c,m-c,m-b,m-a。先执行的捕获在是冒泡。得出：同时存在捕获与冒泡时，捕获的优先级是高于冒泡的 下面，我们变一下代码：123456789101112131415161718192021222324var a = document.getElementById(\"a\");var b = document.getElementById(\"b\");var c = document.getElementById(\"c\");// 捕获a.addEventListener(\"click\", function()&#123; alert(\"b-a\")&#125;,true)b.addEventListener(\"click\", function()&#123; alert(\"b-b\")&#125;) // 此处不在添加捕获事件，那么就是绑定一个默认的事件c.addEventListener(\"click\", function()&#123; alert(\"b-c\")&#125;,true)// 冒泡a.addEventListener(\"click\", function()&#123; alert(\"m-a\")&#125;,false)b.addEventListener(\"click\", function()&#123; alert(\"m-b\")&#125;,false)c.addEventListener(\"click\", function()&#123; alert(\"m-c\")&#125;,false) 此时的执行顺序为：b-a,b-c,m-c,b-b,m-b,m-a 再来：12345678910111213141516171819202122232425262728var a = document.getElementById(\"a\");var b = document.getElementById(\"b\");var c = document.getElementById(\"c\");// 捕获a.addEventListener(\"click\", function()&#123; alert(\"b-a\")&#125;,true)b.addEventListener(\"click\", function()&#123; alert(\"m-b\")&#125;,false) // 把b的冒泡放在这里来了b.addEventListener(\"click\", function()&#123; alert(\"b-b\")&#125;) // 此处不在添加捕获事件，那么就是绑定一个默认的事件。即冒泡c.addEventListener(\"click\", function()&#123; alert(\"b-c\")&#125;,true)// 冒泡a.addEventListener(\"click\", function()&#123; alert(\"m-a\")&#125;,false)c.addEventListener(\"click\", function()&#123; alert(\"m-c\")&#125;,false) 此时的执行顺序为：b-a,b-c,m-c,m-b,b-b,m-a得出，没有捕获的时候谁在前面先执行谁 OK。事件绑定就此结束。下面说说取消事件绑定吧。如果要取消一个使用addEventListener绑定的事件函数，使用removeEventListener可以移除事件。与添加事件一致。不过如果使用这个，最好把这个函数给单离拿出来。 停止传播使用stopPropagation可以阻止事件的传播。不能使用return false123456789101112131415161718192021222324252627var a = document.getElementById(\"a\");var b = document.getElementById(\"b\");var c = document.getElementById(\"c\");// 捕获a.addEventListener(\"click\", function()&#123; alert(\"b-a\")&#125;,true)b.addEventListener(\"click\", function()&#123; alert(\"b-b\")&#125;)c.addEventListener(\"click\", function()&#123; alert(\"b-c\")&#125;,true)// 冒泡a.addEventListener(\"click\", function()&#123; alert(\"m-a\")&#125;)b.addEventListener(\"click\", function()&#123; alert(\"m-b\")&#125;,false)// 阻止冒泡c.addEventListener(\"click\", function(e)&#123; alert(\"m-c\") e.stopPropagation(); // 此处阻止传播&#125;,false) 此时的顺序：b-a,b-c,m-c。不会传递，后面的不会执行了。阻止捕获也是一样，添加之后就不会在继续往下传递了。 这里有涉及到一个阻止事件的默认行为：preventDefault或者是前面提到的return false 对于IE下的事件绑定适用与IE6，7，8IE的事件与模型与W3C的标准事件相比，主要是以下三点不同： 绑定事件的函数不同，IE中使用attachEvent()和detachEvent() 事件必须加上on IE6模型中，不支持捕获，只支持冒泡 IE中还有毛病，先绑定的事件后发生（准确的说是随机发生） IE中this指向window 更新与2017年12月2日14:30:05关于使用addEventListener给元素添加事件一般使用addEventListener的方式来添加，这样才可以个一个元素添加多个事件。但是由于addEventListener单词太长，容易写错，并且代码压缩的时候不会压缩，所以一般很少直接使用他，而是使用函数把他封装起来使用，避免出错：1234567function addEvent(ele,type,fn)&#123; ele.addEventListener(type,function(e)&#123; // fn(e) // 更新于2019年09月17日，添加call，修改this指向，感谢 小兔子乖乖别开门 指出的错误 fn.call(ele, e) &#125;)&#125; 使用以上的方式可以减少出错率以及方便 关于事件代理（委托）一般情况下，如果一个元素下存在多个点击事件，代码结构如下：123456&lt;ul id=\"box\"&gt; &lt;li&gt;list-1&lt;/li&gt; &lt;li&gt;list-2&lt;/li&gt; &lt;li&gt;list-3&lt;/li&gt; &lt;li&gt;list-4&lt;/li&gt;&lt;/ul&gt; 此时，如果你要给每一个li标签添加一个点击事件，弹出每一个li的索引值，初学者可能会使用for循环的方式来添加：12345678var oLis = document.getElementsByTagName(\"li\");for (var i = 0; i &lt; oLis.length; i++) &#123; oLis[i].i = i; addEvent(oLis[i],\"click\",function(e)&#123; alert(this.i) &#125;)&#125; 或者是使用闭包：123456789var oLis = document.getElementsByTagName(\"li\");for (var i = 0; i &lt; oLis.length; i++) &#123; (function(i)&#123; addEvent(oLis[i],\"click\",function(e)&#123; alert(i) &#125;) &#125;)(i)&#125; 但是以上两种都不是一个最好的方法，因为你的li的个数可能发生改变，如果是这样的话，可能会出一些问题。那么，此时如果使用事件代理的方式，效果会更好。事件代理代码：123456789var oBox = document.getElementById(\"box\");addEvent(oBox,'click',function(e)&#123; var target = e.target; // 判断点击的是li if ( target.nodeName == 'LI' ) &#123; alert(target.innerHTML) &#125;&#125;) 这样也是可以的，不过此时的addEvent函数点击的时候就需要在fn里面判断点击的是哪一个标签。为了更好的使用addEvent，我们可以改进一下：123456789101112131415161718192021function addEvent(ele,type,selector,fn)&#123; // 如果只有三个参数，那么3,4互换 if ( fn == null ) &#123; fn = selector; selector = null &#125; ele.addEventListener(type,function(e)&#123; var target; if ( selector ) &#123; // 代理 target = e.target; if(target.matches(selector))&#123; fn.call(target, e) &#125; &#125; else &#123; // 不代理 // 更新于2019年09月17日，添加call，修改this指向，感谢 小兔子乖乖别开门 指出的错误 fn.call(ele, e) &#125; &#125;)&#125; 这时点击li弹出innerHTML就可以这样实现123addEvent(oBox,'click','li',function(e)&#123; alert(this.innerHTML)&#125;)","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.lyt007.cn/tags/js/"}]},{"title":"javascript错误类型","slug":"javascript错误类型","date":"2018-12-27T08:42:31.000Z","updated":"2020-04-13T03:13:34.962Z","comments":true,"path":"技术/javascript错误类型.html","link":"","permalink":"https://blog.lyt007.cn/技术/javascript错误类型.html","excerpt":"","text":"作为一个程序员，需要的不仅仅是技术，更是需要在遇到错误的时候对错误的处理能力。就前端而言，技术一直在更新，但是JavaScript中的错误也就是那么几个。掌握不同的报错信息会让你的实际开发事半功倍。 JavaScript中的错误类型 Error EvalError RangeError ReferenceError SyntaxError TypeError URIError ErrorError是最基本的错误类型，其他的错误类型都继承自该类型。因此，所有错误的类型共享了一组相同的属性。这个类型的错误很少见。一般使用开发人员自定义抛出的错误。 EvalError这个错误会在使用eval()函数发生异常时候抛出。两种情况会出错： new eval(); eval = foo;上面两个的意思结合就是没有直接调用eval函数，而是new或者是重新赋值这个错误基本上不会遇到，因为eval函数本来用的就不多。不过需要注意的是，eval是一个关键字。 RangeError这个错误会在数值超出相应范围时触发。比如使用new Array()的时候传递一个负数或者是超过数组最大长度（4,294,967,295）的数，比如Number.MAX_VALUE，Number.MIN_VALUE。注意递归爆炸也有这个错误。 ReferenceError这个错误一般就是出现在变量找不到的情况，比如：12var a = b;Uncaught ReferenceError: b is not defined 这时候就需要检查一下一个变量了 SyntaxError当Javascript语言解析代码时,Javascript引擎发现了不符合语法规范的tokens或token顺序时抛出SyntaxError。 TypeError这个错误在JavaScript中是经常遇到的，不管是初学者还是老手。在变量中保存着以外的类型时，或者在访问不存在的方法时。都会导致这种错误。但是归根结底还是由于在执行特定于类型的操作时，变量的类型并不符合要求所致。比如：12var o = new 10;a.style.widht = \"10px\"; 关于设置样式这个东西，新手会遇到很多，一般这都是由获取不到元素导致的。 URIError在使用encodeURI或者decodeURI因为URL格式不正确时，就会导致URIError错误。这种错误也很少见。 使用try-catch进行错误处理try-catch是一个错误处理的方法。使用法法是：12345try &#123; // 尝试执行的代码&#125; catch(error) &#123; // 如果上市执行的代码不成功则执行这段代码&#125; 代码中 catch语句的error不能省略。在自己不能把我是否会出错的地方使用try-catch语句能让代码运行的更舒服。try-catch语句其实还有一句finally语句：1234567try &#123; // 尝试执行的代码&#125; catch(error) &#123; // 如果上市执行的代码不成功则执行这段代码&#125; finally &#123; // finally的语句始终都会执行&#125; 因为finally语句使用会执行，所以我们一般都不会使用 finally语句。 抛出错误在使用try-catch语句时发生错误我们可以执行其他事情或者是抛出这个错误。抛出错误使用throw操作符。12345try &#123; alert(a)&#125; catch(error)&#123; throw new Error(\"a is not defined\")&#125; 上面的代码就会抛出一个一般的错误：Uncaught Error: a is not defined。具体抛出什么错误根据实际情况确定。类型就是上面的那几种错误类型。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.lyt007.cn/tags/js/"}]},{"title":"javascript字符串","slug":"javascript字符串","date":"2018-12-27T08:42:03.000Z","updated":"2020-04-13T03:13:34.961Z","comments":true,"path":"技术/javascript字符串.html","link":"","permalink":"https://blog.lyt007.cn/技术/javascript字符串.html","excerpt":"","text":"字符串是JavaScript中7种数据中的一种，用于表示由零个或多个16位的Unicode字符组成的字符序列。创建字符串有两种方式，一种是字面量，另一种是构造函数。 字面量 1var str = \"一个字符串\"; 构造函数 1var str = new String(\"一个字符串\"); 上面就是两个字符串，但是字面量对构造函数说：“我们不一样。”那有啥不一样？好。下面来看看具体的。123456var str1 = \"一个字符串\";console.log(str1); // 一个字符串console.log(typeof str1); // stringvar str2 = new String(\"一个字符串\");console.log(str2); // String &#123;\"一个字符串\"&#125;console.log(typeof str2); // object 可以看出来两个的值与类型都不相同。使用字面量就是返回一个字符串。使用构造函数则是一个字符串对象。如果要将字符串对象转换为字符串。可以使用toString，toLocalSring，valueOf转换为字符串。123456var str2 = new String(\"一个字符串\");console.log(str2); // String &#123;\"一个字符串\"&#125;console.log(typeof str2); // objectconsole.log(str2.toString()) // 一个字符串console.log(str2.toLocaleString()) // 一个字符串console.log(str2.valueOf()) // 一个字符串 这样要使用一个字符串费劲。所以一般看不到这样的操作，都是使用的字面量定义。下面的关于字符串的一些方法都将使用字面量的形式。 字符串是有长度的字符串是有长度这个属性的。从刚刚的构造函数中可以看出来。获取长度使用length属性就不在过多的说明。 字符方法字符串用于两个访问特定字符的方法：charAt：一个参数，返回给定位置的字符charCodeAt：一个参数，返回给定位置的字符的字符编码以及一个将字符编码转换为字符的方法，这个是String构造函数的fromCharCode 12345678var str = \"测试字符方法\";console.log(str.charAt(2)); // 字console.log(str.charCodeAt(2)); // 23383console.log(String.fromCharCode(23383)) // 字// charAt()方法获取指定位置的字符还可以直接使用下标获取，因为字符串是有长度的。console.log(str[2]); // 字 虽说可以使用下标获取指定位置的字符。但是此方法不兼容IE8以下。所以如果使用需要谨慎。 字符操作方法concat() - 拼接字符串concat方法用于讲一个或者多个字符串拼接起来。所以他接收一个或者多个字符创作为参数。1234var str = \"我\";var res = str.concat(\"喜\",\"欢\",\"你\",\"！\");console.log(str); // 我console.log(res); // 我喜欢你！ 经过上面的代码发现，使用concat是不会影响原字符串的。这个方法在数组中也存在，不过那是连接数组了。虽说可以使用concat方法连接两个或者两个以上的字符串，但是基本不使用。开发中还是使用+号拼接的使用更多。 substr()，substring()，slice() - 切割字符串三个方法都是基于字符串创建新字符的方法，都接收一个或者两个参数，返回一个新字符串，不影响原字符串。第一个参数是切割的开始位置（包括这个位置）。 substr：第二个参数指切割的字符串的个数，因为是个数。所以包含最后一个substring：第二个参数指切割的字符串的位置，不包含最后一个slice：第二个参数指切割的字符串的位置，不包含最后一个三个若都没有第二个参数。默认都字符串末尾123456789101112131415161718var str = \"我喜欢你一生一世！\";// 传递的参数是一个正数console.log(str.substr(2)); // 欢你一生一世！console.log(str.substring(2)); // 欢你一生一世！console.log(str.slice(2)); // 欢你一生一世！console.log(str.substr(2,3)); // 欢你一console.log(str.substring(2,3)); // 欢console.log(str.slice(2,3)); // 欢// 传递的参数是一个负数console.log(str.substr(-3)); // 一世！console.log(str.substring(-3)); // 我喜欢你一生一世！console.log(str.slice(-3)); // 一世！console.log(str.substr(3,-4)); // 空字符串console.log(str.substring(3,-4)); // 我喜欢console.log(str.slice(3,-4)); // 你一 对比上面的代码。当两个参数都是正数的时候很简单。但是当两个都是负数的时候，问题就来了。substr会将负的第一个参数从后往前数第几位作为开始位置。负的第二个参数转化为0。slice会将负数全部从后往前数。但是substring像是没事人一样。把负数忽略了。转化为0，同时以较小数作为开始位置。 字符串位置方法 - 查找字符串indexOf：从头到尾的找lastIndexOf：从尾到头的找两个方法都接收一个或者两个参数，第一个是需要查找的字符，第二个是从哪个位置开始查找（下标，默认是0）。 12345678910var str = \"我是真的真的喜欢你！\";// 0 1 23 4 56 7 8console.log(str.indexOf(\"真\")); // 2console.log(str.lastIndexOf(\"真\")); // 4console.log(str.indexOf(\"真\",3)); // 4console.log(str.lastIndexOf(\"真\",3)); // 2console.log(str.indexOf(\"他\")); // -1console.log(str.lastIndexOf(\"他\")); // -1 可以看的，不管是indexOf还是lastIndexOf找到字符串后都会返回这个字符的下标。不过一个是正着数一个是倒着数。但是当去寻找小三他的时候没有发现小三旧放回一个-1。 所以，两个方法都是找到返回下标(注意从哪头开始的)。未找到返回 -1。 trim()方法trim()方法很简单，就是取出字符串的收尾的空格。但是此方法不兼容IE8及以下。123var str = \" 我喜欢你！ \";console.log(str); // 我喜欢你！ console.log(str.trim()); // 我喜欢你！ 如果是要兼容IE8及以下，可是使用正则去替换。1234567var str = \" 我喜欢你！ \";var res = str.replace(/^\\s*|\\s*$/g,\"\");console.log(res); // 我喜欢你！var str = \" 我喜 欢你！ \";var res = str.replace(/^\\s*|\\s*$/g,\"\");console.log(res); // 我喜 欢你！ 大小写转化方法四个方法：toLowerCase：转换为小写toLocaleLowerCase：转换为当地时区小写，一些地方专用toUpperCase：转换为大写toLocaleUpperCase：转换为当地时区大写，一些地方专用12345var str = \"I Love You!\";console.log(str.toLowerCase()); // i love you!console.log(str.toLocaleLowerCase()); // i love you!console.log(str.toUpperCase()); // I LOVE YOU!console.log(str.toLocaleUpperCase()); // I LOVE YOU! 为了保险起见，使用带Locale的更好。 字符串匹配方法match() - 匹配match本质上与RegExp的exec()方法是一样的。接收一个参数，正则表达式或者是RegExp对象。返回一个数组。1234var str = \"bat,cat,fat,hat\";var reg = /.at/g;var res = str.match(reg);console.log(res) // (4) [\"bat\", \"cat\", \"fat\", \"hat\"] var res = str.match(reg);与var res = reg.exec(str);本质上相同。但是后面的无论是不是全局都是返回长度为1的数组。如果不是全局匹配，两者没有区别。 search() - 搜索search的参数与match一样。search方法返回字符串中第一个匹配项的索引。没有则返回-1。1234var str = \"bat,cat,fat,hat\";var reg = /at/;var res = str.search(reg);console.log(res); // 1。因为第一个 a 的下标为 1 replace() - 替换replace方法是字符串中十分重要的一个方法，必须掌握。接收两个参数。 第一个参数：可以是一个字符串或者是一个正则第二个参数：可以是一个字符串或者是一个函数 第二个参数是字符串：123456var str = \"abcdcba\";var res1 = str.replace(\"b\",\"逼\");console.log(res1); // a逼cdcbavar res2 = str.replace(/b/g,\"逼\");console.log(res2); // a逼cdc逼a 第一个参数为字符串基本不用，因为他只能匹配第一个，且只能匹配一个 第二个参数是函数：如果是函数第一个参数：匹配项中间的参数：捕获组1，捕获组2，捕获组3······倒数第二个：位置最后一个：原始字符串 123456789101112var str = \"fathermatherbrothersister\";var reg = /father(mather(brother(sister)))/;var res = str.replace(reg,function(match,capture1,capture2,capture3,pos,originalText)&#123; console.log(match); // fathermatherbrothersister console.log(capture1); // matherbrothersister console.log(capture2); // brothersister console.log(capture3); // sister console.log(pos); // 0 console.log(originalText); // fathermatherbrothersister&#125;)console.log(res); // undefined 。因为第二个参数无返回值 第二个参数既然可以拿到这些东西。那我们就可以做任何事情。 split() - 分割split方法可以将字符串按指定的符号进行分割，返回一个数组。第一个参数：分隔符。字符串或者正则第二个参数：可选。返回数字的长度，不能大于可切割的长度1234var color = \"yellow,red,green,blue\";console.log(color.split(\",\")); // (4) [\"yellow\", \"red\", \"green\", \"blue\"]console.log(color.split(\",\",2)); //(2) [\"yellow\", \"red\"]console.log(color.split(/[^,]+/)); (5) [\"\", \",\", \",\", \",\", \"\"] 。[^,]除了 , 以外","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.lyt007.cn/tags/js/"}]},{"title":"javascript函数","slug":"javascript函数","date":"2018-12-27T08:41:09.000Z","updated":"2020-04-13T03:13:34.961Z","comments":true,"path":"技术/javascript函数.html","link":"","permalink":"https://blog.lyt007.cn/技术/javascript函数.html","excerpt":"","text":"函数的分类与定义函数的方式JavaScript中的函数可以分为两类：有名函数与匿名函数。而定义函数的方式有两种：函数声明与函数表达式。 目标：定义一个函数 fn ==&gt; 有名函数12345678// 使用函数声明function fn()&#123; // 函数执行体&#125;// 使用函数表达式var fn = function()&#123; // 函数执行体&#125; 使用函数声明的重要特征就是函数声明提升，即在读取代码前会先读取函数声明。函数名()表示执行函数看看下面的代码没有任何问题。12345678910111213// 定义一个有名函数 fn1 使用函数声明function fn()&#123; console.log(\"fn1\")&#125;// 调用函数 fn1fn1(); // fn1// 定义一个有名函数 fn2 使用函数表达式var fn2 = function()&#123; console.log(\"fn2\")&#125;// 调用函数 fn2fn2(); // fn2 但是如果是把调用放在定义函数前面，使用函数表达式的就会报错（Uncaught ReferenceError: fn1 is not defined）12345678910111213// 调用函数 fn1fn1(); // fn1// 定义一个有名函数 fn1 使用函数声明function fn()&#123; console.log(\"fn1\")&#125;// 调用函数 fn2fn2(); // Uncaught ReferenceError: fn1 is not defined// 定义一个有名函数 fn2 使用函数表达式var fn2 = function()&#123; console.log(\"fn2\")&#125; 这就是使用两种的区别。 函数的返回值每一个函数在调用的时候都会默认返回一个undefined。123456function fn()&#123; console.log(1)&#125;fn(); // 1console.log(fn); // console出一个函数 即 fnconsole.log(fn()); // undefined 这里需要注意的地方就是关于函数执行过程与函数执行结果。 fn()表示调用函数。那就会执行函数体。并默认返回一个undefined。只不过这个值undefined没有变量接收或者说是我们没有用这个值。 console.log(fn)就只是console出一个变量fn的值。只不过这个值是一个函数。 console.log(fn())与第一个的区别就是函数执行了并返回了一个结果。这个结果呢与上面不同的就是现在这个结果我们用上了（放在了console）里面。再由于值是undefined，所以console了一个undefined。 既然函数是可以有返回值的，并且这个值默认是一个undefined。那我们可以可以修改呢？答案是可以的。我们使用return语句可以让函数返回一个值1234567function fn()&#123; console.log(1) return \"哈哈\"&#125;fn(); // 1console.log(fn); // 函数 fnconsole.log(fn()); // 哈哈 可以看一下第一个与第二个的结果与之前的是相同的。但是第三个的结果就不同了，他是字符串哈哈。因为我们修改了函数的默认返回值。 所以，可以把默认函数理解成这样的123function fn()&#123; return undefined;&#125; 而我们修改返回值就是吧这个undefined给变成其他的值了。注意：函数的返回值可以是任意的数据类型。 函数参数函数是可以接收参数的，在定义函数的时候放的参数叫形式参数，简称形参。在调用函数的时候传递的参数叫实际参数，简称实参。一个函数可以拥有任意个参数1234567891011function fn(a,b)&#123; console.log(a) console.log(b) console.log(a+b)&#125;// 调用函数并传递参数fn(3,5); // 3,5,8fn(3); // 3,undefined,NaNfn(3,5,10) // 3,5,8 可以看看上面的例子。定义函数的时候有两个形参。调用的时候分为了三种情况。 第一种，传递两个参数，在console时候a=3,b=5,a+b=8。老铁，没问题。 第二种，传递一个参数，在console的时候a=3,b=undefined,a+b=NaN。哈哈，你不行。 第三种，传递3个。在console的时候a=3,b=5,a+b=8。握草，你牛逼。对第三个参数视而不见了。 以上就是三种情况。一句话：参数一一对应，实参少了，那么没有对应的就是undefined，实参多了，多出来的就是没有用的 arguments在不确定参数（或者定义函数的时候没有形参）的时候，调用函数你传递参数了，但是你没有使用新参去接收，就无法使用。把此时就有一个arguments对象可以获取到实参的个数以及具体的值。1234function fn()&#123; console.log(arguments)&#125;fn(1,2,3,4,5,6,7) // Arguments(7) [1, 2, 3, 4, 5, 6, 7, callee: ƒ, Symbol(Symbol.iterator): ƒ] arguments在严格模式下无法使用。 函数递归递归：就是函数自己调用自己。比如下面经典的阶层递归函数12345678function stratum(n)&#123; if (n &lt;= 1)&#123; return 1; &#125; else &#123; return n * stratum(n - 1); &#125;&#125;stratum(5) // 120 = 5 * (4 * (3 * (2 * 1) ) ) 可以看出实现的阶层的功能。不过需要注意一下每一个的执行顺序。不是5 * 4 * 3 * 2 * 1。而是5 * (4 * (3 * (2 * 1) ) )的顺序。为了证明这一点。可以将*换为-12345678function fn(n)&#123; if (n &lt;= 1)&#123; return 1; &#125; else &#123; return n - fn(n - 1); &#125;&#125;fn(5) // 3 如果是按照不带括号的5-4-3-2-1 = -5。但是结果却是3。那3是怎么来的呢？5 - (4 - (3 - (2 - 1) ) ) = 5 - (4 - (3 - 1)) = 5 - (4 - 2) = 5 - 2 = 3 还可以使用arguments.callee方法调用自身。这个方法就指向当前运行的函数12345678function stratum(n)&#123; if (n &lt;= 1)&#123; return 1; &#125; else &#123; return n * arguments.callee(n - 1); &#125;&#125;stratum(5) // 120 递归虽然可以让代码更简洁，但是能不使用递归的时候就不要使用，递归会影响性能（因为过多的调用自己会一直保存每一次的返回值与变量，导致内存占用过多甚至内存泄露）。123456789101112131415161718console.time(1);function stratum(n)&#123; if (n &lt;= 1)&#123; return 1; &#125; else &#123; return n * arguments.callee(n - 1); &#125;&#125;console.log(stratum(5))console.timeEnd(1) // 1: 4.470947265625msconsole.time(2)var a = 1;for (var i = 1; i &lt;= 5; i++) &#123; a *= i;&#125;console.log(a);console.timeEnd(2) // 2: 0.2373046875ms 两个阶层，一看。for循环快太多了。具体的性能问题可以看看爱情小傻蛋关于递归的算法改进。 函数闭包闭包是指有权访问另一个函数作用域中的变量的函数。两个条件： 函数嵌套函数 内部函数使用包含函数的变量或者是参数 12345678910111213function fn()&#123; var a = 1; return function()&#123; console.log(a); a++; &#125;&#125;fn()(); // 1fn()(); // 1var a = fn();a(); // 1a(); // 2 上面的例子中的函数就是一个闭包。注意上面的直接调用返回值与先保存返回值在调用的区别。 闭包只能取得包含函数中任何变量的最后一个值。this是无法在闭包函数中调用的。因为每一个函数都有一个this。 闭包函数中使用的变量是不会进行销毁的，像上面的var a = fn()，这个函数a中使用了函数fn中的变量，且a是一直存在的，所以函数fn里面的变量a是不会销毁的。如果是直接调用函数fn()()只是相当于调用一次fn函数的返回值。调用完函数返回值就销毁了。所以变量a不会一直保存。 因为闭包函数的变量会一直保存不会 call，apply与bind三个方法都是改变this指向 call apply123456789101112function fn(a,b)&#123; console.log(a) console.log(b) console.log(this.name)&#125;var name = \"嘻嘻\"var obj = &#123; \"name\": \"哈哈\"&#125;// 执行函数fnfn(1,2) // 1,2,嘻嘻 直接调用函数fn(1,2)，this.name的值是嘻嘻 如果使用call：1fn.call(obj,1,2) // 1,2,哈哈 call方法的第一个参数是改变this指向的东西，可以是任何的数据类型。只不过如果是null或者是undefined就会指向window。其他的参数依次对应函数的每一个形参。 如果使用apply1fn.apply(obj,[1,2]) apply的使用与call的使用的唯一的区别就是它对应函数每一项形参是一个数组而不是单独的每一个。 call与applu都是在函数调用的时候去使用 bind则是在函数定义的时候使用123456789101112function fn(a,b)&#123; console.log(a) console.log(b) console.log(this.name)&#125;var name = \"嘻嘻\"var obj = &#123; \"name\": \"哈哈\"&#125;// 执行函数fnfn(1,2) // 1,2,嘻嘻 如果使用bind可以是一下几种方式12345678910111213141516171819202122232425262728293031323334// 使用函数表达式 + 匿名函数var fn = function(a,b)&#123; console.log(a) console.log(b) console.log(this.name)&#125;.bind(obj)fn(1,2)// 使用有名函数function fn(a,b)&#123; console.log(a) console.log(b) console.log(this.name)&#125;fn.bind(obj)(1,2)// 函数在自执行(function fn(a,b)&#123; console.log(a) console.log(b) console.log(this.name) &#125;.bind(obj)(1,2))(function fn()&#123; console.log(a) console.log(b) console.log(this.name)&#125;.bind(obj))(1,2);(function fn()&#123; console.log(a) console.log(b) console.log(this.name)&#125;).bind(obj)(1,2); 使用bind的时候也是可以传递参数的，但是不要这样使用，因为使用bind后你不调用函数那么参数还是没有作用。既然还是要调用函数，我们一般就把函数的实参传递到调用的括号里面。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.lyt007.cn/tags/js/"}]},{"title":"HTML5多线程与离线存储","slug":"HTML5多线程与离线存储","date":"2018-12-27T08:38:17.000Z","updated":"2020-04-13T03:13:34.959Z","comments":true,"path":"技术/HTML5多线程与离线存储.html","link":"","permalink":"https://blog.lyt007.cn/技术/HTML5多线程与离线存储.html","excerpt":"","text":"多线程 Worker 前端页面123456// 创建对象var w = new Worker(\"work.js\");w.postmessage(\"发送的数据\");w.onmessage = function(e)&#123; // do something&#125; 2.多线程处理页面1234self.onmessage = function(e)&#123; // 前端页面传过来的数据 console.log(e.data)&#125; 离线存储使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。HTML5引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。 应用程序缓存为应用带来三个优势： 离线浏览 – 用户可在应用离线时使用它们 速度 – 已缓存资源加载得更快 减少服务器负载 – 浏览器将只从服务器下载更新过或更改过的资源。 新建一个 .appcache 文件，html文件的html标签中引入这个文件 在apache的httpd.conf文件下添加 AddType text/cache-manifest .appcache 在.appcache文件下进行设置： manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次加载后进行缓存 NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 在线的情况下,用户代理每次访问页面，都会去读一次manifest.如果发现其改变, 则重新加载全部清单中的资源 更新缓存一旦应用被缓存，它就会保持缓存直到发生下列情况：用户清空浏览器缓存manifest 文件被修改（包括注释）由程序来更新应用缓存 注意事项 站点离线存储的容量限制是5M 如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存 引用manifest的html必须与manifest文件同源，在同一个域下 在manifest中使用的相对路径，相对参照物为manifest文件 CACHE MANIFEST字符串应在第一行，且必不可少 系统会自动缓存引用清单文件的 HTML 文件 manifest文件中CACHE则与NETWORK，FALLBACK的位置顺序没有关系，如果是隐式声明需要在最前面 FALLBACK中的资源必须和manifest文件同源 当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。 站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问 当manifest文件发生改变时，资源请求本身也会触发更新 同域跨文档操作（服务器下运行）iframe内页： 父页面操作子页面：contentWindow 子页面操作父页面：window.top(找到最顶级的父页面)/parent(第一父页面) 新窗口页： 父页面操作子页面：window.open 子页面操作父页面：window.opener","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"HTML5拖拽","slug":"HTML5拖拽","date":"2018-12-27T08:37:36.000Z","updated":"2020-04-13T03:13:34.959Z","comments":true,"path":"技术/HTML5拖拽.html","link":"","permalink":"https://blog.lyt007.cn/技术/HTML5拖拽.html","excerpt":"","text":"@(HTML5)[HTML 5拖拽] HTML 5 拖拽事件图片自带拖拽功能其他元素可设置draggable属性：draggable ：true拖拽元素(被拖拽的元素)事件 : ondragstart : 拖拽的一瞬间触发 ondrag : 拖拽前、拖拽结束之间，连续触发 ondragend : 拖拽结束触发 目标元素(拖拽元素被拖到的地方)事件 : ondragenter : 进入目标元素触发 ondragover : 进入目标、离开目标之间，连续触发 ondragleave : 离开目标元素触发 ondrop :在目标元素上释放鼠标触发默认状态下，一个元素不能放另一元素的上面，需要在ondragover事件里面阻止默认事件IE没效果 生命周期：dragstart -&gt; drag -&gt; dragenter -&gt; dragover -&gt; dragleave -&gt; drop -&gt; dragend 火狐下的兼容火狐浏览器下需设置dataTransfer对象才可以拖拽除图片外的其他标签 dataTransfer对象 setData() : 设置数据 key和value(必须是字符串) getData() : 获取数据，根据key值，获取对应的value effectAllowed : 设置光标样式(none, copy, copyLink, copyMove, link, linkMove, move, all 和 uninitialized) setDragImage ： 三个参数（指定的元素，坐标X，坐标Y） files： 获取外部拖拽的文件，返回一个filesList列表 filesList下有个type属性，返回文件的类型 FileReader(读取文件信息)readAsDataURL 参数为要读取的文件对象 onload当读取文件成功完成的时候触发此事件 this. result 获取读取的文件数据","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"HTML5视频与音频","slug":"HTML5视频与音频","date":"2018-12-27T08:36:52.000Z","updated":"2020-04-13T03:13:34.959Z","comments":true,"path":"技术/HTML5视频与音频.html","link":"","permalink":"https://blog.lyt007.cn/技术/HTML5视频与音频.html","excerpt":"","text":"简单介绍HTML5 对视频和音频特性规范文档的制定是被讨论最多的。除浏览器自带支持的明显好处外，评论点集中在浏览器提供商对音频/视频格式 的不同选择。如果你准备使用HTML5的 音频: ogg (ogg, oga), mp3, wav, AAC视频: ogg (ogv), H.264 (mp4) 另外你还需要留意一下 Google 的 VP8 视频解码，这个将被作为一个开源格式来结束（格式选择的）纷争。HTML5 提供的一个解决方案是 ，让你可以指定多个不同格式的源文件，以便于用户浏览器选择它认识的文件。对于 &lt; IE9 和旧浏览器，你将需要一个折衷的解决方案。 当你第一次尝试 HTML5 的音频/视频，你可能会想知道这些可能对你有帮助的东东： 你的服务器必须支持你打算提供的音频/视频的 MIME 格式。你将需要检查一下其在本地服务器上是否被支持。 如果你使用 Safari 来检测 HTML5 的音频/视频支持，需要安装 QuickTime Player，没有QuickTime Player 的 Safari 什么都不能播放。 音频 - audio关于音频的格式oggOgg全称应该是OGGVobis(oggVorbis)是一种新的音频压缩格式，类似于MP3等的音乐格式。Ogg是完全免费、开放和没 有专利限制的。OggVorbis文件的扩展名是.OGG。Ogg文件格式可以不断地进行大小和音质的改良，而不影响旧有的编码器或播放器。 mp3MP3是一种音频压缩技术，其全称是 动态影像专家压缩标准音频层面3（Moving Picture Experts Group Audio Layer III），简称为MP3。 它被设计用来大幅度地降低音频数据量。利用 MPEG Audio Layer 3 的技术，将音乐以1:10 甚至 1:12 的压缩率，压缩成容量较小的文件，而 对于大多数用户来说重放的音质与最初的不压缩音频相比没有明显的下降。它是在1991年由位于德国埃尔朗根的研究组织Fraunhofer-Gesellschaft 的一组工程师发明和标准化的。用MP3形式存储的音乐就叫作MP3音乐，能播放MP3音乐的机器就叫作MP3播放器。 wavWAV为微软公司(Microsoft)开发的一种声音文件格式，它符合RIFF(Resource Interchange File Format)文件规范，用于保存Windows平台的音 频信息资源，被Windows平台及其应用程序所广泛支持，该格式也支持MSADPCM，CCITT A LAW等多种压缩运算法，支持多种音频数字，取样频率和 声道，标准格式化的WAV文件和CD格式一样，也是44.1K的取样频率，16位量化数字，因此在声音文件质量和CD相差无几！ WAV打开工具是WINDOWS 的媒体播放器。 accAAC（Advanced Audio Coding），中文称为“高级音频编码”，出现于1997年，基于 MPEG-2的音频编码技术。由Fraunhofer IIS、杜比实验室 、AT&amp;T、Sony（索尼）等公司共同开发，目的是取代MP3格式。2000年，MPEG-4标准出现后，AAC 重新集成了其特性，加入了SBR技术和PS技术， 为了区别于传统的 MPEG-2 AAC 又称为 MPEG-4 AAC。 使用123&lt;audio controls autoplay loop src=\"audio/after the afterparty.mp3\"&gt; &lt;!-- &lt;source src=\"audio/after the afterparty.mp3\" type=\"\"&gt; --&gt;&lt;/audio&gt; 属性HTML5 Audio/Video 方法addTextTrack()：向音频/视频添加新的文本轨道 canPlayType()：检测浏览器是否能播放指定的音频/视频类型 load()：重新加载音频/视频元素 play()：开始播放音频/视频 pause()：暂停当前播放的音频/视频 HTML5 Audio/Video 属性audioTracks：返回表示可用音轨的 AudioTrackList 对象 autoplay：设置或返回是否在加载完成后随即播放音频/视频 buffered：返回表示音频/视频已缓冲部分的 TimeRanges 对象 `controller：返回表示音频/视频当前媒体控制器的 MediaController 对象 controls：设置或返回音频/视频是否显示控件（比如播放/暂停等）crossOrigin：设置或返回音频/视频的 CORS 设置 currentSrc：返回当前音频/视频的 URL currentTime：设置或返回音频/视频中的当前播放位置（以秒计） defaultMuted：设置或返回音频/视频默认是否静音 defaultPlaybackRate：设置或返回音频/视频的默认播放速度 duration：返回当前音频/视频的长度（以秒计） ended：返回音频/视频的播放是否已结束 error：返回表示音频/视频错误状态的 MediaError 对象 loop：设置或返回音频/视频是否应在结束时重新播放 mediaGroup：设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） muted：设置或返回音频/视频是否静音 networkState：返回音频/视频的当前网络状态 paused：设置或返回音频/视频是否暂停 playbackRate：设置或返回音频/视频播放的速度 played：返回表示音频/视频已播放部分的 TimeRanges 对象 preload：设置或返回音频/视频是否应该在页面加载后进行加载 readyState：返回音频/视频当前的就绪状态 seekable：返回表示音频/视频可寻址部分的 TimeRanges 对象 seeking：返回用户是否正在音频/视频中进行查找 src：设置或返回音频/视频元素的当前来源 startDate：返回表示当前时间偏移的 Date 对象 textTracks：返回表示可用文本轨道的 TextTrackList 对象 videoTracks：返回表示可用视频轨道的 VideoTrackList 对象 volume：设置或返回音频/视频的音量 HTML5 Audio/Video 事件abort：当音频/视频的加载已放弃时 canplay：当浏览器可以播放音频/视频时 canplaythrough：当浏览器可在不因缓冲而停顿的情况下进行播放时 durationchange：当音频/视频的时长已更改时 emptied：当目前的播放列表为空时 ended：当目前的播放列表已结束时 error：当在音频/视频加载期间发生错误时 loadeddata：当浏览器已加载音频/视频的当前帧时 loadedmetadata：当浏览器已加载音频/视频的元数据时 loadstart：当浏览器开始查找音频/视频时 pause：当音频/视频已暂停时 play：当音频/视频已开始或不再暂停时 playing：当音频/视频在已因缓冲而暂停或停止后已就绪时 progress：当浏览器正在下载音频/视频时 ratechange：当音频/视频的播放速度已更改时 seeked：当用户已移动/跳跃到音频/视频中的新位置时 seeking：当用户开始移动/跳跃到音频/视频中的新位置时 stalled：当浏览器尝试获取媒体数据，但数据不可用时 suspend：当浏览器刻意不获取媒体数据时 timeupdate：当目前的播放位置已更改时 volumechange：当音量已更改时 waiting：当视频由于需要缓冲下一帧而停止 注意：为了兼容性。一般使用source标签加载多个音频 利用AudioContext绘制","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"SVG","slug":"SVG","date":"2018-12-27T08:36:12.000Z","updated":"2020-04-13T03:13:34.960Z","comments":true,"path":"技术/SVG.html","link":"","permalink":"https://blog.lyt007.cn/技术/SVG.html","excerpt":"","text":"HTML体系中，最常用的绘制矢量图的技术是SVG和HTML5新增加的canvas元素。这两种技术都支持绘制矢量图和光栅图。不过canvas更偏重于动画的制作。所以，绘制矢量图的大任落到了SVG身上。 SVG简介可缩放矢量图形(Scalable Vector Graphics，简称SVG)是一种使用XML来描述二维图形的语言(SVG严格遵从XML语法)。 SVG允许三种类型的图形对象：矢量图形形状（例如由直线和曲线组成的路径）、图像和文本。 可以将图形对象（包括文本）分组、样式化、转换和组合到以前呈现的对象中。 SVG 功能集包括嵌套转换、剪切路径、alpha 蒙板和模板对象。 SVG既可以说是一种协议，也可以说是一门语言；既是HTML的一个标准元素，也是一种图片格式。 SVG与其他的图片格式对比SVG与其它的图片格式相比，有很多优点(很多优点来源于矢量图的优点)： SVG文件是纯粹的XML， 可被非常多的工具读取和修改(比如记事本)。 SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同） SVG里的属性值必须用引号引起来，就算是数值也必须这样做。 SVG 与JPEG 和GIF图像比起来，尺寸更小，且可压缩性更强。 SVG 是可伸缩的，可在图像质量不下降的情况下被放大，可在任何的分辨率下被高质量地打印。 SVG 图像中的文本是可选的，同时也是可搜索的(很适合制作地图)。 SVG 可以与 Java 技术一起运行。 SVG 是开放的标准。 注意事项： SVG的元素和属性必须按标准格式书写，因为XML是区分大小写的（这一点和html不同） SVG里的属性值必须用引号引起来，就算是数值也必须这样做。 SVG使用 可以直接使用svg 可以使用img标签引用svg 可以在HTML中使用svg 可以作为背景图片 使用SVG画图矩形 - rect元素&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot;/&gt; &lt;rect x=&quot;60&quot; y=&quot;10&quot; rx=&quot;10&quot; ry=&quot;10&quot; width=&quot;30&quot; height=&quot;30&quot;/&gt; 这个元素有6个控制位置和形状的属性，分别是： x：矩形左上角的坐标(用户坐标系)的x值。 y：矩形左上角的坐标(用户坐标系)的y值。 width：矩形宽度。 height：矩形高度。 rx：实现圆角效果时，圆角沿x轴的半径。 ry：实现圆角效果时，圆角沿y轴的半径。 注意：rx与ry只设置了一个，另一个值等于设置了的这个值 圆 - circle元素&lt;circle cx=&quot;25&quot; cy=&quot;75&quot; r=&quot;20&quot;/&gt; 这个元素的属性很简单，主要是定义圆心和半径： r：圆的半径。 cx：圆心坐标x值。 cy：圆心坐标y值。 椭圆 - ellipse元素&lt;ellipse cx=&quot;75&quot; cy=&quot;75&quot; rx=&quot;20&quot; ry=&quot;5&quot;/&gt; 这个是更加通用的圆形元素，你可以分别控制半长轴和半短轴的长度，来实现不同的椭圆，很容易想到，当两个半轴相等时，就是正圆形了。 rx：半长轴(x半径)。 ry：半短轴(y半径)。 cx：圆心坐标x值。 cy：圆心坐标y值。 直线 - line元素&lt;line x1=&quot;10&quot; x2=&quot;50&quot; y1=&quot;110&quot; y2=&quot;150&quot;/&gt; 直线需要定义起点与终点即可： x1：起点x坐标。 y1：起点y坐标。 x2：终点x坐标。 y2：终点y坐标。 折线 - polyline元素&lt;polyline points=&quot;60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145&quot;/&gt; 折线主要是要定义每条线段的端点即可，所以只需要一个点的集合作为参数： points：一系列的用空格，逗号，换行符等分隔开的点。每个点必须有2个数字：x值和y值。所以下面3个点 (0,0), (1,1)和(2,2)可以写成：”0 0, 1 1, 2 2”。 多边形- polygon元素&lt;polygon points=&quot;50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180&quot;/&gt; 这个元素就是比polyline元素多做一步，把最后一个点和第一个点连起来，形成闭合图形。参数是一样的。 points：一系列的用空格，逗号，换行符等分隔开的点。每个点必须有2个数字：x值和y值。所以下面3个点 (0,0), (1,1)和(2,2)可以写成：”0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0)。 路径 - path元素&lt;path d=&quot;M 20 230 Q 40 205, 50 230 T 90230&quot;/&gt; 这个是最通用，最强力的元素了；使用这个元素你可以实现任何其他的图形，不仅包括上面这些基本形状，也可以实现像贝塞尔曲线那样的复杂形状；此外，使用path可以实现平滑的过渡线段，虽然也可以使用polyline来实现这种效果，但是需要提供的点很多，而且放大了效果也不好。这个元素控制位置和形状的只有一个参数： d：一系列绘制指令和绘制参数(点)组合成。 中间的字母的意思： M：moveTo M10 10 L：lineTo L10 10 H：H draws a horizontal line H 90 V：V draws a vertical line V 90 Z：ClosePath Z C：三次贝赛尔曲线 C x1 y1, x2 y2, x y S：三次贝赛尔曲线补充命令。S命令可以用来创建与之前那些曲线一样的贝塞尔曲线但是，如果S命令跟在一个C命令或者另一个S命令的后面，它的第一个控制点，就会被假设成前一个控制点的对称点。如果S命令单独使用，前面没有C命令或者另一个S命令，那么它的两个控制点就会被假设为同一个点。S x2 y2, x y Q：二次贝塞尔曲线 Q x1 y1, x y T：三次贝赛尔曲线补充命令。与S有异曲同工之妙。T命令前面必须是一个Q命令，或者是另一个T命令，才能达到这种效果。需要注意的是，如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。 T x y A：弧形命令 A rx ry x-axis-rotation large-arc-flag sweep-flag x y 前两个参数分别是x轴半径和y轴半径，第三个参数表示弧形的旋转情况。large-arc-flag（角度大小） 和sweep-flag（弧线方向），large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。最后两个参数是指定弧形的终点 L,H,V为小写的时候便表示的是长度，为大写的表示的是坐标 绘制指令分为绝对坐标指令和相对坐标指令两种，这两种指令使用的字母是一样的，就是大小写不一样，绝对指令使用大写字母，坐标也是绝对坐标；相对指令使用对应的小写字母，点的坐标表示的都是偏移量。 绝对坐标绘制指令这组指令的参数代表的是绝对坐标。假设当前画笔所在的位置为(x0,y0)，则下面的绝对坐标指令代表的含义如下所示： SVG画笔与填充边框色 - stroke属性这个属性使用设置的值画图形的边框，使用起来也很直接，把颜色值赋给它就可以了。注意： 如果不提供stroke属性，则默认不绘制图形边框。 可以设置边的透明度，就是stroke-opacity，值的范围是0到1。 使用stroke-width定义描边的宽度 实际上，边的情况比图形内部稍微复杂一点，因为边除了颜色，还有”形状”需要定义。 线的端点 - stroke-linecap属性这个属性定义了线段端点的风格，这个属性可以使用butt,square,round三个值。 线的连接 - stroke-linejoin属性这个属性定义了线段连接处的风格，这个属性可以使用miter,round,bevel三个值。 线的虚实 - stroke-dasharray属性这个属性可以设置线段采用何种虚实线。这个属性是设置一些列数字，不过这些数字必须是逗号隔开的。属性中当然可以包含空格，但是空格不作为分隔符。每个数字定义了实线段的长度，分别是按照绘制、不绘制这个顺序循环下去。需要注意两个只与三个值的情况 stroke-miterlimit这个和canvas中的一样，它处理什么时候画和不画线连接处的miter效果。 stroke-dashoffset这个属性设置开始画虚线的位置 填充色 - fill属性这个属性使用设置的颜色填充图形内部，使用很简单，直接把颜色值赋给这个属性就可以了。注意事项： 如果不提供fill属性，则默认会使用黑色填充,如果要取消填充，需要设置成none。 可以设置填充的透明度，就是fill-opacity，值的范围是0到1。 稍微复杂一点的是fill-rule属性。这个属性定义了判断点是不是属于填充范围的算法；除了inherit这个值外，还有两个取值： nonzero：这个值采用的算法是：从需要判定的点向任意方向发射线，然后计算图形与线段交点的处的走向；计算结果从0开始，每有一个交点处的线段是从左到右的，就加1；每有一个交点处的线段是从右到左的，就减1；这样计算完所有交点后，如果这个计算的结果不等于0，则该点在图形内，需要填充；如果该值等于0，则在图形外，不需要填充。 evenodd：这个值采用的算法是：从需要判定的点向任意方向发射线，然后计算图形与线段交点的个数，个数为奇数则改点在图形内，需要填充；个数为偶数则点在图形外，不需要填充。 使用CSS展示数据当然，你也可以直接使用css来修改这些样式 SVG颜色的表示SVG和canvas中是一样的，都是使用标准的HTML/CSS中的颜色表示方法，这些颜色都可以用于fill和stroke属性。 基本有下面这些定义颜色的方式： 颜色名字： 直接使用颜色名字red, blue, black… rgba/rgb值： 这个也很好理解，例如#ff0000,rgba(255,100,100,0.5)。 十六进制值： 用十六进制定义的颜色，例如#ffffff。 渐变值：这个也与canvas中一样，支持两种渐变色：线性渐变，环形渐变。 图案填充：使用自定义的图案作为填充色。 渐变使用linearGradient元素即可定义线性渐变，每一个渐变色成分使用stop元素定义。注意： 使用stop定义 渐变代码需要放在&lt;defs&gt;标签中 必须使用id命名 使用url(#id)赋值 线性：linearGradientoffset属性：这个和线性渐变的值是一样，但是含义不一样。在环形渐变中，0%代表圆心处，这个很好理解。 x1=”0” x2=”0” y1=”0” y2=”1”：四个属性决定渐变的方向 径向：radialGradientcx,cy,r属性：其实也很好理解，环形渐变，当然要定义环的圆心和半径了，体会一下上面例子中圆的大小和位置就能理解了。 fx,fy属性：定义颜色中心(焦点)处的位置，也就是渐变色最浓处的坐标 不过这里需要注意一下上面cx,cy,r,fx,fy的值，你会发现它们都是小数，那么单位是什么呢？ 这个需要先了解另外一个相关的属性：gradientUnits，它定义了定义渐变色使用的坐标单位。这个属性有2个可用值：userSpaceOnUse和objectBoundingBox。 objectBoundingBox是默认值，它使用的坐标都是相对于对象包围盒的(方形包围盒，不是方形包围盒的情况比较复杂，略过)，取值范围是0到1。例如上例中的cx,cy的坐标值(0.25,0.25)。意味着这个圆心是在包围盒的左上角1/4处，半径0.25意味着半径长是对象方形包围盒长的1/4，就像你们图中看到的那样。 userSpaceOnUse表示使用的是绝对坐标，使用这个设置的时候，你必须要保证渐变色和填充的对象要保持在一个位置。 spreadMethod属性：这个属性定义了渐变色到达它的终点时应该采取的行为。该属性有3个可选值：pad(默认值),reflect,repeat。pad不用说了，属于自然过渡，渐变色结束以后，使用最后一个成员色直接渲染对象剩下的部分。refect会让渐变色继续，只不过渐变色会反向继续渲染，从最后一个颜色开始到第一个颜色这个顺序渲染；等到再次到达渐变色终点时，再反序，如此这般指导对象填充完毕。repeat也会让渐变色继续渲染，但是不会反序，还是一遍一遍从第一种颜色到最后一种颜色渲染 纹理填充例子看起来很简单，由渐变色创建pattern，然后使用pattern填充矩形。这里需要注意： 不同的浏览器填充这个pattern的时候效果不一样。 pattern也需要定义id。 pattern也必须要定义在defs中。 pattern的使用也是把url(#id)直接赋值给fill或stroke。 SVG文本与图像SVG中渲染文本直接显示在图片中文本 -text元素直接显示文本可以使用text元素12345&lt;svg&gt; &lt;rect width=\"300\" height=\"200\" fill=\"red\" /&gt; &lt;circle r=\"80\" cx=\"150\" cy=\"100\" fill=\"green\" /&gt; &lt;text x=\"150\" y=\"125\" font-size=\"60\" text-anchor=\"middle\" fill=\"white\"&gt;SVG&lt;/text&gt;&lt;/svg&gt; 如上面的例子中所示，text元素可以设置下列的属性： x,y是文本位置坐标。 text-anchor是文本显示的方向，其实也就是位置(x,y)处于文本的位置。这个属性有start,middle,end和inherit三种值。 start表示文本位置坐标(x,y)位于文本的开始处，文本从这点开始向右挨个显示。 middle表示(x,y)位于文本中间处，文本向左右两个方向显示，其实就是居中显示。 end表示(x,y)点位于文本结尾，文本向左挨个显示。 除了这些属性，下面的这些属性都既可以在CSS中指定，也可以直接在属性中指定: fill,stroke：填充和描边颜色，具体使用在后面总结。 font的相关属性：font-family, font-style, font-weight, font-variant, font-stretch, font-size, font-size-adjust, kerning, letter-spacing, word-spacing 和 text-decoration。 文本区间 - tspan元素 这个元素是text元素的强力补充；它用于渲染一个区间内的文本；它只能出现在text元素或者tspan元素的子元素中。典型的用法就是强调显示部分文本。例如：123&lt;text&gt; &lt;tspan font-weight=\"bold\" fill=\"red\"&gt;文字&lt;/tspan&gt;&lt;/text&gt; tspan元素可以设置一下的属性： x,y：设置包含的文本的绝对坐标值，这个值会覆盖默认的文本位置 dx,dy：设置包含的文本相对于默认的文本位置的偏移量 rotate：设置字体的旋转角度 textLength：给出字符串的计算长度 文本引用 - tref元素这个元素允许引用定义过的文本，并高效的拷贝到当前位置，通常配合xlink:href指定目的元素。因为是拷贝过来的，所以使用css修改当前文本的时候，不会修改原来的文本。 文本路径 - textPatch元素这个比较有意思，效果也很酷，能做出很多的艺术效果；这个元素从它的xlink:href属性获取指定的路径并把文本对齐到这个路径上 SVG坐标与变换坐标系统SVG存在两套坐标系统：视窗坐标系与用户坐标系。默认情况下，用户坐标系与视窗坐标系的点是一一对应的，都为原点在视窗的左上角，x轴水平向右，y轴竖直向下；SVG的视窗位置一般是由CSS指定，尺寸由SVG元素的属性width和height设置 视窗：指的是网页上面可视的矩形局域，长度和宽度都是有限的，这个区域一般与外围对象的尺寸有关。 视窗坐标系：本质是一个坐标系，有原点，x轴与y轴；而且在两个方向上是无限延伸的。默认情况下，原点在视窗的左上角，x轴水平向右，y轴竖直向下。可以对这个坐标系的点进行变换。 用户坐标系：本质是一个坐标系，有原点，x轴与y轴；而且在两个方向上是无限延伸的。默认情况下，原点在视窗的左上角，x轴水平向右，y轴竖直向下。可以对这个坐标系的点进行变换。 坐标空间变换视窗空间变换由相关元素(这些元素创建了新的视窗)的属性viewBox控制；用户空间变换由图形元素的transform属性控制。视窗空间变换应用于对应的整个视窗，用户空间变换应用于当前元素及其子元素。 视窗变换 - viewBox属性viewBox属性值的格式为(x0,y0,u_width,u_height)，每个值之间用逗号或者空格隔开，它们共同确定了视窗显示的区域：视窗左上角坐标设为(x0,y0)、视窗的宽设为u_width，高为u_height；这个变换对整个视窗都起作用。 用户坐标系的变换 - transform属性这个与css中的translate，rotate，skew，scale一样。同样可以一起使用 SVG的重用与引用组合- g元素g元素是一种容器，它组合一组相关的图形元素成为一个整体；这样，我们就可以对这个整体进行操作。这个元素通常可以和desc和title元素配合使用，提供文档的结构信息。结构良好的文档通常可读性和渲染效率都不错。 注意几点： xmlns=”http://www.w3.org/2000/svg&quot;表明了整个svg元素默认的命名空间是svg。这个在无歧义的时候可以省略。这里由于svg文档是一个XML文档，XML命名空间的相关规则这里都是适用的。例如可以给svg显示的指定命名空间，给命名空间提供别名等。 g元素是可以嵌套的。 组合起来的图形元素就和单个的元素一样，可以给id值，这样，需要的时候(例如动画和重用一组元素)只用引用这个id值就可以了。 组合一组图形元素可以统一设置这组元素的相关属性(fill,stroke,transform等)，这也是使用组合的一种场景。 基础变形平移：translate(x,y)两个参数，如果没有第二个参数，则默认赋值为0。 旋转：rotate(angle)一个参数，参数指旋转的度数 斜切：skewX()与skewY()每个需要一角度以确定元素斜切到多远。 scale()它需要两个数字，作为比率计算如何缩放。0.5表示收缩到50%。如果第二个数字被忽略了，它默认等于第一个值。 利用刚刚介绍的&lt;g&gt;元素，把这些东西变成一个整体。可以对整体进行操作 如果使用了变形，你会在元素内部建立了一个新的坐标系统，应用了这些变形，你为该元素和它的子元素指定的单位可能不是1:1像素映射。但是依然会根据这个变形进行歪曲、斜切、转换、缩放操作。 SVG可以嵌套SVG 剪切与遮罩clipPath：剪切。clipPath的这一部分区域才会被显示mask：遮罩 用opacity定义透明度opacity：fill-opacity：stroke-opacity：当然，你可以使用CSS样式来修饰 SVG中渲染图片 - image元素使用xlink:href插入图片路径注意：如果你没有设置x属性或y属性，它们自动被设置为0。 如果你没有设置height属性或width属性，它们自动被设置为0。 如果width属性或height等于0，将不会呈现这个图像。 模板 - symbol元素symbol元素用于定义图形模板(模板可以包含很多图形)，这个模板可以被use元素实例化。模板的功能与g元素很相似，都是提供一组图形对象，但是也有一些区别。与g元素不同的地方是： 1.symbol元素本身是不会被渲染的，只有symbol模板的实例会被渲染。 2.symbol元素可以拥有属性viewBox和preserveAspectRatio，这些允许symbol缩放图形元素。 从渲染角度来说，与symbol元素相似的元素是marker(定义箭头和标号)和pattern(定义颜色)元素；这些元素不会直接被渲染；他们的使用方式基本都是由use元素去实例化。正是这个原因，对于symbol来说，’display’属性是没有意义的。 定义 - defs元素SVG允许定义一组对象，然后重用这组对象(注意，不仅仅是图形对象)。最常见的例子如定义渐变色，然后再其他的图形对象中赋给fill属性。渐变色定义的时候是不会渲染的，所以这类型的对象可以放到任何地方。重用对于图形对象中也是经常存在的，而且我们也不希望定义的时候直接渲染，而是想在引用的地方渲染，这个可以用defs元素实现。 两种使用：一种是使用fill填充。另一个是使用use元素连接 引用 - use元素任何svg, symbol, g, 单个的图形元素和use元素本质上都可以作为模板对象被use元素引用(例如初始化)。use引用的图形内容会在指定的位置渲染。与image元素不同，use元素不能引用整个文档。use元素也有x, y, width和height属性，这些属性可以省略，如果不省略的话，会将被引用的图形内容坐标或长度映射到当前的用户坐标空间来。 基本操作API 创建图形： document.createElementNS(ns,tagName) ns是什么呢？就是 这个 &quot;http://www.w3.org/2000/svg&quot; tagName值 svg rect，circle等 添加图形： appendChild 设置/获取属性： setAttribute getAttribute SVG SMIL animationSMIL是Synchronized Multimedia Integration Language（同步多媒体集成语言）的首字母缩写简称 SMIL允许你做下面这些事情： 动画元素的数值属性（X, Y, …） 动画属性变换（平移或旋转） 动画颜色属性 沿着运动路径运动 五大元素 set animate animateColor ：以废弃，使用animate实现 animateTransform animateMotion setset意思设置，此元素没有动画效果。你可能会疑问了，既然这个元素没有动画效果，怎么会是animation五大成员之一呢？ OK, 这样的，虽然set虽然不能触发连续的动画，但是，其还是可以实现基本的延迟功能。就是指：可以在特定时间之后修改某个属性值（也可以是CSS属性值）。 12345678&lt;svg width=\"320\" height=\"320\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;g&gt; &lt;text font-family=\"microsoft yahei\" font-size=\"120\" y=\"160\" x=\"160\"&gt; 马 &lt;set attributeName=\"x\" attributeType=\"XML\" to=\"60\" begin=\"3s\" /&gt; &lt;/text&gt; &lt;/g&gt;&lt;/svg&gt; animate基础动画元素。实现单属性的动画过渡效果。12345678&lt;svg width=\"320\" height=\"320\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;g&gt; &lt;text font-family=\"microsoft yahei\" font-size=\"120\" y=\"160\" x=\"160\"&gt; 马 &lt;animate attributeName=\"x\" from=\"160\" to=\"60\" begin=\"0s\" dur=\"3s\" repeatCount=\"indefinite\" /&gt; &lt;/text&gt; &lt;/g&gt;&lt;/svg&gt; animateTransform一看就知道实现transform变换动画效果的。知识是一脉相承的，这里的transform变换与CSS3的transform变换 123456&lt;svg width=\"320\" height=\"320\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;g&gt; &lt;text font-family=\"microsoft yahei\" font-size=\"80\" y=\"100\" x=\"100\"&gt;马&lt;/text&gt; &lt;animateTransform attributeName=\"transform\" begin=\"0s\" dur=\"3s\" type=\"scale\" from=\"1\" to=\"1.5\" repeatCount=\"indefinite\"/&gt; &lt;/g&gt;&lt;/svg&gt; animateMotionanimateMotion元素可以让SVG各种图形沿着特定的path路径运动 123456&lt;svg width=\"360\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;text font-family=\"microsoft yahei\" font-size=\"40\" x=\"0\" y=\"0\" fill=\"#cd0000\"&gt;马 &lt;animateMotion path=\"M10,80 q100,120 120,20 q140,-50 160,0\" begin=\"0s\" dur=\"3s\" repeatCount=\"indefinite\"/&gt; &lt;/text&gt; &lt;path d=\"M10,80 q100,120 120,20 q140,-50 160,0\" stroke=\"#cd0000\" stroke-width=\"2\" fill=\"none\" /&gt;&lt;/svg&gt; 自由组合SVG animation 参数 attributeName = “attributeName”要变化的元素属性名称，① 可以是元素直接暴露的属性，例如，对于本文反复出现的「马」对应的text元素上的x, y或者font-size; ② 可以是CSS属性。例如，透明度opacity attributeType = “CSS | XML | auto”attributeType支持三个固定参数，CSS/XML/auto. 用来表明attributeName属性值的列表。x, y以及transform就属于XML, opacity就属于CSS. auto为默认值，自动判别的意思（实际上是先当成CSS处理，如果发现不认识，直接XML类别处理）。因此，如果你不确信某属性是XML类别还是CSS类别的时候，我的建议是不设置attributeType值，直接让浏览器自己去判断，几乎无差错。那么疑问来了：“既然浏览器酱可以自己判断属性类别，那这个属性还有什么意义吗？”我琢磨着，可能某些属性，XML能其作用，CSS也能其作用，例如font-size, 此时就需要明确下归属。 from, to, by, values上面4个属性是一个家族的，是最具哲理的一个家族。他们解决的是非常有哲理的问题：你从哪里来？要到哪里去？ from = “value“：动画的起始值。 to = “value“：指定动画的结束值。 by = “value“：动画的相对变化值。 values = “list”：用分号分隔的一个或多个值，可以看出是动画的多个关键值点。 四个之间的约束：a. 如果动画的起始值与元素的默认值是一样的，from参数可以省略。b. （不考虑values）to,by两个参数至少需要有一个出现。否则动画效果没有。to表示绝对值，by表示相对值。拿位移距离，如果from是100, to值为160则表示移动到160这个位置，但是，如果by值是160，则表示移动到100+160=260这个位置。c. 如果to,by同时出现，则by打酱油，只识别to.d. 如果to,by,values都没设置，自然没动画效果。如果任意（包括from）一个属性的值不合法，规范上说是没有动画效果。但是，经测试，FireFox浏览器确实如此，但是Chrome特意做了写容错处理。例如，本来是数值的属性，写了个诸如a这个不合法的值，其会当作0来处理，动画效果依然存在。e. values可以是一个值或多值。根据在Chrome浏览器下的测试，是一个值的时候是没有动画效果。多值时候有动画效果。当values值设置并能识别时候，from, to, by的值都会被忽略。那values属性是干什么的呢？别看名字挺大众的，其还是有些功力的。我们实现动画，不可能就是单纯的从a位置到b位置，有时候，需要去c位置过渡下。此时，实际上有3个动画关键点。而from, to/by只能驾驭两个，此时就是values大显身手的时候了！总结下，也就是from-to动画、from-by动画、to动画、by动画以及values动画。 begin, endbegin的定义是分号分隔的一组值。看到没？是一组值，单值只是其中的情况之一。例如，beigin=”3s;5s”表示的是3s之后动画走一下，6s时候动画再走一下（如果之前动画没走完，会立即停止从头开始） durdur属性值比begin简单了好几层楼，就后面两种：常规时间值 | “indefinite”. “常规时间值”就是3s之类的正常值；”indefinite”指事件无限。试想下，动画时间无限，实际上就是动画压根不执行的意思。因此，设置为”indefinite”跟没有dur是一个意思，与dur解析异常一个意思。 calcMode, keyTimes, keySplines这几个参数是控制动画先快还是先慢类似这样作用的。 calcMode属性支持4个值：discrete | linear | paced | spline. 中文意思分别是：“离散”|“线性”|“踏步”|“样条”。 discretefrom值直接跳到to值。 linearanimateMotion元素以外元素的calcMode默认值。动画从头到尾的速率都是一致的。 paced通过插值让动画的变化步调平稳均匀。仅支持线性数值区域内的值，这样点之间“距离”的概念才能被计算（如position, width, height等）。如果”paced“指定，任何keyTimes或keySplines值都会打酱油。 spline 谷歌不兼容插值定义贝塞尔曲线。spline点的定义在keyTimes属性中，每个时间间隔控制点由keySplines定义。 keyTimes = “list”跟上面提到的list类似，都是分号分隔一组值。keyTimes总名字上看是关键时间点的意思，大致就是这个意思。前面提到过values也是多值，这里有一些约定的规则：首先，keyTimes值的数目要和values一致，如果是from/to/by动画，keyTimes就必须有两个值。然后对于linear和spline动画，第一个数字要是0, 最后一个是1。 最后，每个连续的时间值必须比它前面的值大或者相等。 paced模式下，keyTimes会被忽略；keyTimes定义错误，也会被忽略；dur为indefinite也会被忽略。 keySplines = “list”keySplines表示的是与keyTimes相关联的一组贝塞尔控制点（默认0 0 1 1）。每个控制点使用4个浮点值表示：x1 y1 x2 y2. 只有模式是spline时候这个参数才有用，也是分号分隔，值范围0~1，总是比keyTimes少一个值。 如果keySplines值不合法或个数不对，是没有动画效果的。 repeatCount, repeatDurrepeatCount表示动画执行次数，可以是合法数值或者”indefinite“（动画循环到电脑死机）。 repeatDur定义重复动画的总时间。可以是普通时间值或者”indefinite（”动画循环到电脑死机）。 fillfill表示动画间隙的填充方式。支持参数有：freeze | remove. 其中remove是默认值，表示动画结束直接回到开始的地方。freeze“冻结”表示动画结束后像是被冻住了，元素保持了动画结束之后的状态。 accumulate, additiveaccumulate是累积的意思。支持参数有：none | sum. 默认值是none. 如果值是sum表示动画结束时候的位置作为下次动画的起始位置。 additive控制动画是否附加。支持参数有：replace | sum. 默认值是replace. 如果值是sum表示动画的基础知识会附加到其他低优先级的动画上， restartrestart这个属性诞生的背景如下：很多动画呢，其触发可能与事件相关，例如，点击某圆圈，马儿就跑。而且，似乎没点一次，马儿就跑一下。现在，存在这种情况，希望马儿只跑一次，之后在点击就没有反应。这种需求的出现迫使restart参数的出现。支持的参数有：always | whenNotActive | never. always是默认值，表示总是，也就是点一次圈圈，马儿跑一下。whenNotActive表示动画正在进行的时候，是不能重启动画的。never表示动画是一波流。 min, maxmin/max表示动画执行最短和最长时间。支持参数为时间值和”media”（媒介元素有效）, max还支持indefinite. 动画的暂停与播放123456// svg指当前svg DOM元素// 暂停svg.pauseAnimations();// 重启动svg.unpauseAnimations()","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"HTML5响应式布局","slug":"HTML5响应式布局","date":"2018-12-27T08:35:46.000Z","updated":"2020-04-13T03:13:34.958Z","comments":true,"path":"技术/HTML5响应式布局.html","link":"","permalink":"https://blog.lyt007.cn/技术/HTML5响应式布局.html","excerpt":"","text":"什么是响应式网页设计（布局）响应式网页设计(Responsive Web design，通常缩写为RWD)是指：页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整。可以说是一种网页设计的技术做法，该设计可使网站在多种浏览设备（从桌面电脑显示器到移动电话或其他移动产品设备）上阅读和导航，同时减少缩放、平移和滚动。响应式网页设计就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。 响应式布局的实现1. Meta标签定义使用viewport meta标签在手机上控制布局 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1&quot; /&gt; 隐藏状态栏 &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;blank&quot; /&gt; iPhone会将看起来像是电话号码的数字添加链接，需要关闭 &lt;meta name=&quot;format-detection content=&quot;telephone=no&quot; /&gt; 2.使用Media Queries适配对应样式常用于布局的CSS Media Queries 设备类型 all 所有设备； screen 电脑显示器； int 打印用纸或打印预览视图； ndheld 便携设备； 电视机类型的设备； eech 语意和音频盒成器； aille 盲人用点字法触觉回馈设备； bossed 盲文打印机； ojection 各种投影设备； tty 使用固定密度字母栅格的媒介，比如电传打字机和终端。设备特性 width 浏览器宽度； height 浏览器高度； device-width 设备屏幕分辨率的宽度值； device-height 设备屏幕分辨率的高度值； orientation 浏览器窗口的方向纵向还是横向，当窗口的高度值大于等于宽度时该特性值为portrait，否则为landscape； aspect-ratio 比例值，浏览器的纵横比； device-aspect-ratio 比例值，屏幕的纵横比。 实现响应式布局通过媒体查询12345@media screen and (max-width:320px) &#123; &#125; @media screen and (min-width:320px) and (max-width:640px) &#123; &#125;样式表也可以引入外部的@import url(\"css/demo.css\") screen and (min-width:320px) and (max-width:640px);@media screen and (min-width:640px) &#123; &#125; 当然，工作中是使用的外部样式表12345&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"a.css\" media=\"screen and (min-width: 1000px)\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"b.css\" media=\"screen and (min-width: 600px) and (max-width: 1000px)\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"c.css\" media=\"screen and (max-width: 600px)\"&gt; 也许，你需要让手机的屏幕横着，比如你在玩王者荣耀12345竖屏- 屏幕宽度小于高度&lt;link rel=\"stylesheet\" media=\"all and (orientation:portrait)\" href=\"portrait.css\"&gt;横屏-屏幕宽度大于高度&lt;link rel=\"stylesheet\" media=\"all and (orientation:landscape)\" href=\"portrait.css\"&gt; 响应式布局缺点和优点 优点：面对不同分辨率设备，灵活性强，能够快捷地解决设备显示适应问题。 缺点：兼容各种设备时所需工作量大、效率低下、代码累赘，会隐藏无用的元素，加载时间延长，其实这是一种折中性质的设计解决方案，由于多方面元素影响而达不到最佳效果，在一定程度上改变了网站原有的布局结构，会出现用户混淆的情况。 这里有一个很严重的缺点由于PC端和移动终端访问的是同一个网站，PC端可以不计较流量限制，但是移动端不可能不计较。 这里主要是针对于图片的使用，为适配不同终端机型的屏幕宽度和像素密度，我们一般会使用如下方法设置图片的CSS样式： &lt;style&gt; img{ max-width:100%; height:auto; } &lt;/style&gt; 将图片的最大宽度设置为100%，以确保图像不会超出其父级元素的宽度，如果父级元素的宽度发生改变，图片的宽度也随之改变，height：auto 可以确保图片的宽度发生改变时，图片的高度会依据自身的宽高比例进行缩放。这样当我们在移动设备上访问响应式网页里的图片时，只是把图片的分辨率做了缩放，下载的还是PC端的那张大图，这样不仅浪费流量，而且浪费带宽，而且会拖慢网页的打开速度，严重影响用户的使用体验。 解决方案：&lt;picture&gt;如下栗子中针对不同屏幕宽度加载不同的图片；当页面宽度 在320px到640px之间时加载minpic.png；当页面宽度大于640px时加载middle.png &lt;picture&gt; &lt;source media=&quot;(min-width: 320px) and (max-width: 640px)&quot; srcset=&quot;img/minpic.png&quot;&gt; &lt;source media=&quot;(min-width: 640px)&quot; srcset=&quot;img/middle.png&quot;&gt; &lt;img src=&quot;img/picture.png&quot; alt=&quot;this is a picture&quot;&gt; &lt;/picture&gt; 如下例子中添加了屏幕的方向作为条件；当屏幕方向为横屏方向时加载_landscape.png结尾的图片；当屏幕方向为竖屏方向时加载 _portrait.png结尾的图片； &lt;picture&gt; &lt;source media=&quot;(min-width: 320px) and (max-width: 640px) and (orientation: landscape)&quot; srcset=&quot;img/minpic_landscape.png&quot;&gt; &lt;source media=&quot;(min-width: 320px) and (max-width: 640px) and (orientation: portrait)&quot; srcset=&quot;img/minpic_portrait.png&quot;&gt; &lt;source media=&quot;(min-width: 640px) and (orientation: landscape)&quot; srcset=&quot;img/middlepic_landscape.png&quot;&gt; &lt;source media=&quot;(min-width: 640px) and (orientation: portrait)&quot; srcset=&quot;img/middlepic_portrait.png&quot;&gt; &lt;img src=&quot;img/picture.png&quot; alt=&quot;this is a picture&quot;&gt; &lt;/picture&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"css-transform","slug":"css-transform","date":"2018-12-27T08:35:14.000Z","updated":"2020-04-13T03:13:34.961Z","comments":true,"path":"技术/css-transform.html","link":"","permalink":"https://blog.lyt007.cn/技术/css-transform.html","excerpt":"","text":"transform 2D变换rotate旋转，只有一个参数单位角度：deg scale缩放 一个参数：水平和垂直同时缩放 transform:scale(1.1) 两个参数：第一个参数指定水平方向的缩放倍率，第二个参数指定垂直方向的缩放倍率。可以是负数，如果是负数则会图片翻转translate位移 一个值表示X轴的位移，两个值表示X轴Y轴skew倾斜 一个参数时：表示水平方向的倾斜角度； 两个参数时：第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度。水平方向对应垂直方向的角，垂直方向对应方向的角skew的默认原点transform-origin是这个物件的中心点 变换基点transform-origin 默认基点为中心点，可以通过关键词设置坐标值或关键词改变基点 perspective-origin景深基点 在什么方位去看多方法组合变形上面我们介绍了使用transform对元素进行旋转、缩放、倾斜、移动的方法，这里讲介绍综合使用这几个方法来对一个元素进行多重变形。 用法：transform: rotate(45deg) scale(0.5) skew(30deg, 30deg) translate(100px, 100px); 这四种变形方法顺序可以随意，但不同的顺序导致变形结果不同，原因是变形的顺序是从左到右依次进行，这个用法中的执行顺序为1.rotate 2.scalse 3.skew 4.translate并且，每个变形之间用“空格”分隔符，而不是“，”。 transform 3D变换变换风格transform-style flat：没有3D效果。不是默认值。这个值js改变值的时候用 preserve-3d：子元素将有3D的效果perspective景深，近大远小 景深给爷爷，风格给父亲 3D 属性3D位移：CSS3中的3D位移主要包括translateZ()和translate3d()两个功能函数； translate3d(tx,ty,tz) 其属性值取值说明如下： tx：代表横向坐标位移向量的长度；ty：代表纵向坐标位移向量的长度；tz：代表Z轴位移向量的长度。此值不能是一个百分比值，如果取值为百分比值，将会认为无效值。 3D旋转：CSS3中的3D旋转主要包括rotateX()、rotateY()、rotateZ()和rotate3d()四个功能函数； scale3d(sx,sy,sz) sx：横向缩放比例；sy：纵向缩放比例；sz：Z轴缩放比例； 3D缩放：CSS3中的3D缩放主要包括scaleZ()和scale3d()两个功能函数； rotate3d(x,y,z,a) x：是一个0到１之间的数值，主要用来描述元素围绕X轴旋转的矢量值；y：是一个０到１之间的数值，主要用来描述元素围绕Y轴旋转的矢量值；z：是一个０到１之间的数值，主要用来描述元素围绕Z轴旋转的矢量值；a：是一个角度值，主要用来指定元素在3D空间旋转的角度，如果其值为正值，元素顺时针旋转，反之元素逆时针旋转。 下面介绍的三个旋转函数功能等同： rotateX(a)函数功能等同于rotate3d(1,0,0,a)rotateY(a)函数功能等同于rotate3d(0,1,0,a)rotateZ(a)函数功能等同于rotate3d(0,0,1,a) 3D矩阵：CSS3中3D变形中和2D变形一样也有一个3D矩阵功能函数matrix3d()。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"CSS3盒子模型","slug":"CSS3盒子模型","date":"2018-12-27T08:34:38.000Z","updated":"2020-04-13T03:13:34.958Z","comments":true,"path":"技术/CSS3盒子模型.html","link":"","permalink":"https://blog.lyt007.cn/技术/CSS3盒子模型.html","excerpt":"","text":"盒子阴影 box-shadow h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 弹性盒子模型display:flex给父级设置一个display:flex属性，子元素设置flex相关属性才可以自动分配宽高。 flex – 给需要设置弹性布局的子元素设置该属性 flex-grow：占父元素的剩余空间的多少比如这个例子： 12345678910&lt;ul class=\"flex\"&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;.flex&#123;display:flex;width:600px;margin:0;padding:0;list-style:none;&#125;.flex li:nth-child(1)&#123;width:200px;&#125;.flex li:nth-child(2)&#123;flex-grow:1;width:50px;&#125;.flex li:nth-child(3)&#123;flex-grow:3;width:50px;&#125; flex-grow的默认值为0，如果没有显示定义该属性，是不会拥有分配剩余空间权利的。 本例中b,c两项都设置的定义了flex-grow，flex容器的剩余空间分成了4份，其中b占1份，c占3分，即1:3 flex容器的剩余空间长度为：600-200-50-50=300px，所以最终a,b,c的长度分别为： a: 50+(300/4)=200px b: 50+(300/41)=125px a: 50+(300/43)=275px flex-shrink： 默认值是1。占据超出父级容器的宽度的百分比。如果所有的子元素的宽度相加没有超过父级的在宽度，则次属性无效。 123456789&lt;ul class=\"flex\"&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;.flex&#123;display:flex;width:400px;margin:0;padding:0;list-style:none;&#125;.flex li&#123;width:200px;&#125;.flex li:nth-child(3)&#123;flex-shrink:3;&#125; flex-shrink的默认值为1，如果没有显示定义该属性，将会自动按照默认值1在所有因子相加之后计算比率来进行空间收缩。 本例中c显式的定义了flex-shrink，a,b没有显式定义，但将根据默认值1来计算，可以看到总共将剩余空间分成了5份，其中a占1份，b占1份，c占3分，即1:1:3 我们可以看到父容器定义为400px，子项被定义为200px，相加之后即为600px，超出父容器200px。那么这么超出的200px需要被a,b,c消化 通过收缩因子，所以加权综合可得2001+2001+2003=1000px； 于是我们可以计算a,b,c将被移除的溢出量是多少： a被移除溢出量：(2001/1000)200，即约等于40px b被移除溢出量：(2001/1000)200，即约等于40px c被移除溢出量：(2003/1000)*200，即约等于120px 最后a,b,c的实际宽度分别为：200-40=160px, 200-40=160px, 200-120=80px flex-basis：和width一样，他的默认值为auto，把上面几个例子换成flex-basis也是一样的。工作中最好用flex-basis，更符合规范。 总结：如果父级的空间足够：flex-grow有效，flex-shrink无效。 如果父级的空间不够：flex-shrink 有效，flex-grow无效。 flex属性是以上三者的集合，一般设置为flex：1 其他属性，设置给父级元素 flex-wrap：wrap;子元素在必要的时候换行显示。默认值是nowrap，还有一个值是wrap-reverse flex-direction：规定主轴的方向（水平与垂直） row：主轴与行内轴方向作为默认的书写模式。即横向从左到右排列（左对齐）。 row-reverse：对齐方式与row相反。 column：主轴与块轴方向作为默认的书写模式。即纵向从上往下排列（顶对齐）。 column-reverse：对齐方式与column相反。 flex-flow：flex-wrap flex-direction; align-content：设置子元素的整体对齐方式 此值必须子元素占据多行 flex-start：各行向弹性盒容器的起始位置堆叠。弹性盒容器中第一行的侧轴起始边界紧靠住该弹性盒容器的侧轴起始边界，之后的每一行都紧靠住前面一行。 flex-end：各行向弹性盒容器的结束位置堆叠。弹性盒容器中最后一行的侧轴起结束界紧靠住该弹性盒容器的侧轴结束边界，之后的每一行都紧靠住前面一行。 center：各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一行之间的距离相等。（如果剩下的空间是负数，则各行会向两个方向溢出的相等距离。） space-between：各行在弹性盒容器中平均分布。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于&apos;flex-start&apos;。在其它情况下，第一行的侧轴起始边界紧靠住弹性盒容器的侧轴起始内容边界，最后一行的侧轴结束边界紧靠住弹性盒容器的侧轴结束内容边界，剩余的行则按一定方式在弹性盒窗口中排列，以保持两两之间的空间相等。 space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于&apos;center&apos;。在其它情况下，各行会按一定方式在弹性盒容器中排列，以保持两两之间的空间相等，同时第一行前面及最后一行后面的空间是其他空间的一半。 stretch：各行将会伸展以占用剩余的空间。如果剩余的空间是负数，该值等效于&apos;flex-start&apos;。在其它情况下，剩余空间被所有行平分，以扩大它们的侧轴尺寸。 （默认值） align-items: 定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。 flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。 flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。 center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。 baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与&apos;flex-start&apos;等效。其它情况下，该值将参与基线对齐。 stretch：如果指定侧轴大小的属性值为&apos;auto&apos;，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照&apos;min/max-width/height&apos;属性的限制。 justify-content：设置盒子在主轴方向上的对齐方式 flex-start：弹性盒子元素将向行起始位置对齐。该行的第一个子元素的主起始位置的边界将与该行的主起始位置的边界对齐，同时所有后续的伸缩盒项目与其前一个项目对齐。 flex-end：弹性盒子元素将向行结束位置对齐。该行的第一个子元素的主结束位置的边界将与该行的主结束位置的边界对齐，同时所有后续的伸缩盒项目与其前一个项目对齐。 center：弹性盒子元素将向行中间位置对齐。该行的子元素将相互对齐并在行中居中对齐，同时第一个元素与行的主起始位置的边距等同与最后一个元素与行的主结束位置的边距（如果剩余空间是负数，则保持两端相等长度的溢出）。 space-between：弹性盒子元素会平均地分布在行里。如果最左边的剩余空间是负数，或该行只有一个子元素，则该值等效于&apos;flex-start&apos;。在其它情况下，第一个元素的边界与行的主起始位置的边界对齐，同时最后一个元素的边界与行的主结束位置的边距对齐，而剩余的伸缩盒项目则平均分布，并确保两两之间的空白空间相等。 space-around：弹性盒子元素会平均地分布在行里，两端保留子元素与子元素之间间距大小的一半。如果最左边的剩余空间是负数，或该行只有一个伸缩盒项目，则该值等效于&apos;center&apos;。在其它情况下，伸缩盒项目则平均分布，并确保两两之间的空白空间相等，同时第一个元素前的空间以及最后一个元素后的空间为其他空白空间的一半。 其他属性，设置给子元素 align-self: 定义flex子项单独在侧轴（纵轴）方向上的对齐方式。取值与align-items一样。不过多了一个auto值： auto：如果&apos;align-self&apos;的值为&apos;auto&apos;，则其计算值为元素的父元素的&apos;align-items&apos;值，如果其没有父元素，则计算为&apos;stretch&apos;。 order：设置弹性盒子的顺序 允许调整大小reisze： both none horizontal vertical 倒影box-reflect：a b c； a:left/right/above/below b:距离本体多远 c:遮盖层 怪异盒子模型box-sizing content-box : 默认值 盒子总宽=内(width)+padding+border border-box : 怪异盒模型 盒子的总宽=width，会对应得缩小内容部分 如果border+padding &gt; width，盒子总宽=border+padding，内容部分为0 多列布局（加上兼容性前缀）column-width：每列的最小宽度column-count：列数columns：column-width column-count；规定列的宽度和列数。column-gap：列之间间隙的大小column-rule：列之间的边框。值与border一样的column-span：none/all 设置给子元素，规定这个元素跨不夸列 // 下面两个只兼容谷歌 -webkit-column-break-before: 设置或检索对象之前是否断行。设定给子元素，子元素之前是否另起一列 auto/always/avoid auto：既不强迫也不禁止在元素之前断行并产生新列 always：总是在元素之前断行并产生新列 avoid：避免在元素之前断行并产生新列 -webkit-column-break-after: 设定给子元素，子元素之后 禁止文字选中user-select：none；-moz-user-select:none;-ms-user-select:none;","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"HTML5表单","slug":"HTML5表单","date":"2018-12-27T08:34:10.000Z","updated":"2020-04-13T03:13:34.959Z","comments":true,"path":"技术/HTML5表单.html","link":"","permalink":"https://blog.lyt007.cn/技术/HTML5表单.html","excerpt":"","text":"新的输入型控件 email：电子邮件 tel：电话号码 url：网页的url（需要带上http(s)://） search：搜索引擎 range：数值控件，特定范围内的数值选择器 min max step（步数） value 新的输入控件number : 只能包含数字的输入框color : 颜色选择器datetime : 显示完整日期（chrome）datetime-local : 显示完整日期，不含时区time : 显示时间，不含时区date : 显示日期week : 显示周month : 显示月 新的表单特性placeholder : 输入框提示信息autocomplete : 是否保存用户输入值。默认为on，关闭提示选择offautofocus : 指定表单获取输入焦点 truerequired : 此项必填，不能为空Pattern : 正则验证 pattern=”\\d{1,5}“Formaction 在submit里定义提交地址 表单验证validity对象，通过下面的valid可以查看验证是否通过，如果八种验证都通过返回true，一种验证失败返回falseoText.addEventListener(“invalid”,fn1,false);ev.preventDefault()valueMissing : 输入值为空时 返回的是truetypeMismatch : 控件值与预期类型不匹配 返回的是truepatternMismatch : 输入值不满足pattern正则 返回的是truetooLong : 超过maxLength最大限制 超出的返回的是truerangeUnderflow : 验证的range最小值rangeOverflow：验证的range最大值stepMismatch: 验证range 的当前值 是否符合min、max及step的规则customError 不符合自定义验证 是不是匹配 truesetCustomValidity(); 自定义验证Invalid事件 : 验证反馈 input.addEventListener(‘invalid’,fn,false)阻止默认验证：ev.preventDefault()formnovalidate属性 : 关闭验证","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"过渡与动画","slug":"过渡与动画","date":"2018-12-27T08:32:40.000Z","updated":"2020-04-13T03:13:34.963Z","comments":true,"path":"技术/过渡与动画.html","link":"","permalink":"https://blog.lyt007.cn/技术/过渡与动画.html","excerpt":"","text":"过渡transition：property duration delay timing-function transition-property：过渡属性的名称 none：没有过渡属性all：所有的属性都过渡(默认值)property：具体的属性名称 transition-duration：过渡属性花费的时间 s/mstransition-delay：过渡效果延时时间 s/mstransition-timing-function：过渡效果速度曲线 linear / ease / ease-in / ease-out / ease-in-out 过渡完成事件： Webkit内核： obj.addEventListener(&apos;webkitTransitionEnd&apos;,function(){}); 标准: obj.addEventListener(&apos;transitionend&apos;,function(){}); 动画animation: name duration delay timing-function iteration-count direction; animation-name: 动画名称 keyframename 自定义的名字 none 无动画效果 animation-duration: 动画执行时间 animation-delay:动画效果延迟时间 animation-timing-function: 动画速度曲线 linear / ease / ease-in / ease-out / ease-in-out animation-iteration-count: 动画执行次数 次数数值 / infinite无限重复 animation-direction:动画执行方向 normal正常/alternate 动画轮流反向播放 animation-play-state:动画执行状态 paused 暂停动画 / running 运行动画 animation-fill-mode:动画执行过程效果是否可见 none 不改变（默认） forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义） backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义） both 向前和向后填充模式都被应用，forwards 与backwards 的 @keyframes:规定动画 @keyframes animationname {keyframes-selector {css-styles;}} animationname 定义动画的名称。keyframes-selector 动画时长的百分比。 0-100% from（与 0% 相同） to（与 100% 相同） 可以只有to css-styles 一个或多个合法的 CSS 样式属性。 动画事件： 动画开始触发：obj.addEventListener(&quot;webkitAnimationStart&quot;, fn); obj.addEventListener(&quot;animationstart&quot;, fn); 动画执行过程中触发： obj.addEventListener(&quot;webkitAnimationIteration&quot;, fn); obj.addEventListener(&quot;animationiteration&quot;, fn); 动画结束触发:obj.addEventListener(&apos;webkitAnimationEnd&apos;,fn); obj.addEventListener(&apos;animationend&apos;,fn); HTML5中的requestAnimationFrame动画优化 window.requestAnimFrame = (function () { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) { window.setTimeout(callback, 1000 / 60); }; })();","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"圆角与文本","slug":"圆角与文本","date":"2018-12-27T08:30:48.000Z","updated":"2020-04-13T03:13:34.963Z","comments":true,"path":"技术/圆角与文本.html","link":"","permalink":"https://blog.lyt007.cn/技术/圆角与文本.html","excerpt":"","text":"圆角 border-radius 如果是一个值，那么 top-left、top-right、bottom-right、bottom-left 四个值相等。 如果是两个值，那么 top-left和bottom-right相等，为第一个值，top-right和bottom-left值相等，为第二个值。 如果是三个值，那么第一个值是设置top-left，而第二个值是 top-right 和 bottom-left 并且他们会相等,第三个值是设置 bottom-right。 如果是四个值，那么第一个值是设置 top-left， 而第二个值是 top-right 第三个值 bottom-right 第四个值是设置 bottom-leftborder-radius可以单独指定水平和垂直半径，只需要用一个斜杠(水平/垂直)分割即可。除了上述的简写外，还可以和border一样，分别写四个角，如下：border-top-left-radius: //左上角border-top-right-radius: //右上角border-bottom-right-radius: //右下角border-bottom-left-radius: //左下角分别是水平方向和竖直方向半径，第二值省略的情况下，水平方向和竖直方向的半径相等 文本属性white-space：空格、缩进、换行的处理方式normal 默认 忽略多个空格/缩进/换行只留一个 nowrap 控制文本不换行 pre 空白/缩进/换行 会被浏览器保留 pre-line 合并空白/缩进 保留换行符 pre-wrap 保留空白/缩进 正常换行 2. Word-wrap:break-word 与 word-break:break-all两者究竟有什么样的区别呢。我们看看官方的解释： word-wrap word-break 看看翻译后的： word-wrap:css的 word-wrap 属性用来标明是否允许浏览器在单词内进行断句，这是为了防止当一个字符串太长而找不到它的自然断句点时产生溢出现象。从上一个单词换行开始 word-break:css的 word-break 属性用来标明怎么样进行单词内的断句。可以从上一个的结尾开始 两者对中文无效 文本书写模式direction：规定文本的方向unicode-bidi：设置文本的方向 direction: rtl =&gt; right to left direction: ltr =&gt; left to rigth unicode-bidi：bidi-override writing-mode:设置或检索对象的内容块固有的书写方向 horizontal-tb：水平方向自上而下的书写方式。即 left-right-top-bottom（类似IE私有值lr-tb） vertical-rl：垂直方向自右而左的书写方式。即 top-bottom-right-left（类似IE私有值tb-rl） vertical-lr：垂直方向自左而右的书写方式。即 top-bottom-left-right lr-tb：左-右，上-下。对象中的内容在水平方向上从左向右流入，后一行在前一行的下面。 所有的字形都是竖直向上的。这种布局是罗马语系使用的（IE） tb-rl：上-下，右-左。对象中的内容在垂直方向上从上向下流入，自右向左。后一竖行在前一竖行的左面。全角字符是竖直向上的，半角字符如拉丁字母或片假名顺时针旋转90度。这种布局是东亚语系通常使用的（IE） 文本超出：text-overflow主要用于文本超出后显示省略号，结合white-space与overflow使用 white-space:nowrap; /*文本不换行*/ overflow:hidden; /*超出隐藏*/ text-overflow:ellipsis; /*显示省略号*/ 上面的是单行的显示，多行的显示省略号怎么弄呢？结合以下的几个属性 display:-webkit-box; -webkit-box-orient:vertical; -webkit-line-clamp:5; /*设置文本显示的行数*/ 当然，你也可以使用js实现 文字阴影：text-shadow参数：x轴偏移量 y轴偏移量 模糊度 颜色例子：浮雕例子： color:#fff;text-shadow:2px 2px 4px #000; 立体字： color:#fff; text-shadow:0 1px 0 #ccc,0 2px 0 #9c9c9c,0 3px 0 #bbb,0 4px 0 #9b9b9b,0 5px 0 #aaa; 模糊字： color:rgba(0,0,0,0); text-shadow:0 0 20px blue; 霓虹灯： text-shadow:0px 0px 10px #f3c,0px 0px 20px #f39,0px 0px 40px #f33,0px 0px 60px #f30; 文字描边、文字填充text-stroke：宽度 颜色； 描边，加上兼容性前缀text-stroke-width： 宽度text-stroke-color： 颜色 text-fill-color: 颜色 文字大小写 text-transform四个值： none：默认值 capitaize：将每个单词的第一个字母转换为大写 uppercase：转换为大写 lowercase：转换为小写","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"CSS3背景","slug":"CSSS3背景","date":"2018-12-27T08:29:06.000Z","updated":"2020-04-13T03:13:34.958Z","comments":true,"path":"技术/CSSS3背景.html","link":"","permalink":"https://blog.lyt007.cn/技术/CSSS3背景.html","excerpt":"","text":"CSS背景属性回顾背景单个属性 background-image background-color background-repeat background-position background-attachment背景符合属性 background注意：复合属性会覆盖前面的单个属性，反之则不会 背景定位的扩展在CSS3中，背景定位得到了扩展，它允许我们指定背景图片在距离任意角的偏移量，只需要在偏移量前面指定关键字 background-position：right 20px bottom 10px;使用时单独设置。也可以使用background-origin：content-box实现 CSS3新增背景属性背景尺寸：background-size 设置背景尺寸 background-sizebackground-size:x y; //水平 垂直；值可以为像素、百分比、auto等background-size:cover; //保持宽高比不变，保证占满盒子，但是不一定能看到全部图backgroundsize:contain; //保持宽高比不变，保证看清全图，但是不一定占满盒子 多背景 background-imagebackground-image:url(1.jpg),url(2.jpg); 多个背景以逗号隔开，无限个数 背景起始区域 background-originbackground-origin:border-box; //从border区域起始background-origin:padding-box; //默认值，从padding区域起始background-origin:content-box; //从内容部分起始 背景显示区域 background-clip //从什么地方看到图片 background-clip:border-box; //默认值，从border区域开始显示背景 background-clip:padding-box; //从padding区域开始显示背景 background-clip:content-box; //从内部区域开始显示背景 新增颜色与背景渐变新增背景色 rgb：rgb为三原色，取值范围为0~255 hsl：H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 – 360，S：Saturation(饱和度)。取值为：0.0% - 100.0%，L：Lightness(亮度)。取值为：0.0% - 100.0%。 100%纯白色 rgba，hsla：在上面的基础上多了一个a透明度数值，取值范围0~1，0为完全透明，1为完全不透明 渐变色 线性渐变：linear-gradient() 径向渐变：radial-gradient() 线性渐变很简单，这里说一下经向渐变。1234//标准写法radial-gradient([[&lt;shape&gt;||&lt;size&gt;]?[at &lt;position&gt;,]?&lt;color-stop&gt;[,&lt;color-stop&gt;]+)//-webkit-老版本径向渐变的写法-webkit-radial-gradient([&lt;position&gt;||&lt;angle&gt;,]? [&lt;shape&gt;||&lt;size&gt;,]&gt;?&lt;color-stop&gt;[,&lt;color-stop&gt;]+) 径向渐变方式主要由position、shape、size这三个参数影响，分别控制椭圆的圆心、形状和大小 position：定义渐变的圆心。默认是center（X轴），center（Y轴），可以是left，right，center关键词，也可以是具体的数值，还可以是百分比。最后可以是单个值，另一个就默认是center shape：定义渐变的形状是圆（circle）或者是椭圆（ellipse 默认） size：定义渐变的大小、默认是farthest-corner。有四个值。1234closest-side:半径为从圆心到最近边closest-corner:半径为从圆心到最近角farthest-side:半径为从圆心到最远边farthest-side:半径为从圆心到最远角 注意：在使用时需要加上 –webkit-兼容前缀 IE低版本兼容filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#39;#ffffff&#39;,endColorstr=&#39;#ff0000&#39;,GradientType=&#39;1&#39;).","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"HTML5选择器","slug":"HTML5选择器","date":"2018-12-27T08:27:13.000Z","updated":"2020-04-13T03:13:34.960Z","comments":true,"path":"技术/HTML5选择器.html","link":"","permalink":"https://blog.lyt007.cn/技术/HTML5选择器.html","excerpt":"","text":"CSS选择器回顾 ID选择器 类名选择器：多类（.class1.class2）不被ie6支持 标签（元素）选择器 组合（后代）选择器 通配符选择器 直接子元素选择器 &gt;：ie6不支持 相邻兄弟选择器 +：ie6不支持 属性选择器 伪元素选择器 伪类选择器 CSS新增选择器 通用兄弟（关联）选择器：~，选择后面的所有的子元素 属性选择器（新增的）： E[attr~=&quot;value&quot;]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写； E[attr^=&quot;value&quot;]：指定了属性名，并且有属性值，属性值是以value开头的； E[attr$=&quot;value&quot;]：指定了属性名，并且有属性值，而且属性值是以value结束的； E[attr*=&quot;value&quot;]：指定了属性名，并且有属性值，而且属值中包含了value； E[attr|=&quot;value&quot;]：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn）; 注意：IE6不支持所有的属性选择器 :nth选择器 :first-child 选择某个元素的第一个子元素； :last-child 选择某个元素的最后一个子元素； :nth-child() 选择某个元素的一个或多个特定的子元素； :nth-child(length);/*参数是具体数字*/ :nth-child(n);/*参数是n,n从0开始计算*/ :nth-child(n*length)/*n的倍数选择，n从0开始算*/ :nth-child(n+length);/*选择大于length后面的元素*/ :nth-child(-n+length)/*选择小于length前面的元素*/ :nth-child(n*length+1);/*表示隔几选一*/ //上面length为整数 :nth-last-child() 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算； 其实这种使用和:nth-child使用是一样的，也可以使用:nth-child的那些表达式和使用方法，唯一不同的是这种指定了元素的类型而以。 :nth-of-type() 选择指定的元素； :nth-last-of-type() 选择指定的元素，从元素的最后一个开始计算； :first-of-type 选择一个上级元素下的第一个同类子元素； :last-of-type 选择一个上级元素的最后一个同类子元素； :only-child 选择的元素是它的父元素的唯一一个了元素； :only-of-type 选择一个元素是它的上级元素的唯一一个相同类型的子元素 :empty 选择的元素里面没有任何内容 :not 否定选择器 UI元素状态伪类我们把&quot;:enabled&quot;,&quot;:disabled&quot;,&quot;:checked&quot;伪类称为UI元素状态伪类，这些主要是针对于HTML中的Form元素操作，最常见的比如我们“type=”text”有enable和disabled两种状态，前者为可写状态后者为不可状态；另外“type=”radio”和“type=”checkbox”有”checked”和”unchecked”两种状态。来看两个实例，比如说你想将”disabled”的文本框与别的文本框区别出来，你就可以这样应用 input[type=&quot;text&quot;]:disabled {border:1px solid #999;background-color: #fefefe;} 注意：IE6-8不支持&quot;:checked&quot;,&quot;:enabled&quot;,&quot;:disabled&quot;这三种选择器。著作权归作者所有。 伪元素新增 ::selection 选择被用户选中的input：注意是选中，不是获得焦点","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]},{"title":"HTML5语法,标签,属性","slug":"HTML5语法-标签-属性","date":"2018-12-27T07:22:53.000Z","updated":"2020-04-13T03:13:34.960Z","comments":true,"path":"技术/HTML5语法-标签-属性.html","link":"","permalink":"https://blog.lyt007.cn/技术/HTML5语法-标签-属性.html","excerpt":"","text":"HTML 5的语法html5相对于以前的html（html4，xhtml等）更加简洁更加的人性化。主要体现在一下几个方面： 文档申明：DOCTYPE 字符编码：charset 不区分大小写了：DIV标签与div标签一样 布尔值：主要是关于input等的checked=”checked”属性 可以省略引号：属性的引号可以省略 可以进行标签的省略：大多数标签可以省略，不过不建议 HTML 5新增/删除标签新增的标签主要分为以下几个方面： 结构标签 表单标签 媒体标签 其他功能标签 结构标签 header：定义整个文档的头部区域或者是一篇文章的头部区域 section：表示页面中的一个内容区块，比如页眉、页脚或页面的其他部分 article：定义页面独立（与上下文不相关）的文章内容 aside：表示article标签内容之外，与article标签内容相关的辅助信息 hgroup：对整个页面或者是页面中的一个区块的标题进行组合使用 nav：表示页面中的导航链接的部分 figure：表示一段独立的内容，一般表示一个独立的单元，使用figcaption为figure添加标题，写出来有点像定义列表 footer：定义整个文档的尾部区域或者是一篇文章的尾部区域 媒体标签大致包含： video：视频 audio：音频 embed：嵌入内容（包括各种媒体），Midi、Wav、AU、MP3、Flash、AIFF等。这里不做过多的说明 表单控件标签 email：必须输入邮件； url：必须输入url地址； number：必须输入数值； range：必须输入一定范围内的数值； Date Pickers：日期选择器； date：选取日、月、年 month：选取月、年 week：选取周和年 time：选取时间（小时和分钟） datetime：选取时间、日、月、年（UTC时间） datetime-local：选取时间、日、月、年（本地时间） search：搜索常规的文本域； color：颜色这里不做过多的说明 其他功能标签 mark：凸显文字 meter： 标签定义度量衡。仅用于已知最大和最小值的度量。 progress：定义运行中的进度（进程）。 ruby：12&lt;p&gt;&lt;ruby&gt;月明&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;つきあ&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;かり昇る頃&lt;/p&gt;&lt;p&gt;灯る &lt;ruby&gt;赤提灯 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;あかちょうちん&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/p&gt; 月明(つきあ)かり昇る頃 灯る 赤提灯 (あかちょうちん) details：显示详情 123456789&lt;details&gt; &lt;summary&gt;选择详细的信息&lt;/summary&gt; &lt;ul&gt; &lt;li&gt;列表1&lt;/li&gt; &lt;li&gt;列表2&lt;/li&gt; &lt;li&gt;列表3&lt;/li&gt; &lt;li&gt;列表4&lt;/li&gt; &lt;/ul&gt;&lt;/details&gt; datalist：下拉选框，有点像select，不过还是有区别 123456&lt;input type=\"text\" name=\"\" list=\"cars\"&gt;&lt;datalist id=\"cars\"&gt; &lt;option value=\"宝马\"&gt;宝马&lt;/option&gt; &lt;option value=\"奔驰\"&gt;奔驰&lt;/option&gt; &lt;option value=\"劳斯莱斯\"&gt;劳斯莱斯&lt;/option&gt;&lt;/datalist&gt; 删除的标签1、能用css代替的元素basefont、big、center、font、s、strike、tt、u。这些元素纯粹是为画面展示服务的，HTML5中提倡把画面展示性功能放在css中统一编辑。 2、不再使用frame框架。 frameset、frame、noframes。HTML5中不支持frame框架，只支持iframe框架，或者用服务器方创建的由多个页面组成的符合页面的形式，删除以上这三个标签。 3、只有部分浏览器支持的元素 applet、bgsound、blink、marquee等标签。 4、其他被废除的元素 废除rb，使用ruby替代。 废除acronym使用abbr替代。 废除dir使用ul替代。 废除isindex使用form与input相结合的方式替代 废除listing使用pre替代 废除xmp使用code替代 废除nextid使用guids 废除plaintex使用“text/plian”（无格式正文）MIME类型替代。 新增的属性对于js进行添加的属性。` ` 如果没有以上两个属性的话，执行顺序为先加载（下载）第一个src，然后在执行其onload，然后在向下依次同步执行defer属性在h5之前就已经有了，输入延迟加载（推迟执行），它会先加载（下载）src中文件内容，然后等页面全部加载完成后，再加载onload中js.async属性属于异步加载，它会在加载src后，立即执行onload,同时还会继续加载页面以上执行顺序，alert显示会先显示b然后再显示a 网页中标签中加入小图标的样式代码&lt;link rel=&quot;icon&quot; href=&quot;url...&quot; type=&quot;图片名称&quot; sizes=&quot;16*16&quot;&gt;有序列表ol:新增start（列表起始值），reversed（是否倒置）menu菜单type属性（3个菜单类型）内嵌css样式：在标签内部来定义一个样式区块（scoped）,只对样式标签内部才有效内嵌框架：iframe元素，新增了seamless无边距无边框，srcdoc定义了内嵌框架的内容 iframe新增属性：&lt;!--seamless定义框架无边框 无边距--&gt; &lt;!--srcdoc的显示级别比sandbox高--&gt; &lt;!--sandbox用来规定一个内嵌框架的安全级别--&gt; &lt;!--sandbox=&quot;allow-forms:允许提交表单&quot;--&gt; &lt;!--sandbox=&quot;allow-origin:允许是相同的源&quot;--&gt; &lt;!--sandbox=&quot;allow-scripts：允许执行脚本&quot;--&gt; &lt;!--sandbox=&quot;allow-top-navigation:允许使外面的页面进行跳转&quot;--&gt; charset属性：meta属性之一,定义页面的字符集 sizes属性：link新增属性，当link的rel=”icon”时，用以设置图标大小 base属性:&lt;base href=&quot;http://localhost/&quot; target=&quot;_blank&quot;&gt;表示当在新窗口打开一个页面时，会将href中的内容作为前缀添加到地址前 defer属性：script标签属性，表示脚本加载完毕后，只有当页面也加载完毕才执行（推迟执行） async属性：script标签属性，脚本加载完毕后马上执行（运行过程中浏览器会解析下面的内容），即使页面还没有加载完毕（异步执行） media属性：&lt;a&gt;元素属性：表示对何种设备进行优化 hreflang属性：&lt;a&gt;的属性，表示超链接指向的网址使用的语言 ref属性：&lt;a&gt;的属性,定义超链接是否是外部链接 reversed属性:&lt;ol&gt;的属性，定义序号是否倒叙 start属性：&lt;ol&gt;的属性，定义序号的起始值 scoped属性：内嵌CSS样式的属性，定义该样式只局限于拥有该内嵌样式的元素，适用于单页开发 HTML 5全局属性 可直接在标签里插入的：data-自定义属性名字； hidden（直接放上去就是隐藏）； spellcheck=”true”（语法纠错）； tabindex=”1”（Tab跳转顺序）； contenteditable=”true”(可编辑状态，单击内容，可修改)； 在JavaScript里插入的window.document.designMode = ‘on’（JavaScript的全局属性，整个页面的文本都可以编辑了）； HTML 5的兼容性 HTML5有部分内容兼容到IE9，IE8及以下对H5完全不兼容后面的内容不再考虑此类浏览器。 部分内容需要加兼容前缀， -webkit-常用于兼容chrome浏览器， -moz-常用于兼容火狐， -o-常用于兼容opera， -ms-常用于兼容IE。 兼容性查询网站：http://caniuse.com/ web语义化的定义在HTML结构的恰当位置上使用语义恰当的标签，使页面具有良好的结构，是页面标签元素具有含义，能让搜索引擎更容易理解。从一下几点理解： 用正确的标签做正确的事 HTML语义化能让页面更具结构化且更加清晰，便于浏览器和搜索引擎进行解析因此在兼容条件下，要尽量使用具有语义化的结构标签。 即使在没有css样式的情况下，网页的内容也应该是有序的文档格式显示，并且是容易阅读的。 使项目维护人员更容易对网站进行分块，便于阅读理解。 不具有语义的标签元素最好不要在里面放文字。比如div与i标签。一般div是作为容器。i标签作为图标（icon）","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.lyt007.cn/categories/技术/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.lyt007.cn/tags/html/"}]}]}